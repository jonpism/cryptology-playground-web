var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
(function() {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const s of document.querySelectorAll('link[rel="modulepreload"]')) r(s);
  new MutationObserver((s) => {
    for (const i of s) if (i.type === "childList") for (const a of i.addedNodes) a.tagName === "LINK" && a.rel === "modulepreload" && r(a);
  }).observe(document, { childList: true, subtree: true });
  function n(s) {
    const i = {};
    return s.integrity && (i.integrity = s.integrity), s.referrerPolicy && (i.referrerPolicy = s.referrerPolicy), s.crossOrigin === "use-credentials" ? i.credentials = "include" : s.crossOrigin === "anonymous" ? i.credentials = "omit" : i.credentials = "same-origin", i;
  }
  function r(s) {
    if (s.ep) return;
    s.ep = true;
    const i = n(s);
    fetch(s.href, i);
  }
})();
function dt() {
}
function jp(t3, e) {
  for (const n in e) t3[n] = e[n];
  return t3;
}
function TC(t3) {
  return t3();
}
function t6() {
  return /* @__PURE__ */ Object.create(null);
}
function Mn(t3) {
  t3.forEach(TC);
}
function DC(t3) {
  return typeof t3 == "function";
}
function At(t3, e) {
  return t3 != t3 ? e == e : t3 !== e || t3 && typeof t3 == "object" || typeof t3 == "function";
}
let Rd;
function r6(t3, e) {
  return t3 === e ? true : (Rd || (Rd = document.createElement("a")), Rd.href = e, t3 === Rd.href);
}
function $P(t3) {
  return Object.keys(t3).length === 0;
}
function Ob(t3, e, n, r) {
  if (t3) {
    const s = RC(t3, e, n, r);
    return t3[0](s);
  }
}
function RC(t3, e, n, r) {
  return t3[1] && r ? jp(n.ctx.slice(), t3[1](r(e))) : n.ctx;
}
function Qb(t3, e, n, r) {
  return t3[2], e.dirty;
}
function Kb(t3, e, n, r, s, i) {
  if (s) {
    const a = RC(e, n, r, i);
    t3.p(a, s);
  }
}
function Hb(t3) {
  if (t3.ctx.length > 32) {
    const e = [], n = t3.ctx.length / 32;
    for (let r = 0; r < n; r++) e[r] = -1;
    return e;
  }
  return -1;
}
function TP(t3) {
  const e = {};
  for (const n in t3) n[0] !== "$" && (e[n] = t3[n]);
  return e;
}
function n6(t3, e) {
  const n = {};
  e = new Set(e);
  for (const r in t3) !e.has(r) && r[0] !== "$" && (n[r] = t3[r]);
  return n;
}
const $y = globalThis || void 0 || self;
function q(t3, e) {
  t3.appendChild(e);
}
function R(t3, e, n) {
  t3.insertBefore(e, n || null);
}
function D(t3) {
  t3.parentNode && t3.parentNode.removeChild(t3);
}
function jn(t3, e) {
  for (let n = 0; n < t3.length; n += 1) t3[n] && t3[n].d(e);
}
function H(t3) {
  return document.createElement(t3);
}
function Nr(t3) {
  return document.createElementNS("http://www.w3.org/2000/svg", t3);
}
function we(t3) {
  return document.createTextNode(t3);
}
function z() {
  return we(" ");
}
function Lt() {
  return we("");
}
function Kt(t3, e, n, r) {
  return t3.addEventListener(e, n, r), () => t3.removeEventListener(e, n, r);
}
function V(t3, e, n) {
  n == null ? t3.removeAttribute(e) : t3.getAttribute(e) !== n && t3.setAttribute(e, n);
}
function Nn(t3) {
  return t3 === "" ? null : +t3;
}
function DP(t3) {
  return Array.from(t3.childNodes);
}
function Ze(t3, e) {
  e = "" + e, t3.data !== e && (t3.data = e);
}
function yr(t3, e) {
  t3.value = e ?? "";
}
function St(t3, e, n, r) {
  n == null ? t3.style.removeProperty(e) : t3.style.setProperty(e, n, "");
}
function i6(t3, e, n) {
  for (let r = 0; r < t3.options.length; r += 1) {
    const s = t3.options[r];
    if (s.__value === e) {
      s.selected = true;
      return;
    }
  }
  (!n || e !== void 0) && (t3.selectedIndex = -1);
}
function RP(t3) {
  const e = t3.querySelector(":checked");
  return e && e.__value;
}
function Zt(t3, e, n) {
  t3.classList.toggle(e, !!n);
}
function FP(t3, e, { bubbles: n = false, cancelable: r = false } = {}) {
  return new CustomEvent(t3, { detail: e, bubbles: n, cancelable: r });
}
function s6(t3, e) {
  return new t3(e);
}
let _h;
function ih(t3) {
  _h = t3;
}
function FC() {
  if (!_h) throw new Error("Function called outside component initialization");
  return _h;
}
function qb(t3) {
  FC().$$.on_mount.push(t3);
}
function Vh() {
  const t3 = FC();
  return (e, n, { cancelable: r = false } = {}) => {
    const s = t3.$$.callbacks[e];
    if (s) {
      const i = FP(e, n, { cancelable: r });
      return s.slice().forEach((a) => {
        a.call(t3, i);
      }), !i.defaultPrevented;
    }
    return true;
  };
}
function Ds(t3, e) {
  const n = t3.$$.callbacks[e.type];
  n && n.slice().forEach((r) => r.call(this, e));
}
const K0 = [], Qe = [];
let au = [];
const Ty = [], PC = Promise.resolve();
let Dy = false;
function NC() {
  Dy || (Dy = true, PC.then(UC));
}
function dc() {
  return NC(), PC;
}
function Xp(t3) {
  au.push(t3);
}
function qe(t3) {
  Ty.push(t3);
}
const $m = /* @__PURE__ */ new Set();
let I0 = 0;
function UC() {
  if (I0 !== 0) return;
  const t3 = _h;
  do {
    try {
      for (; I0 < K0.length; ) {
        const e = K0[I0];
        I0++, ih(e), PP(e.$$);
      }
    } catch (e) {
      throw K0.length = 0, I0 = 0, e;
    }
    for (ih(null), K0.length = 0, I0 = 0; Qe.length; ) Qe.pop()();
    for (let e = 0; e < au.length; e += 1) {
      const n = au[e];
      $m.has(n) || ($m.add(n), n());
    }
    au.length = 0;
  } while (K0.length);
  for (; Ty.length; ) Ty.pop()();
  Dy = false, $m.clear(), ih(t3);
}
function PP(t3) {
  if (t3.fragment !== null) {
    t3.update(), Mn(t3.before_update);
    const e = t3.dirty;
    t3.dirty = [-1], t3.fragment && t3.fragment.p(t3.ctx, e), t3.after_update.forEach(Xp);
  }
}
function NP(t3) {
  const e = [], n = [];
  au.forEach((r) => t3.indexOf(r) === -1 ? e.push(r) : n.push(r)), n.forEach((r) => r()), au = e;
}
const Ap = /* @__PURE__ */ new Set();
let Ql;
function Xt() {
  Ql = { r: 0, c: [], p: Ql };
}
function er() {
  Ql.r || Mn(Ql.c), Ql = Ql.p;
}
function W(t3, e) {
  t3 && t3.i && (Ap.delete(t3), t3.i(e));
}
function j(t3, e, n, r) {
  if (t3 && t3.o) {
    if (Ap.has(t3)) return;
    Ap.add(t3), Ql.c.push(() => {
      Ap.delete(t3), r && (n && t3.d(1), r());
    }), t3.o(e);
  } else r && r();
}
function Mr(t3) {
  return (t3 == null ? void 0 : t3.length) !== void 0 ? t3 : Array.from(t3);
}
function UP(t3, e) {
  const n = {}, r = {}, s = { $$scope: 1 };
  let i = t3.length;
  for (; i--; ) {
    const a = t3[i], o = e[i];
    if (o) {
      for (const f in a) f in o || (r[f] = 1);
      for (const f in o) s[f] || (n[f] = o[f], s[f] = 1);
      t3[i] = o;
    } else for (const f in a) s[f] = 1;
  }
  for (const a in r) a in n || (n[a] = void 0);
  return n;
}
function LP(t3) {
  return typeof t3 == "object" && t3 !== null ? t3 : {};
}
function ze(t3, e, n) {
  const r = t3.$$.props[e];
  r !== void 0 && (t3.$$.bound[r] = n, n(t3.$$.ctx[r]));
}
function fe(t3) {
  t3 && t3.c();
}
function ae(t3, e, n) {
  const { fragment: r, after_update: s } = t3.$$;
  r && r.m(e, n), Xp(() => {
    const i = t3.$$.on_mount.map(TC).filter(DC);
    t3.$$.on_destroy ? t3.$$.on_destroy.push(...i) : Mn(i), t3.$$.on_mount = [];
  }), s.forEach(Xp);
}
function oe(t3, e) {
  const n = t3.$$;
  n.fragment !== null && (NP(n.after_update), Mn(n.on_destroy), n.fragment && n.fragment.d(e), n.on_destroy = n.fragment = null, n.ctx = []);
}
function OP(t3, e) {
  t3.$$.dirty[0] === -1 && (K0.push(t3), NC(), t3.$$.dirty.fill(0)), t3.$$.dirty[e / 31 | 0] |= 1 << e % 31;
}
function wt(t3, e, n, r, s, i, a = null, o = [-1]) {
  const f = _h;
  ih(t3);
  const c = t3.$$ = { fragment: null, ctx: [], props: i, update: dt, not_equal: s, bound: t6(), on_mount: [], on_destroy: [], on_disconnect: [], before_update: [], after_update: [], context: new Map(e.context || (f ? f.$$.context : [])), callbacks: t6(), dirty: o, skip_bound: false, root: e.target || f.$$.root };
  a && a(c.root);
  let l = false;
  if (c.ctx = n ? n(t3, e.props || {}, (h, m, ...v) => {
    const b = v.length ? v[0] : m;
    return c.ctx && s(c.ctx[h], c.ctx[h] = b) && (!c.skip_bound && c.bound[h] && c.bound[h](b), l && OP(t3, h)), m;
  }) : [], c.update(), l = true, Mn(c.before_update), c.fragment = r ? r(c.ctx) : false, e.target) {
    if (e.hydrate) {
      const h = DP(e.target);
      c.fragment && c.fragment.l(h), h.forEach(D);
    } else c.fragment && c.fragment.c();
    e.intro && W(t3.$$.fragment), ae(t3, e.target, e.anchor), UC();
  }
  ih(f);
}
class xt {
  constructor() {
    __publicField(this, "$$");
    __publicField(this, "$$set");
  }
  $destroy() {
    oe(this, 1), this.$destroy = dt;
  }
  $on(e, n) {
    if (!DC(n)) return dt;
    const r = this.$$.callbacks[e] || (this.$$.callbacks[e] = []);
    return r.push(n), () => {
      const s = r.indexOf(n);
      s !== -1 && r.splice(s, 1);
    };
  }
  $set(e) {
    this.$$set && !$P(e) && (this.$$.skip_bound = true, this.$$set(e), this.$$.skip_bound = false);
  }
}
const QP = "4";
typeof window < "u" && (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(QP);
/*! OpenPGP.js v6.3.0 - 2025-12-09 - this is LGPL licensed code, see LICENSE/our website https://openpgpjs.org/ for more information. */
const es = typeof window < "u" ? window : typeof $y < "u" ? $y : typeof self < "u" ? self : {}, V0 = Symbol("doneWritingPromise"), LC = Symbol("doneWritingResolve"), OC = Symbol("doneWritingReject"), pc = Symbol("readingIndex");
let oo = class QC extends Array {
  constructor() {
    super(), Object.setPrototypeOf(this, QC.prototype), this[V0] = new Promise((e, n) => {
      this[LC] = e, this[OC] = n;
    }), this[V0].catch(() => {
    });
  }
};
function Un(t3) {
  return t3 && t3.getReader && Array.isArray(t3);
}
function Lc(t3) {
  if (!Un(t3)) {
    const e = t3.getWriter(), n = e.releaseLock;
    return e.releaseLock = () => {
      e.closed.catch(function() {
      }), n.call(e);
    }, e;
  }
  this.stream = t3;
}
function si(t3) {
  if (Un(t3)) return "array";
  if (es.ReadableStream && es.ReadableStream.prototype.isPrototypeOf(t3)) return "web";
  if (t3 && !(es.ReadableStream && t3 instanceof es.ReadableStream) && typeof t3._read == "function" && typeof t3._readableState == "object") throw Error("Native Node streams are no longer supported: please manually convert the stream to a WebStream, using e.g. `stream.Readable.toWeb`");
  return !(!t3 || !t3.getReader) && "web-like";
}
function rg(t3) {
  return Uint8Array.prototype.isPrototypeOf(t3);
}
function KC(t3) {
  if (t3.length === 1) return t3[0];
  let e = 0;
  for (let s = 0; s < t3.length; s++) {
    if (!rg(t3[s])) throw Error("concatUint8Array: Data must be in the form of a Uint8Array");
    e += t3[s].length;
  }
  const n = new Uint8Array(e);
  let r = 0;
  return t3.forEach(function(s) {
    n.set(s, r), r += s.length;
  }), n;
}
oo.prototype.getReader = function() {
  return this[pc] === void 0 && (this[pc] = 0), { read: async () => (await this[V0], this[pc] === this.length ? { value: void 0, done: true } : { value: this[this[pc]++], done: false }) };
}, oo.prototype.readToEnd = async function(t3) {
  await this[V0];
  const e = t3(this.slice(this[pc]));
  return this.length = 0, e;
}, oo.prototype.clone = function() {
  const t3 = new oo();
  return t3[V0] = this[V0].then(() => {
    t3.push(...this);
  }), t3;
}, Lc.prototype.write = async function(t3) {
  this.stream.push(t3);
}, Lc.prototype.close = async function() {
  this.stream[LC]();
}, Lc.prototype.abort = async function(t3) {
  return this.stream[OC](t3), t3;
}, Lc.prototype.releaseLock = function() {
}, typeof es.process == "object" && es.process.versions;
const a6 = /* @__PURE__ */ new WeakSet(), vn = Symbol("externalBuffer");
function Ha(t3) {
  if (this.stream = t3, t3[vn] && (this[vn] = t3[vn].slice()), Un(t3)) {
    const n = t3.getReader();
    return this._read = n.read.bind(n), this._releaseLock = () => {
    }, void (this._cancel = () => {
    });
  }
  if (si(t3)) {
    const n = t3.getReader();
    return this._read = n.read.bind(n), this._releaseLock = () => {
      n.closed.catch(function() {
      }), n.releaseLock();
    }, void (this._cancel = n.cancel.bind(n));
  }
  let e = false;
  this._read = async () => e || a6.has(t3) ? { value: void 0, done: true } : (e = true, { value: t3, done: false }), this._releaseLock = () => {
    if (e) try {
      a6.add(t3);
    } catch {
    }
  };
}
function Yh(t3) {
  return si(t3) ? t3 : new ReadableStream({ start(e) {
    e.enqueue(t3), e.close();
  } });
}
function HC(t3) {
  const e = si(t3);
  if (e) {
    if (e !== "array") throw Error("Can't convert Stream to ArrayStream here, call `readToEnd` first");
    return t3;
  }
  const n = new oo();
  return (async () => {
    const r = Hs(n);
    await r.write(t3), await r.close();
  })(), n;
}
function hs(t3) {
  return t3.some((e) => si(e) && !Un(e)) ? function(e) {
    e = e.map(Yh);
    const n = qC(async function(i) {
      await Promise.all(s.map((a) => Fy(a, i)));
    });
    let r = Promise.resolve();
    const s = e.map((i, a) => hl(i, (o, f) => (r = r.then(() => mu(o, n.writable, { preventClose: a !== e.length - 1 })), r)));
    return n.readable;
  }(t3) : t3.some((e) => Un(e)) ? function(e) {
    const n = new oo();
    let r = Promise.resolve();
    return e.forEach((s, i) => (r = r.then(() => mu(s, n, { preventClose: i !== e.length - 1 })), r)), n;
  }(t3) : typeof t3[0] == "string" ? t3.join("") : KC(t3);
}
async function mu(t3, e, { preventClose: n = false, preventAbort: r = false, preventCancel: s = false } = {}) {
  if (si(t3) && !Un(t3) && !Un(e)) {
    t3 = Yh(t3);
    try {
      if (t3[vn]) {
        const o = Hs(e);
        for (let f = 0; f < t3[vn].length; f++) await o.ready, await o.write(t3[vn][f]);
        o.releaseLock();
      }
      await t3.pipeTo(e, { preventClose: n, preventAbort: r, preventCancel: s });
    } catch {
    }
    return;
  }
  si(t3) || (t3 = HC(t3));
  const i = Ma(t3), a = Hs(e);
  try {
    for (; ; ) {
      await a.ready;
      const { done: o, value: f } = await i.read();
      if (o) {
        n || await a.close();
        break;
      }
      await a.write(f);
    }
  } catch (o) {
    r || await a.abort(o);
  } finally {
    i.releaseLock(), a.releaseLock();
  }
}
function qC(t3) {
  let e, n, r, s = false, i = false;
  return { readable: new ReadableStream({ start(a) {
    r = a;
  }, pull() {
    e ? e() : s = true;
  }, async cancel(a) {
    i = true, t3 && await t3(a), n && n(a);
  } }, { highWaterMark: 0 }), writable: new WritableStream({ write: async function(a) {
    if (i) throw Error("Stream is cancelled");
    r.enqueue(a), s ? s = false : (await new Promise((o, f) => {
      e = o, n = f;
    }), e = null, n = null);
  }, close: r.close.bind(r), abort: r.error.bind(r) }) };
}
function ii(t3, e = () => {
}, n = () => {
}, r = { highWaterMark: 0 }) {
  if (si(t3)) return zC(t3, e, n, r);
  const s = e(t3), i = n();
  return s !== void 0 && i !== void 0 ? hs([s, i]) : s !== void 0 ? s : i;
}
async function Ry(t3, e = async () => {
}, n = async () => {
}, r = { highWaterMark: 1 }) {
  if (si(t3)) return zC(t3, e, n, r);
  const s = await e(t3), i = await n();
  return s !== void 0 && i !== void 0 ? hs([s, i]) : s !== void 0 ? s : i;
}
function zC(t3, e, n, r) {
  if (Un(t3)) {
    const s = new oo();
    return (async () => {
      const i = Hs(s);
      try {
        const a = await Zn(t3), o = await e(a), f = await n();
        let c;
        c = o !== void 0 && f !== void 0 ? hs([o, f]) : o !== void 0 ? o : f, await i.write(c), await i.close();
      } catch (a) {
        await i.abort(a);
      }
    })(), s;
  }
  if (si(t3)) {
    let s, i = false;
    return new ReadableStream({ start() {
      s = t3.getReader();
    }, async pull(a) {
      if (i) return a.close(), void t3.releaseLock();
      try {
        for (; ; ) {
          const { value: o, done: f } = await s.read();
          i = f;
          const c = await (f ? n : e)(o);
          if (c !== void 0) return void a.enqueue(c);
          if (f) return a.close(), void t3.releaseLock();
        }
      } catch (o) {
        a.error(o);
      }
    }, async cancel(a) {
      await s.cancel(a);
    } }, r);
  }
  throw Error("Unreachable");
}
function hl(t3, e) {
  if (si(t3) && !Un(t3)) {
    let r;
    const s = new TransformStream({ start(o) {
      r = o;
    } }), i = mu(t3, s.writable), a = qC(async function(o) {
      r.error(o), await i, await new Promise((f) => setTimeout(f));
    });
    return e(s.readable, a.writable), a.readable;
  }
  t3 = HC(t3);
  const n = new oo();
  return e(t3, n), n;
}
function ng(t3, e) {
  let n;
  const r = hl(t3, (s, i) => {
    const a = Ma(s);
    a.remainder = () => (a.releaseLock(), mu(s, i), r), n = e(a);
  });
  return n;
}
function i0(t3) {
  if (Un(t3)) return t3.clone();
  if (si(t3)) {
    const e = function(n) {
      if (Un(n)) throw Error("ArrayStream cannot be tee()d, use clone() instead");
      if (si(n)) {
        const r = Yh(n).tee();
        return r[0][vn] = r[1][vn] = n[vn], r;
      }
      return [Fi(n), Fi(n)];
    }(t3);
    return GC(t3, e[0]), e[1];
  }
  return Fi(t3);
}
function sh(t3) {
  return Un(t3) ? i0(t3) : si(t3) ? new ReadableStream({ start(e) {
    const n = hl(t3, async (r, s) => {
      const i = Ma(r), a = Hs(s);
      try {
        for (; ; ) {
          await a.ready;
          const { done: o, value: f } = await i.read();
          if (o) {
            try {
              e.close();
            } catch {
            }
            return void await a.close();
          }
          try {
            e.enqueue(f);
          } catch {
          }
          await a.write(f);
        }
      } catch (o) {
        e.error(o), await a.abort(o);
      }
    });
    GC(t3, n);
  } }) : Fi(t3);
}
function GC(t3, e) {
  Object.entries(Object.getOwnPropertyDescriptors(t3.constructor.prototype)).forEach(([n, r]) => {
    n !== "constructor" && (r.value ? r.value = r.value.bind(e) : r.get = r.get.bind(e), Object.defineProperty(t3, n, r));
  });
}
function Fi(t3, e = 0, n = 1 / 0) {
  if (Un(t3)) throw Error("Not implemented");
  if (si(t3)) {
    if (e >= 0 && n >= 0) {
      let r, s = 0;
      return new ReadableStream({ start() {
        r = t3.getReader();
      }, async pull(i) {
        try {
          for (; ; ) {
            if (!(s < n)) return i.close(), void t3.releaseLock();
            {
              const { value: a, done: o } = await r.read();
              if (o) return i.close(), void t3.releaseLock();
              let f;
              if (s + a.length >= e && (f = Fi(a, Math.max(e - s, 0), n - s)), s += a.length, f) return void i.enqueue(f);
            }
          }
        } catch (a) {
          i.error(a);
        }
      }, async cancel(i) {
        await r.cancel(i);
      } }, { highWaterMark: 0 });
    }
    if (e < 0 && (n < 0 || n === 1 / 0)) {
      let r = [];
      return ii(t3, (s) => {
        s.length >= -e ? r = [s] : r.push(s);
      }, () => Fi(hs(r), e, n));
    }
    if (e === 0 && n < 0) {
      let r;
      return ii(t3, (s) => {
        const i = r ? hs([r, s]) : s;
        if (i.length >= -n) return r = Fi(i, n), Fi(i, e, n);
        r = i;
      });
    }
    return console.warn(`stream.slice(input, ${e}, ${n}) not implemented efficiently.`), d0(async () => Fi(await Zn(t3), e, n));
  }
  return t3[vn] && (t3 = hs(t3[vn].concat([t3]))), rg(t3) ? t3.subarray(e, n === 1 / 0 ? t3.length : n) : t3.slice(e, n);
}
async function Zn(t3, e = hs) {
  return Un(t3) ? t3.readToEnd(e) : si(t3) ? Ma(t3).readToEnd(e) : t3;
}
async function Fy(t3, e) {
  if (si(t3)) {
    if (t3.cancel) {
      const n = await t3.cancel(e);
      return await new Promise((r) => setTimeout(r)), n;
    }
    if (t3.destroy) return t3.destroy(e), await new Promise((n) => setTimeout(n)), e;
  }
}
function d0(t3) {
  const e = new oo();
  return (async () => {
    const n = Hs(e);
    try {
      await n.write(await t3()), await n.close();
    } catch (r) {
      await n.abort(r);
    }
  })(), e;
}
function Ma(t3) {
  return new Ha(t3);
}
function Hs(t3) {
  return new Lc(t3);
}
Ha.prototype.read = async function() {
  return this[vn] && this[vn].length ? { done: false, value: this[vn].shift() } : this._read();
}, Ha.prototype.releaseLock = function() {
  this[vn] && (this.stream[vn] = this[vn]), this._releaseLock();
}, Ha.prototype.cancel = function(t3) {
  return this._cancel(t3);
}, Ha.prototype.readLine = async function() {
  let t3, e = [];
  for (; !t3; ) {
    let { done: n, value: r } = await this.read();
    if (r += "", n) return e.length ? hs(e) : void 0;
    const s = r.indexOf(`
`) + 1;
    s && (t3 = hs(e.concat(r.substr(0, s))), e = []), s !== r.length && e.push(r.substr(s));
  }
  return this.unshift(...e), t3;
}, Ha.prototype.readByte = async function() {
  const { done: t3, value: e } = await this.read();
  if (t3) return;
  const n = e[0];
  return this.unshift(Fi(e, 1)), n;
}, Ha.prototype.readBytes = async function(t3) {
  const e = [];
  let n = 0;
  for (; ; ) {
    const { done: r, value: s } = await this.read();
    if (r) return e.length ? hs(e) : void 0;
    if (e.push(s), n += s.length, n >= t3) {
      const i = hs(e);
      return this.unshift(Fi(i, t3)), Fi(i, 0, t3);
    }
  }
}, Ha.prototype.peekBytes = async function(t3) {
  const e = await this.readBytes(t3);
  return this.unshift(e), e;
}, Ha.prototype.unshift = function(...t3) {
  this[vn] || (this[vn] = []), t3.length === 1 && rg(t3[0]) && this[vn].length && t3[0].length && this[vn][0].byteOffset >= t3[0].length ? this[vn][0] = new Uint8Array(this[vn][0].buffer, this[vn][0].byteOffset - t3[0].length, this[vn][0].byteLength + t3[0].length) : this[vn].unshift(...t3.filter((e) => e && e.length));
}, Ha.prototype.readToEnd = async function(t3 = hs) {
  const e = [];
  for (; ; ) {
    const { done: n, value: r } = await this.read();
    if (n) break;
    e.push(r);
  }
  return t3(e);
};
const gc = Symbol("byValue");
var ee = { curve: { nistP256: "nistP256", p256: "nistP256", nistP384: "nistP384", p384: "nistP384", nistP521: "nistP521", p521: "nistP521", secp256k1: "secp256k1", ed25519Legacy: "ed25519Legacy", ed25519: "ed25519Legacy", curve25519Legacy: "curve25519Legacy", curve25519: "curve25519Legacy", brainpoolP256r1: "brainpoolP256r1", brainpoolP384r1: "brainpoolP384r1", brainpoolP512r1: "brainpoolP512r1" }, s2k: { simple: 0, salted: 1, iterated: 3, argon2: 4, gnu: 101 }, publicKey: { rsaEncryptSign: 1, rsaEncrypt: 2, rsaSign: 3, elgamal: 16, dsa: 17, ecdh: 18, ecdsa: 19, eddsaLegacy: 22, aedh: 23, aedsa: 24, x25519: 25, x448: 26, ed25519: 27, ed448: 28 }, symmetric: { idea: 1, tripledes: 2, cast5: 3, blowfish: 4, aes128: 7, aes192: 8, aes256: 9, twofish: 10 }, compression: { uncompressed: 0, zip: 1, zlib: 2, bzip2: 3 }, hash: { md5: 1, sha1: 2, ripemd: 3, sha256: 8, sha384: 9, sha512: 10, sha224: 11, sha3_256: 12, sha3_512: 14 }, webHash: { "SHA-1": 2, "SHA-256": 8, "SHA-384": 9, "SHA-512": 10 }, aead: { eax: 1, ocb: 2, gcm: 3, experimentalGCM: 100 }, packet: { publicKeyEncryptedSessionKey: 1, signature: 2, symEncryptedSessionKey: 3, onePassSignature: 4, secretKey: 5, publicKey: 6, secretSubkey: 7, compressedData: 8, symmetricallyEncryptedData: 9, marker: 10, literalData: 11, trust: 12, userID: 13, publicSubkey: 14, userAttribute: 17, symEncryptedIntegrityProtectedData: 18, modificationDetectionCode: 19, aeadEncryptedData: 20, padding: 21 }, literal: { binary: 98, text: 116, utf8: 117, mime: 109 }, signature: { binary: 0, text: 1, standalone: 2, certGeneric: 16, certPersona: 17, certCasual: 18, certPositive: 19, certRevocation: 48, subkeyBinding: 24, keyBinding: 25, key: 31, keyRevocation: 32, subkeyRevocation: 40, timestamp: 64, thirdParty: 80 }, signatureSubpacket: { signatureCreationTime: 2, signatureExpirationTime: 3, exportableCertification: 4, trustSignature: 5, regularExpression: 6, revocable: 7, keyExpirationTime: 9, placeholderBackwardsCompatibility: 10, preferredSymmetricAlgorithms: 11, revocationKey: 12, issuerKeyID: 16, notationData: 20, preferredHashAlgorithms: 21, preferredCompressionAlgorithms: 22, keyServerPreferences: 23, preferredKeyServer: 24, primaryUserID: 25, policyURI: 26, keyFlags: 27, signersUserID: 28, reasonForRevocation: 29, features: 30, signatureTarget: 31, embeddedSignature: 32, issuerFingerprint: 33, preferredAEADAlgorithms: 34, preferredCipherSuites: 39 }, keyFlags: { certifyKeys: 1, signData: 2, encryptCommunication: 4, encryptStorage: 8, splitPrivateKey: 16, authentication: 32, sharedPrivateKey: 128 }, armor: { multipartSection: 0, multipartLast: 1, signed: 2, message: 3, publicKey: 4, privateKey: 5, signature: 6 }, reasonForRevocation: { noReason: 0, keySuperseded: 1, keyCompromised: 2, keyRetired: 3, userIDInvalid: 32 }, features: { modificationDetection: 1, aead: 2, v5Keys: 4, seipdv2: 8 }, write: function(t3, e) {
  if (typeof e == "number" && (e = this.read(t3, e)), t3[e] !== void 0) return t3[e];
  throw Error("Invalid enum value.");
}, read: function(t3, e) {
  if (t3[gc] || (t3[gc] = [], Object.entries(t3).forEach(([n, r]) => {
    t3[gc][r] = n;
  })), t3[gc][e] !== void 0) return t3[gc][e];
  throw Error("Invalid enum value.");
} }, Qt = { preferredHashAlgorithm: ee.hash.sha512, preferredSymmetricAlgorithm: ee.symmetric.aes256, preferredCompressionAlgorithm: ee.compression.uncompressed, aeadProtect: false, parseAEADEncryptedV4KeysAsLegacy: false, preferredAEADAlgorithm: ee.aead.gcm, aeadChunkSizeByte: 12, v6Keys: false, enableParsingV5Entities: false, s2kType: ee.s2k.iterated, s2kIterationCountByte: 224, s2kArgon2Params: { passes: 3, parallelism: 4, memoryExponent: 16 }, allowUnauthenticatedMessages: false, allowUnauthenticatedStream: false, minRSABits: 2047, passwordCollisionCheck: false, allowInsecureDecryptionWithSigningKeys: false, allowInsecureVerificationWithReformattedKeys: false, allowMissingKeyFlags: false, constantTimePKCS1Decryption: false, constantTimePKCS1DecryptionSupportedSymmetricAlgorithms: /* @__PURE__ */ new Set([ee.symmetric.aes128, ee.symmetric.aes192, ee.symmetric.aes256]), ignoreUnsupportedPackets: true, ignoreMalformedPackets: false, enforceGrammar: true, additionalAllowedPackets: [], showVersion: false, showComment: false, versionString: "OpenPGP.js 6.3.0", commentString: "https://openpgpjs.org", maxUserIDLength: 5120, maxDecompressedMessageSize: 1 / 0, knownNotations: [], nonDeterministicSignaturesViaNotation: true, useEllipticFallback: true, rejectHashAlgorithms: /* @__PURE__ */ new Set([ee.hash.md5, ee.hash.ripemd]), rejectMessageHashAlgorithms: /* @__PURE__ */ new Set([ee.hash.md5, ee.hash.ripemd, ee.hash.sha1]), rejectPublicKeyAlgorithms: /* @__PURE__ */ new Set([ee.publicKey.elgamal, ee.publicKey.dsa]), rejectCurves: /* @__PURE__ */ new Set([ee.curve.secp256k1]) };
const o6 = (() => {
  try {
    return false;
  } catch {
  }
  return false;
})(), Ee = { isString: function(t3) {
  return typeof t3 == "string" || t3 instanceof String;
}, nodeRequire: () => {
}, isArray: function(t3) {
  return t3 instanceof Array;
}, isUint8Array: rg, isStream: si, getNobleCurve: async (t3, e) => {
  if (!Qt.useEllipticFallback) throw Error("This curve is only supported in the full build of OpenPGP.js");
  const { nobleCurves: n } = await Promise.resolve().then(function() {
    return HL;
  });
  switch (t3) {
    case ee.publicKey.ecdh:
    case ee.publicKey.ecdsa: {
      const r = n.get(e);
      if (!r) throw Error("Unsupported curve");
      return r;
    }
    case ee.publicKey.x448:
      return n.get("x448");
    case ee.publicKey.ed448:
      return n.get("ed448");
    default:
      throw Error("Unsupported curve");
  }
}, readNumber: function(t3) {
  let e = 0;
  for (let n = 0; n < t3.length; n++) e += 256 ** n * t3[t3.length - 1 - n];
  return e;
}, writeNumber: function(t3, e) {
  const n = new Uint8Array(e);
  for (let r = 0; r < e; r++) n[r] = t3 >> 8 * (e - r - 1) & 255;
  return n;
}, readDate: function(t3) {
  const e = Ee.readNumber(t3);
  return new Date(1e3 * e);
}, writeDate: function(t3) {
  const e = Math.floor(t3.getTime() / 1e3);
  return Ee.writeNumber(e, 4);
}, normalizeDate: function(t3 = Date.now()) {
  return t3 === null || t3 === 1 / 0 ? t3 : new Date(1e3 * Math.floor(+t3 / 1e3));
}, readMPI: function(t3) {
  const e = (t3[0] << 8 | t3[1]) + 7 >>> 3;
  return Ee.readExactSubarray(t3, 2, 2 + e);
}, readExactSubarray: function(t3, e, n) {
  if (t3.length < n - e) throw Error("Input array too short");
  return t3.subarray(e, n);
}, leftPad(t3, e) {
  if (t3.length > e) throw Error("Input array too long");
  const n = new Uint8Array(e), r = e - t3.length;
  return n.set(t3, r), n;
}, uint8ArrayToMPI: function(t3) {
  const e = Ee.uint8ArrayBitLength(t3);
  if (e === 0) throw Error("Zero MPI");
  const n = t3.subarray(t3.length - Math.ceil(e / 8)), r = new Uint8Array([(65280 & e) >> 8, 255 & e]);
  return Ee.concatUint8Array([r, n]);
}, uint8ArrayBitLength: function(t3) {
  let e;
  for (e = 0; e < t3.length && t3[e] === 0; e++) ;
  if (e === t3.length) return 0;
  const n = t3.subarray(e);
  return 8 * (n.length - 1) + Ee.nbits(n[0]);
}, hexToUint8Array: function(t3) {
  const e = new Uint8Array(t3.length >> 1);
  for (let n = 0; n < t3.length >> 1; n++) e[n] = parseInt(t3.substr(n << 1, 2), 16);
  return e;
}, uint8ArrayToHex: function(t3) {
  const e = "0123456789abcdef";
  let n = "";
  return t3.forEach((r) => {
    n += e[r >> 4] + e[15 & r];
  }), n;
}, stringToUint8Array: function(t3) {
  return ii(t3, (e) => {
    if (!Ee.isString(e)) throw Error("stringToUint8Array: Data must be in the form of a string");
    const n = new Uint8Array(e.length);
    for (let r = 0; r < e.length; r++) n[r] = e.charCodeAt(r);
    return n;
  });
}, uint8ArrayToString: function(t3) {
  const e = [], r = (t3 = new Uint8Array(t3)).length;
  for (let s = 0; s < r; s += 16384) e.push(String.fromCharCode.apply(String, t3.subarray(s, s + 16384 < r ? s + 16384 : r)));
  return e.join("");
}, encodeUTF8: function(t3) {
  const e = new TextEncoder("utf-8");
  function n(r, s = false) {
    return e.encode(r, { stream: !s });
  }
  return ii(t3, n, () => n("", true));
}, decodeUTF8: function(t3) {
  const e = new TextDecoder("utf-8");
  function n(r, s = false) {
    return e.decode(r, { stream: !s });
  }
  return ii(t3, n, () => n(new Uint8Array(), true));
}, concat: hs, concatUint8Array: KC, equalsUint8Array: function(t3, e) {
  if (!Ee.isUint8Array(t3) || !Ee.isUint8Array(e)) throw Error("Data must be in the form of a Uint8Array");
  if (t3.length !== e.length) return false;
  for (let n = 0; n < t3.length; n++) if (t3[n] !== e[n]) return false;
  return true;
}, findLastIndex: function(t3, e) {
  for (let n = t3.length; n >= 0; n--) if (e(t3[n], n, t3)) return n;
  return -1;
}, writeChecksum: function(t3) {
  let e = 0;
  for (let n = 0; n < t3.length; n++) e = e + t3[n] & 65535;
  return Ee.writeNumber(e, 2);
}, printDebug: function(t3) {
  o6 && console.log("[OpenPGP.js debug]", t3);
}, printDebugError: function(t3) {
  o6 && console.error("[OpenPGP.js debug]", t3);
}, nbits: function(t3) {
  let e = 1, n = t3 >>> 16;
  return n !== 0 && (t3 = n, e += 16), n = t3 >> 8, n !== 0 && (t3 = n, e += 8), n = t3 >> 4, n !== 0 && (t3 = n, e += 4), n = t3 >> 2, n !== 0 && (t3 = n, e += 2), n = t3 >> 1, n !== 0 && (t3 = n, e += 1), e;
}, double: function(t3) {
  const e = new Uint8Array(t3.length), n = t3.length - 1;
  for (let r = 0; r < n; r++) e[r] = t3[r] << 1 ^ t3[r + 1] >> 7;
  return e[n] = t3[n] << 1 ^ 135 * (t3[0] >> 7), e;
}, shiftRight: function(t3, e) {
  if (e) for (let n = t3.length - 1; n >= 0; n--) t3[n] >>= e, n > 0 && (t3[n] |= t3[n - 1] << 8 - e);
  return t3;
}, getWebCrypto: function() {
  var _a2;
  const t3 = es !== void 0 && es.crypto && es.crypto.subtle || ((_a2 = this.getNodeCrypto()) == null ? void 0 : _a2.webcrypto.subtle);
  if (!t3) throw Error("The WebCrypto API is not available");
  return t3;
}, getNodeCrypto: function() {
  return this.nodeRequire("crypto");
}, getNodeZlib: function() {
  return this.nodeRequire("zlib");
}, getNodeBuffer: function() {
  return (this.nodeRequire("buffer") || {}).Buffer;
}, getHardwareConcurrency: function() {
  return typeof navigator < "u" ? navigator.hardwareConcurrency || 1 : this.nodeRequire("os").cpus().length;
}, isEmailAddress: function(t3) {
  return Ee.isString(t3) ? /^[^\p{C}\p{Z}@<>\\]+@[^\p{C}\p{Z}@<>\\]+[^\p{C}\p{Z}\p{P}]$/u.test(t3) : false;
}, canonicalizeEOL: function(t3) {
  let e = false;
  return ii(t3, (n) => {
    let r;
    e && (n = Ee.concatUint8Array([new Uint8Array([13]), n])), n[n.length - 1] === 13 ? (e = true, n = n.subarray(0, -1)) : e = false;
    const s = [];
    for (let o = 0; r = n.indexOf(10, o) + 1, r; o = r) n[r - 2] !== 13 && s.push(r);
    if (!s.length) return n;
    const i = new Uint8Array(n.length + s.length);
    let a = 0;
    for (let o = 0; o < s.length; o++) {
      const f = n.subarray(s[o - 1] || 0, s[o]);
      i.set(f, a), a += f.length, i[a - 1] = 13, i[a] = 10, a++;
    }
    return i.set(n.subarray(s[s.length - 1] || 0), a), i;
  }, () => e ? new Uint8Array([13]) : void 0);
}, nativeEOL: function(t3) {
  let e = false;
  return ii(t3, (n) => {
    let r;
    (n = e && n[0] !== 10 ? Ee.concatUint8Array([new Uint8Array([13]), n]) : new Uint8Array(n))[n.length - 1] === 13 ? (e = true, n = n.subarray(0, -1)) : e = false;
    let s = 0;
    for (let i = 0; i !== n.length; i = r) {
      r = n.indexOf(13, i) + 1, r || (r = n.length);
      const a = r - (n[r] === 10 ? 1 : 0);
      i && n.copyWithin(s, i, a), s += a - i;
    }
    return n.subarray(0, s);
  }, () => e ? new Uint8Array([13]) : void 0);
}, removeTrailingSpaces: function(t3) {
  return t3.split(`
`).map((e) => {
    let n = e.length - 1;
    for (; n >= 0 && (e[n] === " " || e[n] === "	" || e[n] === "\r"); n--) ;
    return e.substr(0, n + 1);
  }).join(`
`);
}, wrapError: function(t3, e) {
  if (!e) return t3 instanceof Error ? t3 : Error(t3);
  if (t3 instanceof Error) {
    try {
      t3.message += ": " + e.message, t3.cause = e;
    } catch {
    }
    return t3;
  }
  return Error(t3 + ": " + e.message, { cause: e });
}, constructAllowedPackets: function(t3) {
  const e = {};
  return t3.forEach((n) => {
    if (!n.tag) throw Error("Invalid input: expected a packet class");
    e[n.tag] = n;
  }), e;
}, anyPromise: function(t3) {
  return new Promise((e, n) => {
    let r;
    Promise.all(t3.map(async (s) => {
      try {
        e(await s);
      } catch (i) {
        r = i;
      }
    })).then(() => {
      n(r);
    });
  });
}, selectUint8Array: function(t3, e, n) {
  const r = Math.max(e.length, n.length), s = new Uint8Array(r);
  let i = 0;
  for (let a = 0; a < s.length; a++) s[a] = e[a] & 256 - t3 | n[a] & 255 + t3, i += t3 & a < e.length | 1 - t3 & a < n.length;
  return s.subarray(0, i);
}, selectUint8: function(t3, e, n) {
  return e & 256 - t3 | n & 255 + t3;
}, isAES: function(t3) {
  return t3 === ee.symmetric.aes128 || t3 === ee.symmetric.aes192 || t3 === ee.symmetric.aes256;
} }, Tm = Ee.getNodeBuffer();
let e1, t1;
function Ho(t3) {
  let e = new Uint8Array();
  return ii(t3, (n) => {
    e = Ee.concatUint8Array([e, n]);
    const r = [], s = Math.floor(e.length / 45), i = 45 * s, a = e1(e.subarray(0, i));
    for (let o = 0; o < s; o++) r.push(a.substr(60 * o, 60)), r.push(`
`);
    return e = e.subarray(i), r.join("");
  }, () => e.length ? e1(e) + `
` : "");
}
function VC(t3) {
  let e = "";
  return ii(t3, (n) => {
    e += n;
    let r = 0;
    const s = [" ", "	", "\r", `
`];
    for (let o = 0; o < s.length; o++) {
      const f = s[o];
      for (let c = e.indexOf(f); c !== -1; c = e.indexOf(f, c + 1)) r++;
    }
    let i = e.length;
    for (; i > 0 && (i - r) % 4 != 0; i--) s.includes(e[i]) && r--;
    const a = t1(e.substr(0, i));
    return e = e.substr(i), a;
  }, () => t1(e));
}
function _s(t3) {
  return VC(t3.replace(/-/g, "+").replace(/_/g, "/"));
}
function Ri(t3, e) {
  let n = Ho(t3).replace(/[\r\n]/g, "");
  return n = n.replace(/[+]/g, "-").replace(/[/]/g, "_").replace(/[=]/g, ""), n;
}
function KP(t3) {
  const e = t3.match(/^-----BEGIN PGP (MESSAGE, PART \d+\/\d+|MESSAGE, PART \d+|SIGNED MESSAGE|MESSAGE|PUBLIC KEY BLOCK|PRIVATE KEY BLOCK|SIGNATURE)-----$/m);
  if (!e) throw Error("Unknown ASCII armor type");
  return /MESSAGE, PART \d+\/\d+/.test(e[1]) ? ee.armor.multipartSection : /MESSAGE, PART \d+/.test(e[1]) ? ee.armor.multipartLast : /SIGNED MESSAGE/.test(e[1]) ? ee.armor.signed : /MESSAGE/.test(e[1]) ? ee.armor.message : /PUBLIC KEY BLOCK/.test(e[1]) ? ee.armor.publicKey : /PRIVATE KEY BLOCK/.test(e[1]) ? ee.armor.privateKey : /SIGNATURE/.test(e[1]) ? ee.armor.signature : void 0;
}
function _l(t3, e) {
  let n = "";
  return e.showVersion && (n += "Version: " + e.versionString + `
`), e.showComment && (n += "Comment: " + e.commentString + `
`), t3 && (n += "Comment: " + t3 + `
`), n += `
`, n;
}
function El(t3) {
  const e = function(n) {
    let r = 13501623;
    return ii(n, (s) => {
      const i = HP ? Math.floor(s.length / 4) : 0, a = new Uint32Array(s.buffer, s.byteOffset, i);
      for (let o = 0; o < i; o++) r ^= a[o], r = wi[0][r >> 24 & 255] ^ wi[1][r >> 16 & 255] ^ wi[2][r >> 8 & 255] ^ wi[3][255 & r];
      for (let o = 4 * i; o < s.length; o++) r = r >> 8 ^ wi[0][255 & r ^ s[o]];
    }, () => new Uint8Array([r, r >> 8, r >> 16]));
  }(t3);
  return Ho(e);
}
Tm ? (e1 = (t3) => Tm.from(t3).toString("base64"), t1 = (t3) => {
  const e = Tm.from(t3, "base64");
  return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
}) : (e1 = (t3) => btoa(Ee.uint8ArrayToString(t3)), t1 = (t3) => Ee.stringToUint8Array(atob(t3)));
const wi = [Array(255), Array(255), Array(255), Array(255)];
for (let t3 = 0; t3 <= 255; t3++) {
  let e = t3 << 16;
  for (let n = 0; n < 8; n++) e = e << 1 ^ (8388608 & e ? 8801531 : 0);
  wi[0][t3] = (16711680 & e) >> 16 | 65280 & e | (255 & e) << 16;
}
for (let t3 = 0; t3 <= 255; t3++) wi[1][t3] = wi[0][t3] >> 8 ^ wi[0][255 & wi[0][t3]];
for (let t3 = 0; t3 <= 255; t3++) wi[2][t3] = wi[1][t3] >> 8 ^ wi[0][255 & wi[1][t3]];
for (let t3 = 0; t3 <= 255; t3++) wi[3][t3] = wi[2][t3] >> 8 ^ wi[0][255 & wi[2][t3]];
const HP = function() {
  const t3 = new ArrayBuffer(2);
  return new DataView(t3).setInt16(0, 255, true), new Int16Array(t3)[0] === 255;
}();
function f6(t3) {
  for (let e = 0; e < t3.length; e++) /^([^\s:]|[^\s:][^:]*[^\s:]): .+$/.test(t3[e]) || Ee.printDebugError(Error("Improperly formatted armor header: " + t3[e])), /^(Version|Comment|MessageID|Hash|Charset): .+$/.test(t3[e]) || Ee.printDebugError(Error("Unknown header: " + t3[e]));
}
function qP(t3) {
  let e = t3;
  const n = t3.lastIndexOf("=");
  return n >= 0 && n !== t3.length - 1 && (e = t3.slice(0, n)), e;
}
function Wh(t3) {
  return new Promise((e, n) => {
    try {
      const r = /^-----[^-]+-----$/m, s = /^[ \f\r\t\u00a0\u2000-\u200a\u202f\u205f\u3000]*$/;
      let i;
      const a = [];
      let o, f, c = a, l = [];
      const h = VC(hl(t3, async (m, v) => {
        const b = Ma(m);
        try {
          for (; ; ) {
            let _ = await b.readLine();
            if (_ === void 0) throw Error("Misformed armored text");
            if (_ = Ee.removeTrailingSpaces(_.replace(/[\r\n]/g, "")), i) if (o) f || i !== ee.armor.signed || (r.test(_) ? (l = l.join(`\r
`), f = true, f6(c), c = [], o = false) : l.push(_.replace(/^- /, "")));
            else if (r.test(_) && n(Error("Mandatory blank line missing between armor headers and armor data")), s.test(_)) {
              if (f6(c), o = true, f || i !== ee.armor.signed) {
                e({ text: l, data: h, headers: a, type: i });
                break;
              }
            } else c.push(_);
            else r.test(_) && (i = KP(_));
          }
        } catch (_) {
          return void n(_);
        }
        const A = Hs(v);
        try {
          for (; ; ) {
            await A.ready;
            const { done: _, value: C } = await b.read();
            if (_) throw Error("Misformed armored text");
            const I = C + "";
            if (I.indexOf("=") !== -1 || I.indexOf("-") !== -1) {
              let S = await b.readToEnd();
              S.length || (S = ""), S = I + S, S = Ee.removeTrailingSpaces(S.replace(/\r/g, ""));
              const $ = S.split(r);
              if ($.length === 1) throw Error("Misformed armored text");
              const F = qP($[0].slice(0, -1));
              await A.write(F);
              break;
            }
            await A.write(I);
          }
          await A.ready, await A.close();
        } catch (_) {
          await A.abort(_);
        }
      }));
    } catch (r) {
      n(r);
    }
  }).then(async (e) => (Un(e.data) && (e.data = await Zn(e.data)), e));
}
function Jh(t3, e, n, r, s, i = false, a = Qt) {
  let o, f;
  t3 === ee.armor.signed && (o = e.text, f = e.hash, e = e.data);
  const c = i && sh(e), l = [];
  switch (t3) {
    case ee.armor.multipartSection:
      l.push("-----BEGIN PGP MESSAGE, PART " + n + "/" + r + `-----
`), l.push(_l(s, a)), l.push(Ho(e)), c && l.push("=", El(c)), l.push("-----END PGP MESSAGE, PART " + n + "/" + r + `-----
`);
      break;
    case ee.armor.multipartLast:
      l.push("-----BEGIN PGP MESSAGE, PART " + n + `-----
`), l.push(_l(s, a)), l.push(Ho(e)), c && l.push("=", El(c)), l.push("-----END PGP MESSAGE, PART " + n + `-----
`);
      break;
    case ee.armor.signed:
      l.push(`-----BEGIN PGP SIGNED MESSAGE-----
`), l.push(f ? `Hash: ${f}

` : `
`), l.push(o.replace(/^-/gm, "- -")), l.push(`
-----BEGIN PGP SIGNATURE-----
`), l.push(_l(s, a)), l.push(Ho(e)), c && l.push("=", El(c)), l.push(`-----END PGP SIGNATURE-----
`);
      break;
    case ee.armor.message:
      l.push(`-----BEGIN PGP MESSAGE-----
`), l.push(_l(s, a)), l.push(Ho(e)), c && l.push("=", El(c)), l.push(`-----END PGP MESSAGE-----
`);
      break;
    case ee.armor.publicKey:
      l.push(`-----BEGIN PGP PUBLIC KEY BLOCK-----
`), l.push(_l(s, a)), l.push(Ho(e)), c && l.push("=", El(c)), l.push(`-----END PGP PUBLIC KEY BLOCK-----
`);
      break;
    case ee.armor.privateKey:
      l.push(`-----BEGIN PGP PRIVATE KEY BLOCK-----
`), l.push(_l(s, a)), l.push(Ho(e)), c && l.push("=", El(c)), l.push(`-----END PGP PRIVATE KEY BLOCK-----
`);
      break;
    case ee.armor.signature:
      l.push(`-----BEGIN PGP SIGNATURE-----
`), l.push(_l(s, a)), l.push(Ho(e)), c && l.push("=", El(c)), l.push(`-----END PGP SIGNATURE-----
`);
  }
  return Ee.concat(l);
}
const Cs = BigInt(0), ou = BigInt(1);
function pr(t3) {
  const e = "0123456789ABCDEF";
  let n = "";
  return t3.forEach((r) => {
    n += e[r >> 4] + e[15 & r];
  }), BigInt("0x0" + n);
}
function Wr(t3, e) {
  const n = t3 % e;
  return n < Cs ? n + e : n;
}
function _i(t3, e, n) {
  if (n === Cs) throw Error("Modulo cannot be zero");
  if (n === ou) return BigInt(0);
  if (e < Cs) throw Error("Unsopported negative exponent");
  let r = e, s = t3;
  s %= n;
  let i = BigInt(1);
  for (; r > Cs; ) {
    const a = r & ou;
    r >>= ou, i = a ? i * s % n : i, s = s * s % n;
  }
  return i;
}
function l6(t3) {
  return t3 >= Cs ? t3 : -t3;
}
function vu(t3, e) {
  const { gcd: n, x: r } = function(s, i) {
    let a = BigInt(0), o = BigInt(1), f = BigInt(1), c = BigInt(0), l = l6(s), h = l6(i);
    const m = s < Cs, v = i < Cs;
    for (; h !== Cs; ) {
      const b = l / h;
      let A = a;
      a = f - b * a, f = A, A = o, o = c - b * o, c = A, A = h, h = l % h, l = A;
    }
    return { x: m ? -f : f, y: v ? -c : c, gcd: l };
  }(t3, e);
  if (n !== ou) throw Error("Inverse does not exist");
  return Wr(r + e, e);
}
function Py(t3) {
  const e = Number(t3);
  if (e > Number.MAX_SAFE_INTEGER) throw Error("Number can only safely store up to 53 bits");
  return e;
}
function zP(t3, e) {
  return (t3 >> BigInt(e) & ou) === Cs ? 0 : 1;
}
function fu(t3) {
  const e = t3 < Cs ? BigInt(-1) : Cs;
  let n = 1, r = t3;
  for (; (r >>= ou) !== e; ) n++;
  return n;
}
function ks(t3) {
  const e = t3 < Cs ? BigInt(-1) : Cs, n = BigInt(8);
  let r = 1, s = t3;
  for (; (s >>= n) !== e; ) r++;
  return r;
}
function Jn(t3, e = "be", n) {
  let r = t3.toString(16);
  r.length % 2 == 1 && (r = "0" + r);
  const s = r.length / 2, i = new Uint8Array(n || s), a = n ? n - s : 0;
  let o = 0;
  for (; o < s; ) i[o + a] = parseInt(r.slice(2 * o, 2 * o + 2), 16), o++;
  return e !== "be" && i.reverse(), i;
}
const GP = Ee.getNodeCrypto();
function Ni(t3) {
  const e = typeof crypto < "u" ? crypto : GP == null ? void 0 : GP.webcrypto;
  if (e == null ? void 0 : e.getRandomValues) {
    const n = new Uint8Array(t3);
    return e.getRandomValues(n);
  }
  throw Error("No secure random number generator available.");
}
function Xf(t3, e) {
  if (e < t3) throw Error("Illegal parameter value: max <= min");
  const n = e - t3;
  return Wr(pr(Ni(ks(n) + 8)), n) + t3;
}
const Va = BigInt(1);
function u6(t3, e, n) {
  const r = BigInt(30), s = Va << BigInt(t3 - 1), i = [1, 6, 5, 4, 3, 2, 1, 4, 3, 2, 1, 2, 1, 4, 3, 2, 1, 2, 1, 4, 3, 2, 1, 6, 5, 4, 3, 2, 1, 2];
  let a = Xf(s, s << Va), o = Py(Wr(a, r));
  do
    a += BigInt(i[o]), o = (o + i[o]) % i.length, fu(a) > t3 && (a = Wr(a, s << Va), a += s, o = Py(Wr(a, r)));
  while (!YC(a, e, n));
  return a;
}
function YC(t3, e, n) {
  return (!e || function(r, s) {
    let i = r, a = s;
    for (; a !== Cs; ) {
      const o = a;
      a = i % a, i = o;
    }
    return i;
  }(t3 - Va, e) === Va) && !!function(r) {
    const s = BigInt(0);
    return VP.every((i) => Wr(r, i) !== s);
  }(t3) && !!function(r, s = BigInt(2)) {
    return _i(s, r - Va, r) === Va;
  }(t3) && !!function(r, s) {
    const i = fu(r);
    s || (s = Math.max(1, i / 48 | 0));
    const a = r - Va;
    let o = 0;
    for (; !zP(a, o); ) o++;
    const f = r >> BigInt(o);
    for (; s > 0; s--) {
      let c, l = _i(Xf(BigInt(2), a), f, r);
      if (l !== Va && l !== a) {
        for (c = 1; c < o; c++) {
          if (l = Wr(l * l, r), l === Va) return false;
          if (l === a) break;
        }
        if (c === o) return false;
      }
    }
    return true;
  }(t3, n);
}
const VP = [7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999].map((t3) => BigInt(t3)), c6 = Ee.getWebCrypto(), r1 = Ee.getNodeCrypto(), YP = r1 && r1.getHashes();
function cf(t3) {
  if (r1 && YP.includes(t3)) return async function(e) {
    const n = r1.createHash(t3);
    return ii(e, (r) => {
      n.update(r);
    }, () => new Uint8Array(n.digest()));
  };
}
function hf(t3, e) {
  const n = async () => {
    const { nobleHashes: r } = await Promise.resolve().then(function() {
      return iO;
    }), s = r.get(t3);
    if (!s) throw Error("Unsupported hash");
    return s;
  };
  return async function(r) {
    if (Un(r) && (r = await Zn(r)), Ee.isStream(r)) {
      const s = (await n()).create();
      return ii(r, (i) => {
        s.update(i);
      }, () => s.digest());
    }
    return c6 && e ? new Uint8Array(await c6.digest(e, r)) : (await n())(r);
  };
}
const WP = cf("md5") || hf("md5"), JP = cf("sha1") || hf("sha1", "SHA-1"), ZP = cf("sha224") || hf("sha224"), jP = cf("sha256") || hf("sha256", "SHA-256"), XP = cf("sha384") || hf("sha384", "SHA-384"), eN = cf("sha512") || hf("sha512", "SHA-512"), tN = cf("ripemd160") || hf("ripemd160"), rN = cf("sha3-256") || hf("sha3_256"), nN = cf("sha3-512") || hf("sha3_512");
function _o(t3, e) {
  switch (t3) {
    case ee.hash.md5:
      return WP(e);
    case ee.hash.sha1:
      return JP(e);
    case ee.hash.ripemd:
      return tN(e);
    case ee.hash.sha256:
      return jP(e);
    case ee.hash.sha384:
      return XP(e);
    case ee.hash.sha512:
      return eN(e);
    case ee.hash.sha224:
      return ZP(e);
    case ee.hash.sha3_256:
      return rN(e);
    case ee.hash.sha3_512:
      return nN(e);
    default:
      throw Error("Unsupported hash function");
  }
}
function li(t3) {
  switch (t3) {
    case ee.hash.md5:
      return 16;
    case ee.hash.sha1:
    case ee.hash.ripemd:
      return 20;
    case ee.hash.sha256:
      return 32;
    case ee.hash.sha384:
      return 48;
    case ee.hash.sha512:
      return 64;
    case ee.hash.sha224:
      return 28;
    case ee.hash.sha3_256:
      return 32;
    case ee.hash.sha3_512:
      return 64;
    default:
      throw Error("Invalid hash algorithm.");
  }
}
const Ya = [];
function WC(t3, e) {
  const n = t3.length;
  if (n > e - 11) throw Error("Message too long");
  const r = function(i) {
    const a = new Uint8Array(i);
    let o = 0;
    for (; o < i; ) {
      const f = Ni(i - o);
      for (let c = 0; c < f.length; c++) f[c] !== 0 && (a[o++] = f[c]);
    }
    return a;
  }(e - n - 3), s = new Uint8Array(e);
  return s[1] = 2, s.set(r, 2), s.set(t3, e - n), s;
}
function JC(t3, e) {
  let n = 2, r = 1;
  for (let o = n; o < t3.length; o++) r &= t3[o] !== 0, n += r;
  const s = n - 2, i = t3.subarray(n + 1), a = t3[0] === 0 & t3[1] === 2 & s >= 8 & !r;
  if (e) return Ee.selectUint8Array(a, i, e);
  if (a) return i;
  throw Error("Decryption error");
}
function ZC(t3, e, n) {
  let r;
  if (e.length !== li(t3)) throw Error("Invalid hash length");
  const s = new Uint8Array(Ya[t3].length);
  for (r = 0; r < Ya[t3].length; r++) s[r] = Ya[t3][r];
  const i = s.length + e.length;
  if (n < i + 11) throw Error("Intended encoded message length too short");
  const a = new Uint8Array(n - i - 3).fill(255), o = new Uint8Array(n);
  return o[1] = 1, o.set(a, 2), o.set(s, n - i), o.set(e, n - e.length), o;
}
Ya[1] = [48, 32, 48, 12, 6, 8, 42, 134, 72, 134, 247, 13, 2, 5, 5, 0, 4, 16], Ya[2] = [48, 33, 48, 9, 6, 5, 43, 14, 3, 2, 26, 5, 0, 4, 20], Ya[3] = [48, 33, 48, 9, 6, 5, 43, 36, 3, 2, 1, 5, 0, 4, 20], Ya[8] = [48, 49, 48, 13, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 5, 0, 4, 32], Ya[9] = [48, 65, 48, 13, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 2, 5, 0, 4, 48], Ya[10] = [48, 81, 48, 13, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 3, 5, 0, 4, 64], Ya[11] = [48, 45, 48, 13, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 4, 5, 0, 4, 28];
const yu = Ee.getWebCrypto(), s0 = Ee.getNodeCrypto(), nl = BigInt(1);
async function iN(t3, e, n, r, s, i, a, o, f) {
  if (li(t3) >= n.length) throw Error("Digest size cannot exceed key modulus size");
  if (e && !Ee.isStream(e)) {
    if (Ee.getWebCrypto()) try {
      return await async function(c, l, h, m, v, b, A, _) {
        const C = Ny(h, m, v, b, A, _), I = { name: "RSASSA-PKCS1-v1_5", hash: { name: c } }, S = await yu.importKey("jwk", C, I, false, ["sign"]);
        return new Uint8Array(await yu.sign("RSASSA-PKCS1-v1_5", S, l));
      }(ee.read(ee.webHash, t3), e, n, r, s, i, a, o);
    } catch (c) {
      Ee.printDebugError(c);
    }
    else if (Ee.getNodeCrypto()) return function(c, l, h, m, v, b, A, _) {
      const C = s0.createSign(ee.read(ee.hash, c));
      C.write(l), C.end();
      const I = Ny(h, m, v, b, A, _);
      return new Uint8Array(C.sign({ key: I, format: "jwk", type: "pkcs1" }));
    }(t3, e, n, r, s, i, a, o);
  }
  return function(c, l, h, m) {
    l = pr(l);
    const v = pr(ZC(c, m, ks(l)));
    return h = pr(h), Jn(_i(v, h, l), "be", ks(l));
  }(t3, n, s, f);
}
async function sN(t3, e, n, r, s, i) {
  if (e && !Ee.isStream(e)) {
    if (Ee.getWebCrypto()) try {
      return await async function(a, o, f, c, l) {
        const h = Uy(c, l), m = await yu.importKey("jwk", h, { name: "RSASSA-PKCS1-v1_5", hash: { name: a } }, false, ["verify"]);
        return yu.verify("RSASSA-PKCS1-v1_5", m, f, o);
      }(ee.read(ee.webHash, t3), e, n, r, s);
    } catch (a) {
      Ee.printDebugError(a);
    }
    else if (Ee.getNodeCrypto()) return function(a, o, f, c, l) {
      const h = Uy(c, l), m = { key: h, format: "jwk", type: "pkcs1" }, v = s0.createVerify(ee.read(ee.hash, a));
      v.write(o), v.end();
      try {
        return v.verify(m, f);
      } catch {
        return false;
      }
    }(t3, e, n, r, s);
  }
  return function(a, o, f, c, l) {
    if (f = pr(f), o = pr(o), c = pr(c), o >= f) throw Error("Signature size cannot exceed modulus size");
    const h = Jn(_i(o, c, f), "be", ks(f)), m = ZC(a, l, ks(f));
    return Ee.equalsUint8Array(h, m);
  }(t3, n, r, s, i);
}
async function aN(t3, e, n) {
  return Ee.getNodeCrypto() ? function(r, s, i) {
    const a = Uy(s, i), o = { key: a, format: "jwk", type: "pkcs1", padding: s0.constants.RSA_PKCS1_PADDING };
    return new Uint8Array(s0.publicEncrypt(o, r));
  }(t3, e, n) : function(r, s, i) {
    if (s = pr(s), r = pr(WC(r, ks(s))), i = pr(i), r >= s) throw Error("Message size cannot exceed modulus size");
    return Jn(_i(r, i, s), "be", ks(s));
  }(t3, e, n);
}
async function oN(t3, e, n, r, s, i, a, o) {
  if (Ee.getNodeCrypto() && !o) try {
    return function(f, c, l, h, m, v, b) {
      const A = Ny(c, l, h, m, v, b), _ = { key: A, format: "jwk", type: "pkcs1", padding: s0.constants.RSA_PKCS1_PADDING };
      try {
        return new Uint8Array(s0.privateDecrypt(_, f));
      } catch {
        throw Error("Decryption error");
      }
    }(t3, e, n, r, s, i, a);
  } catch (f) {
    Ee.printDebugError(f);
  }
  return function(f, c, l, h, m, v, b, A) {
    if (f = pr(f), c = pr(c), l = pr(l), h = pr(h), m = pr(m), v = pr(v), b = pr(b), f >= c) throw Error("Data too large.");
    const _ = Wr(h, v - nl), C = Wr(h, m - nl), I = Xf(BigInt(2), c), S = _i(vu(I, c), l, c);
    f = Wr(f * S, c);
    const $ = _i(f, C, m), F = _i(f, _, v);
    let Q = Wr(b * (F - $), v) * m + $;
    return Q = Wr(Q * I, c), JC(Jn(Q, "be", ks(c)), A);
  }(t3, e, n, r, s, i, a, o);
}
function Ny(t3, e, n, r, s, i) {
  const a = pr(r), o = pr(s), f = pr(n);
  let c = Wr(f, o - nl), l = Wr(f, a - nl);
  return l = Jn(l), c = Jn(c), { kty: "RSA", n: Ri(t3), e: Ri(e), d: Ri(n), p: Ri(s), q: Ri(r), dp: Ri(c), dq: Ri(l), qi: Ri(i), ext: true };
}
function Uy(t3, e) {
  return { kty: "RSA", n: Ri(t3), e: Ri(e), ext: true };
}
function h6(t3, e) {
  return { n: _s(t3.n), e: Jn(e), d: _s(t3.d), p: _s(t3.q), q: _s(t3.p), u: _s(t3.qi) };
}
const Uf = BigInt(1), fN = { "2a8648ce3d030107": ee.curve.nistP256, "2b81040022": ee.curve.nistP384, "2b81040023": ee.curve.nistP521, "2b8104000a": ee.curve.secp256k1, "2b06010401da470f01": ee.curve.ed25519Legacy, "2b060104019755010501": ee.curve.curve25519Legacy, "2b2403030208010107": ee.curve.brainpoolP256r1, "2b240303020801010b": ee.curve.brainpoolP384r1, "2b240303020801010d": ee.curve.brainpoolP512r1 };
class ef {
  constructor(e) {
    if (e instanceof ef) this.oid = e.oid;
    else if (Ee.isArray(e) || Ee.isUint8Array(e)) {
      if ((e = new Uint8Array(e))[0] === 6) {
        if (e[1] !== e.length - 2) throw Error("Length mismatch in DER encoded oid");
        e = e.subarray(2);
      }
      this.oid = e;
    } else this.oid = "";
  }
  read(e) {
    if (e.length >= 1) {
      const n = e[0];
      if (e.length >= 1 + n) return this.oid = e.subarray(1, 1 + n), 1 + this.oid.length;
    }
    throw Error("Invalid oid");
  }
  write() {
    return Ee.concatUint8Array([new Uint8Array([this.oid.length]), this.oid]);
  }
  toHex() {
    return Ee.uint8ArrayToHex(this.oid);
  }
  getName() {
    const e = fN[this.toHex()];
    if (!e) throw Error("Unknown curve object identifier.");
    return e;
  }
}
function jC(t3) {
  let e, n = 0;
  const r = t3[0];
  return r < 192 ? ([n] = t3, e = 1) : r < 255 ? (n = (t3[0] - 192 << 8) + t3[1] + 192, e = 2) : r === 255 && (n = Ee.readNumber(t3.subarray(1, 5)), e = 5), { len: n, offset: e };
}
function ig(t3) {
  return t3 < 192 ? new Uint8Array([t3]) : t3 > 191 && t3 < 8384 ? new Uint8Array([192 + (t3 - 192 >> 8), t3 - 192 & 255]) : Ee.concatUint8Array([new Uint8Array([255]), Ee.writeNumber(t3, 4)]);
}
function lN(t3) {
  if (t3 < 0 || t3 > 30) throw Error("Partial Length power must be between 1 and 30");
  return new Uint8Array([224 + t3]);
}
function n1(t3) {
  return new Uint8Array([192 | t3]);
}
function d6(t3, e) {
  return Ee.concatUint8Array([n1(t3), ig(e)]);
}
function wp(t3) {
  return [ee.packet.literalData, ee.packet.compressedData, ee.packet.symmetricallyEncryptedData, ee.packet.symEncryptedIntegrityProtectedData, ee.packet.aeadEncryptedData].includes(t3);
}
async function uN(t3, e, n) {
  let r, s;
  try {
    const i = await t3.peekBytes(2);
    if (!i || i.length < 2 || !(128 & i[0])) throw Error("Error during parsing. This message / key probably does not conform to a valid OpenPGP format.");
    const a = await t3.readByte();
    let o, f, c = -1, l = -1;
    l = 0, 64 & a && (l = 1), l ? c = 63 & a : (c = (63 & a) >> 2, f = 3 & a);
    const h = wp(c);
    let m, v = null;
    if (e && h) {
      if (e === "array") {
        const b = new oo();
        r = Hs(b), v = b;
      } else {
        const b = new TransformStream();
        r = Hs(b.writable), v = b.readable;
      }
      s = n({ tag: c, packet: v });
    } else v = [];
    do {
      if (l) {
        const b = await t3.readByte();
        if (m = false, b < 192) o = b;
        else if (b >= 192 && b < 224) o = (b - 192 << 8) + await t3.readByte() + 192;
        else if (b > 223 && b < 255) {
          if (o = 1 << (31 & b), m = true, !h) throw new TypeError("This packet type does not support partial lengths.");
        } else o = await t3.readByte() << 24 | await t3.readByte() << 16 | await t3.readByte() << 8 | await t3.readByte();
      } else switch (f) {
        case 0:
          o = await t3.readByte();
          break;
        case 1:
          o = await t3.readByte() << 8 | await t3.readByte();
          break;
        case 2:
          o = await t3.readByte() << 24 | await t3.readByte() << 16 | await t3.readByte() << 8 | await t3.readByte();
          break;
        default:
          o = 1 / 0;
      }
      if (o > 0) {
        let b = 0;
        for (; ; ) {
          r && await r.ready;
          const { done: A, value: _ } = await t3.read();
          if (A) {
            if (o === 1 / 0) break;
            throw Error("Unexpected end of packet");
          }
          const C = o === 1 / 0 ? _ : _.subarray(0, o - b);
          if (r ? await r.write(C) : v.push(C), b += _.length, b >= o) {
            t3.unshift(_.subarray(o - b + _.length));
            break;
          }
        }
      }
    } while (m);
    r ? (await r.ready, await r.close()) : (v = Ee.concatUint8Array(v), await n({ tag: c, packet: v }));
  } catch (i) {
    if (r) return await r.abort(i), true;
    throw i;
  } finally {
    r && await s;
  }
}
class fn extends Error {
  constructor(...e) {
    super(...e), Error.captureStackTrace && Error.captureStackTrace(this, fn), this.name = "UnsupportedError";
  }
}
class xp extends fn {
  constructor(...e) {
    super(...e), Error.captureStackTrace && Error.captureStackTrace(this, fn), this.name = "UnknownPacketError";
  }
}
class Dm extends fn {
  constructor(...e) {
    super(...e), Error.captureStackTrace && Error.captureStackTrace(this, fn), this.name = "MalformedPacketError";
  }
}
class Ly {
  constructor(e, n) {
    this.tag = e, this.rawContent = n;
  }
  write() {
    return this.rawContent;
  }
}
async function zb(t3) {
  switch (t3) {
    case ee.publicKey.ed25519:
      try {
        const e = Ee.getWebCrypto(), n = await e.generateKey("Ed25519", true, ["sign", "verify"]).catch((i) => {
          if (i.name === "OperationError") {
            const a = Error("Unexpected key generation issue");
            throw a.name = "NotSupportedError", a;
          }
          throw i;
        }), r = await e.exportKey("jwk", n.privateKey), s = await e.exportKey("jwk", n.publicKey);
        return { A: new Uint8Array(_s(s.x)), seed: _s(r.d) };
      } catch (e) {
        if (e.name !== "NotSupportedError") throw e;
        const { default: n } = await Promise.resolve().then(function() {
          return v0;
        }), r = Ni(sg(t3)), { publicKey: s } = n.sign.keyPair.fromSeed(r);
        return { A: s, seed: r };
      }
    case ee.publicKey.ed448: {
      const e = await Ee.getNobleCurve(ee.publicKey.ed448), { secretKey: n, publicKey: r } = e.keygen();
      return { A: r, seed: n };
    }
    default:
      throw Error("Unsupported EdDSA algorithm");
  }
}
async function Gb(t3, e, n, r, s, i) {
  if (li(e) < li(ag(t3))) throw Error("Hash algorithm too weak for EdDSA.");
  switch (t3) {
    case ee.publicKey.ed25519:
      try {
        const a = Ee.getWebCrypto(), o = XC(t3, r, s), f = await a.importKey("jwk", o, "Ed25519", false, ["sign"]);
        return { RS: new Uint8Array(await a.sign("Ed25519", f, i)) };
      } catch (a) {
        if (a.name !== "NotSupportedError") throw a;
        const { default: o } = await Promise.resolve().then(function() {
          return v0;
        }), f = Ee.concatUint8Array([s, r]);
        return { RS: o.sign.detached(i, f) };
      }
    case ee.publicKey.ed448:
      return { RS: (await Ee.getNobleCurve(ee.publicKey.ed448)).sign(i, s) };
    default:
      throw Error("Unsupported EdDSA algorithm");
  }
}
async function Vb(t3, e, { RS: n }, r, s, i) {
  if (li(e) < li(ag(t3))) throw Error("Hash algorithm too weak for EdDSA.");
  switch (t3) {
    case ee.publicKey.ed25519:
      try {
        const a = Ee.getWebCrypto(), o = Wb(t3, s), f = await a.importKey("jwk", o, "Ed25519", false, ["verify"]);
        return await a.verify("Ed25519", f, n, i);
      } catch (a) {
        if (a.name !== "NotSupportedError") throw a;
        const { default: o } = await Promise.resolve().then(function() {
          return v0;
        });
        return o.sign.detached.verify(i, n, s);
      }
    case ee.publicKey.ed448:
      return (await Ee.getNobleCurve(ee.publicKey.ed448)).verify(n, i, s);
    default:
      throw Error("Unsupported EdDSA algorithm");
  }
}
async function Yb(t3, e, n) {
  switch (t3) {
    case ee.publicKey.ed25519:
      try {
        const r = Ee.getWebCrypto(), s = XC(t3, e, n), i = Wb(t3, e), a = await r.importKey("jwk", s, "Ed25519", false, ["sign"]), o = await r.importKey("jwk", i, "Ed25519", false, ["verify"]), f = Ni(8), c = new Uint8Array(await r.sign("Ed25519", a, f));
        return await r.verify("Ed25519", o, c, f);
      } catch (r) {
        if (r.name !== "NotSupportedError") return false;
        const { default: s } = await Promise.resolve().then(function() {
          return v0;
        }), { publicKey: i } = s.sign.keyPair.fromSeed(n);
        return Ee.equalsUint8Array(e, i);
      }
    case ee.publicKey.ed448: {
      const r = (await Ee.getNobleCurve(ee.publicKey.ed448)).getPublicKey(n);
      return Ee.equalsUint8Array(e, r);
    }
    default:
      return false;
  }
}
function sg(t3) {
  switch (t3) {
    case ee.publicKey.ed25519:
      return 32;
    case ee.publicKey.ed448:
      return 57;
    default:
      throw Error("Unsupported EdDSA algorithm");
  }
}
function ag(t3) {
  switch (t3) {
    case ee.publicKey.ed25519:
      return ee.hash.sha256;
    case ee.publicKey.ed448:
      return ee.hash.sha512;
    default:
      throw Error("Unknown EdDSA algo");
  }
}
const Wb = (t3, e) => {
  if (t3 === ee.publicKey.ed25519) return { kty: "OKP", crv: "Ed25519", x: Ri(e), ext: true };
  throw Error("Unsupported EdDSA algorithm");
}, XC = (t3, e, n) => {
  if (t3 === ee.publicKey.ed25519) {
    const r = Wb(t3, e);
    return r.d = Ri(n), r;
  }
  throw Error("Unsupported EdDSA algorithm");
};
var cN = Object.freeze({ __proto__: null, generate: zb, getPayloadSize: sg, getPreferredHashAlgo: ag, sign: Gb, validateParams: Yb, verify: Vb });
/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */
function ek(t3) {
  return t3 instanceof Uint8Array || ArrayBuffer.isView(t3) && t3.constructor.name === "Uint8Array";
}
function Fn(t3, ...e) {
  if (!ek(t3)) throw Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t3.length)) throw Error("Uint8Array expected of length " + e + ", got length=" + t3.length);
}
function i1(t3, e = true) {
  if (t3.destroyed) throw Error("Hash instance has been destroyed");
  if (e && t3.finished) throw Error("Hash#digest() has already been called");
}
function tk(t3, e) {
  Fn(t3);
  const n = e.outputLen;
  if (t3.length < n) throw Error("digestInto() expects output buffer of length at least " + n);
}
function Jb(t3) {
  return new Uint8Array(t3.buffer, t3.byteOffset, t3.byteLength);
}
function An(t3) {
  return new Uint32Array(t3.buffer, t3.byteOffset, Math.floor(t3.byteLength / 4));
}
function ns(...t3) {
  for (let e = 0; e < t3.length; e++) t3[e].fill(0);
}
function og(t3) {
  return new DataView(t3.buffer, t3.byteOffset, t3.byteLength);
}
const hN = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function Eh(t3) {
  if (typeof t3 == "string") t3 = function(e) {
    if (typeof e != "string") throw Error("string expected");
    return new Uint8Array(new TextEncoder().encode(e));
  }(t3);
  else {
    if (!ek(t3)) throw Error("Uint8Array expected, got " + typeof t3);
    t3 = Es(t3);
  }
  return t3;
}
function rk(t3, e) {
  return t3.buffer === e.buffer && t3.byteOffset < e.byteOffset + e.byteLength && e.byteOffset < t3.byteOffset + t3.byteLength;
}
function Oy(t3, e) {
  if (rk(t3, e) && t3.byteOffset < e.byteOffset) throw Error("complex overlap of input and output is not supported");
}
function nk(t3, e) {
  if (t3.length !== e.length) return false;
  let n = 0;
  for (let r = 0; r < t3.length; r++) n |= t3[r] ^ e[r];
  return n === 0;
}
const Zh = (t3, e) => {
  function n(r, ...s) {
    if (Fn(r), !hN) throw Error("Non little-endian hardware is not yet supported");
    if (t3.nonceLength !== void 0) {
      const c = s[0];
      if (!c) throw Error("nonce / iv required");
      t3.varSizeNonce ? Fn(c) : Fn(c, t3.nonceLength);
    }
    const i = t3.tagLength;
    i && s[1] !== void 0 && Fn(s[1]);
    const a = e(r, ...s), o = (c, l) => {
      if (l !== void 0) {
        if (c !== 2) throw Error("cipher output not supported");
        Fn(l);
      }
    };
    let f = false;
    return { encrypt(c, l) {
      if (f) throw Error("cannot encrypt() twice with same key + nonce");
      return f = true, Fn(c), o(a.encrypt.length, l), a.encrypt(c, l);
    }, decrypt(c, l) {
      if (Fn(c), i && c.length < i) throw Error("invalid ciphertext length: smaller than tagLength=" + i);
      return o(a.decrypt.length, l), a.decrypt(c, l);
    } };
  }
  return Object.assign(n, t3), n;
};
function Bh(t3, e, n = true) {
  if (e === void 0) return new Uint8Array(t3);
  if (e.length !== t3) throw Error("invalid output length, expected " + t3 + ", got: " + e.length);
  if (n && !ta(e)) throw Error("invalid output, must be aligned");
  return e;
}
function Qy(t3, e, n, r) {
  if (typeof t3.setBigUint64 == "function") return t3.setBigUint64(e, n, r);
  const s = BigInt(32), i = BigInt(4294967295), a = Number(n >> s & i), o = Number(n & i);
  t3.setUint32(e + 0, a, r), t3.setUint32(e + 4, o, r);
}
function ta(t3) {
  return t3.byteOffset % 4 == 0;
}
function Es(t3) {
  return Uint8Array.from(t3);
}
const Go = 16, Zb = new Uint8Array(16), to = An(Zb), Zs = (t3) => (t3 >>> 0 & 255) << 24 | (t3 >>> 8 & 255) << 16 | (t3 >>> 16 & 255) << 8 | t3 >>> 24 & 255;
class ik {
  constructor(e, n) {
    this.blockLen = Go, this.outputLen = Go, this.s0 = 0, this.s1 = 0, this.s2 = 0, this.s3 = 0, this.finished = false, Fn(e = Eh(e), 16);
    const r = og(e);
    let s = r.getUint32(0, false), i = r.getUint32(4, false), a = r.getUint32(8, false), o = r.getUint32(12, false);
    const f = [];
    for (let I = 0; I < 128; I++) f.push({ s0: Zs(s), s1: Zs(i), s2: Zs(a), s3: Zs(o) }), { s0: s, s1: i, s2: a, s3: o } = { s3: (h = a) << 31 | (m = o) >>> 1, s2: (l = i) << 31 | h >>> 1, s1: (c = s) << 31 | l >>> 1, s0: c >>> 1 ^ 225 << 24 & -(1 & m) };
    var c, l, h, m;
    const v = (b = n || 1024) > 65536 ? 8 : b > 1024 ? 4 : 2;
    var b;
    if (![1, 2, 4, 8].includes(v)) throw Error("ghash: invalid window size, expected 2, 4 or 8");
    this.W = v;
    const A = 128 / v, _ = this.windowSize = 2 ** v, C = [];
    for (let I = 0; I < A; I++) for (let S = 0; S < _; S++) {
      let $ = 0, F = 0, U = 0, Q = 0;
      for (let P = 0; P < v; P++) {
        if (!(S >>> v - P - 1 & 1)) continue;
        const { s0: N, s1: L, s2: B, s3: u } = f[v * I + P];
        $ ^= N, F ^= L, U ^= B, Q ^= u;
      }
      C.push({ s0: $, s1: F, s2: U, s3: Q });
    }
    this.t = C;
  }
  _updateBlock(e, n, r, s) {
    e ^= this.s0, n ^= this.s1, r ^= this.s2, s ^= this.s3;
    const { W: i, t: a, windowSize: o } = this;
    let f = 0, c = 0, l = 0, h = 0;
    const m = (1 << i) - 1;
    let v = 0;
    for (const b of [e, n, r, s]) for (let A = 0; A < 4; A++) {
      const _ = b >>> 8 * A & 255;
      for (let C = 8 / i - 1; C >= 0; C--) {
        const I = _ >>> i * C & m, { s0: S, s1: $, s2: F, s3: U } = a[v * o + I];
        f ^= S, c ^= $, l ^= F, h ^= U, v += 1;
      }
    }
    this.s0 = f, this.s1 = c, this.s2 = l, this.s3 = h;
  }
  update(e) {
    i1(this), Fn(e = Eh(e));
    const n = An(e), r = Math.floor(e.length / Go), s = e.length % Go;
    for (let i = 0; i < r; i++) this._updateBlock(n[4 * i + 0], n[4 * i + 1], n[4 * i + 2], n[4 * i + 3]);
    return s && (Zb.set(e.subarray(r * Go)), this._updateBlock(to[0], to[1], to[2], to[3]), ns(to)), this;
  }
  destroy() {
    const { t: e } = this;
    for (const n of e) n.s0 = 0, n.s1 = 0, n.s2 = 0, n.s3 = 0;
  }
  digestInto(e) {
    i1(this), tk(e, this), this.finished = true;
    const { s0: n, s1: r, s2: s, s3: i } = this, a = An(e);
    return a[0] = n, a[1] = r, a[2] = s, a[3] = i, e;
  }
  digest() {
    const e = new Uint8Array(Go);
    return this.digestInto(e), this.destroy(), e;
  }
}
class dN extends ik {
  constructor(e, n) {
    Fn(e = Eh(e));
    const r = function(s) {
      s.reverse();
      const i = 1 & s[15];
      let a = 0;
      for (let o = 0; o < s.length; o++) {
        const f = s[o];
        s[o] = f >>> 1 | a, a = (1 & f) << 7;
      }
      return s[0] ^= 225 & -i, s;
    }(Es(e));
    super(r, n), ns(r);
  }
  update(e) {
    e = Eh(e), i1(this);
    const n = An(e), r = e.length % Go, s = Math.floor(e.length / Go);
    for (let i = 0; i < s; i++) this._updateBlock(Zs(n[4 * i + 3]), Zs(n[4 * i + 2]), Zs(n[4 * i + 1]), Zs(n[4 * i + 0]));
    return r && (Zb.set(e.subarray(s * Go)), this._updateBlock(Zs(to[3]), Zs(to[2]), Zs(to[1]), Zs(to[0])), ns(to)), this;
  }
  digestInto(e) {
    i1(this), tk(e, this), this.finished = true;
    const { s0: n, s1: r, s2: s, s3: i } = this, a = An(e);
    return a[0] = n, a[1] = r, a[2] = s, a[3] = i, e.reverse();
  }
}
function sk(t3) {
  const e = (r, s) => t3(s, r.length).update(Eh(r)).digest(), n = t3(new Uint8Array(16), 0);
  return e.outputLen = n.outputLen, e.blockLen = n.blockLen, e.create = (r, s) => t3(r, s), e;
}
const p6 = sk((t3, e) => new ik(t3, e));
sk((t3, e) => new dN(t3, e));
const Us = 16, Fd = new Uint8Array(Us);
function jb(t3) {
  return t3 << 1 ^ 283 & -(t3 >> 7);
}
function Y0(t3, e) {
  let n = 0;
  for (; e > 0; e >>= 1) n ^= t3 & -(1 & e), t3 = jb(t3);
  return n;
}
const Ky = (() => {
  const t3 = new Uint8Array(256);
  for (let n = 0, r = 1; n < 256; n++, r ^= jb(r)) t3[n] = r;
  const e = new Uint8Array(256);
  e[0] = 99;
  for (let n = 0; n < 255; n++) {
    let r = t3[255 - n];
    r |= r << 8, e[t3[n]] = 255 & (r ^ r >> 4 ^ r >> 5 ^ r >> 6 ^ r >> 7 ^ 99);
  }
  return ns(t3), e;
})(), pN = Ky.map((t3, e) => Ky.indexOf(e)), Rm = (t3) => t3 << 8 | t3 >>> 24, g6 = (t3) => t3 << 24 & 4278190080 | t3 << 8 & 16711680 | t3 >>> 8 & 65280 | t3 >>> 24 & 255;
function ak(t3, e) {
  if (t3.length !== 256) throw Error("Wrong sbox length");
  const n = new Uint32Array(256).map((c, l) => e(t3[l])), r = n.map(Rm), s = r.map(Rm), i = s.map(Rm), a = new Uint32Array(65536), o = new Uint32Array(65536), f = new Uint16Array(65536);
  for (let c = 0; c < 256; c++) for (let l = 0; l < 256; l++) {
    const h = 256 * c + l;
    a[h] = n[c] ^ r[l], o[h] = s[c] ^ i[l], f[h] = t3[c] << 8 | t3[l];
  }
  return { sbox: t3, sbox2: f, T0: n, T1: r, T2: s, T3: i, T01: a, T23: o };
}
const Xb = ak(Ky, (t3) => Y0(t3, 3) << 24 | t3 << 16 | t3 << 8 | Y0(t3, 2)), ok = ak(pN, (t3) => Y0(t3, 11) << 24 | Y0(t3, 13) << 16 | Y0(t3, 9) << 8 | Y0(t3, 14)), gN = (() => {
  const t3 = new Uint8Array(16);
  for (let e = 0, n = 1; e < 16; e++, n = jb(n)) t3[e] = n;
  return t3;
})();
function p0(t3) {
  Fn(t3);
  const e = t3.length;
  if (![16, 24, 32].includes(e)) throw Error("aes: invalid key size, should be 16, 24 or 32, got " + e);
  const { sbox2: n } = Xb, r = [];
  ta(t3) || r.push(t3 = Es(t3));
  const s = An(t3), i = s.length, a = (c) => fo(n, c, c, c, c), o = new Uint32Array(e + 28);
  o.set(s);
  for (let c = i; c < o.length; c++) {
    let l = o[c - 1];
    c % i == 0 ? l = a((f = l) << 24 | f >>> 8) ^ gN[c / i - 1] : i > 6 && c % i == 4 && (l = a(l)), o[c] = o[c - i] ^ l;
  }
  var f;
  return ns(...r), o;
}
function eA(t3) {
  const e = p0(t3), n = e.slice(), r = e.length, { sbox2: s } = Xb, { T0: i, T1: a, T2: o, T3: f } = ok;
  for (let c = 0; c < r; c += 4) for (let l = 0; l < 4; l++) n[c + l] = e[r - c - 4 + l];
  ns(e);
  for (let c = 4; c < r - 4; c++) {
    const l = n[c], h = fo(s, l, l, l, l);
    n[c] = i[255 & h] ^ a[h >>> 8 & 255] ^ o[h >>> 16 & 255] ^ f[h >>> 24];
  }
  return n;
}
function Hf(t3, e, n, r, s, i) {
  return t3[n << 8 & 65280 | r >>> 8 & 255] ^ e[s >>> 8 & 65280 | i >>> 24 & 255];
}
function fo(t3, e, n, r, s) {
  return t3[255 & e | 65280 & n] | t3[r >>> 16 & 255 | s >>> 16 & 65280] << 16;
}
function $a(t3, e, n, r, s) {
  const { sbox2: i, T01: a, T23: o } = Xb;
  let f = 0;
  e ^= t3[f++], n ^= t3[f++], r ^= t3[f++], s ^= t3[f++];
  const c = t3.length / 4 - 2;
  for (let l = 0; l < c; l++) {
    const h = t3[f++] ^ Hf(a, o, e, n, r, s), m = t3[f++] ^ Hf(a, o, n, r, s, e), v = t3[f++] ^ Hf(a, o, r, s, e, n), b = t3[f++] ^ Hf(a, o, s, e, n, r);
    e = h, n = m, r = v, s = b;
  }
  return { s0: t3[f++] ^ fo(i, e, n, r, s), s1: t3[f++] ^ fo(i, n, r, s, e), s2: t3[f++] ^ fo(i, r, s, e, n), s3: t3[f++] ^ fo(i, s, e, n, r) };
}
function fg(t3, e, n, r, s) {
  const { sbox2: i, T01: a, T23: o } = ok;
  let f = 0;
  e ^= t3[f++], n ^= t3[f++], r ^= t3[f++], s ^= t3[f++];
  const c = t3.length / 4 - 2;
  for (let l = 0; l < c; l++) {
    const h = t3[f++] ^ Hf(a, o, e, s, r, n), m = t3[f++] ^ Hf(a, o, n, e, s, r), v = t3[f++] ^ Hf(a, o, r, n, e, s), b = t3[f++] ^ Hf(a, o, s, r, n, e);
    e = h, n = m, r = v, s = b;
  }
  return { s0: t3[f++] ^ fo(i, e, s, r, n), s1: t3[f++] ^ fo(i, n, e, s, r), s2: t3[f++] ^ fo(i, r, n, e, s), s3: t3[f++] ^ fo(i, s, r, n, e) };
}
function fk(t3, e, n, r) {
  Fn(e, Us), Fn(n);
  const s = n.length;
  Oy(n, r = Bh(s, r));
  const i = e, a = An(i);
  let { s0: o, s1: f, s2: c, s3: l } = $a(t3, a[0], a[1], a[2], a[3]);
  const h = An(n), m = An(r);
  for (let b = 0; b + 4 <= h.length; b += 4) {
    m[b + 0] = h[b + 0] ^ o, m[b + 1] = h[b + 1] ^ f, m[b + 2] = h[b + 2] ^ c, m[b + 3] = h[b + 3] ^ l;
    let A = 1;
    for (let _ = i.length - 1; _ >= 0; _--) A = A + (255 & i[_]) | 0, i[_] = 255 & A, A >>>= 8;
    ({ s0: o, s1: f, s2: c, s3: l } = $a(t3, a[0], a[1], a[2], a[3]));
  }
  const v = Us * Math.floor(h.length / 4);
  if (v < s) {
    const b = new Uint32Array([o, f, c, l]), A = Jb(b);
    for (let _ = v, C = 0; _ < s; _++, C++) r[_] = n[_] ^ A[C];
    ns(b);
  }
  return r;
}
function Oc(t3, e, n, r, s) {
  Fn(n, Us), Fn(r), s = Bh(r.length, s);
  const i = n, a = An(i), o = og(i), f = An(r), c = An(s), l = e ? 0 : 12, h = r.length;
  let m = o.getUint32(l, e), { s0: v, s1: b, s2: A, s3: _ } = $a(t3, a[0], a[1], a[2], a[3]);
  for (let I = 0; I + 4 <= f.length; I += 4) c[I + 0] = f[I + 0] ^ v, c[I + 1] = f[I + 1] ^ b, c[I + 2] = f[I + 2] ^ A, c[I + 3] = f[I + 3] ^ _, m = m + 1 >>> 0, o.setUint32(l, m, e), { s0: v, s1: b, s2: A, s3: _ } = $a(t3, a[0], a[1], a[2], a[3]);
  const C = Us * Math.floor(f.length / 4);
  if (C < h) {
    const I = new Uint32Array([v, b, A, _]), S = Jb(I);
    for (let $ = C, F = 0; $ < h; $++, F++) s[$] = r[$] ^ S[F];
    ns(I);
  }
  return s;
}
const mN = Zh({ blockSize: 16, nonceLength: 16 }, function(t3, e) {
  function n(r, s) {
    if (Fn(r), s !== void 0 && (Fn(s), !ta(s))) throw Error("unaligned destination");
    const i = p0(t3), a = Es(e), o = [i, a];
    ta(r) || o.push(r = Es(r));
    const f = fk(i, a, r, s);
    return ns(...o), f;
  }
  return { encrypt: (r, s) => n(r, s), decrypt: (r, s) => n(r, s) };
}), Hy = Zh({ blockSize: 16, nonceLength: 16 }, function(t3, e, n = {}) {
  const r = !n.disablePadding;
  return { encrypt(s, i) {
    const a = p0(t3), { b: o, o: f, out: c } = function(I, S, $) {
      Fn(I);
      let F = I.length;
      const U = F % Us;
      if (!S && U !== 0) throw Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");
      ta(I) || (I = Es(I));
      const Q = An(I);
      if (S) {
        let P = Us - U;
        P || (P = Us), F += P;
      }
      return Oy(I, $ = Bh(F, $)), { b: Q, o: An($), out: $ };
    }(s, r, i);
    let l = e;
    const h = [a];
    ta(l) || h.push(l = Es(l));
    const m = An(l);
    let v = m[0], b = m[1], A = m[2], _ = m[3], C = 0;
    for (; C + 4 <= o.length; ) v ^= o[C + 0], b ^= o[C + 1], A ^= o[C + 2], _ ^= o[C + 3], { s0: v, s1: b, s2: A, s3: _ } = $a(a, v, b, A, _), f[C++] = v, f[C++] = b, f[C++] = A, f[C++] = _;
    if (r) {
      const I = function(S) {
        const $ = new Uint8Array(16), F = An($);
        $.set(S);
        const U = Us - S.length;
        for (let Q = Us - U; Q < Us; Q++) $[Q] = U;
        return F;
      }(s.subarray(4 * C));
      v ^= I[0], b ^= I[1], A ^= I[2], _ ^= I[3], { s0: v, s1: b, s2: A, s3: _ } = $a(a, v, b, A, _), f[C++] = v, f[C++] = b, f[C++] = A, f[C++] = _;
    }
    return ns(...h), c;
  }, decrypt(s, i) {
    (function(_) {
      if (Fn(_), _.length % Us != 0) throw Error("aes-(cbc/ecb).decrypt ciphertext should consist of blocks with size 16");
    })(s);
    const a = eA(t3);
    let o = e;
    const f = [a];
    ta(o) || f.push(o = Es(o));
    const c = An(o);
    i = Bh(s.length, i), ta(s) || f.push(s = Es(s)), Oy(s, i);
    const l = An(s), h = An(i);
    let m = c[0], v = c[1], b = c[2], A = c[3];
    for (let _ = 0; _ + 4 <= l.length; ) {
      const C = m, I = v, S = b, $ = A;
      m = l[_ + 0], v = l[_ + 1], b = l[_ + 2], A = l[_ + 3];
      const { s0: F, s1: U, s2: Q, s3: P } = fg(a, m, v, b, A);
      h[_++] = F ^ C, h[_++] = U ^ I, h[_++] = Q ^ S, h[_++] = P ^ $;
    }
    return ns(...f), function(_, C) {
      if (!C) return _;
      const I = _.length;
      if (!I) throw Error("aes/pcks5: empty ciphertext not allowed");
      const S = _[I - 1];
      if (S <= 0 || S > 16) throw Error("aes/pcks5: wrong padding");
      const $ = _.subarray(0, -S);
      for (let F = 0; F < S; F++) if (_[I - F - 1] !== S) throw Error("aes/pcks5: wrong padding");
      return $;
    }(i, r);
  } };
}), lk = Zh({ blockSize: 16, nonceLength: 16 }, function(t3, e) {
  function n(r, s, i) {
    Fn(r);
    const a = r.length;
    if (rk(r, i = Bh(a, i))) throw Error("overlapping src and dst not supported.");
    const o = p0(t3);
    let f = e;
    const c = [o];
    ta(f) || c.push(f = Es(f)), ta(r) || c.push(r = Es(r));
    const l = An(r), h = An(i), m = s ? h : l, v = An(f);
    let b = v[0], A = v[1], _ = v[2], C = v[3];
    for (let S = 0; S + 4 <= l.length; ) {
      const { s0: $, s1: F, s2: U, s3: Q } = $a(o, b, A, _, C);
      h[S + 0] = l[S + 0] ^ $, h[S + 1] = l[S + 1] ^ F, h[S + 2] = l[S + 2] ^ U, h[S + 3] = l[S + 3] ^ Q, b = m[S++], A = m[S++], _ = m[S++], C = m[S++];
    }
    const I = Us * Math.floor(l.length / 4);
    if (I < a) {
      ({ s0: b, s1: A, s2: _, s3: C } = $a(o, b, A, _, C));
      const S = Jb(new Uint32Array([b, A, _, C]));
      for (let $ = I, F = 0; $ < a; $++, F++) i[$] = r[$] ^ S[F];
      ns(S);
    }
    return ns(...c), i;
  }
  return { encrypt: (r, s) => n(r, true, s), decrypt: (r, s) => n(r, false, s) };
});
function vN(t3, e, n, r, s) {
  const i = s ? s.length : 0, a = t3.create(n, r.length + i);
  s && a.update(s);
  const o = function(c, l, h) {
    const m = new Uint8Array(16), v = og(m);
    return Qy(v, 0, BigInt(l), h), Qy(v, 8, BigInt(c), h), m;
  }(8 * r.length, 8 * i, e);
  a.update(r), a.update(o);
  const f = a.digest();
  return ns(o), f;
}
const Pd = Zh({ blockSize: 16, nonceLength: 12, tagLength: 16, varSizeNonce: true }, function(t3, e, n) {
  if (e.length < 8) throw Error("aes/gcm: invalid nonce length");
  function r(i, a, o) {
    const f = vN(p6, false, i, o, n);
    for (let c = 0; c < a.length; c++) f[c] ^= a[c];
    return f;
  }
  function s() {
    const i = p0(t3), a = Fd.slice(), o = Fd.slice();
    if (Oc(i, false, o, o, a), e.length === 12) o.set(e);
    else {
      const f = Fd.slice();
      Qy(og(f), 8, BigInt(8 * e.length), false);
      const c = p6.create(a).update(e).update(f);
      c.digestInto(o), c.destroy();
    }
    return { xk: i, authKey: a, counter: o, tagMask: Oc(i, false, o, Fd) };
  }
  return { encrypt(i) {
    const { xk: a, authKey: o, counter: f, tagMask: c } = s(), l = new Uint8Array(i.length + 16), h = [a, o, f, c];
    ta(i) || h.push(i = Es(i)), Oc(a, false, f, i, l.subarray(0, i.length));
    const m = r(o, c, l.subarray(0, l.length - 16));
    return h.push(m), l.set(m, i.length), ns(...h), l;
  }, decrypt(i) {
    const { xk: a, authKey: o, counter: f, tagMask: c } = s(), l = [a, o, c, f];
    ta(i) || l.push(i = Es(i));
    const h = i.subarray(0, -16), m = i.subarray(-16), v = r(o, c, h);
    if (l.push(v), !nk(v, m)) throw Error("aes/gcm: invalid ghash tag");
    const b = Oc(a, false, f, h);
    return ns(...l), b;
  } };
});
function uk(t3) {
  return t3 instanceof Uint32Array || ArrayBuffer.isView(t3) && t3.constructor.name === "Uint32Array";
}
function ck(t3, e) {
  if (Fn(e, 16), !uk(t3)) throw Error("_encryptBlock accepts result of expandKeyLE");
  const n = An(e);
  let { s0: r, s1: s, s2: i, s3: a } = $a(t3, n[0], n[1], n[2], n[3]);
  return n[0] = r, n[1] = s, n[2] = i, n[3] = a, e;
}
function hk(t3, e) {
  if (Fn(e, 16), !uk(t3)) throw Error("_decryptBlock accepts result of expandKeyLE");
  const n = An(e);
  let { s0: r, s1: s, s2: i, s3: a } = fg(t3, n[0], n[1], n[2], n[3]);
  return n[0] = r, n[1] = s, n[2] = i, n[3] = a, e;
}
const m6 = { encrypt(t3, e) {
  if (e.length >= 2 ** 32) throw Error("plaintext should be less than 4gb");
  const n = p0(t3);
  if (e.length === 16) ck(n, e);
  else {
    const r = An(e);
    let s = r[0], i = r[1];
    for (let a = 0, o = 1; a < 6; a++) for (let f = 2; f < r.length; f += 2, o++) {
      const { s0: c, s1: l, s2: h, s3: m } = $a(n, s, i, r[f], r[f + 1]);
      s = c, i = l ^ g6(o), r[f] = h, r[f + 1] = m;
    }
    r[0] = s, r[1] = i;
  }
  n.fill(0);
}, decrypt(t3, e) {
  if (e.length - 8 >= 2 ** 32) throw Error("ciphertext should be less than 4gb");
  const n = eA(t3), r = e.length / 8 - 1;
  if (r === 1) hk(n, e);
  else {
    const s = An(e);
    let i = s[0], a = s[1];
    for (let o = 0, f = 6 * r; o < 6; o++) for (let c = 2 * r; c >= 1; c -= 2, f--) {
      a ^= g6(f);
      const { s0: l, s1: h, s2: m, s3: v } = fg(n, i, a, s[c], s[c + 1]);
      i = l, a = h, s[c] = m, s[c + 1] = v;
    }
    s[0] = i, s[1] = a;
  }
  n.fill(0);
} }, v6 = new Uint8Array(8).fill(166), dk = Zh({ blockSize: 8 }, (t3) => ({ encrypt(e) {
  if (!e.length || e.length % 8 != 0) throw Error("invalid plaintext length");
  if (e.length === 8) throw Error("8-byte keys not allowed in AESKW, use AESKWP instead");
  const n = function(...r) {
    let s = 0;
    for (let a = 0; a < r.length; a++) {
      const o = r[a];
      Fn(o), s += o.length;
    }
    const i = new Uint8Array(s);
    for (let a = 0, o = 0; a < r.length; a++) {
      const f = r[a];
      i.set(f, o), o += f.length;
    }
    return i;
  }(v6, e);
  return m6.encrypt(t3, n), n;
}, decrypt(e) {
  if (e.length % 8 != 0 || e.length < 24) throw Error("invalid ciphertext length");
  const n = Es(e);
  if (m6.decrypt(t3, n), !nk(n.subarray(0, 8), v6)) throw Error("integrity check failed");
  return n.subarray(0, 8).fill(0), n.subarray(8);
} })), y6 = { expandKeyLE: p0, expandKeyDecLE: eA, encrypt: $a, decrypt: fg, encryptBlock: ck, decryptBlock: hk, ctrCounter: fk, ctr32: Oc };
async function pk(t3) {
  switch (t3) {
    case ee.symmetric.aes128:
    case ee.symmetric.aes192:
    case ee.symmetric.aes256:
      throw Error("Not a legacy cipher");
    case ee.symmetric.cast5:
    case ee.symmetric.blowfish:
    case ee.symmetric.twofish:
    case ee.symmetric.tripledes: {
      const { legacyCiphers: e } = await Promise.resolve().then(function() {
        return hO;
      }), n = ee.read(ee.symmetric, t3), r = e.get(n);
      if (!r) throw Error("Unsupported cipher algorithm");
      return r;
    }
    default:
      throw Error("Unsupported cipher algorithm");
  }
}
function yN(t3) {
  switch (t3) {
    case ee.symmetric.aes128:
    case ee.symmetric.aes192:
    case ee.symmetric.aes256:
    case ee.symmetric.twofish:
      return 16;
    case ee.symmetric.blowfish:
    case ee.symmetric.cast5:
    case ee.symmetric.tripledes:
      return 8;
    default:
      throw Error("Unsupported cipher");
  }
}
function bN(t3) {
  switch (t3) {
    case ee.symmetric.aes128:
    case ee.symmetric.blowfish:
    case ee.symmetric.cast5:
      return 16;
    case ee.symmetric.aes192:
    case ee.symmetric.tripledes:
      return 24;
    case ee.symmetric.aes256:
    case ee.symmetric.twofish:
      return 32;
    default:
      throw Error("Unsupported cipher");
  }
}
function mn(t3) {
  return { keySize: bN(t3), blockSize: yN(t3) };
}
const lu = Ee.getWebCrypto();
async function qy(t3, e, n) {
  const { keySize: r } = mn(t3);
  if (!Ee.isAES(t3) || e.length !== r) throw Error("Unexpected algorithm or key size");
  try {
    const s = await lu.importKey("raw", e, { name: "AES-KW" }, false, ["wrapKey"]), i = await lu.importKey("raw", n, { name: "HMAC", hash: "SHA-256" }, true, ["sign"]), a = await lu.wrapKey("raw", i, s, { name: "AES-KW" });
    return new Uint8Array(a);
  } catch (s) {
    if (s.name !== "NotSupportedError" && (e.length !== 24 || s.name !== "OperationError")) throw s;
    Ee.printDebugError("Browser did not support operation: " + s.message);
  }
  return dk(e).encrypt(n);
}
async function zy(t3, e, n) {
  const { keySize: r } = mn(t3);
  if (!Ee.isAES(t3) || e.length !== r) throw Error("Unexpected algorithm or key size");
  let s;
  try {
    s = await lu.importKey("raw", e, { name: "AES-KW" }, false, ["unwrapKey"]);
  } catch (i) {
    if (i.name !== "NotSupportedError" && (e.length !== 24 || i.name !== "OperationError")) throw i;
    return Ee.printDebugError("Browser did not support operation: " + i.message), dk(e).decrypt(n);
  }
  try {
    const i = await lu.unwrapKey("raw", n, s, { name: "AES-KW" }, { name: "HMAC", hash: "SHA-256" }, true, ["sign"]);
    return new Uint8Array(await lu.exportKey("raw", i));
  } catch (i) {
    throw i.name === "OperationError" ? Error("Key Data Integrity failed") : i;
  }
}
async function il(t3, e, n, r, s) {
  const i = Ee.getWebCrypto(), a = ee.read(ee.webHash, t3);
  if (!a) throw Error("Hash algo not supported with HKDF");
  const o = await i.importKey("raw", e, "HKDF", false, ["deriveBits"]), f = await i.deriveBits({ name: "HKDF", hash: a, salt: n, info: r }, o, 8 * s);
  return new Uint8Array(f);
}
const s1 = { x25519: Ee.encodeUTF8("OpenPGP X25519"), x448: Ee.encodeUTF8("OpenPGP X448") };
async function tA(t3) {
  switch (t3) {
    case ee.publicKey.x25519:
      try {
        const e = Ee.getWebCrypto(), n = await e.generateKey("X25519", true, ["deriveKey", "deriveBits"]).catch((i) => {
          if (i.name === "OperationError") {
            const a = Error("Unexpected key generation issue");
            throw a.name = "NotSupportedError", a;
          }
          throw i;
        }), r = await e.exportKey("jwk", n.privateKey), s = await e.exportKey("jwk", n.publicKey);
        if (r.x !== s.x) {
          const i = Error("Unexpected mismatching public point");
          throw i.name = "NotSupportedError", i;
        }
        return { A: new Uint8Array(_s(s.x)), k: _s(r.d) };
      } catch (e) {
        if (e.name !== "NotSupportedError") throw e;
        const { default: n } = await Promise.resolve().then(function() {
          return v0;
        }), { secretKey: r, publicKey: s } = n.box.keyPair();
        return { A: s, k: r };
      }
    case ee.publicKey.x448: {
      const e = await Ee.getNobleCurve(ee.publicKey.x448), { secretKey: n, publicKey: r } = e.keygen();
      return { A: r, k: n };
    }
    default:
      throw Error("Unsupported ECDH algorithm");
  }
}
async function rA(t3, e, n) {
  switch (t3) {
    case ee.publicKey.x25519:
      try {
        const { ephemeralPublicKey: r, sharedSecret: s } = await ug(t3, e), i = await cg(t3, r, e, n);
        return Ee.equalsUint8Array(s, i);
      } catch {
        return false;
      }
    case ee.publicKey.x448: {
      const r = (await Ee.getNobleCurve(ee.publicKey.x448)).getPublicKey(n);
      return Ee.equalsUint8Array(e, r);
    }
    default:
      return false;
  }
}
async function gk(t3, e, n) {
  const { ephemeralPublicKey: r, sharedSecret: s } = await ug(t3, n), i = Ee.concatUint8Array([r, n, s]);
  switch (t3) {
    case ee.publicKey.x25519: {
      const a = ee.symmetric.aes128, { keySize: o } = mn(a), f = await il(ee.hash.sha256, i, new Uint8Array(), s1.x25519, o);
      return { ephemeralPublicKey: r, wrappedKey: await qy(a, f, e) };
    }
    case ee.publicKey.x448: {
      const a = ee.symmetric.aes256, { keySize: o } = mn(ee.symmetric.aes256), f = await il(ee.hash.sha512, i, new Uint8Array(), s1.x448, o);
      return { ephemeralPublicKey: r, wrappedKey: await qy(a, f, e) };
    }
    default:
      throw Error("Unsupported ECDH algorithm");
  }
}
async function mk(t3, e, n, r, s) {
  const i = await cg(t3, e, r, s), a = Ee.concatUint8Array([e, r, i]);
  switch (t3) {
    case ee.publicKey.x25519: {
      const o = ee.symmetric.aes128, { keySize: f } = mn(o);
      return zy(o, await il(ee.hash.sha256, a, new Uint8Array(), s1.x25519, f), n);
    }
    case ee.publicKey.x448: {
      const o = ee.symmetric.aes256, { keySize: f } = mn(ee.symmetric.aes256);
      return zy(o, await il(ee.hash.sha512, a, new Uint8Array(), s1.x448, f), n);
    }
    default:
      throw Error("Unsupported ECDH algorithm");
  }
}
function lg(t3) {
  switch (t3) {
    case ee.publicKey.x25519:
      return 32;
    case ee.publicKey.x448:
      return 56;
    default:
      throw Error("Unsupported ECDH algorithm");
  }
}
async function ug(t3, e) {
  switch (t3) {
    case ee.publicKey.x25519:
      try {
        const n = Ee.getWebCrypto(), r = await n.generateKey("X25519", true, ["deriveKey", "deriveBits"]).catch((f) => {
          if (f.name === "OperationError") {
            const c = Error("Unexpected key generation issue");
            throw c.name = "NotSupportedError", c;
          }
          throw f;
        }), s = await n.exportKey("jwk", r.publicKey);
        if ((await n.exportKey("jwk", r.privateKey)).x !== s.x) {
          const f = Error("Unexpected mismatching public point");
          throw f.name = "NotSupportedError", f;
        }
        const i = Gy(t3, e), a = await n.importKey("jwk", i, "X25519", false, []), o = await n.deriveBits({ name: "X25519", public: a }, r.privateKey, 8 * lg(t3));
        return { sharedSecret: new Uint8Array(o), ephemeralPublicKey: new Uint8Array(_s(s.x)) };
      } catch (n) {
        if (n.name !== "NotSupportedError") throw n;
        const { default: r } = await Promise.resolve().then(function() {
          return v0;
        }), { secretKey: s, publicKey: i } = r.box.keyPair(), a = r.scalarMult(s, e);
        return a1(a), { ephemeralPublicKey: i, sharedSecret: a };
      }
    case ee.publicKey.x448: {
      const n = await Ee.getNobleCurve(ee.publicKey.x448), { secretKey: r, publicKey: s } = n.keygen(), i = n.getSharedSecret(r, e);
      return a1(i), { ephemeralPublicKey: s, sharedSecret: i };
    }
    default:
      throw Error("Unsupported ECDH algorithm");
  }
}
async function cg(t3, e, n, r) {
  switch (t3) {
    case ee.publicKey.x25519:
      try {
        const s = Ee.getWebCrypto(), i = function(l, h, m) {
          if (l === ee.publicKey.x25519) {
            const v = Gy(l, h);
            return v.d = Ri(m), v;
          }
          throw Error("Unsupported ECDH algorithm");
        }(t3, n, r), a = Gy(t3, e), o = await s.importKey("jwk", i, "X25519", false, ["deriveKey", "deriveBits"]), f = await s.importKey("jwk", a, "X25519", false, []), c = await s.deriveBits({ name: "X25519", public: f }, o, 8 * lg(t3));
        return new Uint8Array(c);
      } catch (s) {
        if (s.name !== "NotSupportedError") throw s;
        const { default: i } = await Promise.resolve().then(function() {
          return v0;
        }), a = i.scalarMult(r, e);
        return a1(a), a;
      }
    case ee.publicKey.x448: {
      const s = (await Ee.getNobleCurve(ee.publicKey.x448)).getSharedSecret(r, e);
      return a1(s), s;
    }
    default:
      throw Error("Unsupported ECDH algorithm");
  }
}
function a1(t3) {
  let e = 0;
  for (let n = 0; n < t3.length; n++) e |= t3[n];
  if (e === 0) throw Error("Unexpected low order point");
}
function Gy(t3, e) {
  if (t3 === ee.publicKey.x25519) return { kty: "OKP", crv: "X25519", x: Ri(e), ext: true };
  throw Error("Unsupported ECDH algorithm");
}
var AN = Object.freeze({ __proto__: null, decrypt: mk, encrypt: gk, generate: tA, generateEphemeralEncryptionMaterial: ug, getPayloadSize: lg, recomputeSharedSecret: cg, validateParams: rA });
const Fm = Ee.getWebCrypto(), o1 = Ee.getNodeCrypto(), po = { [ee.curve.nistP256]: "P-256", [ee.curve.nistP384]: "P-384", [ee.curve.nistP521]: "P-521" }, Ro = o1 ? o1.getCurves() : [], Wa = o1 ? { [ee.curve.secp256k1]: Ro.includes("secp256k1") ? "secp256k1" : void 0, [ee.curve.nistP256]: Ro.includes("prime256v1") ? "prime256v1" : void 0, [ee.curve.nistP384]: Ro.includes("secp384r1") ? "secp384r1" : void 0, [ee.curve.nistP521]: Ro.includes("secp521r1") ? "secp521r1" : void 0, [ee.curve.ed25519Legacy]: Ro.includes("ED25519") ? "ED25519" : void 0, [ee.curve.curve25519Legacy]: Ro.includes("X25519") ? "X25519" : void 0, [ee.curve.brainpoolP256r1]: Ro.includes("brainpoolP256r1") ? "brainpoolP256r1" : void 0, [ee.curve.brainpoolP384r1]: Ro.includes("brainpoolP384r1") ? "brainpoolP384r1" : void 0, [ee.curve.brainpoolP512r1]: Ro.includes("brainpoolP512r1") ? "brainpoolP512r1" : void 0 } : {}, vk = { [ee.curve.nistP256]: { oid: [6, 8, 42, 134, 72, 206, 61, 3, 1, 7], keyType: ee.publicKey.ecdsa, hash: ee.hash.sha256, cipher: ee.symmetric.aes128, node: Wa[ee.curve.nistP256], web: po[ee.curve.nistP256], payloadSize: 32, sharedSize: 256, wireFormatLeadingByte: 4 }, [ee.curve.nistP384]: { oid: [6, 5, 43, 129, 4, 0, 34], keyType: ee.publicKey.ecdsa, hash: ee.hash.sha384, cipher: ee.symmetric.aes192, node: Wa[ee.curve.nistP384], web: po[ee.curve.nistP384], payloadSize: 48, sharedSize: 384, wireFormatLeadingByte: 4 }, [ee.curve.nistP521]: { oid: [6, 5, 43, 129, 4, 0, 35], keyType: ee.publicKey.ecdsa, hash: ee.hash.sha512, cipher: ee.symmetric.aes256, node: Wa[ee.curve.nistP521], web: po[ee.curve.nistP521], payloadSize: 66, sharedSize: 528, wireFormatLeadingByte: 4 }, [ee.curve.secp256k1]: { oid: [6, 5, 43, 129, 4, 0, 10], keyType: ee.publicKey.ecdsa, hash: ee.hash.sha256, cipher: ee.symmetric.aes128, node: Wa[ee.curve.secp256k1], payloadSize: 32, wireFormatLeadingByte: 4 }, [ee.curve.ed25519Legacy]: { oid: [6, 9, 43, 6, 1, 4, 1, 218, 71, 15, 1], keyType: ee.publicKey.eddsaLegacy, hash: ee.hash.sha512, node: false, payloadSize: 32, wireFormatLeadingByte: 64 }, [ee.curve.curve25519Legacy]: { oid: [6, 10, 43, 6, 1, 4, 1, 151, 85, 1, 5, 1], keyType: ee.publicKey.ecdh, hash: ee.hash.sha256, cipher: ee.symmetric.aes128, node: false, payloadSize: 32, wireFormatLeadingByte: 64 }, [ee.curve.brainpoolP256r1]: { oid: [6, 9, 43, 36, 3, 3, 2, 8, 1, 1, 7], keyType: ee.publicKey.ecdsa, hash: ee.hash.sha256, cipher: ee.symmetric.aes128, node: Wa[ee.curve.brainpoolP256r1], payloadSize: 32, wireFormatLeadingByte: 4 }, [ee.curve.brainpoolP384r1]: { oid: [6, 9, 43, 36, 3, 3, 2, 8, 1, 1, 11], keyType: ee.publicKey.ecdsa, hash: ee.hash.sha384, cipher: ee.symmetric.aes192, node: Wa[ee.curve.brainpoolP384r1], payloadSize: 48, wireFormatLeadingByte: 4 }, [ee.curve.brainpoolP512r1]: { oid: [6, 9, 43, 36, 3, 3, 2, 8, 1, 1, 13], keyType: ee.publicKey.ecdsa, hash: ee.hash.sha512, cipher: ee.symmetric.aes256, node: Wa[ee.curve.brainpoolP512r1], payloadSize: 64, wireFormatLeadingByte: 4 } };
let oa = class {
  constructor(e) {
    try {
      this.name = e instanceof ef ? e.getName() : ee.write(ee.curve, e);
    } catch {
      throw new fn("Unknown curve");
    }
    const n = vk[this.name];
    this.keyType = n.keyType, this.oid = n.oid, this.hash = n.hash, this.cipher = n.cipher, this.node = n.node, this.web = n.web, this.payloadSize = n.payloadSize, this.sharedSize = n.sharedSize, this.wireFormatLeadingByte = n.wireFormatLeadingByte, this.web && Ee.getWebCrypto() ? this.type = "web" : this.node && Ee.getNodeCrypto() ? this.type = "node" : this.name === ee.curve.curve25519Legacy ? this.type = "curve25519Legacy" : this.name === ee.curve.ed25519Legacy && (this.type = "ed25519Legacy");
  }
  async genKeyPair() {
    switch (this.type) {
      case "web":
        try {
          return await async function(e, n) {
            const r = await Fm.generateKey({ name: "ECDSA", namedCurve: po[e] }, true, ["sign", "verify"]), s = await Fm.exportKey("jwk", r.privateKey);
            return { publicKey: Ak(await Fm.exportKey("jwk", r.publicKey), n), privateKey: _s(s.d) };
          }(this.name, this.wireFormatLeadingByte);
        } catch (e) {
          return Ee.printDebugError("Browser did not support generating ec key " + e.message), b6(this.name);
        }
      case "node":
        return function(e) {
          const n = o1.createECDH(Wa[e]);
          return n.generateKeys(), { publicKey: new Uint8Array(n.getPublicKey()), privateKey: new Uint8Array(n.getPrivateKey()) };
        }(this.name);
      case "curve25519Legacy": {
        const { k: e, A: n } = await tA(ee.publicKey.x25519), r = e.slice().reverse();
        return r[0] = 127 & r[0] | 64, r[31] &= 248, { publicKey: Ee.concatUint8Array([new Uint8Array([this.wireFormatLeadingByte]), n]), privateKey: r };
      }
      case "ed25519Legacy": {
        const { seed: e, A: n } = await zb(ee.publicKey.ed25519);
        return { publicKey: Ee.concatUint8Array([new Uint8Array([this.wireFormatLeadingByte]), n]), privateKey: e };
      }
      default:
        return b6(this.name);
    }
  }
};
async function _p(t3) {
  const e = new oa(t3), { oid: n, hash: r, cipher: s } = e, i = await e.genKeyPair();
  return { oid: n, Q: i.publicKey, secret: Ee.leftPad(i.privateKey, e.payloadSize), hash: r, cipher: s };
}
function yk(t3) {
  return vk[t3.getName()].hash;
}
async function bk(t3, e, n, r) {
  const s = { [ee.curve.nistP256]: true, [ee.curve.nistP384]: true, [ee.curve.nistP521]: true, [ee.curve.secp256k1]: true, [ee.curve.curve25519Legacy]: t3 === ee.publicKey.ecdh, [ee.curve.brainpoolP256r1]: true, [ee.curve.brainpoolP384r1]: true, [ee.curve.brainpoolP512r1]: true }, i = e.getName();
  if (!s[i]) return false;
  if (i === ee.curve.curve25519Legacy) {
    const o = r.slice().reverse();
    return !(n.length < 1 || n[0] !== 64) && rA(ee.publicKey.x25519, n.subarray(1), o);
  }
  const a = (await Ee.getNobleCurve(ee.publicKey.ecdsa, i)).getPublicKey(r, false);
  return !!Ee.equalsUint8Array(a, n);
}
function a0(t3, e) {
  const { payloadSize: n, wireFormatLeadingByte: r, name: s } = t3, i = s === ee.curve.curve25519Legacy || s === ee.curve.ed25519Legacy ? n : 2 * n;
  if (e[0] !== r || e.length !== i + 1) throw Error("Invalid point encoding");
}
async function b6(t3) {
  const e = await Ee.getNobleCurve(ee.publicKey.ecdsa, t3), { secretKey: n } = e.keygen();
  return { publicKey: e.getPublicKey(n, false), privateKey: n };
}
function Ak(t3, e) {
  const n = _s(t3.x), r = _s(t3.y), s = new Uint8Array(n.length + r.length + 1);
  return s[0] = e, s.set(n, 1), s.set(r, n.length + 1), s;
}
function hg(t3, e, n) {
  const r = t3, s = n.slice(1, r + 1), i = n.slice(r + 1, 2 * r + 1);
  return { kty: "EC", crv: e, x: Ri(s), y: Ri(i), ext: true };
}
function wk(t3, e, n, r) {
  const s = hg(t3, e, n);
  return s.d = Ri(r), s;
}
const f1 = Ee.getWebCrypto(), xk = Ee.getNodeCrypto();
async function Vy(t3, e, n, r, s, i) {
  const a = new oa(t3);
  if (a0(a, r), n && !Ee.isStream(n)) {
    const f = { publicKey: r, privateKey: s };
    switch (a.type) {
      case "web":
        try {
          return await async function(c, l, h, m) {
            const v = c.payloadSize, b = wk(c.payloadSize, po[c.name], m.publicKey, m.privateKey), A = await f1.importKey("jwk", b, { name: "ECDSA", namedCurve: po[c.name], hash: { name: ee.read(ee.webHash, c.hash) } }, false, ["sign"]), _ = new Uint8Array(await f1.sign({ name: "ECDSA", namedCurve: po[c.name], hash: { name: ee.read(ee.webHash, l) } }, A, h));
            return { r: _.slice(0, v), s: _.slice(v, v << 1) };
          }(a, e, n, f);
        } catch (c) {
          if (a.name !== "nistP521" && (c.name === "DataError" || c.name === "OperationError")) throw c;
          Ee.printDebugError("Browser did not support signing: " + c.message);
        }
        break;
      case "node":
        return function(c, l, h, m) {
          const v = Ee.nodeRequire("eckey-utils"), b = Ee.getNodeBuffer(), { privateKey: A } = v.generateDer({ curveName: Wa[c.name], privateKey: b.from(m) }), _ = xk.createSign(ee.read(ee.hash, l));
          _.write(h), _.end();
          const C = new Uint8Array(_.sign({ key: A, format: "der", type: "sec1", dsaEncoding: "ieee-p1363" })), I = c.payloadSize;
          return { r: C.subarray(0, I), s: C.subarray(I, I << 1) };
        }(a, e, n, s);
    }
  }
  const o = (await Ee.getNobleCurve(ee.publicKey.ecdsa, a.name)).sign(i, s, { lowS: false });
  return { r: Jn(o.r, "be", a.payloadSize), s: Jn(o.s, "be", a.payloadSize) };
}
async function Yy(t3, e, n, r, s, i) {
  const a = new oa(t3);
  a0(a, s);
  const o = async () => i[0] === 0 && A6(a, n, i.subarray(1), s);
  if (r && !Ee.isStream(r)) switch (a.type) {
    case "web":
      try {
        return await async function(c, l, { r: h, s: m }, v, b) {
          const A = hg(c.payloadSize, po[c.name], b), _ = await f1.importKey("jwk", A, { name: "ECDSA", namedCurve: po[c.name], hash: { name: ee.read(ee.webHash, c.hash) } }, false, ["verify"]), C = Ee.concatUint8Array([h, m]).buffer;
          return f1.verify({ name: "ECDSA", namedCurve: po[c.name], hash: { name: ee.read(ee.webHash, l) } }, _, C, v);
        }(a, e, n, r, s) || o();
      } catch (f) {
        if (a.name !== "nistP521" && (f.name === "DataError" || f.name === "OperationError")) throw f;
        Ee.printDebugError("Browser did not support verifying: " + f.message);
      }
      break;
    case "node":
      return function(c, l, { r: h, s: m }, v, b) {
        const A = Ee.nodeRequire("eckey-utils"), _ = Ee.getNodeBuffer(), { publicKey: C } = A.generateDer({ curveName: Wa[c.name], publicKey: _.from(b) }), I = xk.createVerify(ee.read(ee.hash, l));
        I.write(v), I.end();
        const S = Ee.concatUint8Array([h, m]);
        try {
          return I.verify({ key: C, format: "der", type: "spki", dsaEncoding: "ieee-p1363" }, S);
        } catch {
          return false;
        }
      }(a, e, n, r, s) || o();
  }
  return await A6(a, n, i, s) || o();
}
async function A6(t3, e, n, r) {
  return (await Ee.getNobleCurve(ee.publicKey.ecdsa, t3.name)).verify(Ee.concatUint8Array([e.r, e.s]), n, r, { lowS: false });
}
var wN = Object.freeze({ __proto__: null, sign: Vy, validateParams: async function(t3, e, n) {
  const r = new oa(t3);
  if (r.keyType !== ee.publicKey.ecdsa) return false;
  switch (r.type) {
    case "web":
    case "node": {
      const s = Ni(8), i = ee.hash.sha256, a = await _o(i, s);
      try {
        const o = await Vy(t3, i, s, e, n, a);
        return await Yy(t3, i, o, s, e, a);
      } catch {
        return false;
      }
    }
    default:
      return bk(ee.publicKey.ecdsa, t3, e, n);
  }
}, verify: Yy });
async function _k(t3, e, n, r, s, i) {
  if (a0(new oa(t3), r), li(e) < li(ee.hash.sha256)) throw Error("Hash algorithm too weak for EdDSA.");
  const { RS: a } = await Gb(ee.publicKey.ed25519, e, 0, r.subarray(1), s, i);
  return { r: a.subarray(0, 32), s: a.subarray(32) };
}
async function Ek(t3, e, { r: n, s: r }, s, i, a) {
  if (a0(new oa(t3), i), li(e) < li(ee.hash.sha256)) throw Error("Hash algorithm too weak for EdDSA.");
  const o = Ee.concatUint8Array([n, r]);
  return Vb(ee.publicKey.ed25519, e, { RS: o }, 0, i.subarray(1), a);
}
async function Bk(t3, e, n) {
  return t3.getName() === ee.curve.ed25519Legacy && !(e.length < 1 || e[0] !== 64) && Yb(ee.publicKey.ed25519, e.subarray(1), n);
}
var xN = Object.freeze({ __proto__: null, sign: _k, validateParams: Bk, verify: Ek });
function _N(t3) {
  const e = t3.length;
  if (e > 0) {
    const n = t3[e - 1];
    if (n >= 1) {
      const r = t3.subarray(e - n), s = new Uint8Array(n).fill(n);
      if (Ee.equalsUint8Array(r, s)) return t3.subarray(0, e - n);
    }
  }
  throw Error("Invalid padding");
}
function Ck(t3, e, n, r) {
  return Ee.concatUint8Array([e.write(), new Uint8Array([t3]), n.write(), Ee.stringToUint8Array("Anonymous Sender    "), r]);
}
async function kk(t3, e, n, r, s = false, i = false) {
  let a;
  if (s) {
    for (a = 0; a < e.length && e[a] === 0; a++) ;
    e = e.subarray(a);
  }
  if (i) {
    for (a = e.length - 1; a >= 0 && e[a] === 0; a--) ;
    e = e.subarray(0, a + 1);
  }
  return (await _o(t3, Ee.concatUint8Array([new Uint8Array([0, 0, 0, 1]), e, r]))).subarray(0, n);
}
async function EN(t3, e) {
  switch (t3.type) {
    case "curve25519Legacy": {
      const { sharedSecret: n, ephemeralPublicKey: r } = await ug(ee.publicKey.x25519, e.subarray(1));
      return { publicKey: Ee.concatUint8Array([new Uint8Array([t3.wireFormatLeadingByte]), r]), sharedKey: n };
    }
    case "web":
      if (t3.web && Ee.getWebCrypto()) try {
        return await async function(n, r) {
          const s = Ee.getWebCrypto(), i = hg(n.payloadSize, n.web, r);
          let a = s.generateKey({ name: "ECDH", namedCurve: n.web }, true, ["deriveKey", "deriveBits"]), o = s.importKey("jwk", i, { name: "ECDH", namedCurve: n.web }, false, []);
          [a, o] = await Promise.all([a, o]);
          let f = s.deriveBits({ name: "ECDH", namedCurve: n.web, public: o }, a.privateKey, n.sharedSize), c = s.exportKey("jwk", a.publicKey);
          [f, c] = await Promise.all([f, c]);
          const l = new Uint8Array(f);
          return { publicKey: new Uint8Array(Ak(c, n.wireFormatLeadingByte)), sharedKey: l };
        }(t3, e);
      } catch (n) {
        return Ee.printDebugError(n), x6(t3, e);
      }
      break;
    case "node":
      return function(n, r) {
        const s = Ee.getNodeCrypto(), i = s.createECDH(n.node);
        i.generateKeys();
        const a = new Uint8Array(i.computeSecret(r));
        return { publicKey: new Uint8Array(i.getPublicKey()), sharedKey: a };
      }(t3, e);
    default:
      return x6(t3, e);
  }
}
async function Ik(t3, e, n, r, s) {
  const i = function(m) {
    const v = 8 - m.length % 8, b = new Uint8Array(m.length + v).fill(v);
    return b.set(m), b;
  }(n), a = new oa(t3);
  a0(a, r);
  const { publicKey: o, sharedKey: f } = await EN(a, r), c = Ck(ee.publicKey.ecdh, t3, e, s), { keySize: l } = mn(e.cipher), h = await kk(e.hash, f, l, c);
  return { publicKey: o, wrappedKey: await qy(e.cipher, h, i) };
}
async function BN(t3, e, n, r) {
  if (r.length !== t3.payloadSize) {
    const s = new Uint8Array(t3.payloadSize);
    s.set(r, t3.payloadSize - r.length), r = s;
  }
  switch (t3.type) {
    case "curve25519Legacy": {
      const s = r.slice().reverse();
      return { secretKey: s, sharedKey: await cg(ee.publicKey.x25519, e.subarray(1), n.subarray(1), s) };
    }
    case "web":
      if (t3.web && Ee.getWebCrypto()) try {
        return await async function(s, i, a, o) {
          const f = Ee.getWebCrypto(), c = wk(s.payloadSize, s.web, a, o);
          let l = f.importKey("jwk", c, { name: "ECDH", namedCurve: s.web }, true, ["deriveKey", "deriveBits"]);
          const h = hg(s.payloadSize, s.web, i);
          let m = f.importKey("jwk", h, { name: "ECDH", namedCurve: s.web }, true, []);
          [l, m] = await Promise.all([l, m]);
          let v = f.deriveBits({ name: "ECDH", namedCurve: s.web, public: m }, l, s.sharedSize), b = f.exportKey("jwk", l);
          [v, b] = await Promise.all([v, b]);
          const A = new Uint8Array(v);
          return { secretKey: _s(b.d), sharedKey: A };
        }(t3, e, n, r);
      } catch (s) {
        return Ee.printDebugError(s), w6(t3, e, r);
      }
      break;
    case "node":
      return function(s, i, a) {
        const o = Ee.getNodeCrypto(), f = o.createECDH(s.node);
        f.setPrivateKey(a);
        const c = new Uint8Array(f.computeSecret(i));
        return { secretKey: new Uint8Array(f.getPrivateKey()), sharedKey: c };
      }(t3, e, r);
    default:
      return w6(t3, e, r);
  }
}
async function Sk(t3, e, n, r, s, i, a) {
  const o = new oa(t3);
  a0(o, s), a0(o, n);
  const { sharedKey: f } = await BN(o, n, s, i), c = Ck(ee.publicKey.ecdh, t3, e, a), { keySize: l } = mn(e.cipher);
  let h;
  for (let m = 0; m < 3; m++) try {
    const v = await kk(e.hash, f, l, c, m === 1, m === 2);
    return _N(await zy(e.cipher, v, r));
  } catch (v) {
    h = v;
  }
  throw h;
}
async function w6(t3, e, n) {
  return { secretKey: n, sharedKey: (await Ee.getNobleCurve(ee.publicKey.ecdh, t3.name)).getSharedSecret(n, e).subarray(1) };
}
async function x6(t3, e) {
  const n = await Ee.getNobleCurve(ee.publicKey.ecdh, t3.name), { publicKey: r, privateKey: s } = await t3.genKeyPair();
  return { publicKey: r, sharedKey: n.getSharedSecret(s, e).subarray(1) };
}
var CN = Object.freeze({ __proto__: null, CurveWithOID: oa, ecdh: Object.freeze({ __proto__: null, decrypt: Sk, encrypt: Ik, validateParams: async function(t3, e, n) {
  return bk(ee.publicKey.ecdh, t3, e, n);
} }), ecdhX: AN, ecdsa: wN, eddsa: cN, eddsaLegacy: xN, generate: _p, getPreferredHashAlgo: yk });
const Ep = BigInt(0), Qc = BigInt(1);
class Mk {
  constructor(e) {
    e && (this.data = e);
  }
  read(e) {
    if (e.length >= 1) {
      const n = e[0];
      if (e.length >= 1 + n) return this.data = e.subarray(1, 1 + n), 1 + this.data.length;
    }
    throw Error("Invalid symmetric key");
  }
  write() {
    return Ee.concatUint8Array([new Uint8Array([this.data.length]), this.data]);
  }
}
class $k {
  constructor(e) {
    if (e) {
      const { hash: n, cipher: r } = e;
      this.hash = n, this.cipher = r;
    } else this.hash = null, this.cipher = null;
  }
  read(e) {
    if (e.length < 4 || e[0] !== 3 || e[1] !== 1) throw new fn("Cannot read KDFParams");
    return this.hash = e[2], this.cipher = e[3], 4;
  }
  write() {
    return new Uint8Array([3, 1, this.hash, this.cipher]);
  }
}
class dg {
  static fromObject({ wrappedKey: e, algorithm: n }) {
    const r = new dg();
    return r.wrappedKey = e, r.algorithm = n, r;
  }
  read(e) {
    let n = 0, r = e[n++];
    this.algorithm = r % 2 ? e[n++] : null, r -= r % 2, this.wrappedKey = Ee.readExactSubarray(e, n, n + r), n += r;
  }
  write() {
    return Ee.concatUint8Array([this.algorithm ? new Uint8Array([this.wrappedKey.length + 1, this.algorithm]) : new Uint8Array([this.wrappedKey.length]), this.wrappedKey]);
  }
}
async function kN(t3, e, n, r, s) {
  switch (t3) {
    case ee.publicKey.rsaEncrypt:
    case ee.publicKey.rsaEncryptSign: {
      const { n: i, e: a } = n;
      return { c: await aN(r, i, a) };
    }
    case ee.publicKey.elgamal: {
      const { p: i, g: a, y: o } = n;
      return async function(f, c, l, h) {
        c = pr(c), l = pr(l), h = pr(h);
        const m = pr(WC(f, ks(c))), v = Xf(Uf, c - Uf);
        return { c1: Jn(_i(l, v, c)), c2: Jn(Wr(_i(h, v, c) * m, c)) };
      }(r, i, a, o);
    }
    case ee.publicKey.ecdh: {
      const { oid: i, Q: a, kdfParams: o } = n, { publicKey: f, wrappedKey: c } = await Ik(i, o, r, a, s);
      return { V: f, C: new Mk(c) };
    }
    case ee.publicKey.x25519:
    case ee.publicKey.x448: {
      if (e && !Ee.isAES(e)) throw Error("X25519 and X448 keys can only encrypt AES session keys");
      const { A: i } = n, { ephemeralPublicKey: a, wrappedKey: o } = await gk(t3, r, i);
      return { ephemeralPublicKey: a, C: dg.fromObject({ algorithm: e, wrappedKey: o }) };
    }
    default:
      return [];
  }
}
async function IN(t3, e, n, r, s, i) {
  switch (t3) {
    case ee.publicKey.rsaEncryptSign:
    case ee.publicKey.rsaEncrypt: {
      const { c: a } = r, { n: o, e: f } = e, { d: c, p: l, q: h, u: m } = n;
      return oN(a, o, f, c, l, h, m, i);
    }
    case ee.publicKey.elgamal: {
      const { c1: a, c2: o } = r;
      return async function(f, c, l, h, m) {
        return f = pr(f), c = pr(c), l = pr(l), JC(Jn(Wr(vu(_i(f, h = pr(h), l), l) * c, l), "be", ks(l)), m);
      }(a, o, e.p, n.x, i);
    }
    case ee.publicKey.ecdh: {
      const { oid: a, Q: o, kdfParams: f } = e, { d: c } = n, { V: l, C: h } = r;
      return Sk(a, f, l, h.data, o, c, s);
    }
    case ee.publicKey.x25519:
    case ee.publicKey.x448: {
      const { A: a } = e, { k: o } = n, { ephemeralPublicKey: f, C: c } = r;
      if (c.algorithm !== null && !Ee.isAES(c.algorithm)) throw Error("AES session key expected");
      return mk(t3, f, c.wrappedKey, a, o);
    }
    default:
      throw Error("Unknown public key encryption algorithm.");
  }
}
function _6(t3, e, n) {
  let r = 0;
  switch (t3) {
    case ee.publicKey.rsaEncrypt:
    case ee.publicKey.rsaEncryptSign:
    case ee.publicKey.rsaSign: {
      const s = Ee.readMPI(e.subarray(r));
      r += s.length + 2;
      const i = Ee.readMPI(e.subarray(r));
      r += i.length + 2;
      const a = Ee.readMPI(e.subarray(r));
      r += a.length + 2;
      const o = Ee.readMPI(e.subarray(r));
      return r += o.length + 2, { read: r, privateParams: { d: s, p: i, q: a, u: o } };
    }
    case ee.publicKey.dsa:
    case ee.publicKey.elgamal: {
      const s = Ee.readMPI(e.subarray(r));
      return r += s.length + 2, { read: r, privateParams: { x: s } };
    }
    case ee.publicKey.ecdsa:
    case ee.publicKey.ecdh: {
      const s = W0(t3, n.oid);
      let i = Ee.readMPI(e.subarray(r));
      return r += i.length + 2, i = Ee.leftPad(i, s), { read: r, privateParams: { d: i } };
    }
    case ee.publicKey.eddsaLegacy: {
      const s = W0(t3, n.oid);
      if (n.oid.getName() !== ee.curve.ed25519Legacy) throw Error("Unexpected OID for eddsaLegacy");
      let i = Ee.readMPI(e.subarray(r));
      return r += i.length + 2, i = Ee.leftPad(i, s), { read: r, privateParams: { seed: i } };
    }
    case ee.publicKey.ed25519:
    case ee.publicKey.ed448: {
      const s = W0(t3), i = Ee.readExactSubarray(e, r, r + s);
      return r += i.length, { read: r, privateParams: { seed: i } };
    }
    case ee.publicKey.x25519:
    case ee.publicKey.x448: {
      const s = W0(t3), i = Ee.readExactSubarray(e, r, r + s);
      return r += i.length, { read: r, privateParams: { k: i } };
    }
    default:
      throw new fn("Unknown public key encryption algorithm.");
  }
}
function bu(t3, e) {
  const n = /* @__PURE__ */ new Set([ee.publicKey.ed25519, ee.publicKey.x25519, ee.publicKey.ed448, ee.publicKey.x448]), r = Object.keys(e).map((s) => {
    const i = e[s];
    return Ee.isUint8Array(i) ? n.has(t3) ? i : Ee.uint8ArrayToMPI(i) : i.write();
  });
  return Ee.concatUint8Array(r);
}
function SN(t3, e, n) {
  switch (t3) {
    case ee.publicKey.rsaEncrypt:
    case ee.publicKey.rsaEncryptSign:
    case ee.publicKey.rsaSign:
      return async function(r, s) {
        if (s = BigInt(s), Ee.getWebCrypto()) {
          const c = { name: "RSASSA-PKCS1-v1_5", modulusLength: r, publicExponent: Jn(s), hash: { name: "SHA-1" } }, l = await yu.generateKey(c, true, ["sign", "verify"]);
          return h6(await yu.exportKey("jwk", l.privateKey), s);
        }
        if (Ee.getNodeCrypto()) {
          const c = { modulusLength: r, publicExponent: Py(s), publicKeyEncoding: { type: "pkcs1", format: "jwk" }, privateKeyEncoding: { type: "pkcs1", format: "jwk" } }, l = await new Promise((h, m) => {
            s0.generateKeyPair("rsa", c, (v, b, A) => {
              v ? m(v) : h(A);
            });
          });
          return h6(l, s);
        }
        let i, a, o;
        do
          a = u6(r - (r >> 1), s, 40), i = u6(r >> 1, s, 40), o = i * a;
        while (fu(o) !== r);
        const f = (i - nl) * (a - nl);
        return a < i && ([i, a] = [a, i]), { n: Jn(o), e: Jn(s), d: Jn(vu(s, f)), p: Jn(i), q: Jn(a), u: Jn(vu(i, a)) };
      }(e, 65537).then(({ n: r, e: s, d: i, p: a, q: o, u: f }) => ({ privateParams: { d: i, p: a, q: o, u: f }, publicParams: { n: r, e: s } }));
    case ee.publicKey.ecdsa:
      return _p(n).then(({ oid: r, Q: s, secret: i }) => ({ privateParams: { d: i }, publicParams: { oid: new ef(r), Q: s } }));
    case ee.publicKey.eddsaLegacy:
      return _p(n).then(({ oid: r, Q: s, secret: i }) => ({ privateParams: { seed: i }, publicParams: { oid: new ef(r), Q: s } }));
    case ee.publicKey.ecdh:
      return _p(n).then(({ oid: r, Q: s, secret: i, hash: a, cipher: o }) => ({ privateParams: { d: i }, publicParams: { oid: new ef(r), Q: s, kdfParams: new $k({ hash: a, cipher: o }) } }));
    case ee.publicKey.ed25519:
    case ee.publicKey.ed448:
      return zb(t3).then(({ A: r, seed: s }) => ({ privateParams: { seed: s }, publicParams: { A: r } }));
    case ee.publicKey.x25519:
    case ee.publicKey.x448:
      return tA(t3).then(({ A: r, k: s }) => ({ privateParams: { k: s }, publicParams: { A: r } }));
    case ee.publicKey.dsa:
    case ee.publicKey.elgamal:
      throw Error("Unsupported algorithm for key generation.");
    default:
      throw Error("Unknown public key algorithm.");
  }
}
async function MN(t3, e, n) {
  if (!e || !n) throw Error("Missing key parameters");
  switch (t3) {
    case ee.publicKey.rsaEncrypt:
    case ee.publicKey.rsaEncryptSign:
    case ee.publicKey.rsaSign: {
      const { n: r, e: s } = e, { d: i, p: a, q: o, u: f } = n;
      return async function(c, l, h, m, v, b) {
        if (c = pr(c), (m = pr(m)) * (v = pr(v)) !== c) return false;
        const A = BigInt(2);
        if (Wr(m * (b = pr(b)), v) !== BigInt(1)) return false;
        l = pr(l), h = pr(h);
        const _ = Xf(A, A << BigInt(Math.floor(fu(c) / 3))), C = _ * h * l;
        return !(Wr(C, m - nl) !== _ || Wr(C, v - nl) !== _);
      }(r, s, i, a, o, f);
    }
    case ee.publicKey.dsa: {
      const { p: r, q: s, g: i, y: a } = e, { x: o } = n;
      return async function(f, c, l, h, m) {
        const v = pr(f), b = pr(c), A = pr(l), _ = pr(h);
        if (A <= Qc || A >= v || Wr(v - Qc, b) !== Ep || _i(A, b, v) !== Qc) return false;
        const C = BigInt(fu(b));
        if (C < BigInt(150) || !YC(b, null, 32)) return false;
        const I = pr(m), S = BigInt(2);
        return _ === _i(A, b * Xf(S << C - Qc, S << C) + I, v);
      }(r, s, i, a, o);
    }
    case ee.publicKey.elgamal: {
      const { p: r, g: s, y: i } = e, { x: a } = n;
      return async function(o, f, c, l) {
        const h = pr(o), m = pr(f), v = pr(c);
        if (m <= Uf || m >= h) return false;
        const b = BigInt(fu(h));
        if (b < BigInt(1023) || _i(m, h - Uf, h) !== Uf) return false;
        let A = m, _ = BigInt(1);
        const C = BigInt(2), I = C << BigInt(17);
        for (; _ < I; ) {
          if (A = Wr(A * m, h), A === Uf) return false;
          _++;
        }
        const S = pr(l), $ = Xf(C << b - Uf, C << b);
        return v === _i(m, (h - Uf) * $ + S, h);
      }(r, s, i, a);
    }
    case ee.publicKey.ecdsa:
    case ee.publicKey.ecdh: {
      const r = CN[ee.read(ee.publicKey, t3)], { oid: s, Q: i } = e, { d: a } = n;
      return r.validateParams(s, i, a);
    }
    case ee.publicKey.eddsaLegacy: {
      const { Q: r, oid: s } = e, { seed: i } = n;
      return Bk(s, r, i);
    }
    case ee.publicKey.ed25519:
    case ee.publicKey.ed448: {
      const { A: r } = e, { seed: s } = n;
      return Yb(t3, r, s);
    }
    case ee.publicKey.x25519:
    case ee.publicKey.x448: {
      const { A: r } = e, { k: s } = n;
      return rA(t3, r, s);
    }
    default:
      throw Error("Unknown public key algorithm.");
  }
}
function Wy(t3) {
  const { keySize: e } = mn(t3);
  return Ni(e);
}
function Pm(t3) {
  try {
    t3.getName();
  } catch {
    throw new fn("Unknown curve OID");
  }
}
function W0(t3, e) {
  switch (t3) {
    case ee.publicKey.ecdsa:
    case ee.publicKey.ecdh:
    case ee.publicKey.eddsaLegacy:
      return new oa(e).payloadSize;
    case ee.publicKey.ed25519:
    case ee.publicKey.ed448:
      return sg(t3);
    case ee.publicKey.x25519:
    case ee.publicKey.x448:
      return lg(t3);
    default:
      throw Error("Unknown elliptic algo");
  }
}
const Bp = Ee.getWebCrypto(), Ch = Ee.getNodeCrypto(), Bl = Ch ? Ch.getCiphers() : [], l1 = { idea: Bl.includes("idea-cfb") ? "idea-cfb" : void 0, tripledes: Bl.includes("des-ede3-cfb") ? "des-ede3-cfb" : void 0, cast5: Bl.includes("cast5-cfb") ? "cast5-cfb" : void 0, blowfish: Bl.includes("bf-cfb") ? "bf-cfb" : void 0, aes128: Bl.includes("aes-128-cfb") ? "aes-128-cfb" : void 0, aes192: Bl.includes("aes-192-cfb") ? "aes-192-cfb" : void 0, aes256: Bl.includes("aes-256-cfb") ? "aes-256-cfb" : void 0 };
function Tk(t3) {
  const { blockSize: e } = mn(t3), n = Ni(e), r = new Uint8Array([n[n.length - 2], n[n.length - 1]]);
  return Ee.concat([n, r]);
}
async function kh(t3, e, n, r, s) {
  const i = ee.read(ee.symmetric, t3);
  if (Ee.getNodeCrypto() && l1[i]) return function(h, m, v, b) {
    const A = ee.read(ee.symmetric, h), _ = new Ch.createCipheriv(l1[A], m, b);
    return ii(v, (C) => new Uint8Array(_.update(C)));
  }(t3, e, n, r);
  if (Ee.isAES(t3)) return async function(h, m, v, b) {
    if (Bp && await E6.isSupported(h)) {
      const A = new E6(h, m, b);
      return Ee.isStream(v) ? Ry(v, (_) => A.encryptChunk(_), () => A.finish()) : A.encrypt(v);
    }
    if (Ee.isStream(v)) {
      const A = new Dk(true, h, m, b);
      return Ry(v, (_) => A.processChunk(_), () => A.finish());
    }
    return lk(m, b).encrypt(v);
  }(t3, e, n, r);
  const a = new (await pk(t3))(e), o = a.blockSize, f = r.slice();
  let c = new Uint8Array();
  const l = (h) => {
    h && (c = Ee.concatUint8Array([c, h]));
    const m = new Uint8Array(c.length);
    let v, b = 0;
    for (; h ? c.length >= o : c.length; ) {
      const A = a.encrypt(f);
      for (v = 0; v < o; v++) f[v] = c[v] ^ A[v], m[b++] = f[v];
      c = c.subarray(o);
    }
    return m.subarray(0, b);
  };
  return ii(n, l, l);
}
async function pg(t3, e, n, r) {
  const s = ee.read(ee.symmetric, t3);
  if (Ch && l1[s]) return function(l, h, m, v) {
    const b = ee.read(ee.symmetric, l), A = new Ch.createDecipheriv(l1[b], h, v);
    return ii(m, (_) => new Uint8Array(A.update(_)));
  }(t3, e, n, r);
  if (Ee.isAES(t3)) return function(l, h, m, v) {
    if (Ee.isStream(m)) {
      const b = new Dk(false, l, h, v);
      return Ry(m, (A) => b.processChunk(A), () => b.finish());
    }
    return lk(h, v).decrypt(m);
  }(t3, e, n, r);
  const i = new (await pk(t3))(e), a = i.blockSize;
  let o = r, f = new Uint8Array();
  const c = (l) => {
    l && (f = Ee.concatUint8Array([f, l]));
    const h = new Uint8Array(f.length);
    let m, v = 0;
    for (; l ? f.length >= a : f.length; ) {
      const b = i.encrypt(o);
      for (o = f.subarray(0, a), m = 0; m < a; m++) h[v++] = o[m] ^ b[m];
      f = f.subarray(a);
    }
    return h.subarray(0, v);
  };
  return ii(n, c, c);
}
class E6 {
  constructor(e, n, r) {
    const { blockSize: s } = mn(e);
    this.key = n, this.prevBlock = r, this.nextBlock = new Uint8Array(s), this.i = 0, this.blockSize = s, this.zeroBlock = new Uint8Array(this.blockSize);
  }
  static isSupported(e) {
    const { keySize: n } = mn(e);
    return Bp.importKey("raw", new Uint8Array(n), "aes-cbc", false, ["encrypt"]).then(() => true, () => false);
  }
  async _runCBC(e, n) {
    const r = "AES-CBC";
    this.keyRef = this.keyRef || await Bp.importKey("raw", this.key, r, false, ["encrypt"]);
    const s = await Bp.encrypt({ name: r, iv: n || this.zeroBlock }, this.keyRef, e);
    return new Uint8Array(s).subarray(0, e.length);
  }
  async encryptChunk(e) {
    const n = this.nextBlock.length - this.i, r = e.subarray(0, n);
    if (this.nextBlock.set(r, this.i), this.i + e.length >= 2 * this.blockSize) {
      const i = (e.length - n) % this.blockSize, a = Ee.concatUint8Array([this.nextBlock, e.subarray(n, e.length - i)]), o = Ee.concatUint8Array([this.prevBlock, a.subarray(0, a.length - this.blockSize)]), f = await this._runCBC(o);
      return Nd(f, a), this.prevBlock = f.slice(-this.blockSize), i > 0 && this.nextBlock.set(e.subarray(-i)), this.i = i, f;
    }
    let s;
    if (this.i += r.length, this.i === this.nextBlock.length) {
      const i = this.nextBlock;
      s = await this._runCBC(this.prevBlock), Nd(s, i), this.prevBlock = s.slice(), this.i = 0;
      const a = e.subarray(r.length);
      this.nextBlock.set(a, this.i), this.i += a.length;
    } else s = new Uint8Array();
    return s;
  }
  async finish() {
    let e;
    if (this.i === 0) e = new Uint8Array();
    else {
      this.nextBlock = this.nextBlock.subarray(0, this.i);
      const n = this.nextBlock, r = await this._runCBC(this.prevBlock);
      Nd(r, n), e = r.subarray(0, n.length);
    }
    return this.clearSensitiveData(), e;
  }
  clearSensitiveData() {
    this.nextBlock.fill(0), this.prevBlock.fill(0), this.keyRef = null, this.key = null;
  }
  async encrypt(e) {
    const n = (await this._runCBC(Ee.concatUint8Array([new Uint8Array(this.blockSize), e]), this.iv)).subarray(0, e.length);
    return Nd(n, e), this.clearSensitiveData(), n;
  }
}
class Dk {
  constructor(e, n, r, s) {
    this.forEncryption = e;
    const { blockSize: i } = mn(n);
    this.key = y6.expandKeyLE(r), s.byteOffset % 4 != 0 && (s = s.slice()), this.prevBlock = Nm(s), this.nextBlock = new Uint8Array(i), this.i = 0, this.blockSize = i;
  }
  _runCFB(e) {
    const n = Nm(e), r = new Uint8Array(e.length), s = Nm(r);
    for (let i = 0; i + 4 <= s.length; i += 4) {
      const { s0: a, s1: o, s2: f, s3: c } = y6.encrypt(this.key, this.prevBlock[0], this.prevBlock[1], this.prevBlock[2], this.prevBlock[3]);
      s[i + 0] = n[i + 0] ^ a, s[i + 1] = n[i + 1] ^ o, s[i + 2] = n[i + 2] ^ f, s[i + 3] = n[i + 3] ^ c, this.prevBlock = (this.forEncryption ? s : n).slice(i, i + 4);
    }
    return r;
  }
  async processChunk(e) {
    const n = this.nextBlock.length - this.i, r = e.subarray(0, n);
    if (this.nextBlock.set(r, this.i), this.i + e.length >= 2 * this.blockSize) {
      const i = (e.length - n) % this.blockSize, a = Ee.concatUint8Array([this.nextBlock, e.subarray(n, e.length - i)]), o = this._runCFB(a);
      return i > 0 && this.nextBlock.set(e.subarray(-i)), this.i = i, o;
    }
    let s;
    if (this.i += r.length, this.i === this.nextBlock.length) {
      s = this._runCFB(this.nextBlock), this.i = 0;
      const i = e.subarray(r.length);
      this.nextBlock.set(i, this.i), this.i += i.length;
    } else s = new Uint8Array();
    return s;
  }
  async finish() {
    let e;
    return this.i === 0 ? e = new Uint8Array() : e = this._runCFB(this.nextBlock).subarray(0, this.i), this.clearSensitiveData(), e;
  }
  clearSensitiveData() {
    this.nextBlock.fill(0), this.prevBlock.fill(0), this.key.fill(0);
  }
}
function Nd(t3, e) {
  const n = Math.min(t3.length, e.length);
  for (let r = 0; r < n; r++) t3[r] = t3[r] ^ e[r];
}
const Nm = (t3) => new Uint32Array(t3.buffer, t3.byteOffset, Math.floor(t3.byteLength / 4)), B6 = Ee.getWebCrypto(), $N = Ee.getNodeCrypto(), Jl = 16;
function C6(t3, e) {
  const n = t3.length - Jl;
  for (let r = 0; r < Jl; r++) t3[r + n] ^= e[r];
  return t3;
}
const Cp = new Uint8Array(Jl);
async function TN(t3) {
  const e = await DN(t3), n = Ee.double(await e(Cp)), r = Ee.double(n);
  return async function(s) {
    return (await e(function(i, a, o) {
      if (i.length && i.length % Jl == 0) return C6(i, a);
      const f = new Uint8Array(i.length + (Jl - i.length % Jl));
      return f.set(i), f[i.length] = 128, C6(f, o);
    }(s, n, r))).subarray(-16);
  };
}
async function DN(t3) {
  if (Ee.getNodeCrypto()) return async function(e) {
    const n = new $N.createCipheriv("aes-" + 8 * t3.length + "-cbc", t3, Cp).update(e);
    return new Uint8Array(n);
  };
  if (Ee.getWebCrypto()) try {
    return t3 = await B6.importKey("raw", t3, { name: "AES-CBC", length: 8 * t3.length }, false, ["encrypt"]), async function(e) {
      const n = await B6.encrypt({ name: "AES-CBC", iv: Cp, length: 128 }, t3, e);
      return new Uint8Array(n).subarray(0, n.byteLength - Jl);
    };
  } catch (e) {
    if (e.name !== "NotSupportedError" && (t3.length !== 24 || e.name !== "OperationError")) throw e;
    Ee.printDebugError("Browser did not support operation: " + e.message);
  }
  return async function(e) {
    return Hy(t3, Cp, { disablePadding: true }).encrypt(e);
  };
}
const k6 = Ee.getWebCrypto(), RN = Ee.getNodeCrypto(), FN = Ee.getNodeBuffer(), jh = 16, kp = jh, I6 = new Uint8Array(jh), Jy = new Uint8Array(jh);
Jy[15] = 1;
const Zy = new Uint8Array(jh);
async function PN(t3) {
  const e = await TN(t3);
  return function(n, r) {
    return e(Ee.concatUint8Array([n, r]));
  };
}
async function NN(t3) {
  if (Ee.getNodeCrypto()) return async function(e, n) {
    const r = new RN.createCipheriv("aes-" + 8 * t3.length + "-ctr", t3, n), s = FN.concat([r.update(e), r.final()]);
    return new Uint8Array(s);
  };
  if (Ee.getWebCrypto()) try {
    const e = await k6.importKey("raw", t3, { name: "AES-CTR", length: 8 * t3.length }, false, ["encrypt"]);
    return async function(n, r) {
      const s = await k6.encrypt({ name: "AES-CTR", counter: r, length: 128 }, e, n);
      return new Uint8Array(s);
    };
  } catch (e) {
    if (e.name !== "NotSupportedError" && (t3.length !== 24 || e.name !== "OperationError")) throw e;
    Ee.printDebugError("Browser did not support operation: " + e.message);
  }
  return async function(e, n) {
    return mN(t3, n).encrypt(e);
  };
}
async function Kc(t3, e) {
  if (t3 !== ee.symmetric.aes128 && t3 !== ee.symmetric.aes192 && t3 !== ee.symmetric.aes256) throw Error("EAX mode supports only AES cipher");
  const [n, r] = await Promise.all([PN(e), NN(e)]);
  return { encrypt: async function(s, i, a) {
    const [o, f] = await Promise.all([n(I6, i), n(Jy, a)]), c = await r(s, o), l = await n(Zy, c);
    for (let h = 0; h < kp; h++) l[h] ^= f[h] ^ o[h];
    return Ee.concatUint8Array([c, l]);
  }, decrypt: async function(s, i, a) {
    if (s.length < kp) throw Error("Invalid EAX ciphertext");
    const o = s.subarray(0, -16), f = s.subarray(-16), [c, l, h] = await Promise.all([n(I6, i), n(Jy, a), n(Zy, o)]), m = h;
    for (let v = 0; v < kp; v++) m[v] ^= l[v] ^ c[v];
    if (!Ee.equalsUint8Array(f, m)) throw Error("Authentication tag mismatch");
    return await r(o, c);
  } };
}
Zy[15] = 2, Kc.getNonce = function(t3, e) {
  const n = t3.slice();
  for (let r = 0; r < e.length; r++) n[8 + r] ^= e[r];
  return n;
}, Kc.blockLength = jh, Kc.ivLength = 16, Kc.tagLength = kp;
const Rs = 16, jy = 16;
function S6(t3) {
  let e = 0;
  for (let n = 1; !(t3 & n); n <<= 1) e++;
  return e;
}
function ms(t3, e) {
  for (let n = 0; n < t3.length; n++) t3[n] ^= e[n];
  return t3;
}
function Ud(t3, e) {
  return ms(t3.slice(), e);
}
const mc = new Uint8Array(Rs), UN = new Uint8Array([1]);
async function Hc(t3, e) {
  const { keySize: n } = mn(t3);
  if (!Ee.isAES(t3) || e.length !== n) throw Error("Unexpected algorithm or key size");
  let r = 0;
  const s = (f) => Hy(e, mc, { disablePadding: true }).encrypt(f), i = (f) => Hy(e, mc, { disablePadding: true }).decrypt(f);
  let a;
  function o(f, c, l, h) {
    const m = c.length / Rs | 0;
    (function(Q, P) {
      const N = Ee.nbits(Math.max(Q.length, P.length) / Rs | 0) - 1;
      for (let L = r + 1; L <= N; L++) a[L] = Ee.double(a[L - 1]);
      r = N;
    })(c, h);
    const v = Ee.concatUint8Array([mc.subarray(0, 15 - l.length), UN, l]), b = 63 & v[15];
    v[15] &= 192;
    const A = s(v), _ = Ee.concatUint8Array([A, Ud(A.subarray(0, 8), A.subarray(1, 9))]), C = Ee.shiftRight(_.subarray(0 + (b >> 3), 17 + (b >> 3)), 8 - (7 & b)).subarray(1), I = new Uint8Array(Rs), S = new Uint8Array(c.length + jy);
    let $, F = 0;
    for ($ = 0; $ < m; $++) ms(C, a[S6($ + 1)]), S.set(ms(f(Ud(C, c)), C), F), ms(I, f === s ? c : S.subarray(F)), c = c.subarray(Rs), F += Rs;
    if (c.length) {
      ms(C, a.x);
      const Q = s(C);
      S.set(Ud(c, Q), F);
      const P = new Uint8Array(Rs);
      P.set(f === s ? c : S.subarray(F, -16), 0), P[c.length] = 128, ms(I, P), F += c.length;
    }
    const U = ms(s(ms(ms(I, C), a.$)), function(Q) {
      if (!Q.length) return mc;
      const P = Q.length / Rs | 0, N = new Uint8Array(Rs), L = new Uint8Array(Rs);
      for (let B = 0; B < P; B++) ms(N, a[S6(B + 1)]), ms(L, s(Ud(N, Q))), Q = Q.subarray(Rs);
      if (Q.length) {
        ms(N, a.x);
        const B = new Uint8Array(Rs);
        B.set(Q, 0), B[Q.length] = 128, ms(B, N), ms(L, s(B));
      }
      return L;
    }(h));
    return S.set(U, F), S;
  }
  return function() {
    const f = s(mc), c = Ee.double(f);
    a = [], a[0] = Ee.double(c), a.x = f, a.$ = c;
  }(), { encrypt: async function(f, c, l) {
    return o(s, f, c, l);
  }, decrypt: async function(f, c, l) {
    if (f.length < jy) throw Error("Invalid OCB ciphertext");
    const h = f.subarray(-16);
    f = f.subarray(0, -16);
    const m = o(i, f, c, l);
    if (Ee.equalsUint8Array(h, m.subarray(-16))) return m.subarray(0, -16);
    throw Error("Authentication tag mismatch");
  } };
}
Hc.getNonce = function(t3, e) {
  const n = t3.slice();
  for (let r = 0; r < e.length; r++) n[7 + r] ^= e[r];
  return n;
}, Hc.blockLength = Rs, Hc.ivLength = 15, Hc.tagLength = jy;
const Um = Ee.getWebCrypto(), M6 = Ee.getNodeCrypto(), $6 = Ee.getNodeBuffer(), Ip = 16, Lm = "AES-GCM";
async function J0(t3, e) {
  if (t3 !== ee.symmetric.aes128 && t3 !== ee.symmetric.aes192 && t3 !== ee.symmetric.aes256) throw Error("GCM mode supports only AES cipher");
  if (Ee.getNodeCrypto()) return { encrypt: async function(n, r, s = new Uint8Array()) {
    const i = new M6.createCipheriv("aes-" + 8 * e.length + "-gcm", e, r);
    i.setAAD(s);
    const a = $6.concat([i.update(n), i.final(), i.getAuthTag()]);
    return new Uint8Array(a);
  }, decrypt: async function(n, r, s = new Uint8Array()) {
    const i = new M6.createDecipheriv("aes-" + 8 * e.length + "-gcm", e, r);
    i.setAAD(s), i.setAuthTag(n.slice(n.length - Ip, n.length));
    const a = $6.concat([i.update(n.slice(0, n.length - Ip)), i.final()]);
    return new Uint8Array(a);
  } };
  if (Ee.getWebCrypto()) try {
    const n = await Um.importKey("raw", e, { name: Lm }, false, ["encrypt", "decrypt"]), r = navigator.userAgent.match(/Version\/13\.\d(\.\d)* Safari/) || navigator.userAgent.match(/Version\/(13|14)\.\d(\.\d)* Mobile\/\S* Safari/);
    return { encrypt: async function(s, i, a = new Uint8Array()) {
      if (r && !s.length) return Pd(e, i, a).encrypt(s);
      const o = await Um.encrypt({ name: Lm, iv: i, additionalData: a, tagLength: 128 }, n, s);
      return new Uint8Array(o);
    }, decrypt: async function(s, i, a = new Uint8Array()) {
      if (r && s.length === Ip) return Pd(e, i, a).decrypt(s);
      try {
        const o = await Um.decrypt({ name: Lm, iv: i, additionalData: a, tagLength: 128 }, n, s);
        return new Uint8Array(o);
      } catch (o) {
        if (o.name === "OperationError") throw Error("Authentication tag mismatch");
      }
    } };
  } catch (n) {
    if (n.name !== "NotSupportedError" && (e.length !== 24 || n.name !== "OperationError")) throw n;
    Ee.printDebugError("Browser did not support operation: " + n.message);
  }
  return { encrypt: async function(n, r, s) {
    return Pd(e, r, s).encrypt(n);
  }, decrypt: async function(n, r, s) {
    return Pd(e, r, s).decrypt(n);
  } };
}
function tf(t3, e = false) {
  switch (t3) {
    case ee.aead.eax:
      return Kc;
    case ee.aead.ocb:
      return Hc;
    case ee.aead.gcm:
      return J0;
    case ee.aead.experimentalGCM:
      if (!e) throw Error("Unexpected non-standard `experimentalGCM` AEAD algorithm provided in `config.preferredAEADAlgorithm`: use `gcm` instead");
      return J0;
    default:
      throw Error("Unsupported AEAD mode");
  }
}
async function LN(t3, e, n, r, s, i) {
  switch (t3) {
    case ee.publicKey.rsaEncryptSign:
    case ee.publicKey.rsaEncrypt:
    case ee.publicKey.rsaSign: {
      const { n: a, e: o } = r;
      return sN(e, s, Ee.leftPad(n.s, a.length), a, o, i);
    }
    case ee.publicKey.dsa: {
      const { g: a, p: o, q: f, y: c } = r, { r: l, s: h } = n;
      return async function(m, v, b, A, _, C, I, S) {
        if (v = pr(v), b = pr(b), C = pr(C), I = pr(I), _ = pr(_), S = pr(S), v <= Ep || v >= I || b <= Ep || b >= I) return Ee.printDebug("invalid DSA Signature"), false;
        const $ = Wr(pr(A.subarray(0, ks(I))), I), F = vu(b, I);
        if (F === Ep) return Ee.printDebug("invalid DSA Signature"), false;
        _ = Wr(_, C), S = Wr(S, C);
        const U = Wr($ * F, I), Q = Wr(v * F, I);
        return Wr(Wr(_i(_, U, C) * _i(S, Q, C), C), I) === v;
      }(0, l, h, i, a, o, f, c);
    }
    case ee.publicKey.ecdsa: {
      const { oid: a, Q: o } = r, f = new oa(a).payloadSize;
      return Yy(a, e, { r: Ee.leftPad(n.r, f), s: Ee.leftPad(n.s, f) }, s, o, i);
    }
    case ee.publicKey.eddsaLegacy: {
      const { oid: a, Q: o } = r, f = new oa(a).payloadSize;
      return Ek(a, e, { r: Ee.leftPad(n.r, f), s: Ee.leftPad(n.s, f) }, 0, o, i);
    }
    case ee.publicKey.ed25519:
    case ee.publicKey.ed448: {
      const { A: a } = r;
      return Vb(t3, e, n, 0, a, i);
    }
    default:
      throw Error("Unknown signature algorithm.");
  }
}
async function ON(t3, e, n, r, s, i) {
  if (!n || !r) throw Error("Missing key parameters");
  switch (t3) {
    case ee.publicKey.rsaEncryptSign:
    case ee.publicKey.rsaEncrypt:
    case ee.publicKey.rsaSign: {
      const { n: a, e: o } = n, { d: f, p: c, q: l, u: h } = r;
      return { s: await iN(e, s, a, o, f, c, l, h, i) };
    }
    case ee.publicKey.dsa: {
      const { g: a, p: o, q: f } = n, { x: c } = r;
      return async function(l, h, m, v, b, A) {
        const _ = BigInt(0);
        let C, I, S, $;
        v = pr(v), b = pr(b), m = pr(m), A = pr(A), m = Wr(m, v), A = Wr(A, b);
        const F = Wr(pr(h.subarray(0, ks(b))), b);
        for (; ; ) {
          if (C = Xf(Qc, b), I = Wr(_i(m, C, v), b), I === _) continue;
          const U = Wr(A * I, b);
          if ($ = Wr(F + U, b), S = Wr(vu(C, b) * $, b), S !== _) break;
        }
        return { r: Jn(I, "be", ks(v)), s: Jn(S, "be", ks(v)) };
      }(0, i, a, o, f, c);
    }
    case ee.publicKey.elgamal:
      throw Error("Signing with Elgamal is not defined in the OpenPGP standard.");
    case ee.publicKey.ecdsa: {
      const { oid: a, Q: o } = n, { d: f } = r;
      return Vy(a, e, s, o, f, i);
    }
    case ee.publicKey.eddsaLegacy: {
      const { oid: a, Q: o } = n, { seed: f } = r;
      return _k(a, e, 0, o, f, i);
    }
    case ee.publicKey.ed25519:
    case ee.publicKey.ed448: {
      const { A: a } = n, { seed: o } = r;
      return Gb(t3, e, 0, a, o, i);
    }
    default:
      throw Error("Unknown signature algorithm.");
  }
}
J0.getNonce = function(t3, e) {
  const n = t3.slice();
  for (let r = 0; r < e.length; r++) n[4 + r] ^= e[r];
  return n;
}, J0.blockLength = 16, J0.ivLength = 12, J0.tagLength = Ip;
class gg extends Error {
  constructor(...e) {
    super(...e), Error.captureStackTrace && Error.captureStackTrace(this, gg), this.name = "Argon2OutOfMemoryError";
  }
}
let Ld, vc;
class QN {
  constructor(e = Qt) {
    const { passes: n, parallelism: r, memoryExponent: s } = e.s2kArgon2Params;
    this.type = "argon2", this.salt = null, this.t = n, this.p = r, this.encodedM = s;
  }
  generateSalt() {
    this.salt = Ni(16);
  }
  read(e) {
    let n = 0;
    return this.salt = e.subarray(n, n + 16), n += 16, this.t = e[n++], this.p = e[n++], this.encodedM = e[n++], n;
  }
  write() {
    const e = [new Uint8Array([ee.write(ee.s2k, this.type)]), this.salt, new Uint8Array([this.t, this.p, this.encodedM])];
    return Ee.concatUint8Array(e);
  }
  async produceKey(e, n) {
    const r = 2 << this.encodedM - 1;
    try {
      Ld = Ld || (await Promise.resolve().then(function() {
        return AO;
      })).default, vc = vc || Ld();
      const s = await vc, i = s({ version: 19, type: 2, password: Ee.encodeUTF8(e), salt: this.salt, tagLength: n, memorySize: r, parallelism: this.p, passes: this.t });
      return r > 1048576 && (vc = Ld(), vc.catch(() => {
      })), i;
    } catch (s) {
      throw s.message && (s.message.includes("Unable to grow instance memory") || s.message.includes("failed to grow memory") || s.message.includes("WebAssembly.Memory.grow") || s.message.includes("Out of memory")) ? new gg("Could not allocate required memory for Argon2") : s;
    }
  }
}
class KN {
  constructor(e, n = Qt) {
    this.algorithm = ee.hash.sha256, this.type = ee.read(ee.s2k, e), this.c = n.s2kIterationCountByte, this.salt = null;
  }
  generateSalt() {
    switch (this.type) {
      case "salted":
      case "iterated":
        this.salt = Ni(8);
    }
  }
  getCount() {
    return 16 + (15 & this.c) << 6 + (this.c >> 4);
  }
  read(e) {
    let n = 0;
    switch (this.algorithm = e[n++], this.type) {
      case "simple":
        break;
      case "salted":
        this.salt = e.subarray(n, n + 8), n += 8;
        break;
      case "iterated":
        this.salt = e.subarray(n, n + 8), n += 8, this.c = e[n++];
        break;
      case "gnu":
        if (Ee.uint8ArrayToString(e.subarray(n, n + 3)) !== "GNU") throw new fn("Unknown s2k type.");
        if (n += 3, 1e3 + e[n++] !== 1001) throw new fn("Unknown s2k gnu protection mode.");
        this.type = "gnu-dummy";
        break;
      default:
        throw new fn("Unknown s2k type.");
    }
    return n;
  }
  write() {
    if (this.type === "gnu-dummy") return new Uint8Array([101, 0, ...Ee.stringToUint8Array("GNU"), 1]);
    const e = [new Uint8Array([ee.write(ee.s2k, this.type), this.algorithm])];
    switch (this.type) {
      case "simple":
        break;
      case "salted":
        e.push(this.salt);
        break;
      case "iterated":
        e.push(this.salt), e.push(new Uint8Array([this.c]));
        break;
      case "gnu":
        throw Error("GNU s2k type not supported.");
      default:
        throw Error("Unknown s2k type.");
    }
    return Ee.concatUint8Array(e);
  }
  async produceKey(e, n) {
    e = Ee.encodeUTF8(e);
    const r = [];
    let s = 0, i = 0;
    for (; s < n; ) {
      let a;
      switch (this.type) {
        case "simple":
          a = Ee.concatUint8Array([new Uint8Array(i), e]);
          break;
        case "salted":
          a = Ee.concatUint8Array([new Uint8Array(i), this.salt, e]);
          break;
        case "iterated": {
          const f = Ee.concatUint8Array([this.salt, e]);
          let c = f.length;
          const l = Math.max(this.getCount(), c);
          a = new Uint8Array(i + l), a.set(f, i);
          for (let h = i + c; h < l; h += c, c *= 2) a.copyWithin(h, i, h);
          break;
        }
        case "gnu":
          throw Error("GNU s2k type not supported.");
        default:
          throw Error("Unknown s2k type.");
      }
      const o = await _o(this.algorithm, a);
      r.push(o), s += o.length, i++;
    }
    return Ee.concatUint8Array(r).subarray(0, n);
  }
}
const HN = /* @__PURE__ */ new Set([ee.s2k.argon2, ee.s2k.iterated]);
function u1(t3, e = Qt) {
  switch (t3) {
    case ee.s2k.argon2:
      return new QN(e);
    case ee.s2k.iterated:
    case ee.s2k.gnu:
    case ee.s2k.salted:
    case ee.s2k.simple:
      return new KN(t3, e);
    default:
      throw new fn("Unsupported S2K type");
  }
}
function Rk(t3) {
  const { s2kType: e } = t3;
  if (!HN.has(e)) throw Error("The provided `config.s2kType` value is not allowed");
  return u1(e, t3);
}
var Wn = Uint8Array, Qs = Uint16Array, nA = Int32Array, mg = new Wn([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), vg = new Wn([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), Xy = new Wn([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), Fk = function(t3, e) {
  for (var n = new Qs(31), r = 0; r < 31; ++r) n[r] = e += 1 << t3[r - 1];
  var s = new nA(n[30]);
  for (r = 1; r < 30; ++r) for (var i = n[r]; i < n[r + 1]; ++i) s[i] = i - n[r] << 5 | r;
  return { b: n, r: s };
}, Pk = Fk(mg, 2), Nk = Pk.b, e3 = Pk.r;
Nk[28] = 258, e3[258] = 28;
for (var T6 = Fk(vg, 0), qN = T6.b, D6 = T6.r, t3 = new Qs(32768), In = 0; In < 32768; ++In) {
  var Cl = (43690 & In) >> 1 | (21845 & In) << 1;
  Cl = (61680 & (Cl = (52428 & Cl) >> 2 | (13107 & Cl) << 2)) >> 4 | (3855 & Cl) << 4, t3[In] = ((65280 & Cl) >> 8 | (255 & Cl) << 8) >> 1;
}
var go = function(t3, e, n) {
  for (var r = t3.length, s = 0, i = new Qs(e); s < r; ++s) t3[s] && ++i[t3[s] - 1];
  var a, o = new Qs(e);
  for (s = 1; s < e; ++s) o[s] = o[s - 1] + i[s - 1] << 1;
  if (n) {
    a = new Qs(1 << e);
    var f = 15 - e;
    for (s = 0; s < r; ++s) if (t3[s]) for (var c = s << 4 | t3[s], l = e - t3[s], h = o[t3[s] - 1]++ << l, m = h | (1 << l) - 1; h <= m; ++h) a[t3[h] >> f] = c;
  } else for (a = new Qs(r), s = 0; s < r; ++s) t3[s] && (a[s] = t3[o[t3[s] - 1]++] >> 15 - t3[s]);
  return a;
}, sl = new Wn(288);
for (In = 0; In < 144; ++In) sl[In] = 8;
for (In = 144; In < 256; ++In) sl[In] = 9;
for (In = 256; In < 280; ++In) sl[In] = 7;
for (In = 280; In < 288; ++In) sl[In] = 8;
var Ih = new Wn(32);
for (In = 0; In < 32; ++In) Ih[In] = 5;
var zN = go(sl, 9, 0), GN = go(sl, 9, 1), VN = go(Ih, 5, 0), YN = go(Ih, 5, 1), Om = function(t3) {
  for (var e = t3[0], n = 1; n < t3.length; ++n) t3[n] > e && (e = t3[n]);
  return e;
}, va = function(t3, e, n) {
  var r = e / 8 | 0;
  return (t3[r] | t3[r + 1] << 8) >> (7 & e) & n;
}, Qm = function(t3, e) {
  var n = e / 8 | 0;
  return (t3[n] | t3[n + 1] << 8 | t3[n + 2] << 16) >> (7 & e);
}, iA = function(t3) {
  return (t3 + 7) / 8 | 0;
}, qc = function(t3, e, n) {
  return (e == null || e < 0) && (e = 0), (n == null || n > t3.length) && (n = t3.length), new Wn(t3.subarray(e, n));
}, WN = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], yi = function(t3, e, n) {
  var r = Error(e || WN[t3]);
  if (r.code = t3, Error.captureStackTrace && Error.captureStackTrace(r, yi), !n) throw r;
  return r;
}, Fo = function(t3, e, n) {
  n <<= 7 & e;
  var r = e / 8 | 0;
  t3[r] |= n, t3[r + 1] |= n >> 8;
}, yc = function(t3, e, n) {
  n <<= 7 & e;
  var r = e / 8 | 0;
  t3[r] |= n, t3[r + 1] |= n >> 8, t3[r + 2] |= n >> 16;
}, Km = function(t3, e) {
  for (var n = [], r = 0; r < t3.length; ++r) t3[r] && n.push({ s: r, f: t3[r] });
  var s = n.length, i = n.slice();
  if (!s) return { t: Lk, l: 0 };
  if (s == 1) {
    var a = new Wn(n[0].s + 1);
    return a[n[0].s] = 1, { t: a, l: 1 };
  }
  n.sort(function(F, U) {
    return F.f - U.f;
  }), n.push({ s: -1, f: 25001 });
  var o = n[0], f = n[1], c = 0, l = 1, h = 2;
  for (n[0] = { s: -1, f: o.f + f.f, l: o, r: f }; l != s - 1; ) o = n[n[c].f < n[h].f ? c++ : h++], f = n[c != l && n[c].f < n[h].f ? c++ : h++], n[l++] = { s: -1, f: o.f + f.f, l: o, r: f };
  var m = i[0].s;
  for (r = 1; r < s; ++r) i[r].s > m && (m = i[r].s);
  var v = new Qs(m + 1), b = r3(n[l - 1], v, 0);
  if (b > e) {
    r = 0;
    var A = 0, _ = b - e, C = 1 << _;
    for (i.sort(function(F, U) {
      return v[U.s] - v[F.s] || F.f - U.f;
    }); r < s; ++r) {
      var I = i[r].s;
      if (!(v[I] > e)) break;
      A += C - (1 << b - v[I]), v[I] = e;
    }
    for (A >>= _; A > 0; ) {
      var S = i[r].s;
      v[S] < e ? A -= 1 << e - v[S]++ - 1 : ++r;
    }
    for (; r >= 0 && A; --r) {
      var $ = i[r].s;
      v[$] == e && (--v[$], ++A);
    }
    b = e;
  }
  return { t: new Wn(v), l: b };
}, r3 = function(t3, e, n) {
  return t3.s == -1 ? Math.max(r3(t3.l, e, n + 1), r3(t3.r, e, n + 1)) : e[t3.s] = n;
}, R6 = function(t3) {
  for (var e = t3.length; e && !t3[--e]; ) ;
  for (var n = new Qs(++e), r = 0, s = t3[0], i = 1, a = function(f) {
    n[r++] = f;
  }, o = 1; o <= e; ++o) if (t3[o] == s && o != e) ++i;
  else {
    if (!s && i > 2) {
      for (; i > 138; i -= 138) a(32754);
      i > 2 && (a(i > 10 ? i - 11 << 5 | 28690 : i - 3 << 5 | 12305), i = 0);
    } else if (i > 3) {
      for (a(s), --i; i > 6; i -= 6) a(8304);
      i > 2 && (a(i - 3 << 5 | 8208), i = 0);
    }
    for (; i--; ) a(s);
    i = 1, s = t3[o];
  }
  return { c: n.subarray(0, r), n: e };
}, bc = function(t3, e) {
  for (var n = 0, r = 0; r < e.length; ++r) n += t3[r] * e[r];
  return n;
}, Uk = function(t3, e, n) {
  var r = n.length, s = iA(e + 2);
  t3[s] = 255 & r, t3[s + 1] = r >> 8, t3[s + 2] = 255 ^ t3[s], t3[s + 3] = 255 ^ t3[s + 1];
  for (var i = 0; i < r; ++i) t3[s + i + 4] = n[i];
  return 8 * (s + 4 + r);
}, F6 = function(t3, e, n, r, s, i, a, o, f, c, l) {
  Fo(e, l++, n), ++s[256];
  for (var h = Km(s, 15), m = h.t, v = h.l, b = Km(i, 15), A = b.t, _ = b.l, C = R6(m), I = C.c, S = C.n, $ = R6(A), F = $.c, U = $.n, Q = new Qs(19), P = 0; P < I.length; ++P) ++Q[31 & I[P]];
  for (P = 0; P < F.length; ++P) ++Q[31 & F[P]];
  for (var N = Km(Q, 7), L = N.t, B = N.l, u = 19; u > 4 && !L[Xy[u - 1]]; --u) ;
  var p, d, y, w, E = c + 5 << 3, M = bc(s, sl) + bc(i, Ih) + a, x = bc(s, m) + bc(i, A) + a + 14 + 3 * u + bc(Q, L) + 2 * Q[16] + 3 * Q[17] + 7 * Q[18];
  if (f >= 0 && E <= M && E <= x) return Uk(e, l, t3.subarray(f, f + c));
  if (Fo(e, l, 1 + (x < M)), l += 2, x < M) {
    p = go(m, v, 0), d = m, y = go(A, _, 0), w = A;
    var g = go(L, B, 0);
    for (Fo(e, l, S - 257), Fo(e, l + 5, U - 1), Fo(e, l + 10, u - 4), l += 14, P = 0; P < u; ++P) Fo(e, l + 3 * P, L[Xy[P]]);
    l += 3 * u;
    for (var k = [I, F], T = 0; T < 2; ++T) {
      var O = k[T];
      for (P = 0; P < O.length; ++P) {
        var K = 31 & O[P];
        Fo(e, l, g[K]), l += L[K], K > 15 && (Fo(e, l, O[P] >> 5 & 127), l += O[P] >> 12);
      }
    }
  } else p = zN, d = sl, y = VN, w = Ih;
  for (P = 0; P < o; ++P) {
    var Y = r[P];
    if (Y > 255) {
      yc(e, l, p[(K = Y >> 18 & 31) + 257]), l += d[K + 257], K > 7 && (Fo(e, l, Y >> 23 & 31), l += mg[K]);
      var J = 31 & Y;
      yc(e, l, y[J]), l += w[J], J > 3 && (yc(e, l, Y >> 5 & 8191), l += vg[J]);
    } else yc(e, l, p[Y]), l += d[Y];
  }
  return yc(e, l, p[256]), l + d[256];
}, JN = new nA([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), Lk = new Wn(0), P6 = function() {
  var t3 = 1, e = 0;
  return { p: function(n) {
    for (var r = t3, s = e, i = 0 | n.length, a = 0; a != i; ) {
      for (var o = Math.min(a + 2655, i); a < o; ++a) s += r += n[a];
      r = (65535 & r) + 15 * (r >> 16), s = (65535 & s) + 15 * (s >> 16);
    }
    t3 = r, e = s;
  }, d: function() {
    return (255 & (t3 %= 65521)) << 24 | (65280 & t3) << 8 | (255 & (e %= 65521)) << 8 | e >> 8;
  } };
}, Ok = function(t3, e, n, r, s) {
  if (!s && (s = { l: 1 }, e.dictionary)) {
    var i = e.dictionary.subarray(-32768), a = new Wn(i.length + t3.length);
    a.set(i), a.set(t3, i.length), t3 = a, s.w = i.length;
  }
  return function(o, f, c, l, h, m) {
    var v = m.z || o.length, b = new Wn(l + v + 5 * (1 + Math.ceil(v / 7e3)) + h), A = b.subarray(l, b.length - h), _ = m.l, C = 7 & (m.r || 0);
    if (f) {
      C && (A[0] = m.r >> 3);
      for (var I = JN[f - 1], S = I >> 13, $ = 8191 & I, F = (1 << c) - 1, U = m.p || new Qs(32768), Q = m.h || new Qs(F + 1), P = Math.ceil(c / 3), N = 2 * P, L = function(Oe) {
        return (o[Oe] ^ o[Oe + 1] << P ^ o[Oe + 2] << N) & F;
      }, B = new nA(25e3), u = new Qs(288), p = new Qs(32), d = 0, y = 0, w = m.i || 0, E = 0, M = m.w || 0, x = 0; w + 2 < v; ++w) {
        var g = L(w), k = 32767 & w, T = Q[g];
        if (U[k] = T, Q[g] = k, M <= w) {
          var O = v - w;
          if ((d > 7e3 || E > 24576) && (O > 423 || !_)) {
            C = F6(o, A, 0, B, u, p, y, E, x, w - x, C), E = d = y = 0, x = w;
            for (var K = 0; K < 286; ++K) u[K] = 0;
            for (K = 0; K < 30; ++K) p[K] = 0;
          }
          var Y = 2, J = 0, G = $, X = k - T & 32767;
          if (O > 2 && g == L(w - X)) for (var ie = Math.min(S, O) - 1, de = Math.min(32767, w), se = Math.min(258, O); X <= de && --G && k != T; ) {
            if (o[w + Y] == o[w + Y - X]) {
              for (var te = 0; te < se && o[w + te] == o[w + te - X]; ++te) ;
              if (te > Y) {
                if (Y = te, J = X, te > ie) break;
                var le = Math.min(X, te - 2), Z = 0;
                for (K = 0; K < le; ++K) {
                  var ve = w - X + K & 32767, he = ve - U[ve] & 32767;
                  he > Z && (Z = he, T = ve);
                }
              }
            }
            X += (k = T) - (T = U[k]) & 32767;
          }
          if (J) {
            B[E++] = 268435456 | e3[Y] << 18 | D6[J];
            var me = 31 & e3[Y], ce = 31 & D6[J];
            y += mg[me] + vg[ce], ++u[257 + me], ++p[ce], M = w + Y, ++d;
          } else B[E++] = o[w], ++u[o[w]];
        }
      }
      for (w = Math.max(w, M); w < v; ++w) B[E++] = o[w], ++u[o[w]];
      C = F6(o, A, _, B, u, p, y, E, x, w - x, C), _ || (m.r = 7 & C | A[C / 8 | 0] << 3, C -= 7, m.h = Q, m.p = U, m.i = w, m.w = M);
    } else {
      for (w = m.w || 0; w < v + _; w += 65535) {
        var ye = w + 65535;
        ye >= v && (A[C / 8 | 0] = _, ye = v), C = Uk(A, C + 1, o.subarray(w, ye));
      }
      m.i = v;
    }
    return qc(b, 0, l + iA(C) + h);
  }(t3, e.level == null ? 6 : e.level, e.mem == null ? s.l ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(t3.length)))) : 20 : 12 + e.mem, n, r, s);
}, N6 = function(t3, e, n) {
  for (; n; ++e) t3[e] = n, n >>>= 8;
}, Sp = function() {
  function t3(e, n) {
    if (typeof e == "function" && (n = e, e = {}), this.ondata = n, this.o = e || {}, this.s = { l: 0, i: 32768, w: 32768, z: 32768 }, this.b = new Wn(98304), this.o.dictionary) {
      var r = this.o.dictionary.subarray(-32768);
      this.b.set(r, 32768 - r.length), this.s.i = 32768 - r.length;
    }
  }
  return t3.prototype.p = function(e, n) {
    this.ondata(Ok(e, this.o, 0, 0, this.s), n);
  }, t3.prototype.push = function(e, n) {
    this.ondata || yi(5), this.s.l && yi(4);
    var r = e.length + this.s.z;
    if (r > this.b.length) {
      if (r > 2 * this.b.length - 32768) {
        var s = new Wn(-32768 & r);
        s.set(this.b.subarray(0, this.s.z)), this.b = s;
      }
      var i = this.b.length - this.s.z;
      this.b.set(e.subarray(0, i), this.s.z), this.s.z = this.b.length, this.p(this.b, false), this.b.set(this.b.subarray(-32768)), this.b.set(e.subarray(i), 32768), this.s.z = e.length - i + 32768, this.s.i = 32766, this.s.w = 32768;
    } else this.b.set(e, this.s.z), this.s.z += e.length;
    this.s.l = 1 & n, (this.s.z > this.s.w + 8191 || n) && (this.p(this.b, n || false), this.s.w = this.s.i, this.s.i -= 2);
  }, t3.prototype.flush = function() {
    this.ondata || yi(5), this.s.l && yi(4), this.p(this.b, false), this.s.w = this.s.i, this.s.i -= 2;
  }, t3;
}(), Mp = function() {
  function t3(e, n) {
    typeof e == "function" && (n = e, e = {}), this.ondata = n;
    var r = e && e.dictionary && e.dictionary.subarray(-32768);
    this.s = { i: 0, b: r ? r.length : 0 }, this.o = new Wn(32768), this.p = new Wn(0), r && this.o.set(r);
  }
  return t3.prototype.e = function(e) {
    if (this.ondata || yi(5), this.d && yi(4), this.p.length) {
      if (e.length) {
        var n = new Wn(this.p.length + e.length);
        n.set(this.p), n.set(e, this.p.length), this.p = n;
      }
    } else this.p = e;
  }, t3.prototype.c = function(e) {
    this.s.i = +(this.d = e || false);
    var n = this.s.b, r = function(s, i, a, o) {
      var f = s.length;
      if (!f || i.f && !i.l) return a || new Wn(0);
      var c = !a, l = c || i.i != 2, h = i.i;
      c && (a = new Wn(3 * f));
      var m = function(Z) {
        var ve = a.length;
        if (Z > ve) {
          var he = new Wn(Math.max(2 * ve, Z));
          he.set(a), a = he;
        }
      }, v = i.f || 0, b = i.p || 0, A = i.b || 0, _ = i.l, C = i.d, I = i.m, S = i.n, $ = 8 * f;
      do {
        if (!_) {
          v = va(s, b, 1);
          var F = va(s, b + 1, 3);
          if (b += 3, !F) {
            var U = s[(E = iA(b) + 4) - 4] | s[E - 3] << 8, Q = E + U;
            if (Q > f) {
              h && yi(0);
              break;
            }
            l && m(A + U), a.set(s.subarray(E, Q), A), i.b = A += U, i.p = b = 8 * Q, i.f = v;
            continue;
          }
          if (F == 1) _ = GN, C = YN, I = 9, S = 5;
          else if (F == 2) {
            var P = va(s, b, 31) + 257, N = va(s, b + 10, 15) + 4, L = P + va(s, b + 5, 31) + 1;
            b += 14;
            for (var B = new Wn(L), u = new Wn(19), p = 0; p < N; ++p) u[Xy[p]] = va(s, b + 3 * p, 7);
            b += 3 * N;
            var d = Om(u), y = (1 << d) - 1, w = go(u, d, 1);
            for (p = 0; p < L; ) {
              var E, M = w[va(s, b, y)];
              if (b += 15 & M, (E = M >> 4) < 16) B[p++] = E;
              else {
                var x = 0, g = 0;
                for (E == 16 ? (g = 3 + va(s, b, 3), b += 2, x = B[p - 1]) : E == 17 ? (g = 3 + va(s, b, 7), b += 3) : E == 18 && (g = 11 + va(s, b, 127), b += 7); g--; ) B[p++] = x;
              }
            }
            var k = B.subarray(0, P), T = B.subarray(P);
            I = Om(k), S = Om(T), _ = go(k, I, 1), C = go(T, S, 1);
          } else yi(1);
          if (b > $) {
            h && yi(0);
            break;
          }
        }
        l && m(A + 131072);
        for (var O = (1 << I) - 1, K = (1 << S) - 1, Y = b; ; Y = b) {
          var J = (x = _[Qm(s, b) & O]) >> 4;
          if ((b += 15 & x) > $) {
            h && yi(0);
            break;
          }
          if (x || yi(2), J < 256) a[A++] = J;
          else {
            if (J == 256) {
              Y = b, _ = null;
              break;
            }
            var G = J - 254;
            if (J > 264) {
              var X = mg[p = J - 257];
              G = va(s, b, (1 << X) - 1) + Nk[p], b += X;
            }
            var ie = C[Qm(s, b) & K], de = ie >> 4;
            if (ie || yi(3), b += 15 & ie, T = qN[de], de > 3 && (X = vg[de], T += Qm(s, b) & (1 << X) - 1, b += X), b > $) {
              h && yi(0);
              break;
            }
            l && m(A + 131072);
            var se = A + G;
            if (A < T) {
              var te = 0 - T, le = Math.min(T, se);
              for (te + A < 0 && yi(3); A < le; ++A) a[A] = o[te + A];
            }
            for (; A < se; ++A) a[A] = a[A - T];
          }
        }
        i.l = _, i.p = Y, i.b = A, i.f = v, _ && (v = 1, i.m = I, i.d = C, i.n = S);
      } while (!v);
      return A != a.length && c ? qc(a, 0, A) : a.subarray(0, A);
    }(this.p, this.s, this.o);
    this.ondata(qc(r, n, this.s.b), this.d), this.o = qc(r, this.s.b - 32768), this.s.b = this.o.length, this.p = qc(this.p, this.s.p / 8 | 0), this.s.p &= 7;
  }, t3.prototype.push = function(e, n) {
    this.e(e), this.c(n);
  }, t3;
}(), ZN = function() {
  function t3(e, n) {
    this.c = P6(), this.v = 1, Sp.call(this, e, n);
  }
  return t3.prototype.push = function(e, n) {
    this.c.p(e), Sp.prototype.push.call(this, e, n);
  }, t3.prototype.p = function(e, n) {
    var r = Ok(e, this.o, this.v && (this.o.dictionary ? 6 : 2), n && 4, this.s);
    this.v && (function(s, i) {
      var a = i.level, o = a == 0 ? 0 : a < 6 ? 1 : a == 9 ? 3 : 2;
      if (s[0] = 120, s[1] = o << 6 | (i.dictionary && 32), s[1] |= 31 - (s[0] << 8 | s[1]) % 31, i.dictionary) {
        var f = P6();
        f.p(i.dictionary), N6(s, 2, f.d());
      }
    }(r, this.o), this.v = 0), n && N6(r, r.length - 4, this.c.d()), this.ondata(r, n);
  }, t3.prototype.flush = function() {
    Sp.prototype.flush.call(this);
  }, t3;
}(), jN = function() {
  function t3(e, n) {
    Mp.call(this, e, n), this.v = e && e.dictionary ? 2 : 1;
  }
  return t3.prototype.push = function(e, n) {
    if (Mp.prototype.e.call(this, e), this.v) {
      if (this.p.length < 6 && !n) return;
      this.p = this.p.subarray((r = this.p, s = this.v - 1, ((15 & r[0]) != 8 || r[0] >> 4 > 7 || (r[0] << 8 | r[1]) % 31) && yi(6, "invalid zlib data"), (r[1] >> 5 & 1) == +!s && yi(6, "invalid zlib data: " + (32 & r[1] ? "need" : "unexpected") + " dictionary"), 2 + (r[1] >> 3 & 4))), this.v = 0;
    }
    var r, s;
    n && (this.p.length < 4 && yi(6, "invalid zlib data"), this.p = this.p.subarray(0, -4)), Mp.prototype.c.call(this, n);
  }, t3;
}(), XN = typeof TextDecoder < "u" && new TextDecoder();
try {
  XN.decode(Lk, { stream: true });
} catch {
}
class zu {
  static get tag() {
    return ee.packet.literalData;
  }
  constructor(e = /* @__PURE__ */ new Date()) {
    this.format = ee.literal.utf8, this.date = Ee.normalizeDate(e), this.text = null, this.data = null, this.filename = "";
  }
  setText(e, n = ee.literal.utf8) {
    this.format = n, this.text = e, this.data = null;
  }
  getText(e = false) {
    return (this.text === null || Ee.isStream(this.text)) && (this.text = Ee.decodeUTF8(Ee.nativeEOL(this.getBytes(e)))), this.text;
  }
  setBytes(e, n) {
    this.format = n, this.data = e, this.text = null;
  }
  getBytes(e = false) {
    return this.data === null && (this.data = Ee.canonicalizeEOL(Ee.encodeUTF8(this.text))), e ? sh(this.data) : this.data;
  }
  setFilename(e) {
    this.filename = e;
  }
  getFilename() {
    return this.filename;
  }
  async read(e) {
    await ng(e, async (n) => {
      const r = await n.readByte(), s = await n.readByte();
      this.filename = Ee.decodeUTF8(await n.readBytes(s)), this.date = Ee.readDate(await n.readBytes(4));
      let i = n.remainder();
      Un(i) && (i = await Zn(i)), this.setBytes(i, r);
    });
  }
  writeHeader() {
    const e = Ee.encodeUTF8(this.filename), n = new Uint8Array([e.length]), r = new Uint8Array([this.format]), s = Ee.writeDate(this.date);
    return Ee.concatUint8Array([r, n, e, s]);
  }
  write() {
    const e = this.writeHeader(), n = this.getBytes();
    return Ee.concat([e, n]);
  }
}
class mo {
  constructor() {
    this.bytes = "";
  }
  read(e) {
    return this.bytes = Ee.uint8ArrayToString(e.subarray(0, 8)), this.bytes.length;
  }
  write() {
    return Ee.stringToUint8Array(this.bytes);
  }
  toHex() {
    return Ee.uint8ArrayToHex(Ee.stringToUint8Array(this.bytes));
  }
  equals(e, n = false) {
    return n && (e.isWildcard() || this.isWildcard()) || this.bytes === e.bytes;
  }
  isNull() {
    return this.bytes === "";
  }
  isWildcard() {
    return /^0+$/.test(this.toHex());
  }
  static mapToHex(e) {
    return e.toHex();
  }
  static fromID(e) {
    const n = new mo();
    return n.read(Ee.hexToUint8Array(e)), n;
  }
  static wildcard() {
    const e = new mo();
    return e.read(new Uint8Array(8)), e;
  }
}
const Ac = Symbol("verified"), U6 = "salt@notations.openpgpjs.org", eU = /* @__PURE__ */ new Set([ee.signatureSubpacket.issuerKeyID, ee.signatureSubpacket.issuerFingerprint, ee.signatureSubpacket.embeddedSignature]);
class Ui {
  static get tag() {
    return ee.packet.signature;
  }
  constructor() {
    this.version = null, this.signatureType = null, this.hashAlgorithm = null, this.publicKeyAlgorithm = null, this.signatureData = null, this.unhashedSubpackets = [], this.unknownSubpackets = [], this.signedHashValue = null, this.salt = null, this.created = null, this.signatureExpirationTime = null, this.signatureNeverExpires = true, this.exportable = null, this.trustLevel = null, this.trustAmount = null, this.regularExpression = null, this.revocable = null, this.keyExpirationTime = null, this.keyNeverExpires = null, this.preferredSymmetricAlgorithms = null, this.revocationKeyClass = null, this.revocationKeyAlgorithm = null, this.revocationKeyFingerprint = null, this.issuerKeyID = new mo(), this.rawNotations = [], this.notations = {}, this.preferredHashAlgorithms = null, this.preferredCompressionAlgorithms = null, this.keyServerPreferences = null, this.preferredKeyServer = null, this.isPrimaryUserID = null, this.policyURI = null, this.keyFlags = null, this.signersUserID = null, this.reasonForRevocationFlag = null, this.reasonForRevocationString = null, this.features = null, this.signatureTargetPublicKeyAlgorithm = null, this.signatureTargetHashAlgorithm = null, this.signatureTargetHash = null, this.embeddedSignature = null, this.issuerKeyVersion = null, this.issuerFingerprint = null, this.preferredAEADAlgorithms = null, this.preferredCipherSuites = null, this.revoked = null, this[Ac] = null;
  }
  read(e, n = Qt) {
    let r = 0;
    if (this.version = e[r++], this.version === 5 && !n.enableParsingV5Entities) throw new fn("Support for v5 entities is disabled; turn on `config.enableParsingV5Entities` if needed");
    if (this.version !== 4 && this.version !== 5 && this.version !== 6) throw new fn(`Version ${this.version} of the signature packet is unsupported.`);
    if (this.signatureType = e[r++], this.publicKeyAlgorithm = e[r++], this.hashAlgorithm = e[r++], r += this.readSubPackets(e.subarray(r, e.length), true), !this.created) throw Error("Missing signature creation time subpacket.");
    if (this.signatureData = e.subarray(0, r), r += this.readSubPackets(e.subarray(r, e.length), false), this.signedHashValue = e.subarray(r, r + 2), r += 2, this.version === 6) {
      const o = e[r++];
      this.salt = e.subarray(r, r + o), r += o;
    }
    const s = e.subarray(r, e.length), { read: i, signatureParams: a } = function(o, f) {
      let c = 0;
      switch (o) {
        case ee.publicKey.rsaEncryptSign:
        case ee.publicKey.rsaEncrypt:
        case ee.publicKey.rsaSign: {
          const l = Ee.readMPI(f.subarray(c));
          return c += l.length + 2, { read: c, signatureParams: { s: l } };
        }
        case ee.publicKey.dsa:
        case ee.publicKey.ecdsa: {
          const l = Ee.readMPI(f.subarray(c));
          c += l.length + 2;
          const h = Ee.readMPI(f.subarray(c));
          return c += h.length + 2, { read: c, signatureParams: { r: l, s: h } };
        }
        case ee.publicKey.eddsaLegacy: {
          const l = Ee.readMPI(f.subarray(c));
          c += l.length + 2;
          const h = Ee.readMPI(f.subarray(c));
          return c += h.length + 2, { read: c, signatureParams: { r: l, s: h } };
        }
        case ee.publicKey.ed25519:
        case ee.publicKey.ed448: {
          const l = 2 * sg(o), h = Ee.readExactSubarray(f, c, c + l);
          return c += h.length, { read: c, signatureParams: { RS: h } };
        }
        default:
          throw new fn("Unknown signature algorithm.");
      }
    }(this.publicKeyAlgorithm, s);
    if (i < s.length) throw Error("Error reading MPIs");
    this.params = a;
  }
  writeParams() {
    return this.params instanceof Promise ? d0(async () => bu(this.publicKeyAlgorithm, await this.params)) : bu(this.publicKeyAlgorithm, this.params);
  }
  write() {
    const e = [];
    return e.push(this.signatureData), e.push(this.writeUnhashedSubPackets()), e.push(this.signedHashValue), this.version === 6 && (e.push(new Uint8Array([this.salt.length])), e.push(this.salt)), e.push(this.writeParams()), Ee.concat(e);
  }
  async sign(e, n, r = /* @__PURE__ */ new Date(), s = false, i) {
    this.version = e.version, this.created = Ee.normalizeDate(r), this.issuerKeyVersion = e.version, this.issuerFingerprint = e.getFingerprintBytes(), this.issuerKeyID = e.getKeyID();
    const a = [new Uint8Array([this.version, this.signatureType, this.publicKeyAlgorithm, this.hashAlgorithm])];
    if (this.version === 6) {
      const l = Hm(this.hashAlgorithm);
      if (this.salt === null) this.salt = Ni(l);
      else if (l !== this.salt.length) throw Error("Provided salt does not have the required length");
    } else if (i.nonDeterministicSignaturesViaNotation) {
      if (this.rawNotations.filter(({ name: l }) => l === U6).length !== 0) throw Error("Unexpected existing salt notation");
      {
        const l = Ni(Hm(this.hashAlgorithm));
        this.rawNotations.push({ name: U6, value: l, humanReadable: false, critical: false });
      }
    }
    a.push(this.writeHashedSubPackets()), this.unhashedSubpackets = [], this.signatureData = Ee.concat(a);
    const o = this.toHash(this.signatureType, n, s), f = await this.hash(this.signatureType, n, o, s);
    this.signedHashValue = Fi(i0(f), 0, 2);
    const c = async () => ON(this.publicKeyAlgorithm, this.hashAlgorithm, e.publicParams, e.privateParams, o, await Zn(f));
    Ee.isStream(f) ? this.params = c() : (this.params = await c(), this[Ac] = true);
  }
  writeHashedSubPackets() {
    const e = ee.signatureSubpacket, n = [];
    let r;
    if (this.created === null) throw Error("Missing signature creation time");
    n.push(pn(e.signatureCreationTime, true, Ee.writeDate(this.created))), this.signatureExpirationTime !== null && n.push(pn(e.signatureExpirationTime, true, Ee.writeNumber(this.signatureExpirationTime, 4))), this.exportable !== null && n.push(pn(e.exportableCertification, true, new Uint8Array([this.exportable ? 1 : 0]))), this.trustLevel !== null && (r = new Uint8Array([this.trustLevel, this.trustAmount]), n.push(pn(e.trustSignature, true, r))), this.regularExpression !== null && n.push(pn(e.regularExpression, true, this.regularExpression)), this.revocable !== null && n.push(pn(e.revocable, true, new Uint8Array([this.revocable ? 1 : 0]))), this.keyExpirationTime !== null && n.push(pn(e.keyExpirationTime, true, Ee.writeNumber(this.keyExpirationTime, 4))), this.preferredSymmetricAlgorithms !== null && (r = Ee.stringToUint8Array(Ee.uint8ArrayToString(this.preferredSymmetricAlgorithms)), n.push(pn(e.preferredSymmetricAlgorithms, false, r))), this.revocationKeyClass !== null && (r = new Uint8Array([this.revocationKeyClass, this.revocationKeyAlgorithm]), r = Ee.concat([r, this.revocationKeyFingerprint]), n.push(pn(e.revocationKey, false, r))), !this.issuerKeyID.isNull() && this.issuerKeyVersion < 5 && n.push(pn(e.issuerKeyID, false, this.issuerKeyID.write())), this.rawNotations.forEach(({ name: a, value: o, humanReadable: f, critical: c }) => {
      r = [new Uint8Array([f ? 128 : 0, 0, 0, 0])];
      const l = Ee.encodeUTF8(a);
      r.push(Ee.writeNumber(l.length, 2)), r.push(Ee.writeNumber(o.length, 2)), r.push(l), r.push(o), r = Ee.concat(r), n.push(pn(e.notationData, c, r));
    }), this.preferredHashAlgorithms !== null && (r = Ee.stringToUint8Array(Ee.uint8ArrayToString(this.preferredHashAlgorithms)), n.push(pn(e.preferredHashAlgorithms, false, r))), this.preferredCompressionAlgorithms !== null && (r = Ee.stringToUint8Array(Ee.uint8ArrayToString(this.preferredCompressionAlgorithms)), n.push(pn(e.preferredCompressionAlgorithms, false, r))), this.keyServerPreferences !== null && (r = Ee.stringToUint8Array(Ee.uint8ArrayToString(this.keyServerPreferences)), n.push(pn(e.keyServerPreferences, false, r))), this.preferredKeyServer !== null && n.push(pn(e.preferredKeyServer, false, Ee.encodeUTF8(this.preferredKeyServer))), this.isPrimaryUserID !== null && n.push(pn(e.primaryUserID, false, new Uint8Array([this.isPrimaryUserID ? 1 : 0]))), this.policyURI !== null && n.push(pn(e.policyURI, false, Ee.encodeUTF8(this.policyURI))), this.keyFlags !== null && (r = Ee.stringToUint8Array(Ee.uint8ArrayToString(this.keyFlags)), n.push(pn(e.keyFlags, true, r))), this.signersUserID !== null && n.push(pn(e.signersUserID, false, Ee.encodeUTF8(this.signersUserID))), this.reasonForRevocationFlag !== null && (r = Ee.stringToUint8Array(String.fromCharCode(this.reasonForRevocationFlag) + this.reasonForRevocationString), n.push(pn(e.reasonForRevocation, true, r))), this.features !== null && (r = Ee.stringToUint8Array(Ee.uint8ArrayToString(this.features)), n.push(pn(e.features, false, r))), this.signatureTargetPublicKeyAlgorithm !== null && (r = [new Uint8Array([this.signatureTargetPublicKeyAlgorithm, this.signatureTargetHashAlgorithm])], r.push(Ee.stringToUint8Array(this.signatureTargetHash)), r = Ee.concat(r), n.push(pn(e.signatureTarget, true, r))), this.embeddedSignature !== null && n.push(pn(e.embeddedSignature, true, this.embeddedSignature.write())), this.issuerFingerprint !== null && (r = [new Uint8Array([this.issuerKeyVersion]), this.issuerFingerprint], r = Ee.concat(r), n.push(pn(e.issuerFingerprint, this.version >= 5, r))), this.preferredAEADAlgorithms !== null && (r = Ee.stringToUint8Array(Ee.uint8ArrayToString(this.preferredAEADAlgorithms)), n.push(pn(e.preferredAEADAlgorithms, false, r))), this.preferredCipherSuites !== null && (r = new Uint8Array([].concat(...this.preferredCipherSuites)), n.push(pn(e.preferredCipherSuites, false, r)));
    const s = Ee.concat(n), i = Ee.writeNumber(s.length, this.version === 6 ? 4 : 2);
    return Ee.concat([i, s]);
  }
  writeUnhashedSubPackets() {
    const e = this.unhashedSubpackets.map(({ type: s, critical: i, body: a }) => pn(s, i, a)), n = Ee.concat(e), r = Ee.writeNumber(n.length, this.version === 6 ? 4 : 2);
    return Ee.concat([r, n]);
  }
  readSubPacket(e, n = true) {
    let r = 0;
    const s = !!(128 & e[r]), i = 127 & e[r];
    if (r++, n || (this.unhashedSubpackets.push({ type: i, critical: s, body: e.subarray(r, e.length) }), eU.has(i))) switch (i) {
      case ee.signatureSubpacket.signatureCreationTime:
        this.created = Ee.readDate(e.subarray(r, e.length));
        break;
      case ee.signatureSubpacket.signatureExpirationTime: {
        const a = Ee.readNumber(e.subarray(r, e.length));
        this.signatureNeverExpires = a === 0, this.signatureExpirationTime = a;
        break;
      }
      case ee.signatureSubpacket.exportableCertification:
        this.exportable = e[r++] === 1;
        break;
      case ee.signatureSubpacket.trustSignature:
        this.trustLevel = e[r++], this.trustAmount = e[r++];
        break;
      case ee.signatureSubpacket.regularExpression:
        this.regularExpression = e[r];
        break;
      case ee.signatureSubpacket.revocable:
        this.revocable = e[r++] === 1;
        break;
      case ee.signatureSubpacket.keyExpirationTime: {
        const a = Ee.readNumber(e.subarray(r, e.length));
        this.keyExpirationTime = a, this.keyNeverExpires = a === 0;
        break;
      }
      case ee.signatureSubpacket.preferredSymmetricAlgorithms:
        this.preferredSymmetricAlgorithms = [...e.subarray(r, e.length)];
        break;
      case ee.signatureSubpacket.revocationKey:
        this.revocationKeyClass = e[r++], this.revocationKeyAlgorithm = e[r++], this.revocationKeyFingerprint = e.subarray(r, r + 20);
        break;
      case ee.signatureSubpacket.issuerKeyID:
        if (this.version === 4) this.issuerKeyID.read(e.subarray(r, e.length));
        else if (n) throw Error("Unexpected Issuer Key ID subpacket");
        break;
      case ee.signatureSubpacket.notationData: {
        const a = !!(128 & e[r]);
        r += 4;
        const o = Ee.readNumber(e.subarray(r, r + 2));
        r += 2;
        const f = Ee.readNumber(e.subarray(r, r + 2));
        r += 2;
        const c = Ee.decodeUTF8(e.subarray(r, r + o)), l = e.subarray(r + o, r + o + f);
        this.rawNotations.push({ name: c, humanReadable: a, value: l, critical: s }), a && (this.notations[c] = Ee.decodeUTF8(l));
        break;
      }
      case ee.signatureSubpacket.preferredHashAlgorithms:
        this.preferredHashAlgorithms = [...e.subarray(r, e.length)];
        break;
      case ee.signatureSubpacket.preferredCompressionAlgorithms:
        this.preferredCompressionAlgorithms = [...e.subarray(r, e.length)];
        break;
      case ee.signatureSubpacket.keyServerPreferences:
        this.keyServerPreferences = [...e.subarray(r, e.length)];
        break;
      case ee.signatureSubpacket.preferredKeyServer:
        this.preferredKeyServer = Ee.decodeUTF8(e.subarray(r, e.length));
        break;
      case ee.signatureSubpacket.primaryUserID:
        this.isPrimaryUserID = e[r++] !== 0;
        break;
      case ee.signatureSubpacket.policyURI:
        this.policyURI = Ee.decodeUTF8(e.subarray(r, e.length));
        break;
      case ee.signatureSubpacket.keyFlags:
        this.keyFlags = [...e.subarray(r, e.length)];
        break;
      case ee.signatureSubpacket.signersUserID:
        this.signersUserID = Ee.decodeUTF8(e.subarray(r, e.length));
        break;
      case ee.signatureSubpacket.reasonForRevocation:
        this.reasonForRevocationFlag = e[r++], this.reasonForRevocationString = Ee.decodeUTF8(e.subarray(r, e.length));
        break;
      case ee.signatureSubpacket.features:
        this.features = [...e.subarray(r, e.length)];
        break;
      case ee.signatureSubpacket.signatureTarget: {
        this.signatureTargetPublicKeyAlgorithm = e[r++], this.signatureTargetHashAlgorithm = e[r++];
        const a = li(this.signatureTargetHashAlgorithm);
        this.signatureTargetHash = Ee.uint8ArrayToString(e.subarray(r, r + a));
        break;
      }
      case ee.signatureSubpacket.embeddedSignature:
        this.embeddedSignature = new Ui(), this.embeddedSignature.read(e.subarray(r, e.length));
        break;
      case ee.signatureSubpacket.issuerFingerprint:
        this.issuerKeyVersion = e[r++], this.issuerFingerprint = e.subarray(r, e.length), this.issuerKeyVersion >= 5 ? this.issuerKeyID.read(this.issuerFingerprint) : this.issuerKeyID.read(this.issuerFingerprint.subarray(-8));
        break;
      case ee.signatureSubpacket.preferredAEADAlgorithms:
        this.preferredAEADAlgorithms = [...e.subarray(r, e.length)];
        break;
      case ee.signatureSubpacket.preferredCipherSuites:
        this.preferredCipherSuites = [];
        for (let a = r; a < e.length; a += 2) this.preferredCipherSuites.push([e[a], e[a + 1]]);
        break;
      default:
        this.unknownSubpackets.push({ type: i, critical: s, body: e.subarray(r, e.length) });
    }
  }
  readSubPackets(e, n = true, r) {
    const s = this.version === 6 ? 4 : 2, i = Ee.readNumber(e.subarray(0, s));
    let a = s;
    for (; a < 2 + i; ) {
      const o = jC(e.subarray(a, e.length));
      a += o.offset, this.readSubPacket(e.subarray(a, a + o.len), n, r), a += o.len;
    }
    return a;
  }
  toSign(e, n) {
    const r = ee.signature;
    switch (e) {
      case r.binary:
        return n.text !== null ? Ee.encodeUTF8(n.getText(true)) : n.getBytes(true);
      case r.text: {
        const s = n.getBytes(true);
        return Ee.canonicalizeEOL(s);
      }
      case r.standalone:
        return new Uint8Array(0);
      case r.certGeneric:
      case r.certPersona:
      case r.certCasual:
      case r.certPositive:
      case r.certRevocation: {
        let s, i;
        if (n.userID) i = 180, s = n.userID;
        else {
          if (!n.userAttribute) throw Error("Either a userID or userAttribute packet needs to be supplied for certification.");
          i = 209, s = n.userAttribute;
        }
        const a = s.write();
        return Ee.concat([this.toSign(r.key, n), new Uint8Array([i]), Ee.writeNumber(a.length, 4), a]);
      }
      case r.subkeyBinding:
      case r.subkeyRevocation:
      case r.keyBinding:
        return Ee.concat([this.toSign(r.key, n), this.toSign(r.key, { key: n.bind })]);
      case r.key:
        if (n.key === void 0) throw Error("Key packet is required for this signature.");
        return n.key.writeForHash(this.version);
      case r.keyRevocation:
        return this.toSign(r.key, n);
      case r.timestamp:
        return new Uint8Array(0);
      case r.thirdParty:
        throw Error("Not implemented");
      default:
        throw Error("Unknown signature type.");
    }
  }
  calculateTrailer(e, n) {
    let r = 0;
    return ii(i0(this.signatureData), (s) => {
      r += s.length;
    }, () => {
      const s = [];
      return this.version !== 5 || this.signatureType !== ee.signature.binary && this.signatureType !== ee.signature.text || (n ? s.push(new Uint8Array(6)) : s.push(e.writeHeader())), s.push(new Uint8Array([this.version, 255])), this.version === 5 && s.push(new Uint8Array(4)), s.push(Ee.writeNumber(r, 4)), Ee.concat(s);
    });
  }
  toHash(e, n, r = false) {
    const s = this.toSign(e, n);
    return Ee.concat([this.salt || new Uint8Array(), s, this.signatureData, this.calculateTrailer(n, r)]);
  }
  async hash(e, n, r, s = false) {
    if (this.version === 6 && this.salt.length !== Hm(this.hashAlgorithm)) throw Error("Signature salt does not have the expected length");
    return r || (r = this.toHash(e, n, s)), _o(this.hashAlgorithm, r);
  }
  async verify(e, n, r, s = /* @__PURE__ */ new Date(), i = false, a = Qt) {
    if (!this.issuerKeyID.equals(e.getKeyID())) throw Error("Signature was not issued by the given public key");
    if (this.publicKeyAlgorithm !== e.algorithm) throw Error("Public key algorithm used to sign signature does not match issuer key algorithm.");
    const o = n === ee.signature.binary || n === ee.signature.text;
    if (!(this[Ac] && !o)) {
      let c, l;
      if (this.hashed ? l = await this.hashed : (c = this.toHash(n, r, i), l = await this.hash(n, r, c)), l = await Zn(l), this.signedHashValue[0] !== l[0] || this.signedHashValue[1] !== l[1]) throw Error("Signed digest did not match");
      if (this.params = await this.params, this[Ac] = await LN(this.publicKeyAlgorithm, this.hashAlgorithm, this.params, e.publicParams, c, l), !this[Ac]) throw Error("Signature verification failed");
    }
    const f = Ee.normalizeDate(s);
    if (f && this.created > f) throw Error("Signature creation time is in the future");
    if (f && f >= this.getExpirationTime()) throw Error("Signature is expired");
    if (a.rejectHashAlgorithms.has(this.hashAlgorithm)) throw Error("Insecure hash algorithm: " + ee.read(ee.hash, this.hashAlgorithm).toUpperCase());
    if (a.rejectMessageHashAlgorithms.has(this.hashAlgorithm) && [ee.signature.binary, ee.signature.text].includes(this.signatureType)) throw Error("Insecure message hash algorithm: " + ee.read(ee.hash, this.hashAlgorithm).toUpperCase());
    if (this.unknownSubpackets.forEach(({ type: c, critical: l }) => {
      if (l) throw Error("Unknown critical signature subpacket type " + c);
    }), this.rawNotations.forEach(({ name: c, critical: l }) => {
      if (l && a.knownNotations.indexOf(c) < 0) throw Error("Unknown critical notation: " + c);
    }), this.revocationKeyClass !== null) throw Error("This key is intended to be revoked with an authorized key, which OpenPGP.js does not support.");
  }
  isExpired(e = /* @__PURE__ */ new Date()) {
    const n = Ee.normalizeDate(e);
    return n !== null && !(this.created <= n && n < this.getExpirationTime());
  }
  getExpirationTime() {
    return this.signatureNeverExpires ? 1 / 0 : new Date(this.created.getTime() + 1e3 * this.signatureExpirationTime);
  }
}
function pn(t3, e, n) {
  const r = [];
  return r.push(ig(n.length + 1)), r.push(new Uint8Array([(e ? 128 : 0) | t3])), r.push(n), Ee.concat(r);
}
function Hm(t3) {
  switch (t3) {
    case ee.hash.sha256:
      return 16;
    case ee.hash.sha384:
      return 24;
    case ee.hash.sha512:
      return 32;
    case ee.hash.sha224:
    case ee.hash.sha3_256:
      return 16;
    case ee.hash.sha3_512:
      return 32;
    default:
      throw Error("Unsupported hash function");
  }
}
class aa {
  static get tag() {
    return ee.packet.onePassSignature;
  }
  static fromSignaturePacket(e, n) {
    const r = new aa();
    return r.version = e.version === 6 ? 6 : 3, r.signatureType = e.signatureType, r.hashAlgorithm = e.hashAlgorithm, r.publicKeyAlgorithm = e.publicKeyAlgorithm, r.issuerKeyID = e.issuerKeyID, r.salt = e.salt, r.issuerFingerprint = e.issuerFingerprint, r.flags = n ? 1 : 0, r;
  }
  constructor() {
    this.version = null, this.signatureType = null, this.hashAlgorithm = null, this.publicKeyAlgorithm = null, this.salt = null, this.issuerKeyID = null, this.issuerFingerprint = null, this.flags = null;
  }
  read(e) {
    let n = 0;
    if (this.version = e[n++], this.version !== 3 && this.version !== 6) throw new fn(`Version ${this.version} of the one-pass signature packet is unsupported.`);
    if (this.signatureType = e[n++], this.hashAlgorithm = e[n++], this.publicKeyAlgorithm = e[n++], this.version === 6) {
      const r = e[n++];
      this.salt = e.subarray(n, n + r), n += r, this.issuerFingerprint = e.subarray(n, n + 32), n += 32, this.issuerKeyID = new mo(), this.issuerKeyID.read(this.issuerFingerprint);
    } else this.issuerKeyID = new mo(), this.issuerKeyID.read(e.subarray(n, n + 8)), n += 8;
    return this.flags = e[n++], this;
  }
  write() {
    const e = [new Uint8Array([this.version, this.signatureType, this.hashAlgorithm, this.publicKeyAlgorithm])];
    return this.version === 6 ? e.push(new Uint8Array([this.salt.length]), this.salt, this.issuerFingerprint) : e.push(this.issuerKeyID.write()), e.push(new Uint8Array([this.flags])), Ee.concatUint8Array(e);
  }
  calculateTrailer(...e) {
    return d0(async () => Ui.prototype.calculateTrailer.apply(await this.correspondingSig, e));
  }
  async verify() {
    const e = await this.correspondingSig;
    if (!e || e.constructor.tag !== ee.packet.signature) throw Error("Corresponding signature packet missing");
    if (e.signatureType !== this.signatureType || e.hashAlgorithm !== this.hashAlgorithm || e.publicKeyAlgorithm !== this.publicKeyAlgorithm || !e.issuerKeyID.equals(this.issuerKeyID) || this.version === 3 && e.version === 6 || this.version === 6 && e.version !== 6 || this.version === 6 && !Ee.equalsUint8Array(e.issuerFingerprint, this.issuerFingerprint) || this.version === 6 && !Ee.equalsUint8Array(e.salt, this.salt)) throw Error("Corresponding signature packet does not match one-pass signature packet");
    return e.hashed = this.hashed, e.verify.apply(e, arguments);
  }
}
function tU(t3, e) {
  if (!e[t3]) {
    let n;
    try {
      n = ee.read(ee.packet, t3);
    } catch {
      throw new xp("Unknown packet type with tag: " + t3);
    }
    throw Error("Packet not allowed in this context: " + n);
  }
  return new e[t3]();
}
aa.prototype.hash = Ui.prototype.hash, aa.prototype.toHash = Ui.prototype.toHash, aa.prototype.toSign = Ui.prototype.toSign;
class cn extends Array {
  static async fromBinary(e, n, r = Qt, s = null, i = false) {
    const a = new cn();
    return await a.read(e, n, r, s, i), a;
  }
  async read(e, n, r = Qt, s = null, i = false) {
    let a;
    r.additionalAllowedPackets.length && (a = Ee.constructAllowedPackets(r.additionalAllowedPackets), n = { ...n, ...a }), this.stream = hl(e, async (f, c) => {
      const l = Ma(f), h = Hs(c);
      try {
        let m = Ee.isStream(f);
        for (; ; ) {
          let v, b;
          if (await h.ready, await uN(l, m, async (_) => {
            try {
              if (_.tag === ee.packet.marker || _.tag === ee.packet.trust || _.tag === ee.packet.padding) return;
              const C = tU(_.tag, n);
              try {
                s == null ? void 0 : s.recordPacket(_.tag, a);
              } catch (I) {
                if (r.enforceGrammar) throw I;
                Ee.printDebugError(I);
              }
              C.packets = new cn(), C.fromStream = Ee.isStream(_.packet), b = C.fromStream;
              try {
                await C.read(_.packet, r);
              } catch (I) {
                throw I instanceof fn ? I : Ee.wrapError(new Dm(`Parsing ${C.constructor.name} failed`), I);
              }
              await h.write(C);
            } catch (C) {
              const I = C instanceof xp && _.tag <= 39, S = C instanceof fn && !(C instanceof xp) && !r.ignoreUnsupportedPackets, $ = C instanceof Dm && !r.ignoreMalformedPackets, F = wp(_.tag);
              if (I || S || $ || F || !(C instanceof xp || C instanceof fn || C instanceof Dm)) i ? v = C : await h.abort(C);
              else {
                const U = new Ly(_.tag, _.packet);
                await h.write(U);
              }
              Ee.printDebugError(C);
            }
          }), b && (m = null), v) throw await l.readToEnd(), v;
          const A = await l.peekBytes(2);
          if (!A || !A.length) {
            try {
              s == null ? void 0 : s.recordEnd();
            } catch (_) {
              if (r.enforceGrammar) throw _;
              Ee.printDebugError(_);
            }
            return await h.ready, void await h.close();
          }
        }
      } catch (m) {
        await h.abort(m);
      }
    });
    const o = Ma(this.stream);
    for (; ; ) {
      const { done: f, value: c } = await o.read();
      if (f ? this.stream = null : this.push(c), f || wp(c.constructor.tag)) break;
    }
    o.releaseLock();
  }
  write() {
    const e = [];
    for (let n = 0; n < this.length; n++) {
      const r = this[n] instanceof Ly ? this[n].tag : this[n].constructor.tag, s = this[n].write();
      if (Ee.isStream(s) && wp(this[n].constructor.tag)) {
        let i = [], a = 0;
        const o = 512;
        e.push(n1(r)), e.push(ii(s, (f) => {
          if (i.push(f), a += f.length, a >= o) {
            const c = Math.min(Math.log(a) / Math.LN2 | 0, 30), l = 2 ** c, h = Ee.concat([lN(c)].concat(i));
            return i = [h.subarray(1 + l)], a = i[0].length, h.subarray(0, 1 + l);
          }
        }, () => Ee.concat([ig(a)].concat(i))));
      } else {
        if (Ee.isStream(s)) {
          let i = 0;
          e.push(ii(i0(s), (a) => {
            i += a.length;
          }, () => d6(r, i)));
        } else e.push(d6(r, s.length));
        e.push(s);
      }
    }
    return Ee.concat(e);
  }
  filterByTag(...e) {
    const n = new cn(), r = (s) => (i) => s === i;
    for (let s = 0; s < this.length; s++) e.some(r(this[s].constructor.tag)) && n.push(this[s]);
    return n;
  }
  findPacket(e) {
    return this.find((n) => n.constructor.tag === e);
  }
  indexOfTag(...e) {
    const n = [], r = this, s = (i) => (a) => i === a;
    for (let i = 0; i < this.length; i++) e.some(s(r[i].constructor.tag)) && n.push(i);
    return n;
  }
}
class qa extends Error {
  constructor(...e) {
    super(...e), Error.captureStackTrace && Error.captureStackTrace(this, qa), this.name = "GrammarError";
  }
}
var Hn;
(function(t3) {
  t3[t3.EmptyMessage = 0] = "EmptyMessage", t3[t3.PlaintextOrEncryptedData = 1] = "PlaintextOrEncryptedData", t3[t3.EncryptedSessionKeys = 2] = "EncryptedSessionKeys", t3[t3.StandaloneAdditionalAllowedData = 3] = "StandaloneAdditionalAllowedData";
})(Hn || (Hn = {}));
class yg {
  constructor() {
    this.state = Hn.EmptyMessage, this.leadingOnePassSignatureCounter = 0;
  }
  recordPacket(e, n) {
    switch (this.state) {
      case Hn.EmptyMessage:
      case Hn.StandaloneAdditionalAllowedData:
        switch (e) {
          case ee.packet.literalData:
          case ee.packet.compressedData:
          case ee.packet.aeadEncryptedData:
          case ee.packet.symEncryptedIntegrityProtectedData:
          case ee.packet.symmetricallyEncryptedData:
            return void (this.state = Hn.PlaintextOrEncryptedData);
          case ee.packet.signature:
            if (this.state === Hn.StandaloneAdditionalAllowedData && --this.leadingOnePassSignatureCounter < 0) throw new qa("Trailing signature packet without OPS");
            return;
          case ee.packet.onePassSignature:
            if (this.state === Hn.StandaloneAdditionalAllowedData) throw new qa("OPS following StandaloneAdditionalAllowedData");
            return void this.leadingOnePassSignatureCounter++;
          case ee.packet.publicKeyEncryptedSessionKey:
          case ee.packet.symEncryptedSessionKey:
            return void (this.state = Hn.EncryptedSessionKeys);
          default:
            if (!(n == null ? void 0 : n[e])) throw new qa(`Unexpected packet ${e} in state ${this.state}`);
            return void (this.state = Hn.StandaloneAdditionalAllowedData);
        }
      case Hn.PlaintextOrEncryptedData:
        if (e === ee.packet.signature) {
          if (--this.leadingOnePassSignatureCounter < 0) throw new qa("Trailing signature packet without OPS");
          return void (this.state = Hn.PlaintextOrEncryptedData);
        }
        if (!(n == null ? void 0 : n[e])) throw new qa(`Unexpected packet ${e} in state ${this.state}`);
        return void (this.state = Hn.PlaintextOrEncryptedData);
      case Hn.EncryptedSessionKeys:
        switch (e) {
          case ee.packet.publicKeyEncryptedSessionKey:
          case ee.packet.symEncryptedSessionKey:
            return void (this.state = Hn.EncryptedSessionKeys);
          case ee.packet.symEncryptedIntegrityProtectedData:
          case ee.packet.aeadEncryptedData:
          case ee.packet.symmetricallyEncryptedData:
            return void (this.state = Hn.PlaintextOrEncryptedData);
          case ee.packet.signature:
            if (--this.leadingOnePassSignatureCounter < 0) throw new qa("Trailing signature packet without OPS");
            return void (this.state = Hn.PlaintextOrEncryptedData);
          default:
            if (!(n == null ? void 0 : n[e])) throw new qa(`Unexpected packet ${e} in state ${this.state}`);
            this.state = Hn.EncryptedSessionKeys;
        }
    }
  }
  recordEnd() {
    switch (this.state) {
      case Hn.EmptyMessage:
      case Hn.PlaintextOrEncryptedData:
      case Hn.EncryptedSessionKeys:
      case Hn.StandaloneAdditionalAllowedData:
        if (this.leadingOnePassSignatureCounter > 0) throw new qa("Missing trailing signature packets");
    }
  }
}
const rU = Ee.constructAllowedPackets([zu, aa, Ui]);
class Xh {
  static get tag() {
    return ee.packet.compressedData;
  }
  constructor(e = Qt) {
    this.packets = null, this.algorithm = e.preferredCompressionAlgorithm, this.compressed = null;
  }
  async read(e, n = Qt) {
    await ng(e, async (r) => {
      this.algorithm = await r.readByte(), this.compressed = r.remainder(), await this.decompress(n);
    });
  }
  write() {
    return this.compressed === null && this.compress(), Ee.concat([new Uint8Array([this.algorithm]), this.compressed]);
  }
  async decompress(e = Qt) {
    const n = ee.read(ee.compression, this.algorithm), r = sU[n];
    if (!r) throw Error(n + " decompression not supported");
    let s = await r(this.compressed);
    if (e.maxDecompressedMessageSize !== 1 / 0) {
      let i = 0;
      s = ii(s, (a) => {
        if (i += a.length, i > e.maxDecompressedMessageSize) throw Error("Maximum decompressed message size exceeded");
        return a;
      });
    }
    si(this.compressed) && !Un(this.compressed) || (s = await Zn(s)), this.packets = await cn.fromBinary(s, rU, e, new yg());
  }
  compress() {
    const e = ee.read(ee.compression, this.algorithm), n = iU[e];
    if (!n) throw Error(e + " compression not supported");
    const r = this.packets.write();
    let s = n(r);
    si(r) && !Un(r) || (s = d0(() => Zn(s))), this.compressed = s;
  }
}
function c1(t3, e) {
  return (n) => {
    let r;
    if (r = Un(n) ? new ReadableStream({ async start(f) {
      try {
        f.enqueue(await Zn(n)), f.close();
      } catch (c) {
        f.error(c);
      }
    } }) : si(n) ? n : Yh(n), r = function(f) {
      const c = Ma(f);
      return new ReadableStream({ async pull(l) {
        try {
          const { value: h, done: m } = await c.read();
          if (m) return void l.close();
          for (let v = 0; v <= h.length; v += 65536) (!v || v < h.length) && l.enqueue(h.subarray(v, v + 65536));
        } catch (h) {
          l.error(h);
        }
      } }, { highWaterMark: 0 });
    }(r), t3) try {
      const f = t3();
      return r.pipeThrough(f);
    } catch (f) {
      if (f.name !== "TypeError") throw f;
    }
    const s = Ma(r), i = new e();
    let a = false, o = false;
    return new ReadableStream({ start(f) {
      i.ondata = (c, l) => {
        f.enqueue(c), a = true, l && (f.close(), o = true);
      };
    }, async pull() {
      for (a = false; !a && !o; ) {
        const { done: f, value: c } = await s.read();
        if (f) return void i.push(new Uint8Array(), true);
        c.length && i.push(c);
      }
    } }, { highWaterMark: 0 });
  };
}
function nU() {
  return async function(t3) {
    const { default: e } = await Promise.resolve().then(function() {
      return _O;
    });
    return e(Yh(t3));
  };
}
const h1 = (t3) => ({ compressor: typeof CompressionStream < "u" && (() => new CompressionStream(t3)), decompressor: typeof DecompressionStream < "u" && (() => new DecompressionStream(t3)) }), iU = { zip: c1(h1("deflate-raw").compressor, Sp), zlib: c1(h1("deflate").compressor, ZN) }, sU = { uncompressed: (t3) => t3, zip: c1(h1("deflate-raw").decompressor, Mp), zlib: c1(h1("deflate").decompressor, jN), bzip2: nU() }, aU = Ee.constructAllowedPackets([zu, Xh, aa, Ui]);
class Au {
  static get tag() {
    return ee.packet.symEncryptedIntegrityProtectedData;
  }
  static fromObject({ version: e, aeadAlgorithm: n }) {
    if (e !== 1 && e !== 2) throw Error("Unsupported SEIPD version");
    const r = new Au();
    return r.version = e, e === 2 && (r.aeadAlgorithm = n), r;
  }
  constructor() {
    this.version = null, this.cipherAlgorithm = null, this.aeadAlgorithm = null, this.chunkSizeByte = null, this.salt = null, this.encrypted = null, this.packets = null;
  }
  async read(e) {
    await ng(e, async (n) => {
      if (this.version = await n.readByte(), this.version !== 1 && this.version !== 2) throw new fn(`Version ${this.version} of the SEIP packet is unsupported.`);
      this.version === 2 && (this.cipherAlgorithm = await n.readByte(), this.aeadAlgorithm = await n.readByte(), this.chunkSizeByte = await n.readByte(), this.salt = await n.readBytes(32)), this.encrypted = n.remainder();
    });
  }
  write() {
    return this.version === 2 ? Ee.concat([new Uint8Array([this.version, this.cipherAlgorithm, this.aeadAlgorithm, this.chunkSizeByte]), this.salt, this.encrypted]) : Ee.concat([new Uint8Array([this.version]), this.encrypted]);
  }
  async encrypt(e, n, r = Qt) {
    const { blockSize: s, keySize: i } = mn(e);
    if (n.length !== i) throw Error("Unexpected session key size");
    let a = this.packets.write();
    if (Un(a) && (a = await Zn(a)), this.version === 2) this.cipherAlgorithm = e, this.salt = Ni(32), this.chunkSizeByte = r.aeadChunkSizeByte, this.encrypted = await d1(this, "encrypt", n, a);
    else {
      const o = await Tk(e), f = new Uint8Array([211, 20]), c = Ee.concat([o, a, f]), l = await _o(ee.hash.sha1, sh(c)), h = Ee.concat([c, l]);
      this.encrypted = await kh(e, n, h, new Uint8Array(s));
    }
    return true;
  }
  async decrypt(e, n, r = Qt) {
    if (n.length !== mn(e).keySize) throw Error("Unexpected session key size");
    let s, i = i0(this.encrypted);
    Un(i) && (i = await Zn(i));
    let a = false;
    if (this.version === 2) {
      if (this.cipherAlgorithm !== e) throw Error("Unexpected session key algorithm");
      s = await d1(this, "decrypt", n, i);
    } else {
      const { blockSize: o } = mn(e), f = await pg(e, n, i, new Uint8Array(o)), c = Fi(sh(f), -20), l = Fi(f, 0, -20), h = Promise.all([Zn(await _o(ee.hash.sha1, sh(l))), Zn(c)]).then(([v, b]) => {
        if (!Ee.equalsUint8Array(v, b)) throw Error("Modification detected.");
        return new Uint8Array();
      }), m = Fi(l, o + 2);
      s = Fi(m, 0, -2), s = hs([s, d0(() => h)]), Ee.isStream(i) && r.allowUnauthenticatedStream ? a = true : s = await Zn(s);
    }
    return this.packets = await cn.fromBinary(s, aU, r, new yg(), a), true;
  }
}
async function d1(t3, e, n, r) {
  const s = t3 instanceof Au && t3.version === 2, i = !s && t3.constructor.tag === ee.packet.aeadEncryptedData;
  if (!s && !i) throw Error("Unexpected packet type");
  const a = tf(t3.aeadAlgorithm, i), o = e === "decrypt" ? a.tagLength : 0, f = e === "encrypt" ? a.tagLength : 0, c = 2 ** (t3.chunkSizeByte + 6) + o, l = i ? 8 : 0, h = new ArrayBuffer(13 + l), m = new Uint8Array(h, 0, 5 + l), v = new Uint8Array(h), b = new DataView(h), A = new Uint8Array(h, 5, 8);
  m.set([192 | t3.constructor.tag, t3.version, t3.cipherAlgorithm, t3.aeadAlgorithm, t3.chunkSizeByte], 0);
  let _, C, I = 0, S = Promise.resolve(), $ = 0, F = 0;
  if (s) {
    const { keySize: Q } = mn(t3.cipherAlgorithm), { ivLength: P } = a, N = new Uint8Array(h, 0, 5), L = await il(ee.hash.sha256, n, t3.salt, N, Q + P);
    n = L.subarray(0, Q), _ = L.subarray(Q), _.fill(0, _.length - 8), C = new DataView(_.buffer, _.byteOffset, _.byteLength);
  } else _ = t3.iv;
  const U = await a(t3.cipherAlgorithm, n);
  return hl(r, async (Q, P) => {
    if (Ee.isStream(Q) !== "array") {
      const B = new TransformStream({}, { highWaterMark: Ee.getHardwareConcurrency() * 2 ** (t3.chunkSizeByte + 6), size: (u) => u.length });
      mu(B.readable, P), P = B.writable;
    }
    const N = Ma(Q), L = Hs(P);
    try {
      for (; ; ) {
        let B = await N.readBytes(c + o) || new Uint8Array();
        const u = B.subarray(B.length - o);
        let p, d, y;
        if (B = B.subarray(0, B.length - o), s) y = _;
        else {
          y = _.slice();
          for (let w = 0; w < 8; w++) y[_.length - 8 + w] ^= A[w];
        }
        if (!I || B.length ? (N.unshift(u), p = U[e](B, y, m), p.catch(() => {
        }), F += B.length - o + f) : (b.setInt32(5 + l + 4, $), p = U[e](u, y, v), p.catch(() => {
        }), F += f, d = true), $ += B.length - o, S = S.then(() => p).then(async (w) => {
          await L.ready, await L.write(w), F -= w.length;
        }).catch((w) => L.abort(w)), (d || F > L.desiredSize) && await S, d) {
          await L.close();
          break;
        }
        s ? C.setInt32(_.length - 4, ++I) : b.setInt32(9, ++I);
      }
    } catch (B) {
      await L.ready.catch(() => {
      }), await L.abort(B);
    }
  });
}
const oU = Ee.constructAllowedPackets([zu, Xh, aa, Ui]);
class fU {
  static get tag() {
    return ee.packet.aeadEncryptedData;
  }
  constructor() {
    this.version = 1, this.cipherAlgorithm = null, this.aeadAlgorithm = ee.aead.eax, this.chunkSizeByte = null, this.iv = null, this.encrypted = null, this.packets = null;
  }
  async read(e) {
    await ng(e, async (n) => {
      const r = await n.readByte();
      if (r !== 1) throw new fn(`Version ${r} of the AEAD-encrypted data packet is not supported.`);
      this.cipherAlgorithm = await n.readByte(), this.aeadAlgorithm = await n.readByte(), this.chunkSizeByte = await n.readByte();
      const s = tf(this.aeadAlgorithm, true);
      this.iv = await n.readBytes(s.ivLength), this.encrypted = n.remainder();
    });
  }
  write() {
    return Ee.concat([new Uint8Array([this.version, this.cipherAlgorithm, this.aeadAlgorithm, this.chunkSizeByte]), this.iv, this.encrypted]);
  }
  async decrypt(e, n, r = Qt) {
    this.packets = await cn.fromBinary(await d1(this, "decrypt", n, i0(this.encrypted)), oU, r, new yg());
  }
  async encrypt(e, n, r = Qt) {
    this.cipherAlgorithm = e;
    const { ivLength: s } = tf(this.aeadAlgorithm, true);
    this.iv = Ni(s), this.chunkSizeByte = r.aeadChunkSizeByte;
    const i = this.packets.write();
    this.encrypted = await d1(this, "encrypt", n, i);
  }
}
class Sh {
  static get tag() {
    return ee.packet.publicKeyEncryptedSessionKey;
  }
  constructor() {
    this.version = null, this.publicKeyID = new mo(), this.publicKeyVersion = null, this.publicKeyFingerprint = null, this.publicKeyAlgorithm = null, this.sessionKey = null, this.sessionKeyAlgorithm = null, this.encrypted = {};
  }
  static fromObject({ version: e, encryptionKeyPacket: n, anonymousRecipient: r, sessionKey: s, sessionKeyAlgorithm: i }) {
    const a = new Sh();
    if (e !== 3 && e !== 6) throw Error("Unsupported PKESK version");
    return a.version = e, e === 6 && (a.publicKeyVersion = r ? null : n.version, a.publicKeyFingerprint = r ? null : n.getFingerprintBytes()), a.publicKeyID = r ? mo.wildcard() : n.getKeyID(), a.publicKeyAlgorithm = n.algorithm, a.sessionKey = s, a.sessionKeyAlgorithm = i, a;
  }
  read(e) {
    let n = 0;
    if (this.version = e[n++], this.version !== 3 && this.version !== 6) throw new fn(`Version ${this.version} of the PKESK packet is unsupported.`);
    if (this.version === 6) {
      const r = e[n++];
      if (r) {
        this.publicKeyVersion = e[n++];
        const s = r - 1;
        this.publicKeyFingerprint = e.subarray(n, n + s), n += s, this.publicKeyVersion >= 5 ? this.publicKeyID.read(this.publicKeyFingerprint) : this.publicKeyID.read(this.publicKeyFingerprint.subarray(-8));
      } else this.publicKeyID = mo.wildcard();
    } else n += this.publicKeyID.read(e.subarray(n, n + 8));
    if (this.publicKeyAlgorithm = e[n++], this.encrypted = function(r, s) {
      let i = 0;
      switch (r) {
        case ee.publicKey.rsaEncrypt:
        case ee.publicKey.rsaEncryptSign:
          return { c: Ee.readMPI(s.subarray(i)) };
        case ee.publicKey.elgamal: {
          const a = Ee.readMPI(s.subarray(i));
          return i += a.length + 2, { c1: a, c2: Ee.readMPI(s.subarray(i)) };
        }
        case ee.publicKey.ecdh: {
          const a = Ee.readMPI(s.subarray(i));
          i += a.length + 2;
          const o = new Mk();
          return o.read(s.subarray(i)), { V: a, C: o };
        }
        case ee.publicKey.x25519:
        case ee.publicKey.x448: {
          const a = W0(r), o = Ee.readExactSubarray(s, i, i + a);
          i += o.length;
          const f = new dg();
          return f.read(s.subarray(i)), { ephemeralPublicKey: o, C: f };
        }
        default:
          throw new fn("Unknown public key encryption algorithm.");
      }
    }(this.publicKeyAlgorithm, e.subarray(n)), this.publicKeyAlgorithm === ee.publicKey.x25519 || this.publicKeyAlgorithm === ee.publicKey.x448) {
      if (this.version === 3) this.sessionKeyAlgorithm = ee.write(ee.symmetric, this.encrypted.C.algorithm);
      else if (this.encrypted.C.algorithm !== null) throw Error("Unexpected cleartext symmetric algorithm");
    }
  }
  write() {
    const e = [new Uint8Array([this.version])];
    return this.version === 6 ? this.publicKeyFingerprint !== null ? (e.push(new Uint8Array([this.publicKeyFingerprint.length + 1, this.publicKeyVersion])), e.push(this.publicKeyFingerprint)) : e.push(new Uint8Array([0])) : e.push(this.publicKeyID.write()), e.push(new Uint8Array([this.publicKeyAlgorithm]), bu(this.publicKeyAlgorithm, this.encrypted)), Ee.concatUint8Array(e);
  }
  async encrypt(e) {
    const n = ee.write(ee.publicKey, this.publicKeyAlgorithm), r = this.version === 3 ? this.sessionKeyAlgorithm : null, s = e.version === 5 ? e.getFingerprintBytes().subarray(0, 20) : e.getFingerprintBytes(), i = L6(this.version, n, r, this.sessionKey);
    this.encrypted = await kN(n, r, e.publicParams, i, s);
  }
  async decrypt(e, n) {
    if (this.publicKeyAlgorithm !== e.algorithm) throw Error("Decryption error");
    const r = n ? L6(this.version, this.publicKeyAlgorithm, n.sessionKeyAlgorithm, n.sessionKey) : null, s = e.version === 5 ? e.getFingerprintBytes().subarray(0, 20) : e.getFingerprintBytes(), i = await IN(this.publicKeyAlgorithm, e.publicParams, e.privateParams, this.encrypted, s, r), { sessionKey: a, sessionKeyAlgorithm: o } = function(f, c, l, h) {
      switch (c) {
        case ee.publicKey.rsaEncrypt:
        case ee.publicKey.rsaEncryptSign:
        case ee.publicKey.elgamal:
        case ee.publicKey.ecdh: {
          const m = l.subarray(0, l.length - 2), v = l.subarray(l.length - 2), b = Ee.writeChecksum(m.subarray(m.length % 8)), A = b[0] === v[0] & b[1] === v[1], _ = f === 6 ? { sessionKeyAlgorithm: null, sessionKey: m } : { sessionKeyAlgorithm: m[0], sessionKey: m.subarray(1) };
          if (h) {
            const C = A & _.sessionKeyAlgorithm === h.sessionKeyAlgorithm & _.sessionKey.length === h.sessionKey.length;
            return { sessionKey: Ee.selectUint8Array(C, _.sessionKey, h.sessionKey), sessionKeyAlgorithm: f === 6 ? null : Ee.selectUint8(C, _.sessionKeyAlgorithm, h.sessionKeyAlgorithm) };
          }
          if (A && (f === 6 || ee.read(ee.symmetric, _.sessionKeyAlgorithm))) return _;
          throw Error("Decryption error");
        }
        case ee.publicKey.x25519:
        case ee.publicKey.x448:
          return { sessionKeyAlgorithm: null, sessionKey: l };
        default:
          throw Error("Unsupported public key algorithm");
      }
    }(this.version, this.publicKeyAlgorithm, i, n);
    if (this.version === 3) {
      const f = this.publicKeyAlgorithm !== ee.publicKey.x25519 && this.publicKeyAlgorithm !== ee.publicKey.x448;
      if (this.sessionKeyAlgorithm = f ? o : this.sessionKeyAlgorithm, a.length !== mn(this.sessionKeyAlgorithm).keySize) throw Error("Unexpected session key size");
    }
    this.sessionKey = a;
  }
}
function L6(t3, e, n, r) {
  switch (e) {
    case ee.publicKey.rsaEncrypt:
    case ee.publicKey.rsaEncryptSign:
    case ee.publicKey.elgamal:
    case ee.publicKey.ecdh:
      return Ee.concatUint8Array([new Uint8Array(t3 === 6 ? [] : [n]), r, Ee.writeChecksum(r.subarray(r.length % 8))]);
    case ee.publicKey.x25519:
    case ee.publicKey.x448:
      return r;
    default:
      throw Error("Unsupported public key algorithm");
  }
}
class wu {
  static get tag() {
    return ee.packet.symEncryptedSessionKey;
  }
  constructor(e = Qt) {
    this.version = e.aeadProtect ? 6 : 4, this.sessionKey = null, this.sessionKeyEncryptionAlgorithm = null, this.sessionKeyAlgorithm = null, this.aeadAlgorithm = ee.write(ee.aead, e.preferredAEADAlgorithm), this.encrypted = null, this.s2k = null, this.iv = null;
  }
  read(e) {
    let n = 0;
    if (this.version = e[n++], this.version !== 4 && this.version !== 5 && this.version !== 6) throw new fn(`Version ${this.version} of the SKESK packet is unsupported.`);
    this.version === 6 && n++;
    const r = e[n++];
    this.version >= 5 && (this.aeadAlgorithm = e[n++], this.version === 6 && n++);
    const s = e[n++];
    if (this.s2k = u1(s), n += this.s2k.read(e.subarray(n, e.length)), this.version >= 5) {
      const i = tf(this.aeadAlgorithm, true);
      this.iv = e.subarray(n, n += i.ivLength);
    }
    this.version >= 5 || n < e.length ? (this.encrypted = e.subarray(n, e.length), this.sessionKeyEncryptionAlgorithm = r) : this.sessionKeyAlgorithm = r;
  }
  write() {
    const e = this.encrypted === null ? this.sessionKeyAlgorithm : this.sessionKeyEncryptionAlgorithm;
    let n;
    const r = this.s2k.write();
    if (this.version === 6) {
      const s = r.length, i = 3 + s + this.iv.length;
      n = Ee.concatUint8Array([new Uint8Array([this.version, i, e, this.aeadAlgorithm, s]), r, this.iv, this.encrypted]);
    } else this.version === 5 ? n = Ee.concatUint8Array([new Uint8Array([this.version, e, this.aeadAlgorithm]), r, this.iv, this.encrypted]) : (n = Ee.concatUint8Array([new Uint8Array([this.version, e]), r]), this.encrypted !== null && (n = Ee.concatUint8Array([n, this.encrypted])));
    return n;
  }
  async decrypt(e) {
    const n = this.sessionKeyEncryptionAlgorithm !== null ? this.sessionKeyEncryptionAlgorithm : this.sessionKeyAlgorithm, { blockSize: r, keySize: s } = mn(n), i = await this.s2k.produceKey(e, s);
    if (this.version >= 5) {
      const a = tf(this.aeadAlgorithm, true), o = new Uint8Array([192 | wu.tag, this.version, this.sessionKeyEncryptionAlgorithm, this.aeadAlgorithm]), f = this.version === 6 ? await il(ee.hash.sha256, i, new Uint8Array(), o, s) : i, c = await a(n, f);
      this.sessionKey = await c.decrypt(this.encrypted, this.iv, o);
    } else if (this.encrypted !== null) {
      const a = await pg(n, i, this.encrypted, new Uint8Array(r));
      if (this.sessionKeyAlgorithm = ee.write(ee.symmetric, a[0]), this.sessionKey = a.subarray(1, a.length), this.sessionKey.length !== mn(this.sessionKeyAlgorithm).keySize) throw Error("Unexpected session key size");
    } else this.sessionKey = i;
  }
  async encrypt(e, n = Qt) {
    const r = this.sessionKeyEncryptionAlgorithm !== null ? this.sessionKeyEncryptionAlgorithm : this.sessionKeyAlgorithm;
    this.sessionKeyEncryptionAlgorithm = r, this.s2k = Rk(n), this.s2k.generateSalt();
    const { blockSize: s, keySize: i } = mn(r), a = await this.s2k.produceKey(e, i);
    if (this.sessionKey === null && (this.sessionKey = Wy(this.sessionKeyAlgorithm)), this.version >= 5) {
      const o = tf(this.aeadAlgorithm);
      this.iv = Ni(o.ivLength);
      const f = new Uint8Array([192 | wu.tag, this.version, this.sessionKeyEncryptionAlgorithm, this.aeadAlgorithm]), c = this.version === 6 ? await il(ee.hash.sha256, a, new Uint8Array(), f, i) : a, l = await o(r, c);
      this.encrypted = await l.encrypt(this.sessionKey, this.iv, f);
    } else {
      const o = Ee.concatUint8Array([new Uint8Array([this.sessionKeyAlgorithm]), this.sessionKey]);
      this.encrypted = await kh(r, a, o, new Uint8Array(s));
    }
  }
}
class lo {
  static get tag() {
    return ee.packet.publicKey;
  }
  constructor(e = /* @__PURE__ */ new Date(), n = Qt) {
    this.version = n.v6Keys ? 6 : 4, this.created = Ee.normalizeDate(e), this.algorithm = null, this.publicParams = null, this.expirationTimeV3 = 0, this.fingerprint = null, this.keyID = null;
  }
  static fromSecretKeyPacket(e) {
    const n = new lo(), { version: r, created: s, algorithm: i, publicParams: a, keyID: o, fingerprint: f } = e;
    return n.version = r, n.created = s, n.algorithm = i, n.publicParams = a, n.keyID = o, n.fingerprint = f, n;
  }
  async read(e, n = Qt) {
    let r = 0;
    if (this.version = e[r++], this.version === 5 && !n.enableParsingV5Entities) throw new fn("Support for parsing v5 entities is disabled; turn on `config.enableParsingV5Entities` if needed");
    if (this.version === 4 || this.version === 5 || this.version === 6) {
      this.created = Ee.readDate(e.subarray(r, r + 4)), r += 4, this.algorithm = e[r++], this.version >= 5 && (r += 4);
      const { read: s, publicParams: i } = function(a, o) {
        let f = 0;
        switch (a) {
          case ee.publicKey.rsaEncrypt:
          case ee.publicKey.rsaEncryptSign:
          case ee.publicKey.rsaSign: {
            const c = Ee.readMPI(o.subarray(f));
            f += c.length + 2;
            const l = Ee.readMPI(o.subarray(f));
            return f += l.length + 2, { read: f, publicParams: { n: c, e: l } };
          }
          case ee.publicKey.dsa: {
            const c = Ee.readMPI(o.subarray(f));
            f += c.length + 2;
            const l = Ee.readMPI(o.subarray(f));
            f += l.length + 2;
            const h = Ee.readMPI(o.subarray(f));
            f += h.length + 2;
            const m = Ee.readMPI(o.subarray(f));
            return f += m.length + 2, { read: f, publicParams: { p: c, q: l, g: h, y: m } };
          }
          case ee.publicKey.elgamal: {
            const c = Ee.readMPI(o.subarray(f));
            f += c.length + 2;
            const l = Ee.readMPI(o.subarray(f));
            f += l.length + 2;
            const h = Ee.readMPI(o.subarray(f));
            return f += h.length + 2, { read: f, publicParams: { p: c, g: l, y: h } };
          }
          case ee.publicKey.ecdsa: {
            const c = new ef();
            f += c.read(o), Pm(c);
            const l = Ee.readMPI(o.subarray(f));
            return f += l.length + 2, { read: f, publicParams: { oid: c, Q: l } };
          }
          case ee.publicKey.eddsaLegacy: {
            const c = new ef();
            if (f += c.read(o), Pm(c), c.getName() !== ee.curve.ed25519Legacy) throw Error("Unexpected OID for eddsaLegacy");
            let l = Ee.readMPI(o.subarray(f));
            return f += l.length + 2, l = Ee.leftPad(l, 33), { read: f, publicParams: { oid: c, Q: l } };
          }
          case ee.publicKey.ecdh: {
            const c = new ef();
            f += c.read(o), Pm(c);
            const l = Ee.readMPI(o.subarray(f));
            f += l.length + 2;
            const h = new $k();
            return f += h.read(o.subarray(f)), { read: f, publicParams: { oid: c, Q: l, kdfParams: h } };
          }
          case ee.publicKey.ed25519:
          case ee.publicKey.ed448:
          case ee.publicKey.x25519:
          case ee.publicKey.x448: {
            const c = Ee.readExactSubarray(o, f, f + W0(a));
            return f += c.length, { read: f, publicParams: { A: c } };
          }
          default:
            throw new fn("Unknown public key encryption algorithm.");
        }
      }(this.algorithm, e.subarray(r));
      if (this.version === 6 && i.oid && (i.oid.getName() === ee.curve.curve25519Legacy || i.oid.getName() === ee.curve.ed25519Legacy)) throw Error("Legacy curve25519 cannot be used with v6 keys");
      return this.publicParams = i, r += s, await this.computeFingerprintAndKeyID(), r;
    }
    throw new fn(`Version ${this.version} of the key packet is unsupported.`);
  }
  write() {
    const e = [];
    e.push(new Uint8Array([this.version])), e.push(Ee.writeDate(this.created)), e.push(new Uint8Array([this.algorithm]));
    const n = bu(this.algorithm, this.publicParams);
    return this.version >= 5 && e.push(Ee.writeNumber(n.length, 4)), e.push(n), Ee.concatUint8Array(e);
  }
  writeForHash(e) {
    const n = this.writePublicKey(), r = 149 + e, s = e >= 5 ? 4 : 2;
    return Ee.concatUint8Array([new Uint8Array([r]), Ee.writeNumber(n.length, s), n]);
  }
  isDecrypted() {
    return null;
  }
  getCreationTime() {
    return this.created;
  }
  getKeyID() {
    return this.keyID;
  }
  async computeFingerprintAndKeyID() {
    if (await this.computeFingerprint(), this.keyID = new mo(), this.version >= 5) this.keyID.read(this.fingerprint.subarray(0, 8));
    else {
      if (this.version !== 4) throw Error("Unsupported key version");
      this.keyID.read(this.fingerprint.subarray(12, 20));
    }
  }
  async computeFingerprint() {
    const e = this.writeForHash(this.version);
    if (this.version >= 5) this.fingerprint = await _o(ee.hash.sha256, e);
    else {
      if (this.version !== 4) throw Error("Unsupported key version");
      this.fingerprint = await _o(ee.hash.sha1, e);
    }
  }
  getFingerprintBytes() {
    return this.fingerprint;
  }
  getFingerprint() {
    return Ee.uint8ArrayToHex(this.getFingerprintBytes());
  }
  hasSameFingerprintAs(e) {
    return this.version === e.version && Ee.equalsUint8Array(this.writePublicKey(), e.writePublicKey());
  }
  getAlgorithmInfo() {
    const e = {};
    e.algorithm = ee.read(ee.publicKey, this.algorithm);
    const n = this.publicParams.n || this.publicParams.p;
    return n ? e.bits = Ee.uint8ArrayBitLength(n) : this.publicParams.oid && (e.curve = this.publicParams.oid.getName()), e;
  }
}
lo.prototype.readPublicKey = lo.prototype.read, lo.prototype.writePublicKey = lo.prototype.write;
const lU = Ee.constructAllowedPackets([zu, Xh, aa, Ui]);
class uU {
  static get tag() {
    return ee.packet.symmetricallyEncryptedData;
  }
  constructor() {
    this.encrypted = null, this.packets = null;
  }
  read(e) {
    this.encrypted = e;
  }
  write() {
    return this.encrypted;
  }
  async decrypt(e, n, r = Qt) {
    if (!r.allowUnauthenticatedMessages) throw Error("Message is not authenticated.");
    const { blockSize: s } = mn(e), i = await Zn(i0(this.encrypted)), a = await pg(e, n, i.subarray(s + 2), i.subarray(2, s + 2));
    this.packets = await cn.fromBinary(a, lU, r);
  }
  async encrypt(e, n, r = Qt) {
    const s = this.packets.write(), { blockSize: i } = mn(e), a = await Tk(e), o = await kh(e, n, a, new Uint8Array(i)), f = await kh(e, n, s, o.subarray(2));
    this.encrypted = Ee.concat([o, f]);
  }
}
class bg extends lo {
  static get tag() {
    return ee.packet.publicSubkey;
  }
  constructor(e, n) {
    super(e, n);
  }
  static fromSecretSubkeyPacket(e) {
    const n = new bg(), { version: r, created: s, algorithm: i, publicParams: a, keyID: o, fingerprint: f } = e;
    return n.version = r, n.created = s, n.algorithm = i, n.publicParams = a, n.keyID = o, n.fingerprint = f, n;
  }
}
class sA {
  static get tag() {
    return ee.packet.userAttribute;
  }
  constructor() {
    this.attributes = [];
  }
  read(e) {
    let n = 0;
    for (; n < e.length; ) {
      const r = jC(e.subarray(n, e.length));
      n += r.offset, this.attributes.push(Ee.uint8ArrayToString(e.subarray(n, n + r.len))), n += r.len;
    }
  }
  write() {
    const e = [];
    for (let n = 0; n < this.attributes.length; n++) e.push(ig(this.attributes[n].length)), e.push(Ee.stringToUint8Array(this.attributes[n]));
    return Ee.concatUint8Array(e);
  }
  equals(e) {
    return !!(e && e instanceof sA) && this.attributes.every(function(n, r) {
      return n === e.attributes[r];
    });
  }
}
class aA extends lo {
  static get tag() {
    return ee.packet.secretKey;
  }
  constructor(e = /* @__PURE__ */ new Date(), n = Qt) {
    super(e, n), this.keyMaterial = null, this.isEncrypted = null, this.s2kUsage = 0, this.s2k = null, this.symmetric = null, this.aead = null, this.isLegacyAEAD = null, this.privateParams = null, this.usedModernAEAD = null;
  }
  async read(e, n = Qt) {
    let r = await this.readPublicKey(e, n);
    const s = r;
    this.s2kUsage = e[r++], this.version === 5 && r++, this.version === 6 && this.s2kUsage && r++;
    try {
      if (this.s2kUsage === 255 || this.s2kUsage === 254 || this.s2kUsage === 253) {
        this.symmetric = e[r++], this.s2kUsage === 253 && (this.aead = e[r++]), this.version === 6 && r++;
        const i = e[r++];
        if (this.s2k = u1(i), r += this.s2k.read(e.subarray(r, e.length)), this.s2k.type === "gnu-dummy") return;
      } else this.s2kUsage && (this.symmetric = this.s2kUsage);
      this.s2kUsage && (this.isLegacyAEAD = this.s2kUsage === 253 && (this.version === 5 || this.version === 4 && n.parseAEADEncryptedV4KeysAsLegacy), this.s2kUsage !== 253 || this.isLegacyAEAD ? (this.iv = e.subarray(r, r + mn(this.symmetric).blockSize), this.usedModernAEAD = false) : (this.iv = e.subarray(r, r + tf(this.aead).ivLength), this.usedModernAEAD = true), r += this.iv.length);
    } catch (i) {
      if (!this.s2kUsage) throw i;
      this.unparseableKeyMaterial = e.subarray(s), this.isEncrypted = true;
    }
    if (this.version === 5 && (r += 4), this.keyMaterial = e.subarray(r), this.isEncrypted = !!this.s2kUsage, !this.isEncrypted) {
      let i;
      if (this.version === 6) i = this.keyMaterial;
      else if (i = this.keyMaterial.subarray(0, -2), !Ee.equalsUint8Array(Ee.writeChecksum(i), this.keyMaterial.subarray(-2))) throw Error("Key checksum mismatch");
      try {
        const { read: a, privateParams: o } = _6(this.algorithm, i, this.publicParams);
        if (a < i.length) throw Error("Error reading MPIs");
        this.privateParams = o;
      } catch (a) {
        throw a instanceof fn ? a : Error("Error reading MPIs");
      }
    }
  }
  write() {
    const e = this.writePublicKey();
    if (this.unparseableKeyMaterial) return Ee.concatUint8Array([e, this.unparseableKeyMaterial]);
    const n = [e];
    n.push(new Uint8Array([this.s2kUsage]));
    const r = [];
    if (this.s2kUsage === 255 || this.s2kUsage === 254 || this.s2kUsage === 253) {
      r.push(this.symmetric), this.s2kUsage === 253 && r.push(this.aead);
      const s = this.s2k.write();
      this.version === 6 && r.push(s.length), r.push(...s);
    }
    return this.s2kUsage && this.s2k.type !== "gnu-dummy" && r.push(...this.iv), (this.version === 5 || this.version === 6 && this.s2kUsage) && n.push(new Uint8Array([r.length])), n.push(new Uint8Array(r)), this.isDummy() || (this.s2kUsage || (this.keyMaterial = bu(this.algorithm, this.privateParams)), this.version === 5 && n.push(Ee.writeNumber(this.keyMaterial.length, 4)), n.push(this.keyMaterial), this.s2kUsage || this.version === 6 || n.push(Ee.writeChecksum(this.keyMaterial))), Ee.concatUint8Array(n);
  }
  isDecrypted() {
    return this.isEncrypted === false;
  }
  isMissingSecretKeyMaterial() {
    return this.unparseableKeyMaterial !== void 0 || this.isDummy();
  }
  isDummy() {
    return !(!this.s2k || this.s2k.type !== "gnu-dummy");
  }
  makeDummy(e = Qt) {
    this.isDummy() || (this.isDecrypted() && this.clearPrivateParams(), delete this.unparseableKeyMaterial, this.isEncrypted = null, this.keyMaterial = null, this.s2k = u1(ee.s2k.gnu, e), this.s2k.algorithm = 0, this.s2k.c = 0, this.s2k.type = "gnu-dummy", this.s2kUsage = 254, this.symmetric = ee.symmetric.aes256, this.isLegacyAEAD = null, this.usedModernAEAD = null);
  }
  async encrypt(e, n = Qt) {
    if (this.isDummy()) return;
    if (!this.isDecrypted()) throw Error("Key packet is already encrypted");
    if (!e) throw Error("A non-empty passphrase is required for key encryption.");
    this.s2k = Rk(n), this.s2k.generateSalt();
    const r = bu(this.algorithm, this.privateParams);
    this.symmetric = ee.symmetric.aes256;
    const { blockSize: s } = mn(this.symmetric);
    if (n.aeadProtect) {
      this.s2kUsage = 253, this.aead = n.preferredAEADAlgorithm;
      const i = tf(this.aead);
      this.isLegacyAEAD = this.version === 5, this.usedModernAEAD = !this.isLegacyAEAD;
      const a = n1(this.constructor.tag), o = await qm(this.version, this.s2k, e, this.symmetric, this.aead, a, this.isLegacyAEAD), f = await i(this.symmetric, o);
      this.iv = this.isLegacyAEAD ? Ni(s) : Ni(i.ivLength);
      const c = this.isLegacyAEAD ? new Uint8Array() : Ee.concatUint8Array([a, this.writePublicKey()]);
      this.keyMaterial = await f.encrypt(r, this.iv.subarray(0, i.ivLength), c);
    } else {
      this.s2kUsage = 254, this.usedModernAEAD = false;
      const i = await qm(this.version, this.s2k, e, this.symmetric);
      this.iv = Ni(s), this.keyMaterial = await kh(this.symmetric, i, Ee.concatUint8Array([r, await _o(ee.hash.sha1, r)]), this.iv);
    }
  }
  async decrypt(e) {
    if (this.isDummy()) return false;
    if (this.unparseableKeyMaterial) throw Error("Key packet cannot be decrypted: unsupported S2K or cipher algo");
    if (this.isDecrypted()) throw Error("Key packet is already decrypted.");
    let n;
    const r = n1(this.constructor.tag);
    if (this.s2kUsage !== 254 && this.s2kUsage !== 253) throw this.s2kUsage === 255 ? Error("Encrypted private key is authenticated using an insecure two-byte hash") : Error("Private key is encrypted using an insecure S2K function: unsalted MD5");
    let s;
    if (n = await qm(this.version, this.s2k, e, this.symmetric, this.aead, r, this.isLegacyAEAD), this.s2kUsage === 253) {
      const i = tf(this.aead, true), a = await i(this.symmetric, n);
      try {
        const o = this.isLegacyAEAD ? new Uint8Array() : Ee.concatUint8Array([r, this.writePublicKey()]);
        s = await a.decrypt(this.keyMaterial, this.iv.subarray(0, i.ivLength), o);
      } catch (o) {
        throw o.message === "Authentication tag mismatch" ? Error("Incorrect key passphrase: " + o.message) : o;
      }
    } else {
      const i = await pg(this.symmetric, n, this.keyMaterial, this.iv);
      s = i.subarray(0, -20);
      const a = await _o(ee.hash.sha1, s);
      if (!Ee.equalsUint8Array(a, i.subarray(-20))) throw Error("Incorrect key passphrase");
    }
    try {
      const { privateParams: i } = _6(this.algorithm, s, this.publicParams);
      this.privateParams = i;
    } catch {
      throw Error("Error reading MPIs");
    }
    this.isEncrypted = false, this.keyMaterial = null, this.s2kUsage = 0, this.aead = null, this.symmetric = null, this.isLegacyAEAD = null;
  }
  async validate() {
    if (this.isDummy()) return;
    if (!this.isDecrypted()) throw Error("Key is not decrypted");
    if (this.usedModernAEAD) return;
    let e;
    try {
      e = await MN(this.algorithm, this.publicParams, this.privateParams);
    } catch {
      e = false;
    }
    if (!e) throw Error("Key is invalid");
  }
  async generate(e, n) {
    if (this.version === 6 && (this.algorithm === ee.publicKey.ecdh && n === ee.curve.curve25519Legacy || this.algorithm === ee.publicKey.eddsaLegacy)) throw Error(`Cannot generate v6 keys of type 'ecc' with curve ${n}. Generate a key of type 'curve25519' instead`);
    const { privateParams: r, publicParams: s } = await SN(this.algorithm, e, n);
    this.privateParams = r, this.publicParams = s, this.isEncrypted = false;
  }
  clearPrivateParams() {
    this.isMissingSecretKeyMaterial() || (Object.keys(this.privateParams).forEach((e) => {
      this.privateParams[e].fill(0), delete this.privateParams[e];
    }), this.privateParams = null, this.isEncrypted = true);
  }
}
async function qm(t3, e, n, r, s, i, a) {
  if (e.type === "argon2" && !s) throw Error("Using Argon2 S2K without AEAD is not allowed");
  if (e.type === "simple" && t3 === 6) throw Error("Using Simple S2K with version 6 keys is not allowed");
  const { keySize: o } = mn(r), f = await e.produceKey(n, o);
  if (!s || t3 === 5 || a) return f;
  const c = Ee.concatUint8Array([i, new Uint8Array([t3, r, s])]);
  return il(ee.hash.sha256, f, new Uint8Array(), c, o);
}
class Ag {
  static get tag() {
    return ee.packet.userID;
  }
  constructor() {
    this.userID = "", this.name = "", this.email = "", this.comment = "";
  }
  static fromObject(e) {
    if (Ee.isString(e) || e.name && !Ee.isString(e.name) || e.email && !Ee.isEmailAddress(e.email) || e.comment && !Ee.isString(e.comment)) throw Error("Invalid user ID format");
    const n = new Ag();
    Object.assign(n, e);
    const r = [];
    return n.name && r.push(n.name), n.comment && r.push(`(${n.comment})`), n.email && r.push(`<${n.email}>`), n.userID = r.join(" "), n;
  }
  read(e, n = Qt) {
    const r = Ee.decodeUTF8(e);
    if (r.length > n.maxUserIDLength) throw Error("User ID string is too long");
    const s = (o) => /^[^\s@]+@[^\s@]+$/.test(o), i = r.indexOf("<"), a = r.lastIndexOf(">");
    if (i !== -1 && a !== -1 && a > i) {
      const o = r.substring(i + 1, a);
      if (s(o)) {
        this.email = o;
        const f = r.substring(0, i).trim(), c = f.indexOf("("), l = f.lastIndexOf(")");
        c !== -1 && l !== -1 && l > c ? (this.comment = f.substring(c + 1, l).trim(), this.name = f.substring(0, c).trim()) : (this.name = f, this.comment = "");
      }
    } else s(r.trim()) && (this.email = r.trim(), this.name = "", this.comment = "");
    this.userID = r;
  }
  write() {
    return Ee.encodeUTF8(this.userID);
  }
  equals(e) {
    return e && e.userID === this.userID;
  }
}
class Qk extends aA {
  static get tag() {
    return ee.packet.secretSubkey;
  }
  constructor(e = /* @__PURE__ */ new Date(), n = Qt) {
    super(e, n);
  }
}
class Kk {
  constructor(e) {
    this.packets = e || new cn();
  }
  write() {
    return this.packets.write();
  }
  armor(e = Qt) {
    const n = this.packets.some((r) => r.constructor.tag === Ui.tag && r.version !== 6);
    return Jh(ee.armor.signature, this.write(), void 0, void 0, void 0, n, e);
  }
  getSigningKeyIDs() {
    return this.packets.map((e) => e.issuerKeyID);
  }
}
async function Hk(t3, e) {
  const n = new Qk(t3.date, e);
  return n.packets = null, n.algorithm = ee.write(ee.publicKey, t3.algorithm), await n.generate(t3.rsaBits, t3.curve), await n.computeFingerprintAndKeyID(), n;
}
async function cU(t3, e) {
  const n = new aA(t3.date, e);
  return n.packets = null, n.algorithm = ee.write(ee.publicKey, t3.algorithm), await n.generate(t3.rsaBits, t3.curve, t3.config), await n.computeFingerprintAndKeyID(), n;
}
async function Ea(t3, e, n, r, s = /* @__PURE__ */ new Date(), i) {
  let a, o;
  for (let f = t3.length - 1; f >= 0; f--) try {
    (!a || t3[f].created >= a.created) && (await t3[f].verify(e, n, r, s, void 0, i), a = t3[f]);
  } catch (c) {
    o = c;
  }
  if (!a) throw Ee.wrapError(`Could not find valid ${ee.read(ee.signature, n)} signature in key ${e.getKeyID().toHex()}`.replace("certGeneric ", "self-").replace(/([a-z])([A-Z])/g, (f, c, l) => c + " " + l.toLowerCase()), o);
  return a;
}
function n3(t3, e, n = /* @__PURE__ */ new Date()) {
  const r = Ee.normalizeDate(n);
  if (r !== null) {
    const s = p1(t3, e);
    return !(t3.created <= r && r < s);
  }
  return false;
}
async function qk(t3, e, n, r) {
  const s = {};
  s.key = e, s.bind = t3;
  const i = { signatureType: ee.signature.subkeyBinding };
  return n.sign ? (i.keyFlags = [ee.keyFlags.signData], i.embeddedSignature = await vo(s, [], t3, { signatureType: ee.signature.keyBinding }, n.date, void 0, void 0, void 0, r)) : i.keyFlags = [ee.keyFlags.encryptCommunication | ee.keyFlags.encryptStorage], n.keyExpirationTime > 0 && (i.keyExpirationTime = n.keyExpirationTime, i.keyNeverExpires = false), await vo(s, [], e, i, n.date, void 0, void 0, void 0, r);
}
async function hU(t3, e, n = /* @__PURE__ */ new Date(), r = [], s) {
  const i = ee.hash.sha256, a = s.preferredHashAlgorithm, o = await Promise.all(t3.map(async (h, m) => (await h.getPrimarySelfSignature(n, r[m], s)).preferredHashAlgorithms || [])), f = /* @__PURE__ */ new Map();
  for (const h of o) for (const m of h) try {
    const v = ee.write(ee.hash, m);
    f.set(v, f.has(v) ? f.get(v) + 1 : 1);
  } catch {
  }
  const c = (h) => t3.length === 0 || f.get(h) === t3.length || h === i, l = () => {
    if (f.size === 0) return i;
    const h = Array.from(f.keys()).filter((m) => c(m)).sort((m, v) => li(m) - li(v))[0];
    return li(h) >= li(i) ? h : i;
  };
  if ((/* @__PURE__ */ new Set([ee.publicKey.ecdsa, ee.publicKey.eddsaLegacy, ee.publicKey.ed25519, ee.publicKey.ed448])).has(e.algorithm)) {
    const h = function(b, A) {
      switch (b) {
        case ee.publicKey.ecdsa:
        case ee.publicKey.eddsaLegacy:
          return yk(A);
        case ee.publicKey.ed25519:
        case ee.publicKey.ed448:
          return ag(b);
        default:
          throw Error("Unknown elliptic signing algo");
      }
    }(e.algorithm, e.publicParams.oid), m = c(a), v = li(a) >= li(h);
    if (m && v) return a;
    {
      const b = l();
      return li(b) >= li(h) ? b : h;
    }
  }
  return c(a) ? a : l();
}
async function vo(t3, e, n, r, s, i, a = [], o = false, f) {
  if (n.isDummy()) throw Error("Cannot sign with a gnu-dummy key.");
  if (!n.isDecrypted()) throw Error("Signing key is not decrypted.");
  const c = new Ui();
  return Object.assign(c, r), c.publicKeyAlgorithm = n.algorithm, c.hashAlgorithm = await hU(e, n, s, i, f), c.rawNotations = [...a], await c.sign(n, t3, s, o, f), c;
}
async function Zl(t3, e, n, r = /* @__PURE__ */ new Date(), s) {
  (t3 = t3[n]) && (e[n].length ? await Promise.all(t3.map(async function(i) {
    i.isExpired(r) || s && !await s(i) || e[n].some(function(a) {
      return Ee.equalsUint8Array(a.writeParams(), i.writeParams());
    }) || e[n].push(i);
  })) : e[n] = t3);
}
async function xu(t3, e, n, r, s, i, a = /* @__PURE__ */ new Date(), o) {
  i = i || t3;
  const f = [];
  return await Promise.all(r.map(async function(c) {
    try {
      if (!s || c.issuerKeyID.equals(s.issuerKeyID)) {
        const l = ![ee.reasonForRevocation.keyRetired, ee.reasonForRevocation.keySuperseded, ee.reasonForRevocation.userIDInvalid].includes(c.reasonForRevocationFlag);
        await c.verify(i, e, n, l ? null : a, false, o), f.push(c.issuerKeyID);
      }
    } catch {
    }
  })), s ? (s.revoked = !!f.some((c) => c.equals(s.issuerKeyID)) || s.revoked || false, s.revoked) : f.length > 0;
}
function p1(t3, e) {
  let n;
  return e.keyNeverExpires === false && (n = t3.created.getTime() + 1e3 * e.keyExpirationTime), n ? new Date(n) : 1 / 0;
}
function i3(t3, e = {}) {
  switch (t3.type = t3.type || e.type, t3.curve = t3.curve || e.curve, t3.rsaBits = t3.rsaBits || e.rsaBits, t3.keyExpirationTime = t3.keyExpirationTime !== void 0 ? t3.keyExpirationTime : e.keyExpirationTime, t3.passphrase = Ee.isString(t3.passphrase) ? t3.passphrase : e.passphrase, t3.date = t3.date || e.date, t3.sign = t3.sign || false, t3.type) {
    case "ecc":
      try {
        t3.curve = ee.write(ee.curve, t3.curve);
      } catch {
        throw Error("Unknown curve");
      }
      t3.curve !== ee.curve.ed25519Legacy && t3.curve !== ee.curve.curve25519Legacy && t3.curve !== "ed25519" && t3.curve !== "curve25519" || (t3.curve = t3.sign ? ee.curve.ed25519Legacy : ee.curve.curve25519Legacy), t3.sign ? t3.algorithm = t3.curve === ee.curve.ed25519Legacy ? ee.publicKey.eddsaLegacy : ee.publicKey.ecdsa : t3.algorithm = ee.publicKey.ecdh;
      break;
    case "curve25519":
      t3.algorithm = t3.sign ? ee.publicKey.ed25519 : ee.publicKey.x25519;
      break;
    case "curve448":
      t3.algorithm = t3.sign ? ee.publicKey.ed448 : ee.publicKey.x448;
      break;
    case "rsa":
      t3.algorithm = ee.publicKey.rsaEncryptSign;
      break;
    default:
      throw Error("Unsupported key type " + t3.type);
  }
  return t3;
}
function O6(t3, e, n) {
  switch (t3.algorithm) {
    case ee.publicKey.rsaEncryptSign:
    case ee.publicKey.rsaSign:
    case ee.publicKey.dsa:
    case ee.publicKey.ecdsa:
    case ee.publicKey.eddsaLegacy:
    case ee.publicKey.ed25519:
    case ee.publicKey.ed448:
      if (!e.keyFlags && !n.allowMissingKeyFlags) throw Error("None of the key flags is set: consider passing `config.allowMissingKeyFlags`");
      return !e.keyFlags || !!(e.keyFlags[0] & ee.keyFlags.signData);
    default:
      return false;
  }
}
function Q6(t3, e, n) {
  switch (t3.algorithm) {
    case ee.publicKey.rsaEncryptSign:
    case ee.publicKey.rsaEncrypt:
    case ee.publicKey.elgamal:
    case ee.publicKey.ecdh:
    case ee.publicKey.x25519:
    case ee.publicKey.x448:
      if (!e.keyFlags && !n.allowMissingKeyFlags) throw Error("None of the key flags is set: consider passing `config.allowMissingKeyFlags`");
      return !e.keyFlags || !!(e.keyFlags[0] & ee.keyFlags.encryptCommunication) || !!(e.keyFlags[0] & ee.keyFlags.encryptStorage);
    default:
      return false;
  }
}
function K6(t3, e, n) {
  if (!e.keyFlags && !n.allowMissingKeyFlags) throw Error("None of the key flags is set: consider passing `config.allowMissingKeyFlags`");
  switch (t3.algorithm) {
    case ee.publicKey.rsaEncryptSign:
    case ee.publicKey.rsaEncrypt:
    case ee.publicKey.elgamal:
    case ee.publicKey.ecdh:
    case ee.publicKey.x25519:
    case ee.publicKey.x448:
      return !(!(!e.keyFlags || e.keyFlags[0] & ee.keyFlags.signData) || !n.allowInsecureDecryptionWithSigningKeys) || !e.keyFlags || !!(e.keyFlags[0] & ee.keyFlags.encryptCommunication) || !!(e.keyFlags[0] & ee.keyFlags.encryptStorage);
    default:
      return false;
  }
}
function Lf(t3, e) {
  const n = ee.write(ee.publicKey, t3.algorithm), r = t3.getAlgorithmInfo();
  if (e.rejectPublicKeyAlgorithms.has(n)) throw Error(r.algorithm + " keys are considered too weak.");
  switch (n) {
    case ee.publicKey.rsaEncryptSign:
    case ee.publicKey.rsaSign:
    case ee.publicKey.rsaEncrypt:
      if (r.bits < e.minRSABits) throw Error(`RSA keys shorter than ${e.minRSABits} bits are considered too weak.`);
      break;
    case ee.publicKey.ecdsa:
    case ee.publicKey.eddsaLegacy:
    case ee.publicKey.ecdh:
      if (e.rejectCurves.has(r.curve)) throw Error(`Support for ${r.algorithm} keys using curve ${r.curve} is disabled.`);
  }
}
class ah {
  constructor(e, n) {
    this.userID = e.constructor.tag === ee.packet.userID ? e : null, this.userAttribute = e.constructor.tag === ee.packet.userAttribute ? e : null, this.selfCertifications = [], this.otherCertifications = [], this.revocationSignatures = [], this.mainKey = n;
  }
  toPacketList() {
    const e = new cn();
    return e.push(this.userID || this.userAttribute), e.push(...this.revocationSignatures), e.push(...this.selfCertifications), e.push(...this.otherCertifications), e;
  }
  clone() {
    const e = new ah(this.userID || this.userAttribute, this.mainKey);
    return e.selfCertifications = [...this.selfCertifications], e.otherCertifications = [...this.otherCertifications], e.revocationSignatures = [...this.revocationSignatures], e;
  }
  async certify(e, n, r) {
    const s = this.mainKey.keyPacket, i = { userID: this.userID, userAttribute: this.userAttribute, key: s }, a = new ah(i.userID || i.userAttribute, this.mainKey);
    return a.otherCertifications = await Promise.all(e.map(async function(o) {
      if (!o.isPrivate()) throw Error("Need private key for signing");
      if (o.hasSameFingerprintAs(s)) throw Error("The user's own key can only be used for self-certifications");
      const f = await o.getSigningKey(void 0, n, void 0, r);
      return vo(i, [o], f.keyPacket, { signatureType: ee.signature.certGeneric, keyFlags: [ee.keyFlags.certifyKeys | ee.keyFlags.signData] }, n, void 0, void 0, void 0, r);
    })), await a.update(this, n, r), a;
  }
  async isRevoked(e, n, r = /* @__PURE__ */ new Date(), s = Qt) {
    const i = this.mainKey.keyPacket;
    return xu(i, ee.signature.certRevocation, { key: i, userID: this.userID, userAttribute: this.userAttribute }, this.revocationSignatures, e, n, r, s);
  }
  async verifyCertificate(e, n, r = /* @__PURE__ */ new Date(), s) {
    const i = this, a = this.mainKey.keyPacket, o = { userID: this.userID, userAttribute: this.userAttribute, key: a }, { issuerKeyID: f } = e, c = n.filter((l) => l.getKeys(f).length > 0);
    return c.length === 0 ? null : (await Promise.all(c.map(async (l) => {
      const h = await l.getSigningKey(f, e.created, void 0, s);
      if (e.revoked || await i.isRevoked(e, h.keyPacket, r, s)) throw Error("User certificate is revoked");
      try {
        await e.verify(h.keyPacket, ee.signature.certGeneric, o, r, void 0, s);
      } catch (m) {
        throw Ee.wrapError("User certificate is invalid", m);
      }
    })), true);
  }
  async verifyAllCertifications(e, n = /* @__PURE__ */ new Date(), r) {
    const s = this, i = this.selfCertifications.concat(this.otherCertifications);
    return Promise.all(i.map(async (a) => ({ keyID: a.issuerKeyID, valid: await s.verifyCertificate(a, e, n, r).catch(() => false) })));
  }
  async verify(e = /* @__PURE__ */ new Date(), n) {
    if (!this.selfCertifications.length) throw Error("No self-certifications found");
    const r = this, s = this.mainKey.keyPacket, i = { userID: this.userID, userAttribute: this.userAttribute, key: s };
    let a;
    for (let o = this.selfCertifications.length - 1; o >= 0; o--) try {
      const f = this.selfCertifications[o];
      if (f.revoked || await r.isRevoked(f, void 0, e, n)) throw Error("Self-certification is revoked");
      try {
        await f.verify(s, ee.signature.certGeneric, i, e, void 0, n);
      } catch (c) {
        throw Ee.wrapError("Self-certification is invalid", c);
      }
      return true;
    } catch (f) {
      a = f;
    }
    throw a;
  }
  async update(e, n, r) {
    const s = this.mainKey.keyPacket, i = { userID: this.userID, userAttribute: this.userAttribute, key: s };
    await Zl(e, this, "selfCertifications", n, async function(a) {
      try {
        return await a.verify(s, ee.signature.certGeneric, i, n, false, r), true;
      } catch {
        return false;
      }
    }), await Zl(e, this, "otherCertifications", n), await Zl(e, this, "revocationSignatures", n, function(a) {
      return xu(s, ee.signature.certRevocation, i, [a], void 0, void 0, n, r);
    });
  }
  async revoke(e, { flag: n = ee.reasonForRevocation.noReason, string: r = "" } = {}, s = /* @__PURE__ */ new Date(), i = Qt) {
    const a = { userID: this.userID, userAttribute: this.userAttribute, key: e }, o = new ah(a.userID || a.userAttribute, this.mainKey);
    return o.revocationSignatures.push(await vo(a, [], e, { signatureType: ee.signature.certRevocation, reasonForRevocationFlag: ee.write(ee.reasonForRevocation, n), reasonForRevocationString: r }, s, void 0, void 0, false, i)), await o.update(this), o;
  }
}
class _u {
  constructor(e, n) {
    this.keyPacket = e, this.bindingSignatures = [], this.revocationSignatures = [], this.mainKey = n;
  }
  toPacketList() {
    const e = new cn();
    return e.push(this.keyPacket), e.push(...this.revocationSignatures), e.push(...this.bindingSignatures), e;
  }
  clone() {
    const e = new _u(this.keyPacket, this.mainKey);
    return e.bindingSignatures = [...this.bindingSignatures], e.revocationSignatures = [...this.revocationSignatures], e;
  }
  async isRevoked(e, n, r = /* @__PURE__ */ new Date(), s = Qt) {
    const i = this.mainKey.keyPacket;
    return xu(i, ee.signature.subkeyRevocation, { key: i, bind: this.keyPacket }, this.revocationSignatures, e, n, r, s);
  }
  async verify(e = /* @__PURE__ */ new Date(), n = Qt) {
    const r = this.mainKey.keyPacket, s = { key: r, bind: this.keyPacket }, i = await Ea(this.bindingSignatures, r, ee.signature.subkeyBinding, s, e, n);
    if (i.revoked || await this.isRevoked(i, null, e, n)) throw Error("Subkey is revoked");
    if (n3(this.keyPacket, i, e)) throw Error("Subkey is expired");
    return i;
  }
  async getExpirationTime(e = /* @__PURE__ */ new Date(), n = Qt) {
    const r = this.mainKey.keyPacket, s = { key: r, bind: this.keyPacket };
    let i;
    try {
      i = await Ea(this.bindingSignatures, r, ee.signature.subkeyBinding, s, e, n);
    } catch {
      return null;
    }
    const a = p1(this.keyPacket, i), o = i.getExpirationTime();
    return a < o ? a : o;
  }
  async update(e, n = /* @__PURE__ */ new Date(), r = Qt) {
    const s = this.mainKey.keyPacket;
    if (!this.hasSameFingerprintAs(e)) throw Error("Subkey update method: fingerprints of subkeys not equal");
    this.keyPacket.constructor.tag === ee.packet.publicSubkey && e.keyPacket.constructor.tag === ee.packet.secretSubkey && (this.keyPacket = e.keyPacket);
    const i = this, a = { key: s, bind: i.keyPacket };
    await Zl(e, this, "bindingSignatures", n, async function(o) {
      for (let f = 0; f < i.bindingSignatures.length; f++) if (i.bindingSignatures[f].issuerKeyID.equals(o.issuerKeyID)) return o.created > i.bindingSignatures[f].created && (i.bindingSignatures[f] = o), false;
      try {
        return await o.verify(s, ee.signature.subkeyBinding, a, n, void 0, r), true;
      } catch {
        return false;
      }
    }), await Zl(e, this, "revocationSignatures", n, function(o) {
      return xu(s, ee.signature.subkeyRevocation, a, [o], void 0, void 0, n, r);
    });
  }
  async revoke(e, { flag: n = ee.reasonForRevocation.noReason, string: r = "" } = {}, s = /* @__PURE__ */ new Date(), i = Qt) {
    const a = { key: e, bind: this.keyPacket }, o = new _u(this.keyPacket, this.mainKey);
    return o.revocationSignatures.push(await vo(a, [], e, { signatureType: ee.signature.subkeyRevocation, reasonForRevocationFlag: ee.write(ee.reasonForRevocation, n), reasonForRevocationString: r }, s, void 0, void 0, false, i)), await o.update(this), o;
  }
  hasSameFingerprintAs(e) {
    return this.keyPacket.hasSameFingerprintAs(e.keyPacket || e);
  }
}
["getKeyID", "getFingerprint", "getAlgorithmInfo", "getCreationTime", "isDecrypted"].forEach((t3) => {
  _u.prototype[t3] = function() {
    return this.keyPacket[t3]();
  };
});
const dU = Ee.constructAllowedPackets([Ui]), H6 = /* @__PURE__ */ new Set([ee.packet.publicKey, ee.packet.privateKey]), q6 = /* @__PURE__ */ new Set([ee.packet.publicKey, ee.packet.privateKey, ee.packet.publicSubkey, ee.packet.privateSubkey]);
class zk {
  packetListToStructure(e, n = /* @__PURE__ */ new Set()) {
    let r, s, i, a;
    for (const o of e) {
      if (o instanceof Ly) {
        q6.has(o.tag) && !a && (a = H6.has(o.tag) ? H6 : q6);
        continue;
      }
      const f = o.constructor.tag;
      if (a) {
        if (!a.has(f)) continue;
        a = null;
      }
      if (n.has(f)) throw Error("Unexpected packet type: " + f);
      switch (f) {
        case ee.packet.publicKey:
        case ee.packet.secretKey:
          if (this.keyPacket) throw Error("Key block contains multiple keys");
          if (this.keyPacket = o, s = this.getKeyID(), !s) throw Error("Missing Key ID");
          break;
        case ee.packet.userID:
        case ee.packet.userAttribute:
          r = new ah(o, this), this.users.push(r);
          break;
        case ee.packet.publicSubkey:
        case ee.packet.secretSubkey:
          r = null, i = new _u(o, this), this.subkeys.push(i);
          break;
        case ee.packet.signature:
          switch (o.signatureType) {
            case ee.signature.certGeneric:
            case ee.signature.certPersona:
            case ee.signature.certCasual:
            case ee.signature.certPositive:
              if (!r) {
                Ee.printDebug("Dropping certification signatures without preceding user packet");
                continue;
              }
              o.issuerKeyID.equals(s) ? r.selfCertifications.push(o) : r.otherCertifications.push(o);
              break;
            case ee.signature.certRevocation:
              r ? r.revocationSignatures.push(o) : this.directSignatures.push(o);
              break;
            case ee.signature.key:
              this.directSignatures.push(o);
              break;
            case ee.signature.subkeyBinding:
              if (!i) {
                Ee.printDebug("Dropping subkey binding signature without preceding subkey packet");
                continue;
              }
              i.bindingSignatures.push(o);
              break;
            case ee.signature.keyRevocation:
              this.revocationSignatures.push(o);
              break;
            case ee.signature.subkeyRevocation:
              if (!i) {
                Ee.printDebug("Dropping subkey revocation signature without preceding subkey packet");
                continue;
              }
              i.revocationSignatures.push(o);
          }
      }
    }
  }
  toPacketList() {
    const e = new cn();
    return e.push(this.keyPacket), e.push(...this.revocationSignatures), e.push(...this.directSignatures), this.users.map((n) => e.push(...n.toPacketList())), this.subkeys.map((n) => e.push(...n.toPacketList())), e;
  }
  clone(e = false) {
    const n = new this.constructor(this.toPacketList());
    return e && n.getKeys().forEach((r) => {
      if (r.keyPacket = Object.create(Object.getPrototypeOf(r.keyPacket), Object.getOwnPropertyDescriptors(r.keyPacket)), !r.keyPacket.isDecrypted()) return;
      const s = {};
      Object.keys(r.keyPacket.privateParams).forEach((i) => {
        s[i] = new Uint8Array(r.keyPacket.privateParams[i]);
      }), r.keyPacket.privateParams = s;
    }), n;
  }
  getSubkeys(e = null) {
    return this.subkeys.filter((n) => !e || n.getKeyID().equals(e, true));
  }
  getKeys(e = null) {
    const n = [];
    return e && !this.getKeyID().equals(e, true) || n.push(this), n.concat(this.getSubkeys(e));
  }
  getKeyIDs() {
    return this.getKeys().map((e) => e.getKeyID());
  }
  getUserIDs() {
    return this.users.map((e) => e.userID ? e.userID.userID : null).filter((e) => e !== null);
  }
  write() {
    return this.toPacketList().write();
  }
  async getSigningKey(e = null, n = /* @__PURE__ */ new Date(), r = {}, s = Qt) {
    await this.verifyPrimaryKey(n, r, s);
    const i = this.keyPacket;
    try {
      Lf(i, s);
    } catch (f) {
      throw Ee.wrapError("Could not verify primary key", f);
    }
    const a = this.subkeys.slice().sort((f, c) => c.keyPacket.created - f.keyPacket.created || c.keyPacket.algorithm - f.keyPacket.algorithm);
    let o;
    for (const f of a) if (!e || f.getKeyID().equals(e)) try {
      await f.verify(n, s);
      const c = { key: i, bind: f.keyPacket }, l = await Ea(f.bindingSignatures, i, ee.signature.subkeyBinding, c, n, s);
      if (!O6(f.keyPacket, l, s)) continue;
      if (!l.embeddedSignature) throw Error("Missing embedded signature");
      return await Ea([l.embeddedSignature], f.keyPacket, ee.signature.keyBinding, c, n, s), Lf(f.keyPacket, s), f;
    } catch (c) {
      o = c;
    }
    try {
      const f = await this.getPrimarySelfSignature(n, r, s);
      if ((!e || i.getKeyID().equals(e)) && O6(i, f, s)) return Lf(i, s), this;
    } catch (f) {
      o = f;
    }
    throw Ee.wrapError("Could not find valid signing key packet in key " + this.getKeyID().toHex(), o);
  }
  async getEncryptionKey(e, n = /* @__PURE__ */ new Date(), r = {}, s = Qt) {
    await this.verifyPrimaryKey(n, r, s);
    const i = this.keyPacket;
    try {
      Lf(i, s);
    } catch (f) {
      throw Ee.wrapError("Could not verify primary key", f);
    }
    const a = this.subkeys.slice().sort((f, c) => c.keyPacket.created - f.keyPacket.created || c.keyPacket.algorithm - f.keyPacket.algorithm);
    let o;
    for (const f of a) if (!e || f.getKeyID().equals(e)) try {
      await f.verify(n, s);
      const c = { key: i, bind: f.keyPacket }, l = await Ea(f.bindingSignatures, i, ee.signature.subkeyBinding, c, n, s);
      if (Q6(f.keyPacket, l, s)) return Lf(f.keyPacket, s), f;
    } catch (c) {
      o = c;
    }
    try {
      const f = await this.getPrimarySelfSignature(n, r, s);
      if ((!e || i.getKeyID().equals(e)) && Q6(i, f, s)) return Lf(i, s), this;
    } catch (f) {
      o = f;
    }
    throw Ee.wrapError("Could not find valid encryption key packet in key " + this.getKeyID().toHex(), o);
  }
  async isRevoked(e, n, r = /* @__PURE__ */ new Date(), s = Qt) {
    return xu(this.keyPacket, ee.signature.keyRevocation, { key: this.keyPacket }, this.revocationSignatures, e, n, r, s);
  }
  async verifyPrimaryKey(e = /* @__PURE__ */ new Date(), n = {}, r = Qt) {
    const s = this.keyPacket;
    if (await this.isRevoked(null, null, e, r)) throw Error("Primary key is revoked");
    if (n3(s, await this.getPrimarySelfSignature(e, n, r), e)) throw Error("Primary key is expired");
    if (s.version !== 6) {
      const i = await Ea(this.directSignatures, s, ee.signature.key, { key: s }, e, r).catch(() => {
      });
      if (i && n3(s, i, e)) throw Error("Primary key is expired");
    }
  }
  async getExpirationTime(e, n = Qt) {
    let r;
    try {
      const s = await this.getPrimarySelfSignature(null, e, n), i = p1(this.keyPacket, s), a = s.getExpirationTime(), o = this.keyPacket.version !== 6 && await Ea(this.directSignatures, this.keyPacket, ee.signature.key, { key: this.keyPacket }, null, n).catch(() => {
      });
      if (o) {
        const f = p1(this.keyPacket, o);
        r = Math.min(i, a, f);
      } else r = i < a ? i : a;
    } catch {
      r = null;
    }
    return Ee.normalizeDate(r);
  }
  async getPrimarySelfSignature(e = /* @__PURE__ */ new Date(), n = {}, r = Qt) {
    const s = this.keyPacket;
    if (s.version === 6) return Ea(this.directSignatures, s, ee.signature.key, { key: s }, e, r);
    const { selfCertification: i } = await this.getPrimaryUser(e, n, r);
    return i;
  }
  async getPrimaryUser(e = /* @__PURE__ */ new Date(), n = {}, r = Qt) {
    const s = this.keyPacket, i = [];
    let a;
    for (let l = 0; l < this.users.length; l++) try {
      const h = this.users[l];
      if (!h.userID) continue;
      if (n.name !== void 0 && h.userID.name !== n.name || n.email !== void 0 && h.userID.email !== n.email || n.comment !== void 0 && h.userID.comment !== n.comment) throw Error("Could not find user that matches that user ID");
      const m = { userID: h.userID, key: s }, v = await Ea(h.selfCertifications, s, ee.signature.certGeneric, m, e, r);
      i.push({ index: l, user: h, selfCertification: v });
    } catch (h) {
      a = h;
    }
    if (!i.length) throw a || Error("Could not find primary user");
    await Promise.all(i.map(async (l) => {
      l.selfCertification.revoked || await l.user.isRevoked(l.selfCertification, null, e, r);
    }));
    const o = i.sort(function(l, h) {
      const m = l.selfCertification, v = h.selfCertification;
      return v.revoked - m.revoked || m.isPrimaryUserID - v.isPrimaryUserID || m.created - v.created;
    }).pop(), { user: f, selfCertification: c } = o;
    if (c.revoked || await f.isRevoked(c, null, e, r)) throw Error("Primary user is revoked");
    return o;
  }
  async update(e, n = /* @__PURE__ */ new Date(), r = Qt) {
    if (!this.hasSameFingerprintAs(e)) throw Error("Primary key fingerprints must be equal to update the key");
    if (!this.isPrivate() && e.isPrivate()) {
      if (!(this.subkeys.length === e.subkeys.length && this.subkeys.every((i) => e.subkeys.some((a) => i.hasSameFingerprintAs(a))))) throw Error("Cannot update public key with private key if subkeys mismatch");
      return e.update(this, r);
    }
    const s = this.clone();
    return await Zl(e, s, "revocationSignatures", n, (i) => xu(s.keyPacket, ee.signature.keyRevocation, s, [i], null, e.keyPacket, n, r)), await Zl(e, s, "directSignatures", n), await Promise.all(e.users.map(async (i) => {
      const a = s.users.filter((o) => i.userID && i.userID.equals(o.userID) || i.userAttribute && i.userAttribute.equals(o.userAttribute));
      if (a.length > 0) await Promise.all(a.map((o) => o.update(i, n, r)));
      else {
        const o = i.clone();
        o.mainKey = s, s.users.push(o);
      }
    })), await Promise.all(e.subkeys.map(async (i) => {
      const a = s.subkeys.filter((o) => o.hasSameFingerprintAs(i));
      if (a.length > 0) await Promise.all(a.map((o) => o.update(i, n, r)));
      else {
        const o = i.clone();
        o.mainKey = s, s.subkeys.push(o);
      }
    })), s;
  }
  async getRevocationCertificate(e = /* @__PURE__ */ new Date(), n = Qt) {
    const r = { key: this.keyPacket }, s = await Ea(this.revocationSignatures, this.keyPacket, ee.signature.keyRevocation, r, e, n), i = new cn();
    i.push(s);
    const a = this.keyPacket.version !== 6;
    return Jh(ee.armor.publicKey, i.write(), null, null, "This is a revocation certificate", a, n);
  }
  async applyRevocationCertificate(e, n = /* @__PURE__ */ new Date(), r = Qt) {
    const s = await Wh(e), i = (await cn.fromBinary(s.data, dU, r)).findPacket(ee.packet.signature);
    if (!i || i.signatureType !== ee.signature.keyRevocation) throw Error("Could not find revocation signature packet");
    if (!i.issuerKeyID.equals(this.getKeyID())) throw Error("Revocation signature does not match key");
    try {
      await i.verify(this.keyPacket, ee.signature.keyRevocation, { key: this.keyPacket }, n, void 0, r);
    } catch (o) {
      throw Ee.wrapError("Could not verify revocation signature", o);
    }
    const a = this.clone();
    return a.revocationSignatures.push(i), a;
  }
  async signPrimaryUser(e, n, r, s = Qt) {
    const { index: i, user: a } = await this.getPrimaryUser(n, r, s), o = await a.certify(e, n, s), f = this.clone();
    return f.users[i] = o, f;
  }
  async signAllUsers(e, n = /* @__PURE__ */ new Date(), r = Qt) {
    const s = this.clone();
    return s.users = await Promise.all(this.users.map(function(i) {
      return i.certify(e, n, r);
    })), s;
  }
  async verifyPrimaryUser(e, n = /* @__PURE__ */ new Date(), r, s = Qt) {
    const i = this.keyPacket, { user: a } = await this.getPrimaryUser(n, r, s);
    return e ? await a.verifyAllCertifications(e, n, s) : [{ keyID: i.getKeyID(), valid: await a.verify(n, s).catch(() => false) }];
  }
  async verifyAllUsers(e, n = /* @__PURE__ */ new Date(), r = Qt) {
    const s = this.keyPacket, i = [];
    return await Promise.all(this.users.map(async (a) => {
      const o = e ? await a.verifyAllCertifications(e, n, r) : [{ keyID: s.getKeyID(), valid: await a.verify(n, r).catch(() => false) }];
      i.push(...o.map((f) => ({ userID: a.userID ? a.userID.userID : null, userAttribute: a.userAttribute, keyID: f.keyID, valid: f.valid })));
    })), i;
  }
}
["getKeyID", "getFingerprint", "getAlgorithmInfo", "getCreationTime", "hasSameFingerprintAs"].forEach((t3) => {
  zk.prototype[t3] = _u.prototype[t3];
});
class s3 extends zk {
  constructor(e) {
    if (super(), this.keyPacket = null, this.revocationSignatures = [], this.directSignatures = [], this.users = [], this.subkeys = [], e && (this.packetListToStructure(e, /* @__PURE__ */ new Set([ee.packet.secretKey, ee.packet.secretSubkey])), !this.keyPacket)) throw Error("Invalid key: missing public-key packet");
  }
  isPrivate() {
    return false;
  }
  toPublic() {
    return this;
  }
  armor(e = Qt) {
    const n = this.keyPacket.version !== 6;
    return Jh(ee.armor.publicKey, this.toPacketList().write(), void 0, void 0, void 0, n, e);
  }
}
class ed extends s3 {
  constructor(e) {
    if (super(), this.packetListToStructure(e, /* @__PURE__ */ new Set([ee.packet.publicKey, ee.packet.publicSubkey])), !this.keyPacket) throw Error("Invalid key: missing private-key packet");
  }
  isPrivate() {
    return true;
  }
  toPublic() {
    const e = new cn(), n = this.toPacketList();
    for (const r of n) switch (r.constructor.tag) {
      case ee.packet.secretKey: {
        const s = lo.fromSecretKeyPacket(r);
        e.push(s);
        break;
      }
      case ee.packet.secretSubkey: {
        const s = bg.fromSecretSubkeyPacket(r);
        e.push(s);
        break;
      }
      default:
        e.push(r);
    }
    return new s3(e);
  }
  armor(e = Qt) {
    const n = this.keyPacket.version !== 6;
    return Jh(ee.armor.privateKey, this.toPacketList().write(), void 0, void 0, void 0, n, e);
  }
  async getDecryptionKeys(e, n = /* @__PURE__ */ new Date(), r = {}, s = Qt) {
    const i = this.keyPacket, a = [];
    let o = null;
    for (let c = 0; c < this.subkeys.length; c++) if (!e || this.subkeys[c].getKeyID().equals(e, true)) {
      if (this.subkeys[c].keyPacket.isDummy()) {
        o = o || Error("Gnu-dummy key packets cannot be used for decryption");
        continue;
      }
      try {
        const l = { key: i, bind: this.subkeys[c].keyPacket }, h = await Ea(this.subkeys[c].bindingSignatures, i, ee.signature.subkeyBinding, l, n, s);
        K6(this.subkeys[c].keyPacket, h, s) && a.push(this.subkeys[c]);
      } catch (l) {
        o = l;
      }
    }
    const f = await this.getPrimarySelfSignature(n, r, s);
    if (e && !i.getKeyID().equals(e, true) || !K6(i, f, s) || (i.isDummy() ? o = o || Error("Gnu-dummy key packets cannot be used for decryption") : a.push(this)), a.length === 0) throw o || Error("No decryption key packets found");
    return a;
  }
  isDecrypted() {
    return this.getKeys().some(({ keyPacket: e }) => e.isDecrypted());
  }
  async validate(e = Qt) {
    if (!this.isPrivate()) throw Error("Cannot validate a public key");
    let n;
    if (this.keyPacket.isDummy()) {
      const r = await this.getSigningKey(null, null, void 0, { ...e, rejectPublicKeyAlgorithms: /* @__PURE__ */ new Set(), minRSABits: 0 });
      r && !r.keyPacket.isDummy() && (n = r.keyPacket);
    } else n = this.keyPacket;
    if (n) return n.validate();
    {
      const r = this.getKeys();
      if (r.map((s) => s.keyPacket.isDummy()).every(Boolean)) throw Error("Cannot validate an all-gnu-dummy key");
      return Promise.all(r.map((s) => s.keyPacket.validate()));
    }
  }
  clearPrivateParams() {
    this.getKeys().forEach(({ keyPacket: e }) => {
      e.isDecrypted() && e.clearPrivateParams();
    });
  }
  async revoke({ flag: e = ee.reasonForRevocation.noReason, string: n = "" } = {}, r = /* @__PURE__ */ new Date(), s = Qt) {
    if (!this.isPrivate()) throw Error("Need private key for revoking");
    const i = { key: this.keyPacket }, a = this.clone();
    return a.revocationSignatures.push(await vo(i, [], this.keyPacket, { signatureType: ee.signature.keyRevocation, reasonForRevocationFlag: ee.write(ee.reasonForRevocation, e), reasonForRevocationString: n }, r, void 0, void 0, void 0, s)), a;
  }
  async addSubkey(e = {}) {
    const n = { ...Qt, ...e.config };
    if (e.passphrase) throw Error("Subkey could not be encrypted here, please encrypt whole key");
    if (e.rsaBits < n.minRSABits) throw Error(`rsaBits should be at least ${n.minRSABits}, got: ${e.rsaBits}`);
    const r = this.keyPacket;
    if (r.isDummy()) throw Error("Cannot add subkey to gnu-dummy primary key");
    if (!r.isDecrypted()) throw Error("Key is not decrypted");
    const s = r.getAlgorithmInfo();
    s.type = function(f) {
      switch (ee.write(ee.publicKey, f)) {
        case ee.publicKey.rsaEncrypt:
        case ee.publicKey.rsaEncryptSign:
        case ee.publicKey.rsaSign:
        case ee.publicKey.dsa:
          return "rsa";
        case ee.publicKey.ecdsa:
        case ee.publicKey.eddsaLegacy:
          return "ecc";
        case ee.publicKey.ed25519:
          return "curve25519";
        case ee.publicKey.ed448:
          return "curve448";
        default:
          throw Error("Unsupported algorithm");
      }
    }(s.algorithm), s.rsaBits = s.bits || 4096, s.curve = s.curve || "curve25519Legacy", e = i3(e, s);
    const i = await Hk(e, { ...n, v6Keys: this.keyPacket.version === 6 });
    Lf(i, n);
    const a = await qk(i, r, e, n), o = this.toPacketList();
    return o.push(i, a), new ed(o);
  }
}
const Gk = Ee.constructAllowedPackets([lo, bg, aA, Qk, Ag, sA, Ui]);
function pU(t3) {
  for (const e of t3) switch (e.constructor.tag) {
    case ee.packet.secretKey:
      return new ed(t3);
    case ee.packet.publicKey:
      return new s3(t3);
  }
  throw Error("No key packet found");
}
async function gU(t3, e, n, r) {
  n.passphrase && await t3.encrypt(n.passphrase, r), await Promise.all(e.map(async function(f, c) {
    const l = n.subkeys[c].passphrase;
    l && await f.encrypt(l, r);
  }));
  const s = new cn();
  function i(f, c) {
    return [c, ...f.filter((l) => l !== c)];
  }
  function a() {
    const f = {};
    f.keyFlags = [ee.keyFlags.certifyKeys | ee.keyFlags.signData];
    const c = i([ee.symmetric.aes256, ee.symmetric.aes128], r.preferredSymmetricAlgorithm);
    if (f.preferredSymmetricAlgorithms = c, r.aeadProtect) {
      const l = i([ee.aead.gcm, ee.aead.eax, ee.aead.ocb], r.preferredAEADAlgorithm);
      f.preferredCipherSuites = l.flatMap((h) => c.map((m) => [m, h]));
    }
    return f.preferredHashAlgorithms = i([ee.hash.sha512, ee.hash.sha256, ee.hash.sha3_512, ee.hash.sha3_256], r.preferredHashAlgorithm), f.preferredCompressionAlgorithms = i([ee.compression.uncompressed, ee.compression.zlib, ee.compression.zip], r.preferredCompressionAlgorithm), f.features = [0], f.features[0] |= ee.features.modificationDetection, r.aeadProtect && (f.features[0] |= ee.features.seipdv2), n.keyExpirationTime > 0 && (f.keyExpirationTime = n.keyExpirationTime, f.keyNeverExpires = false), f;
  }
  if (s.push(t3), t3.version === 6) {
    const f = { key: t3 }, c = a();
    c.signatureType = ee.signature.key;
    const l = await vo(f, [], t3, c, n.date, void 0, void 0, void 0, r);
    s.push(l);
  }
  await Promise.all(n.userIDs.map(async function(f, c) {
    const l = Ag.fromObject(f), h = { userID: l, key: t3 }, m = t3.version !== 6 ? a() : {};
    return m.signatureType = ee.signature.certPositive, c === 0 && (m.isPrimaryUserID = true), { userIDPacket: l, signaturePacket: await vo(h, [], t3, m, n.date, void 0, void 0, void 0, r) };
  })).then((f) => {
    f.forEach(({ userIDPacket: c, signaturePacket: l }) => {
      s.push(c), s.push(l);
    });
  }), await Promise.all(e.map(async function(f, c) {
    const l = n.subkeys[c];
    return { secretSubkeyPacket: f, subkeySignaturePacket: await qk(f, t3, l, r) };
  })).then((f) => {
    f.forEach(({ secretSubkeyPacket: c, subkeySignaturePacket: l }) => {
      s.push(c), s.push(l);
    });
  });
  const o = { key: t3 };
  return s.push(await vo(o, [], t3, { signatureType: ee.signature.keyRevocation, reasonForRevocationFlag: ee.reasonForRevocation.noReason, reasonForRevocationString: "" }, n.date, void 0, void 0, void 0, r)), n.passphrase && t3.clearPrivateParams(), e.map(function(f, c) {
    n.subkeys[c].passphrase && f.clearPrivateParams();
  }), new ed(s);
}
async function mU({ armoredKey: t3, binaryKey: e, config: n, ...r }) {
  if (n = { ...Qt, ...n }, !t3 && !e) throw Error("readKey: must pass options object containing `armoredKey` or `binaryKey`");
  if (t3 && !Ee.isString(t3)) throw Error("readKey: options.armoredKey must be a string");
  if (e && !Ee.isUint8Array(e)) throw Error("readKey: options.binaryKey must be a Uint8Array");
  const s = Object.keys(r);
  if (s.length > 0) throw Error("Unknown option: " + s.join(", "));
  let i;
  if (t3) {
    const { type: f, data: c } = await Wh(t3);
    if (f !== ee.armor.publicKey && f !== ee.armor.privateKey) throw Error("Armored text not of type key");
    i = c;
  } else i = e;
  const a = await cn.fromBinary(i, Gk, n), o = a.indexOfTag(ee.packet.publicKey, ee.packet.secretKey);
  if (o.length === 0) throw Error("No key packet found");
  return pU(a.slice(o[0], o[1]));
}
async function vU({ armoredKey: t3, binaryKey: e, config: n, ...r }) {
  if (n = { ...Qt, ...n }, !t3 && !e) throw Error("readPrivateKey: must pass options object containing `armoredKey` or `binaryKey`");
  if (t3 && !Ee.isString(t3)) throw Error("readPrivateKey: options.armoredKey must be a string");
  if (e && !Ee.isUint8Array(e)) throw Error("readPrivateKey: options.binaryKey must be a Uint8Array");
  const s = Object.keys(r);
  if (s.length > 0) throw Error("Unknown option: " + s.join(", "));
  let i;
  if (t3) {
    const { type: f, data: c } = await Wh(t3);
    if (f !== ee.armor.privateKey) throw Error("Armored text not of type private key");
    i = c;
  } else i = e;
  const a = await cn.fromBinary(i, Gk, n), o = a.indexOfTag(ee.packet.publicKey, ee.packet.secretKey);
  for (let f = 0; f < o.length; f++) {
    if (a[o[f]].constructor.tag === ee.packet.publicKey) continue;
    const c = a.slice(o[f], o[f + 1]);
    return new ed(c);
  }
  throw Error("No secret key packet found");
}
const yU = Ee.constructAllowedPackets([zu, Xh, fU, Au, uU, Sh, wu, aa, Ui]), bU = Ee.constructAllowedPackets([wu]), AU = Ee.constructAllowedPackets([Ui]);
class js {
  constructor(e) {
    this.packets = e || new cn();
  }
  getEncryptionKeyIDs() {
    const e = [];
    return this.packets.filterByTag(ee.packet.publicKeyEncryptedSessionKey).forEach(function(n) {
      e.push(n.publicKeyID);
    }), e;
  }
  getSigningKeyIDs() {
    const e = this.unwrapCompressed(), n = e.packets.filterByTag(ee.packet.onePassSignature);
    return n.length > 0 ? n.map((r) => r.issuerKeyID) : e.packets.filterByTag(ee.packet.signature).map((r) => r.issuerKeyID);
  }
  async decrypt(e, n, r, s = /* @__PURE__ */ new Date(), i = Qt) {
    const a = this.packets.filterByTag(ee.packet.symmetricallyEncryptedData, ee.packet.symEncryptedIntegrityProtectedData, ee.packet.aeadEncryptedData);
    if (a.length === 0) throw Error("No encrypted data found");
    const o = a[0], f = o.cipherAlgorithm, c = r || await this.decryptSessionKeys(e, n, f, s, i);
    let l = null;
    const h = Promise.all(c.map(async ({ algorithm: v, data: b }) => {
      if (!Ee.isUint8Array(b) || !o.cipherAlgorithm && !Ee.isString(v)) throw Error("Invalid session key for decryption.");
      try {
        const A = o.cipherAlgorithm || ee.write(ee.symmetric, v);
        await o.decrypt(A, b, i);
      } catch (A) {
        Ee.printDebugError(A), l = A;
      }
    }));
    if (Fy(o.encrypted), o.encrypted = null, await h, !o.packets || !o.packets.length) throw l || Error("Decryption failed.");
    const m = new js(o.packets);
    return o.packets = new cn(), m;
  }
  async decryptSessionKeys(e, n, r, s = /* @__PURE__ */ new Date(), i = Qt) {
    let a, o = [];
    if (n) {
      const f = this.packets.filterByTag(ee.packet.symEncryptedSessionKey);
      if (f.length === 0) throw Error("No symmetrically encrypted session key packet found.");
      await Promise.all(n.map(async function(c, l) {
        let h;
        h = l ? await cn.fromBinary(f.write(), bU, i) : f, await Promise.all(h.map(async function(m) {
          try {
            await m.decrypt(c), o.push(m);
          } catch (v) {
            Ee.printDebugError(v), v instanceof gg && (a = v);
          }
        }));
      }));
    } else {
      if (!e) throw Error("No key or password specified.");
      {
        const f = this.packets.filterByTag(ee.packet.publicKeyEncryptedSessionKey);
        if (f.length === 0) throw Error("No public key encrypted session key packet found.");
        await Promise.all(f.map(async function(c) {
          await Promise.all(e.map(async function(l) {
            let h;
            try {
              h = (await l.getDecryptionKeys(c.publicKeyID, null, void 0, i)).map((v) => v.keyPacket);
            } catch (v) {
              return void (a = v);
            }
            let m = [ee.symmetric.aes256, ee.symmetric.aes128, ee.symmetric.tripledes, ee.symmetric.cast5];
            try {
              const v = await l.getPrimarySelfSignature(s, void 0, i);
              v.preferredSymmetricAlgorithms && (m = m.concat(v.preferredSymmetricAlgorithms));
            } catch {
            }
            await Promise.all(h.map(async function(v) {
              if (!v.isDecrypted()) throw Error("Decryption key is not decrypted.");
              if (i.constantTimePKCS1Decryption && (c.publicKeyAlgorithm === ee.publicKey.rsaEncrypt || c.publicKeyAlgorithm === ee.publicKey.rsaEncryptSign || c.publicKeyAlgorithm === ee.publicKey.rsaSign || c.publicKeyAlgorithm === ee.publicKey.elgamal)) {
                const b = c.write();
                await Promise.all((r ? [r] : Array.from(i.constantTimePKCS1DecryptionSupportedSymmetricAlgorithms)).map(async (A) => {
                  const _ = new Sh();
                  _.read(b);
                  const C = { sessionKeyAlgorithm: A, sessionKey: Wy(A) };
                  try {
                    await _.decrypt(v, C), o.push(_);
                  } catch (I) {
                    Ee.printDebugError(I), a = I;
                  }
                }));
              } else try {
                await c.decrypt(v);
                const b = r || c.sessionKeyAlgorithm;
                if (b && !m.includes(ee.write(ee.symmetric, b))) throw Error("A non-preferred symmetric algorithm was used.");
                o.push(c);
              } catch (b) {
                Ee.printDebugError(b), a = b;
              }
            }));
          })), Fy(c.encrypted), c.encrypted = null;
        }));
      }
    }
    if (o.length > 0) {
      if (o.length > 1) {
        const f = /* @__PURE__ */ new Set();
        o = o.filter((c) => {
          const l = c.sessionKeyAlgorithm + Ee.uint8ArrayToString(c.sessionKey);
          return !f.has(l) && (f.add(l), true);
        });
      }
      return o.map((f) => ({ data: f.sessionKey, algorithm: f.sessionKeyAlgorithm && ee.read(ee.symmetric, f.sessionKeyAlgorithm) }));
    }
    throw a || Error("Session key decryption failed.");
  }
  getLiteralData() {
    const e = this.unwrapCompressed().packets.findPacket(ee.packet.literalData);
    return e && e.getBytes() || null;
  }
  getFilename() {
    const e = this.unwrapCompressed().packets.findPacket(ee.packet.literalData);
    return e && e.getFilename() || null;
  }
  getText() {
    const e = this.unwrapCompressed().packets.findPacket(ee.packet.literalData);
    return e ? e.getText() : null;
  }
  static async generateSessionKey(e = [], n = /* @__PURE__ */ new Date(), r = [], s = Qt) {
    const { symmetricAlgo: i, aeadAlgo: a } = await async function(c = [], l = /* @__PURE__ */ new Date(), h = [], m = Qt) {
      const v = await Promise.all(c.map((_, C) => _.getPrimarySelfSignature(l, h[C], m)));
      if (c.length ? v.every((_) => _.features && _.features[0] & ee.features.seipdv2) : m.aeadProtect) {
        const _ = { symmetricAlgo: ee.symmetric.aes128, aeadAlgo: ee.aead.ocb }, C = [{ symmetricAlgo: m.preferredSymmetricAlgorithm, aeadAlgo: m.preferredAEADAlgorithm }, { symmetricAlgo: m.preferredSymmetricAlgorithm, aeadAlgo: ee.aead.ocb }, { symmetricAlgo: ee.symmetric.aes128, aeadAlgo: m.preferredAEADAlgorithm }];
        for (const I of C) if (v.every((S) => S.preferredCipherSuites && S.preferredCipherSuites.some(($) => $[0] === I.symmetricAlgo && $[1] === I.aeadAlgo))) return I;
        return _;
      }
      const b = ee.symmetric.aes128, A = m.preferredSymmetricAlgorithm;
      return { symmetricAlgo: v.every((_) => _.preferredSymmetricAlgorithms && _.preferredSymmetricAlgorithms.includes(A)) ? A : b, aeadAlgo: void 0 };
    }(e, n, r, s), o = ee.read(ee.symmetric, i), f = a ? ee.read(ee.aead, a) : void 0;
    return await Promise.all(e.map((c) => c.getEncryptionKey().catch(() => null).then((l) => {
      if (l && (l.keyPacket.algorithm === ee.publicKey.x25519 || l.keyPacket.algorithm === ee.publicKey.x448) && !f && !Ee.isAES(i)) throw Error("Could not generate a session key compatible with the given `encryptionKeys`: X22519 and X448 keys can only be used to encrypt AES session keys; change `config.preferredSymmetricAlgorithm` accordingly.");
    }))), { data: Wy(i), algorithm: o, aeadAlgorithm: f };
  }
  async encrypt(e, n, r, s = false, i = [], a = /* @__PURE__ */ new Date(), o = [], f = Qt) {
    if (r) {
      if (!Ee.isUint8Array(r.data) || !Ee.isString(r.algorithm)) throw Error("Invalid session key for encryption.");
    } else if (e && e.length) r = await js.generateSessionKey(e, a, o, f);
    else {
      if (!n || !n.length) throw Error("No keys, passwords, or session key provided.");
      r = await js.generateSessionKey(void 0, void 0, void 0, f);
    }
    const { data: c, algorithm: l, aeadAlgorithm: h } = r, m = await js.encryptSessionKey(c, l, h, e, n, s, i, a, o, f), v = Au.fromObject({ version: h ? 2 : 1, aeadAlgorithm: h ? ee.write(ee.aead, h) : null });
    v.packets = this.packets;
    const b = ee.write(ee.symmetric, l);
    return await v.encrypt(b, c, f), m.packets.push(v), v.packets = new cn(), m;
  }
  static async encryptSessionKey(e, n, r, s, i, a = false, o = [], f = /* @__PURE__ */ new Date(), c = [], l = Qt) {
    const h = new cn(), m = ee.write(ee.symmetric, n), v = r && ee.write(ee.aead, r);
    if (s) {
      const b = await Promise.all(s.map(async function(A, _) {
        const C = await A.getEncryptionKey(o[_], f, c, l), I = Sh.fromObject({ version: v ? 6 : 3, encryptionKeyPacket: C.keyPacket, anonymousRecipient: a, sessionKey: e, sessionKeyAlgorithm: m });
        return await I.encrypt(C.keyPacket), delete I.sessionKey, I;
      }));
      h.push(...b);
    }
    if (i) {
      const b = async function(I, S) {
        try {
          return await I.decrypt(S), 1;
        } catch {
          return 0;
        }
      }, A = (I, S) => I + S, _ = async function(I, S, $, F) {
        const U = new wu(l);
        return U.sessionKey = I, U.sessionKeyAlgorithm = S, $ && (U.aeadAlgorithm = $), await U.encrypt(F, l), l.passwordCollisionCheck && (await Promise.all(i.map((Q) => b(U, Q)))).reduce(A) !== 1 ? _(I, S, F) : (delete U.sessionKey, U);
      }, C = await Promise.all(i.map((I) => _(e, m, v, I)));
      h.push(...C);
    }
    return new js(h);
  }
  async sign(e = [], n = [], r = null, s = [], i = /* @__PURE__ */ new Date(), a = [], o = [], f = [], c = Qt) {
    const l = new cn(), h = this.packets.findPacket(ee.packet.literalData);
    if (!h) throw Error("No literal data packet to sign.");
    const m = await z6(h, e, n, r, s, i, a, o, f, false, c), v = m.map((b, A) => aa.fromSignaturePacket(b, A === 0)).reverse();
    return l.push(...v), l.push(h), l.push(...m), new js(l);
  }
  compress(e, n = Qt) {
    if (e === ee.compression.uncompressed) return this;
    const r = new Xh(n);
    r.algorithm = e, r.packets = this.packets;
    const s = new cn();
    return s.push(r), new js(s);
  }
  async signDetached(e = [], n = [], r = null, s = [], i = [], a = /* @__PURE__ */ new Date(), o = [], f = [], c = Qt) {
    const l = this.packets.findPacket(ee.packet.literalData);
    if (!l) throw Error("No literal data packet to sign.");
    return new Kk(await z6(l, e, n, r, s, i, a, o, f, true, c));
  }
  async verify(e, n = /* @__PURE__ */ new Date(), r = Qt) {
    const s = this.unwrapCompressed(), i = s.packets.filterByTag(ee.packet.literalData);
    if (i.length !== 1) throw Error("Can only verify message with one literal data packet.");
    let a = s.packets;
    Un(a.stream) && (a = a.concat(await Zn(a.stream, (c) => c || [])));
    const o = a.filterByTag(ee.packet.onePassSignature).reverse(), f = a.filterByTag(ee.packet.signature);
    return o.length && !f.length && Ee.isStream(a.stream) && !Un(a.stream) ? (await Promise.all(o.map(async (c) => {
      c.correspondingSig = new Promise((l, h) => {
        c.correspondingSigResolve = l, c.correspondingSigReject = h;
      }), c.signatureData = d0(async () => (await c.correspondingSig).signatureData), c.hashed = Zn(await c.hash(c.signatureType, i[0], void 0, false)), c.hashed.catch(() => {
      });
    })), a.stream = hl(a.stream, async (c, l) => {
      const h = Ma(c), m = Hs(l);
      try {
        for (let v = 0; v < o.length; v++) {
          const { value: b } = await h.read();
          o[v].correspondingSigResolve(b);
        }
        await h.readToEnd(), await m.ready, await m.close();
      } catch (v) {
        o.forEach((b) => {
          b.correspondingSigReject(v);
        }), await m.abort(v);
      }
    }), zm(o, i, e, n, false, r)) : zm(f, i, e, n, false, r);
  }
  async verifyDetached(e, n, r = /* @__PURE__ */ new Date(), s = Qt) {
    const i = this.unwrapCompressed().packets.filterByTag(ee.packet.literalData);
    if (i.length !== 1) throw Error("Can only verify message with one literal data packet.");
    return zm(e.packets.filterByTag(ee.packet.signature), i, n, r, true, s);
  }
  unwrapCompressed() {
    const e = this.packets.filterByTag(ee.packet.compressedData);
    return e.length ? new js(e[0].packets) : this;
  }
  async appendSignature(e, n = Qt) {
    await this.packets.read(Ee.isUint8Array(e) ? e : (await Wh(e)).data, AU, n);
  }
  write() {
    return this.packets.write();
  }
  armor(e = Qt) {
    const n = this.packets[this.packets.length - 1], r = n.constructor.tag === Au.tag ? n.version !== 2 : this.packets.some((s) => s.constructor.tag === Ui.tag && s.version !== 6);
    return Jh(ee.armor.message, this.write(), null, null, null, r, e);
  }
}
async function z6(t3, e, n = [], r = null, s = [], i = /* @__PURE__ */ new Date(), a = [], o = [], f = [], c = false, l = Qt) {
  const h = new cn(), m = t3.text === null ? ee.signature.binary : ee.signature.text;
  if (await Promise.all(e.map(async (v, b) => {
    const A = a[b];
    if (!v.isPrivate()) throw Error("Need private key for signing");
    const _ = await v.getSigningKey(s[b], i, A, l);
    return vo(t3, n.length ? n : [v], _.keyPacket, { signatureType: m }, i, o, f, c, l);
  })).then((v) => {
    h.push(...v);
  }), r) {
    const v = r.packets.filterByTag(ee.packet.signature);
    h.push(...v);
  }
  return h;
}
function zm(t3, e, n, r = /* @__PURE__ */ new Date(), s = false, i = Qt) {
  return t3.filter((a) => ["text", "binary"].includes(ee.read(ee.signature, a.signatureType))).map((a) => function(o, f, c, l = /* @__PURE__ */ new Date(), h = false, m = Qt) {
    let v, b;
    for (const C of c) {
      const I = C.getKeys(o.issuerKeyID);
      if (I.length > 0) {
        v = C, b = I[0];
        break;
      }
    }
    const A = o instanceof aa ? o.correspondingSig : o, _ = { keyID: o.issuerKeyID, verified: (async () => {
      if (!b) throw Error("Could not find signing key with key ID " + o.issuerKeyID.toHex());
      await o.verify(b.keyPacket, o.signatureType, f[0], l, h, m);
      const C = await A;
      if (b.getCreationTime() > C.created) throw Error("Key is newer than the signature");
      try {
        await v.getSigningKey(b.getKeyID(), C.created, void 0, m);
      } catch (I) {
        if (!m.allowInsecureVerificationWithReformattedKeys || !I.message.match(/Signature creation time is in the future/)) throw I;
        await v.getSigningKey(b.getKeyID(), l, void 0, m);
      }
      return true;
    })(), signature: (async () => {
      const C = await A, I = new cn();
      return C && I.push(C), new Kk(I);
    })() };
    return _.signature.catch(() => {
    }), _.verified.catch(() => {
    }), _;
  }(a, e, n, r, s, i));
}
async function G6({ armoredMessage: t3, binaryMessage: e, config: n, ...r }) {
  n = { ...Qt, ...n };
  let s = t3 || e;
  if (!s) throw Error("readMessage: must pass options object containing `armoredMessage` or `binaryMessage`");
  if (t3 && !Ee.isString(t3) && !Ee.isStream(t3)) throw Error("readMessage: options.armoredMessage must be a string or stream");
  if (e && !Ee.isUint8Array(e) && !Ee.isStream(e)) throw Error("readMessage: options.binaryMessage must be a Uint8Array or stream");
  const i = Object.keys(r);
  if (i.length > 0) throw Error("Unknown option: " + i.join(", "));
  const a = Ee.isStream(s);
  if (t3) {
    const { type: c, data: l } = await Wh(s);
    if (c !== ee.armor.message) throw Error("Armored text not of type message");
    s = l;
  }
  const o = await cn.fromBinary(s, yU, n, new yg()), f = new js(o);
  return f.fromStream = a, f;
}
async function wU({ text: t3, binary: e, filename: n, date: r = /* @__PURE__ */ new Date(), format: s = t3 !== void 0 ? "utf8" : "binary", ...i }) {
  const a = t3 !== void 0 ? t3 : e;
  if (a === void 0) throw Error("createMessage: must pass options object containing `text` or `binary`");
  if (t3 && !Ee.isString(t3) && !Ee.isStream(t3)) throw Error("createMessage: options.text must be a string or stream");
  if (e && !Ee.isUint8Array(e) && !Ee.isStream(e)) throw Error("createMessage: options.binary must be a Uint8Array or stream");
  const o = Object.keys(i);
  if (o.length > 0) throw Error("Unknown option: " + o.join(", "));
  const f = Ee.isStream(a), c = new zu(r);
  t3 !== void 0 ? c.setText(a, ee.write(ee.literal, s)) : c.setBytes(a, ee.write(ee.literal, s)), n !== void 0 && c.setFilename(n);
  const l = new cn();
  l.push(c);
  const h = new js(l);
  return h.fromStream = f, h;
}
async function xU({ userIDs: t3 = [], passphrase: e, type: n, curve: r, rsaBits: s = 4096, keyExpirationTime: i = 0, date: a = /* @__PURE__ */ new Date(), subkeys: o = [{}], format: f = "armored", config: c, ...l }) {
  wg(c = { ...Qt, ...c }), n || r ? (n = n || "ecc", r = r || "curve25519Legacy") : (n = c.v6Keys ? "curve25519" : "ecc", r = "curve25519Legacy"), t3 = Ps(t3);
  const h = Object.keys(l);
  if (h.length > 0) throw Error("Unknown option: " + h.join(", "));
  if (t3.length === 0 && !c.v6Keys) throw Error("UserIDs are required for V4 keys");
  if (n === "rsa" && s < c.minRSABits) throw Error(`rsaBits should be at least ${c.minRSABits}, got: ${s}`);
  const m = { userIDs: t3, passphrase: e, type: n, rsaBits: s, curve: r, keyExpirationTime: i, date: a, subkeys: o };
  try {
    const { key: v, revocationCertificate: b } = await async function(A, _) {
      A.sign = true, (A = i3(A)).subkeys = A.subkeys.map((F, U) => i3(A.subkeys[U], A));
      let C = [cU(A, _)];
      C = C.concat(A.subkeys.map((F) => Hk(F, _)));
      const I = await Promise.all(C), S = await gU(I[0], I.slice(1), A, _), $ = await S.getRevocationCertificate(A.date, _);
      return S.revocationSignatures = [], { key: S, revocationCertificate: $ };
    }(m, c);
    return v.getKeys().forEach(({ keyPacket: A }) => Lf(A, c)), { privateKey: V6(v, f, c), publicKey: V6(v.toPublic(), f, c), revocationCertificate: b };
  } catch (v) {
    throw Ee.wrapError("Error generating keypair", v);
  }
}
async function _U({ privateKey: t3, passphrase: e, config: n, ...r }) {
  wg(n = { ...Qt, ...n });
  const s = Object.keys(r);
  if (s.length > 0) throw Error("Unknown option: " + s.join(", "));
  if (!t3.isPrivate()) throw Error("Cannot decrypt a public key");
  const i = t3.clone(true), a = Ee.isArray(e) ? e : [e];
  try {
    return await Promise.all(i.getKeys().map((o) => Ee.anyPromise(a.map((f) => o.keyPacket.decrypt(f))))), await i.validate(n), i;
  } catch (o) {
    throw i.clearPrivateParams(), Ee.wrapError("Error decrypting private key", o);
  }
}
async function EU({ message: t3, encryptionKeys: e, signingKeys: n, passwords: r, sessionKey: s, format: i = "armored", signature: a = null, wildcard: o = false, signingKeyIDs: f = [], encryptionKeyIDs: c = [], date: l = /* @__PURE__ */ new Date(), signingUserIDs: h = [], encryptionUserIDs: m = [], signatureNotations: v = [], config: b, ...A }) {
  if (wg(b = { ...Qt, ...b }), Vk(t3), CU(i), e = Ps(e), n = Ps(n), r = Ps(r), f = Ps(f), c = Ps(c), h = Ps(h), m = Ps(m), v = Ps(v), A.detached) throw Error("The `detached` option has been removed from openpgp.encrypt, separately call openpgp.sign instead. Don't forget to remove the `privateKeys` option as well.");
  if (A.publicKeys) throw Error("The `publicKeys` option has been removed from openpgp.encrypt, pass `encryptionKeys` instead");
  if (A.privateKeys) throw Error("The `privateKeys` option has been removed from openpgp.encrypt, pass `signingKeys` instead");
  if (A.armor !== void 0) throw Error("The `armor` option has been removed from openpgp.encrypt, pass `format` instead.");
  const _ = Object.keys(A);
  if (_.length > 0) throw Error("Unknown option: " + _.join(", "));
  n || (n = []);
  try {
    if ((n.length || a) && (t3 = await t3.sign(n, e, a, f, l, h, c, v, b)), t3 = t3.compress(await async function(I = [], S = /* @__PURE__ */ new Date(), $ = [], F = Qt) {
      const U = ee.compression.uncompressed, Q = F.preferredCompressionAlgorithm;
      return (await Promise.all(I.map(async function(N, L) {
        const B = (await N.getPrimarySelfSignature(S, $[L], F)).preferredCompressionAlgorithms;
        return !!B && B.indexOf(Q) >= 0;
      }))).every(Boolean) ? Q : U;
    }(e, l, m, b), b), t3 = await t3.encrypt(e, r, s, o, c, l, m, b), i === "object") return t3;
    const C = i === "armored" ? t3.armor(b) : t3.write();
    return await Yk(C);
  } catch (C) {
    throw Ee.wrapError("Error encrypting message", C);
  }
}
async function BU({ message: t3, decryptionKeys: e, passwords: n, sessionKeys: r, verificationKeys: s, expectSigned: i = false, format: a = "utf8", signature: o = null, date: f = /* @__PURE__ */ new Date(), config: c, ...l }) {
  if (wg(c = { ...Qt, ...c }), Vk(t3), s = Ps(s), e = Ps(e), n = Ps(n), r = Ps(r), l.privateKeys) throw Error("The `privateKeys` option has been removed from openpgp.decrypt, pass `decryptionKeys` instead");
  if (l.publicKeys) throw Error("The `publicKeys` option has been removed from openpgp.decrypt, pass `verificationKeys` instead");
  const h = Object.keys(l);
  if (h.length > 0) throw Error("Unknown option: " + h.join(", "));
  try {
    const m = await t3.decrypt(e, n, r, f, c);
    s || (s = []);
    const v = {};
    if (v.signatures = o ? await m.verifyDetached(o, s, f, c) : await m.verify(s, f, c), v.data = a === "binary" ? m.getLiteralData() : m.getText(), v.filename = m.getFilename(), IU(v, t3, .../* @__PURE__ */ new Set([m, m.unwrapCompressed()])), i) {
      if (s.length === 0) throw Error("Verification keys are required to verify message signatures");
      if (v.signatures.length === 0) throw Error("Message is not signed");
      v.data = hs([v.data, d0(async () => (await Ee.anyPromise(v.signatures.map((b) => b.verified)), a === "binary" ? new Uint8Array() : ""))]);
    }
    return v.data = await Yk(v.data), v;
  } catch (m) {
    throw Ee.wrapError("Error decrypting message", m);
  }
}
function Vk(t3) {
  if (!(t3 instanceof js)) throw Error("Parameter [message] needs to be of type Message");
}
function CU(t3) {
  if (t3 !== "armored" && t3 !== "binary" && t3 !== "object") throw Error("Unsupported format " + t3);
}
const kU = Object.keys(Qt).length;
function wg(t3) {
  const e = Object.keys(t3);
  if (e.length !== kU) {
    for (const n of e) if (Qt[n] === void 0) throw Error("Unknown config property: " + n);
  }
}
function Ps(t3) {
  return t3 && !Ee.isArray(t3) && (t3 = [t3]), t3;
}
async function Yk(t3) {
  return Ee.isStream(t3) === "array" ? Zn(t3) : t3;
}
function IU(t3, e, ...n) {
  t3.data = hl(e.packets.stream, async (r, s) => {
    await mu(t3.data, s, { preventClose: true });
    const i = Hs(s);
    try {
      await Zn(r, (a) => a), await Promise.all(n.map((a) => Zn(a.packets.stream, (o) => o))), await i.close();
    } catch (a) {
      await i.abort(a);
    }
  });
}
function V6(t3, e, n) {
  switch (e) {
    case "object":
      return t3;
    case "armored":
      return t3.armor(n);
    case "binary":
      return t3.write();
    default:
      throw Error("Unsupported format " + e);
  }
}
const S0 = typeof es == "object" && "crypto" in es ? es.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function td(t3) {
  return t3 instanceof Uint8Array || ArrayBuffer.isView(t3) && t3.constructor.name === "Uint8Array";
}
function Mh(t3) {
  if (!Number.isSafeInteger(t3) || t3 < 0) throw Error("positive integer expected, got " + t3);
}
function Eo(t3, ...e) {
  if (!td(t3)) throw Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t3.length)) throw Error("Uint8Array expected of length " + e + ", got length=" + t3.length);
}
function Wk(t3) {
  if (typeof t3 != "function" || typeof t3.create != "function") throw Error("Hash should be wrapped by utils.createHasher");
  Mh(t3.outputLen), Mh(t3.blockLen);
}
function Eu(t3, e = true) {
  if (t3.destroyed) throw Error("Hash instance has been destroyed");
  if (e && t3.finished) throw Error("Hash#digest() has already been called");
}
function Jk(t3, e) {
  Eo(t3);
  const n = e.outputLen;
  if (t3.length < n) throw Error("digestInto() expects output buffer of length at least " + n);
}
function fa(...t3) {
  for (let e = 0; e < t3.length; e++) t3[e].fill(0);
}
function Gm(t3) {
  return new DataView(t3.buffer, t3.byteOffset, t3.byteLength);
}
function Oa(t3, e) {
  return t3 << 32 - e | t3 >>> e;
}
function qf(t3, e) {
  return t3 << e | t3 >>> 32 - e >>> 0;
}
const Y6 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68 ? (t3) => t3 : function(t3) {
  for (let n = 0; n < t3.length; n++) t3[n] = (e = t3[n]) << 24 & 4278190080 | e << 8 & 16711680 | e >>> 8 & 65280 | e >>> 24 & 255;
  var e;
  return t3;
}, Zk = typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function", SU = Array.from({ length: 256 }, (t3, e) => e.toString(16).padStart(2, "0"));
function jl(t3) {
  if (Eo(t3), Zk) return t3.toHex();
  let e = "";
  for (let n = 0; n < t3.length; n++) e += SU[t3[n]];
  return e;
}
const W6 = 48, MU = 57, J6 = 65, $U = 70, Z6 = 97, TU = 102;
function j6(t3) {
  return t3 >= W6 && t3 <= MU ? t3 - W6 : t3 >= J6 && t3 <= $U ? t3 - (J6 - 10) : t3 >= Z6 && t3 <= TU ? t3 - (Z6 - 10) : void 0;
}
function g1(t3) {
  if (typeof t3 != "string") throw Error("hex string expected, got " + typeof t3);
  if (Zk) return Uint8Array.fromHex(t3);
  const e = t3.length, n = e / 2;
  if (e % 2) throw Error("hex string expected, got unpadded hex of length " + e);
  const r = new Uint8Array(n);
  for (let s = 0, i = 0; s < n; s++, i += 2) {
    const a = j6(t3.charCodeAt(i)), o = j6(t3.charCodeAt(i + 1));
    if (a === void 0 || o === void 0) {
      const f = t3[i] + t3[i + 1];
      throw Error('hex string expected, got non-hex character "' + f + '" at index ' + i);
    }
    r[s] = 16 * a + o;
  }
  return r;
}
function rd(t3) {
  return typeof t3 == "string" && (t3 = function(e) {
    if (typeof e != "string") throw Error("string expected");
    return new Uint8Array(new TextEncoder().encode(e));
  }(t3)), Eo(t3), t3;
}
function Ba(...t3) {
  let e = 0;
  for (let r = 0; r < t3.length; r++) {
    const s = t3[r];
    Eo(s), e += s.length;
  }
  const n = new Uint8Array(e);
  for (let r = 0, s = 0; r < t3.length; r++) {
    const i = t3[r];
    n.set(i, s), s += i.length;
  }
  return n;
}
class oA {
}
function df(t3) {
  const e = (r) => t3().update(rd(r)).digest(), n = t3();
  return e.outputLen = n.outputLen, e.blockLen = n.blockLen, e.create = () => t3(), e;
}
const DU = df;
function xg(t3 = 32) {
  if (S0 && typeof S0.getRandomValues == "function") return S0.getRandomValues(new Uint8Array(t3));
  if (S0 && typeof S0.randomBytes == "function") return Uint8Array.from(S0.randomBytes(t3));
  throw Error("crypto.getRandomValues must be defined");
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const fA = BigInt(0), a3 = BigInt(1);
function o0(t3, e = "") {
  if (typeof t3 != "boolean") throw Error((e && `"${e}"`) + "expected boolean, got type=" + typeof t3);
  return t3;
}
function Ia(t3, e, n = "") {
  const r = td(t3), s = t3 == null ? void 0 : t3.length, i = e !== void 0;
  if (!r || i && s !== e) throw Error((n && `"${n}" `) + "expected Uint8Array" + (i ? " of length " + e : "") + ", got " + (r ? "length=" + s : "type=" + typeof t3));
  return t3;
}
function Od(t3) {
  const e = t3.toString(16);
  return 1 & e.length ? "0" + e : e;
}
function jk(t3) {
  if (typeof t3 != "string") throw Error("hex string expected, got " + typeof t3);
  return t3 === "" ? fA : BigInt("0x" + t3);
}
function _g(t3) {
  return jk(jl(t3));
}
function f0(t3) {
  return Eo(t3), jk(jl(Uint8Array.from(t3).reverse()));
}
function lA(t3, e) {
  return g1(t3.toString(16).padStart(2 * e, "0"));
}
function uA(t3, e) {
  return lA(t3, e).reverse();
}
function Rn(t3, e, n) {
  let r;
  if (typeof e == "string") try {
    r = g1(e);
  } catch (i) {
    throw Error(t3 + " must be hex string or Uint8Array, cause: " + i);
  }
  else {
    if (!td(e)) throw Error(t3 + " must be hex string or Uint8Array");
    r = Uint8Array.from(e);
  }
  const s = r.length;
  if (typeof n == "number" && s !== n) throw Error(t3 + " of length " + n + " expected, got " + s);
  return r;
}
function X6(t3) {
  return Uint8Array.from(t3);
}
const Vm = (t3) => typeof t3 == "bigint" && fA <= t3;
function $h(t3, e, n, r) {
  if (!function(s, i, a) {
    return Vm(s) && Vm(i) && Vm(a) && i <= s && s < a;
  }(e, n, r)) throw Error("expected valid " + t3 + ": " + n + " <= n < " + r + ", got " + e);
}
function Xk(t3) {
  let e;
  for (e = 0; t3 > fA; t3 >>= a3, e += 1) ;
  return e;
}
const nd = (t3) => (a3 << BigInt(t3)) - a3;
function Gu(t3, e, n = {}) {
  if (!t3 || typeof t3 != "object") throw Error("expected valid options object");
  function r(s, i, a) {
    const o = t3[s];
    if (a && o === void 0) return;
    const f = typeof o;
    if (f !== i || o === null) throw Error(`param "${s}" is invalid: expected ${i}, got ${f}`);
  }
  Object.entries(e).forEach(([s, i]) => r(s, i, false)), Object.entries(n).forEach(([s, i]) => r(s, i, true));
}
function m1(t3) {
  const e = /* @__PURE__ */ new WeakMap();
  return (n, ...r) => {
    const s = e.get(n);
    if (s !== void 0) return s;
    const i = t3(n, ...r);
    return e.set(n, i), i;
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const xs = BigInt(0), us = BigInt(1), Kl = BigInt(2), eI = BigInt(3), tI = BigInt(4), rI = BigInt(5), RU = BigInt(7), nI = BigInt(8), FU = BigInt(9), e5 = BigInt(16);
function ui(t3, e) {
  const n = t3 % e;
  return n >= xs ? n : e + n;
}
function Dn(t3, e, n) {
  let r = t3;
  for (; e-- > xs; ) r *= r, r %= n;
  return r;
}
function t5(t3, e) {
  if (t3 === xs) throw Error("invert: expected non-zero number");
  if (e <= xs) throw Error("invert: expected positive modulus, got " + e);
  let n = ui(t3, e), r = e, s = xs, i = us;
  for (; n !== xs; ) {
    const a = r % n, o = s - i * (r / n);
    r = n, n = a, s = i, i = o;
  }
  if (r !== us) throw Error("invert: does not exist");
  return ui(s, e);
}
function cA(t3, e, n) {
  if (!t3.eql(t3.sqr(e), n)) throw Error("Cannot find square root");
}
function iI(t3, e) {
  const n = (t3.ORDER + us) / tI, r = t3.pow(e, n);
  return cA(t3, r, e), r;
}
function PU(t3, e) {
  const n = (t3.ORDER - rI) / nI, r = t3.mul(e, Kl), s = t3.pow(r, n), i = t3.mul(e, s), a = t3.mul(t3.mul(i, Kl), s), o = t3.mul(i, t3.sub(a, t3.ONE));
  return cA(t3, o, e), o;
}
function r5(t3) {
  if (t3 < eI) throw Error("sqrt is not defined for small field");
  let e = t3 - us, n = 0;
  for (; e % Kl === xs; ) e /= Kl, n++;
  let r = Kl;
  const s = $s(t3);
  for (; n5(s, r) === 1; ) if (r++ > 1e3) throw Error("Cannot find square root: probably non-prime P");
  if (n === 1) return iI;
  let i = s.pow(r, e);
  const a = (e + us) / Kl;
  return function(o, f) {
    if (o.is0(f)) return f;
    if (n5(o, f) !== 1) throw Error("Cannot find square root");
    let c = n, l = o.mul(o.ONE, i), h = o.pow(f, e), m = o.pow(f, a);
    for (; !o.eql(h, o.ONE); ) {
      if (o.is0(h)) return o.ZERO;
      let v = 1, b = o.sqr(h);
      for (; !o.eql(b, o.ONE); ) if (v++, b = o.sqr(b), v === c) throw Error("Cannot find square root");
      const A = us << BigInt(c - v - 1), _ = o.pow(l, A);
      c = v, l = o.sqr(_), h = o.mul(h, l), m = o.mul(m, _);
    }
    return m;
  };
}
function NU(t3) {
  return t3 % tI === eI ? iI : t3 % nI === rI ? PU : t3 % e5 === FU ? function(e) {
    const n = $s(e), r = r5(e), s = r(n, n.neg(n.ONE)), i = r(n, s), a = r(n, n.neg(s)), o = (e + RU) / e5;
    return (f, c) => {
      let l = f.pow(c, o), h = f.mul(l, s);
      const m = f.mul(l, i), v = f.mul(l, a), b = f.eql(f.sqr(h), c), A = f.eql(f.sqr(m), c);
      l = f.cmov(l, h, b), h = f.cmov(v, m, A);
      const _ = f.eql(f.sqr(h), c), C = f.cmov(l, h, _);
      return cA(f, C, c), C;
    };
  }(t3) : r5(t3);
}
const UU = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function sI(t3, e, n = false) {
  const r = Array(e.length).fill(n ? t3.ZERO : void 0), s = e.reduce((a, o, f) => t3.is0(o) ? a : (r[f] = a, t3.mul(a, o)), t3.ONE), i = t3.inv(s);
  return e.reduceRight((a, o, f) => t3.is0(o) ? a : (r[f] = t3.mul(a, r[f]), t3.mul(a, o)), i), r;
}
function n5(t3, e) {
  const n = (t3.ORDER - us) / Kl, r = t3.pow(e, n), s = t3.eql(r, t3.ONE), i = t3.eql(r, t3.ZERO), a = t3.eql(r, t3.neg(t3.ONE));
  if (!s && !i && !a) throw Error("invalid Legendre symbol result");
  return s ? 1 : i ? 0 : -1;
}
function aI(t3, e) {
  e !== void 0 && Mh(e);
  const n = e !== void 0 ? e : t3.toString(2).length;
  return { nBitLength: n, nByteLength: Math.ceil(n / 8) };
}
function $s(t3, e, n = false, r = {}) {
  if (t3 <= xs) throw Error("invalid field: expected ORDER > 0, got " + t3);
  let s, i, a, o = false;
  if (typeof e == "object" && e != null) {
    if (r.sqrt || n) throw Error("cannot specify opts in two arguments");
    const m = e;
    m.BITS && (s = m.BITS), m.sqrt && (i = m.sqrt), typeof m.isLE == "boolean" && (n = m.isLE), typeof m.modFromBytes == "boolean" && (o = m.modFromBytes), a = m.allowedLengths;
  } else typeof e == "number" && (s = e), r.sqrt && (i = r.sqrt);
  const { nBitLength: f, nByteLength: c } = aI(t3, s);
  if (c > 2048) throw Error("invalid field: expected ORDER of <= 2048 bytes");
  let l;
  const h = Object.freeze({ ORDER: t3, isLE: n, BITS: f, BYTES: c, MASK: nd(f), ZERO: xs, ONE: us, allowedLengths: a, create: (m) => ui(m, t3), isValid: (m) => {
    if (typeof m != "bigint") throw Error("invalid field element: expected bigint, got " + typeof m);
    return xs <= m && m < t3;
  }, is0: (m) => m === xs, isValidNot0: (m) => !h.is0(m) && h.isValid(m), isOdd: (m) => (m & us) === us, neg: (m) => ui(-m, t3), eql: (m, v) => m === v, sqr: (m) => ui(m * m, t3), add: (m, v) => ui(m + v, t3), sub: (m, v) => ui(m - v, t3), mul: (m, v) => ui(m * v, t3), pow: (m, v) => function(b, A, _) {
    if (_ < xs) throw Error("invalid exponent, negatives unsupported");
    if (_ === xs) return b.ONE;
    if (_ === us) return A;
    let C = b.ONE, I = A;
    for (; _ > xs; ) _ & us && (C = b.mul(C, I)), I = b.sqr(I), _ >>= us;
    return C;
  }(h, m, v), div: (m, v) => ui(m * t5(v, t3), t3), sqrN: (m) => m * m, addN: (m, v) => m + v, subN: (m, v) => m - v, mulN: (m, v) => m * v, inv: (m) => t5(m, t3), sqrt: i || ((m) => (l || (l = NU(t3)), l(h, m))), toBytes: (m) => n ? uA(m, c) : lA(m, c), fromBytes: (m, v = true) => {
    if (a) {
      if (!a.includes(m.length) || m.length > c) throw Error("Field.fromBytes: expected " + a + " bytes, got " + m.length);
      const A = new Uint8Array(c);
      A.set(m, n ? 0 : A.length - m.length), m = A;
    }
    if (m.length !== c) throw Error("Field.fromBytes: expected " + c + " bytes, got " + m.length);
    let b = n ? f0(m) : _g(m);
    if (o && (b = ui(b, t3)), !v && !h.isValid(b)) throw Error("invalid field element: outside of range 0..ORDER");
    return b;
  }, invertBatch: (m) => sI(h, m), cmov: (m, v, b) => b ? v : m });
  return Object.freeze(h);
}
function oI(t3) {
  if (typeof t3 != "bigint") throw Error("field order must be bigint");
  const e = t3.toString(2).length;
  return Math.ceil(e / 8);
}
function i5(t3) {
  const e = oI(t3);
  return e + Math.ceil(e / 2);
}
function fI(t3, e, n) {
  return t3 & e ^ ~t3 & n;
}
function lI(t3, e, n) {
  return t3 & e ^ t3 & n ^ e & n;
}
class id extends oA {
  constructor(e, n, r, s) {
    super(), this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.blockLen = e, this.outputLen = n, this.padOffset = r, this.isLE = s, this.buffer = new Uint8Array(e), this.view = Gm(this.buffer);
  }
  update(e) {
    Eu(this), Eo(e = rd(e));
    const { view: n, buffer: r, blockLen: s } = this, i = e.length;
    for (let a = 0; a < i; ) {
      const o = Math.min(s - this.pos, i - a);
      if (o !== s) r.set(e.subarray(a, a + o), this.pos), this.pos += o, a += o, this.pos === s && (this.process(n, 0), this.pos = 0);
      else {
        const f = Gm(e);
        for (; s <= i - a; a += s) this.process(f, a);
      }
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    Eu(this), Jk(e, this), this.finished = true;
    const { buffer: n, view: r, blockLen: s, isLE: i } = this;
    let { pos: a } = this;
    n[a++] = 128, fa(this.buffer.subarray(a)), this.padOffset > s - a && (this.process(r, 0), a = 0);
    for (let h = a; h < s; h++) n[h] = 0;
    (function(h, m, v, b) {
      if (typeof h.setBigUint64 == "function") return h.setBigUint64(m, v, b);
      const A = BigInt(32), _ = BigInt(4294967295), C = Number(v >> A & _), I = Number(v & _), S = b ? 4 : 0, $ = b ? 0 : 4;
      h.setUint32(m + S, C, b), h.setUint32(m + $, I, b);
    })(r, s - 8, BigInt(8 * this.length), i), this.process(r, 0);
    const o = Gm(e), f = this.outputLen;
    if (f % 4) throw Error("_sha2: outputLen should be aligned to 32bit");
    const c = f / 4, l = this.get();
    if (c > l.length) throw Error("_sha2: outputLen bigger than state");
    for (let h = 0; h < c; h++) o.setUint32(4 * h, l[h], i);
  }
  digest() {
    const { buffer: e, outputLen: n } = this;
    this.digestInto(e);
    const r = e.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: n, buffer: r, length: s, finished: i, destroyed: a, pos: o } = this;
    return e.destroyed = a, e.finished = i, e.length = s, e.pos = o, s % n && e.buffer.set(r), e;
  }
  clone() {
    return this._cloneInto();
  }
}
const mf = Uint32Array.from([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]), vf = Uint32Array.from([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]), zi = Uint32Array.from([3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]), Gi = Uint32Array.from([1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209]), Qd = BigInt(2 ** 32 - 1), s5 = BigInt(32);
function LU(t3, e = false) {
  return e ? { h: Number(t3 & Qd), l: Number(t3 >> s5 & Qd) } : { h: 0 | Number(t3 >> s5 & Qd), l: 0 | Number(t3 & Qd) };
}
function uI(t3, e = false) {
  const n = t3.length;
  let r = new Uint32Array(n), s = new Uint32Array(n);
  for (let i = 0; i < n; i++) {
    const { h: a, l: o } = LU(t3[i], e);
    [r[i], s[i]] = [a, o];
  }
  return [r, s];
}
const a5 = (t3, e, n) => t3 >>> n, o5 = (t3, e, n) => t3 << 32 - n | e >>> n, M0 = (t3, e, n) => t3 >>> n | e << 32 - n, $0 = (t3, e, n) => t3 << 32 - n | e >>> n, Kd = (t3, e, n) => t3 << 64 - n | e >>> n - 32, Hd = (t3, e, n) => t3 >>> n - 32 | e << 64 - n;
function Po(t3, e, n, r) {
  const s = (e >>> 0) + (r >>> 0);
  return { h: t3 + n + (s / 2 ** 32 | 0) | 0, l: 0 | s };
}
const OU = (t3, e, n) => (t3 >>> 0) + (e >>> 0) + (n >>> 0), QU = (t3, e, n, r) => e + n + r + (t3 / 2 ** 32 | 0) | 0, KU = (t3, e, n, r) => (t3 >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0), HU = (t3, e, n, r, s) => e + n + r + s + (t3 / 2 ** 32 | 0) | 0, qU = (t3, e, n, r, s) => (t3 >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0) + (s >>> 0), zU = (t3, e, n, r, s, i) => e + n + r + s + i + (t3 / 2 ** 32 | 0) | 0, GU = Uint32Array.from([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]), yf = new Uint32Array(64);
class cI extends id {
  constructor(e = 32) {
    super(64, e, 8, false), this.A = 0 | mf[0], this.B = 0 | mf[1], this.C = 0 | mf[2], this.D = 0 | mf[3], this.E = 0 | mf[4], this.F = 0 | mf[5], this.G = 0 | mf[6], this.H = 0 | mf[7];
  }
  get() {
    const { A: e, B: n, C: r, D: s, E: i, F: a, G: o, H: f } = this;
    return [e, n, r, s, i, a, o, f];
  }
  set(e, n, r, s, i, a, o, f) {
    this.A = 0 | e, this.B = 0 | n, this.C = 0 | r, this.D = 0 | s, this.E = 0 | i, this.F = 0 | a, this.G = 0 | o, this.H = 0 | f;
  }
  process(e, n) {
    for (let h = 0; h < 16; h++, n += 4) yf[h] = e.getUint32(n, false);
    for (let h = 16; h < 64; h++) {
      const m = yf[h - 15], v = yf[h - 2], b = Oa(m, 7) ^ Oa(m, 18) ^ m >>> 3, A = Oa(v, 17) ^ Oa(v, 19) ^ v >>> 10;
      yf[h] = A + yf[h - 7] + b + yf[h - 16] | 0;
    }
    let { A: r, B: s, C: i, D: a, E: o, F: f, G: c, H: l } = this;
    for (let h = 0; h < 64; h++) {
      const m = l + (Oa(o, 6) ^ Oa(o, 11) ^ Oa(o, 25)) + fI(o, f, c) + GU[h] + yf[h] | 0, v = (Oa(r, 2) ^ Oa(r, 13) ^ Oa(r, 22)) + lI(r, s, i) | 0;
      l = c, c = f, f = o, o = a + m | 0, a = i, i = s, s = r, r = m + v | 0;
    }
    r = r + this.A | 0, s = s + this.B | 0, i = i + this.C | 0, a = a + this.D | 0, o = o + this.E | 0, f = f + this.F | 0, c = c + this.G | 0, l = l + this.H | 0, this.set(r, s, i, a, o, f, c, l);
  }
  roundClean() {
    fa(yf);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), fa(this.buffer);
  }
}
class VU extends cI {
  constructor() {
    super(28), this.A = 0 | vf[0], this.B = 0 | vf[1], this.C = 0 | vf[2], this.D = 0 | vf[3], this.E = 0 | vf[4], this.F = 0 | vf[5], this.G = 0 | vf[6], this.H = 0 | vf[7];
  }
}
const hI = uI(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((t3) => BigInt(t3))), YU = hI[0], WU = hI[1], bf = new Uint32Array(80), Af = new Uint32Array(80);
class dI extends id {
  constructor(e = 64) {
    super(128, e, 16, false), this.Ah = 0 | Gi[0], this.Al = 0 | Gi[1], this.Bh = 0 | Gi[2], this.Bl = 0 | Gi[3], this.Ch = 0 | Gi[4], this.Cl = 0 | Gi[5], this.Dh = 0 | Gi[6], this.Dl = 0 | Gi[7], this.Eh = 0 | Gi[8], this.El = 0 | Gi[9], this.Fh = 0 | Gi[10], this.Fl = 0 | Gi[11], this.Gh = 0 | Gi[12], this.Gl = 0 | Gi[13], this.Hh = 0 | Gi[14], this.Hl = 0 | Gi[15];
  }
  get() {
    const { Ah: e, Al: n, Bh: r, Bl: s, Ch: i, Cl: a, Dh: o, Dl: f, Eh: c, El: l, Fh: h, Fl: m, Gh: v, Gl: b, Hh: A, Hl: _ } = this;
    return [e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _];
  }
  set(e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _) {
    this.Ah = 0 | e, this.Al = 0 | n, this.Bh = 0 | r, this.Bl = 0 | s, this.Ch = 0 | i, this.Cl = 0 | a, this.Dh = 0 | o, this.Dl = 0 | f, this.Eh = 0 | c, this.El = 0 | l, this.Fh = 0 | h, this.Fl = 0 | m, this.Gh = 0 | v, this.Gl = 0 | b, this.Hh = 0 | A, this.Hl = 0 | _;
  }
  process(e, n) {
    for (let S = 0; S < 16; S++, n += 4) bf[S] = e.getUint32(n), Af[S] = e.getUint32(n += 4);
    for (let S = 16; S < 80; S++) {
      const $ = 0 | bf[S - 15], F = 0 | Af[S - 15], U = M0($, F, 1) ^ M0($, F, 8) ^ a5($, 0, 7), Q = $0($, F, 1) ^ $0($, F, 8) ^ o5($, F, 7), P = 0 | bf[S - 2], N = 0 | Af[S - 2], L = M0(P, N, 19) ^ Kd(P, N, 61) ^ a5(P, 0, 6), B = $0(P, N, 19) ^ Hd(P, N, 61) ^ o5(P, N, 6), u = KU(Q, B, Af[S - 7], Af[S - 16]), p = HU(u, U, L, bf[S - 7], bf[S - 16]);
      bf[S] = 0 | p, Af[S] = 0 | u;
    }
    let { Ah: r, Al: s, Bh: i, Bl: a, Ch: o, Cl: f, Dh: c, Dl: l, Eh: h, El: m, Fh: v, Fl: b, Gh: A, Gl: _, Hh: C, Hl: I } = this;
    for (let S = 0; S < 80; S++) {
      const $ = M0(h, m, 14) ^ M0(h, m, 18) ^ Kd(h, m, 41), F = $0(h, m, 14) ^ $0(h, m, 18) ^ Hd(h, m, 41), U = h & v ^ ~h & A, Q = qU(I, F, m & b ^ ~m & _, WU[S], Af[S]), P = zU(Q, C, $, U, YU[S], bf[S]), N = 0 | Q, L = M0(r, s, 28) ^ Kd(r, s, 34) ^ Kd(r, s, 39), B = $0(r, s, 28) ^ Hd(r, s, 34) ^ Hd(r, s, 39), u = r & i ^ r & o ^ i & o, p = s & a ^ s & f ^ a & f;
      C = 0 | A, I = 0 | _, A = 0 | v, _ = 0 | b, v = 0 | h, b = 0 | m, { h, l: m } = Po(0 | c, 0 | l, 0 | P, 0 | N), c = 0 | o, l = 0 | f, o = 0 | i, f = 0 | a, i = 0 | r, a = 0 | s;
      const d = OU(N, B, p);
      r = QU(d, P, L, u), s = 0 | d;
    }
    ({ h: r, l: s } = Po(0 | this.Ah, 0 | this.Al, 0 | r, 0 | s)), { h: i, l: a } = Po(0 | this.Bh, 0 | this.Bl, 0 | i, 0 | a), { h: o, l: f } = Po(0 | this.Ch, 0 | this.Cl, 0 | o, 0 | f), { h: c, l } = Po(0 | this.Dh, 0 | this.Dl, 0 | c, 0 | l), { h, l: m } = Po(0 | this.Eh, 0 | this.El, 0 | h, 0 | m), { h: v, l: b } = Po(0 | this.Fh, 0 | this.Fl, 0 | v, 0 | b), { h: A, l: _ } = Po(0 | this.Gh, 0 | this.Gl, 0 | A, 0 | _), { h: C, l: I } = Po(0 | this.Hh, 0 | this.Hl, 0 | C, 0 | I), this.set(r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I);
  }
  roundClean() {
    fa(bf, Af);
  }
  destroy() {
    fa(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
class JU extends dI {
  constructor() {
    super(48), this.Ah = 0 | zi[0], this.Al = 0 | zi[1], this.Bh = 0 | zi[2], this.Bl = 0 | zi[3], this.Ch = 0 | zi[4], this.Cl = 0 | zi[5], this.Dh = 0 | zi[6], this.Dl = 0 | zi[7], this.Eh = 0 | zi[8], this.El = 0 | zi[9], this.Fh = 0 | zi[10], this.Fl = 0 | zi[11], this.Gh = 0 | zi[12], this.Gl = 0 | zi[13], this.Hh = 0 | zi[14], this.Hl = 0 | zi[15];
  }
}
const hA = df(() => new cI()), ZU = df(() => new VU()), pI = df(() => new dI()), gI = df(() => new JU());
class mI extends oA {
  constructor(e, n) {
    super(), this.finished = false, this.destroyed = false, Wk(e);
    const r = rd(n);
    if (this.iHash = e.create(), typeof this.iHash.update != "function") throw Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const s = this.blockLen, i = new Uint8Array(s);
    i.set(r.length > s ? e.create().update(r).digest() : r);
    for (let a = 0; a < i.length; a++) i[a] ^= 54;
    this.iHash.update(i), this.oHash = e.create();
    for (let a = 0; a < i.length; a++) i[a] ^= 106;
    this.oHash.update(i), fa(i);
  }
  update(e) {
    return Eu(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    Eu(this), Eo(e, this.outputLen), this.finished = true, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n, iHash: r, finished: s, destroyed: i, blockLen: a, outputLen: o } = this;
    return e.finished = s, e.destroyed = i, e.blockLen = a, e.outputLen = o, e.oHash = n._cloneInto(e.oHash), e.iHash = r._cloneInto(e.iHash), e;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
}
const vI = (t3, e, n) => new mI(t3, e).update(n).digest();
vI.create = (t3, e) => new mI(t3, e);
const Bu = BigInt(0), Hl = BigInt(1);
function v1(t3, e) {
  const n = e.negate();
  return t3 ? n : e;
}
function ql(t3, e) {
  const n = sI(t3.Fp, e.map((r) => r.Z));
  return e.map((r, s) => t3.fromAffine(r.toAffine(n[s])));
}
function yI(t3, e) {
  if (!Number.isSafeInteger(t3) || t3 <= 0 || t3 > e) throw Error("invalid window size, expected [1.." + e + "], got W=" + t3);
}
function Ym(t3, e) {
  yI(t3, e);
  const n = 2 ** t3;
  return { windows: Math.ceil(e / t3) + 1, windowSize: 2 ** (t3 - 1), mask: nd(t3), maxNumber: n, shiftBy: BigInt(t3) };
}
function f5(t3, e, n) {
  const { windowSize: r, mask: s, maxNumber: i, shiftBy: a } = n;
  let o = Number(t3 & s), f = t3 >> a;
  o > r && (o -= i, f += Hl);
  const c = e * r;
  return { nextN: f, offset: c + Math.abs(o) - 1, isZero: o === 0, isNeg: o < 0, isNegF: e % 2 != 0, offsetF: c };
}
const Wm = /* @__PURE__ */ new WeakMap(), bI = /* @__PURE__ */ new WeakMap();
function Jm(t3) {
  return bI.get(t3) || 1;
}
function l5(t3) {
  if (t3 !== Bu) throw Error("invalid wNAF");
}
class AI {
  constructor(e, n) {
    this.BASE = e.BASE, this.ZERO = e.ZERO, this.Fn = e.Fn, this.bits = n;
  }
  _unsafeLadder(e, n, r = this.ZERO) {
    let s = e;
    for (; n > Bu; ) n & Hl && (r = r.add(s)), s = s.double(), n >>= Hl;
    return r;
  }
  precomputeWindow(e, n) {
    const { windows: r, windowSize: s } = Ym(n, this.bits), i = [];
    let a = e, o = a;
    for (let f = 0; f < r; f++) {
      o = a, i.push(o);
      for (let c = 1; c < s; c++) o = o.add(a), i.push(o);
      a = o.double();
    }
    return i;
  }
  wNAF(e, n, r) {
    if (!this.Fn.isValid(r)) throw Error("invalid scalar");
    let s = this.ZERO, i = this.BASE;
    const a = Ym(e, this.bits);
    for (let o = 0; o < a.windows; o++) {
      const { nextN: f, offset: c, isZero: l, isNeg: h, isNegF: m, offsetF: v } = f5(r, o, a);
      r = f, l ? i = i.add(v1(m, n[v])) : s = s.add(v1(h, n[c]));
    }
    return l5(r), { p: s, f: i };
  }
  wNAFUnsafe(e, n, r, s = this.ZERO) {
    const i = Ym(e, this.bits);
    for (let a = 0; a < i.windows && r !== Bu; a++) {
      const { nextN: o, offset: f, isZero: c, isNeg: l } = f5(r, a, i);
      if (r = o, !c) {
        const h = n[f];
        s = s.add(l ? h.negate() : h);
      }
    }
    return l5(r), s;
  }
  getPrecomputes(e, n, r) {
    let s = Wm.get(n);
    return s || (s = this.precomputeWindow(n, e), e !== 1 && (typeof r == "function" && (s = r(s)), Wm.set(n, s))), s;
  }
  cached(e, n, r) {
    const s = Jm(e);
    return this.wNAF(s, this.getPrecomputes(s, e, r), n);
  }
  unsafe(e, n, r, s) {
    const i = Jm(e);
    return i === 1 ? this._unsafeLadder(e, n, s) : this.wNAFUnsafe(i, this.getPrecomputes(i, e, r), n, s);
  }
  createCache(e, n) {
    yI(n, this.bits), bI.set(e, n), Wm.delete(e);
  }
  hasCache(e) {
    return Jm(e) !== 1;
  }
}
function wI(t3, e, n, r) {
  (function(m, v) {
    if (!Array.isArray(m)) throw Error("array expected");
    m.forEach((b, A) => {
      if (!(b instanceof v)) throw Error("invalid point at index " + A);
    });
  })(n, t3), function(m, v) {
    if (!Array.isArray(m)) throw Error("array of scalars expected");
    m.forEach((b, A) => {
      if (!v.isValid(b)) throw Error("invalid scalar at index " + A);
    });
  }(r, e);
  const s = n.length, i = r.length;
  if (s !== i) throw Error("arrays of points and scalars must have equal length");
  const a = t3.ZERO, o = Xk(BigInt(s));
  let f = 1;
  o > 12 ? f = o - 3 : o > 4 ? f = o - 2 : o > 0 && (f = 2);
  const c = nd(f), l = Array(Number(c) + 1).fill(a);
  let h = a;
  for (let m = Math.floor((e.BITS - 1) / f) * f; m >= 0; m -= f) {
    l.fill(a);
    for (let b = 0; b < i; b++) {
      const A = r[b], _ = Number(A >> BigInt(m) & c);
      l[_] = l[_].add(n[b]);
    }
    let v = a;
    for (let b = l.length - 1, A = a; b > 0; b--) A = A.add(l[b]), v = v.add(A);
    if (h = h.add(v), m !== 0) for (let b = 0; b < f; b++) h = h.double();
  }
  return h;
}
function u5(t3, e, n) {
  if (e) {
    if (e.ORDER !== t3) throw Error("Field.ORDER must match order: Fp == p, Fn == n");
    return function(r) {
      Gu(r, UU.reduce((s, i) => (s[i] = "function", s), { ORDER: "bigint", MASK: "bigint", BYTES: "number", BITS: "number" }));
    }(e), e;
  }
  return $s(t3, { isLE: n });
}
function xI(t3, e, n = {}, r) {
  if (r === void 0 && (r = t3 === "edwards"), !e || typeof e != "object") throw Error(`expected valid ${t3} CURVE object`);
  for (const o of ["p", "n", "h"]) {
    const f = e[o];
    if (!(typeof f == "bigint" && f > Bu)) throw Error(`CURVE.${o} must be positive bigint`);
  }
  const s = u5(e.p, n.Fp, r), i = u5(e.n, n.Fn, r), a = ["Gx", "Gy", "a", t3 === "weierstrass" ? "b" : "d"];
  for (const o of a) if (!s.isValid(e[o])) throw Error(`CURVE.${o} must be valid field element of CURVE.Fp`);
  return { CURVE: e = Object.freeze(Object.assign({}, e)), Fp: s, Fn: i };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const c5 = (t3, e) => (t3 + (t3 >= 0 ? e : -e) / _I) / e;
function o3(t3) {
  if (!["compact", "recovered", "der"].includes(t3)) throw Error('Signature format must be "compact", "recovered", or "der"');
  return t3;
}
function Zm(t3, e) {
  const n = {};
  for (let r of Object.keys(e)) n[r] = t3[r] === void 0 ? e[r] : t3[r];
  return o0(n.lowS, "lowS"), o0(n.prehash, "prehash"), n.format !== void 0 && o3(n.format), n;
}
const Vo = { Err: class extends Error {
  constructor(t3 = "") {
    super(t3);
  }
}, _tlv: { encode: (t3, e) => {
  const { Err: n } = Vo;
  if (t3 < 0 || t3 > 256) throw new n("tlv.encode: wrong tag");
  if (1 & e.length) throw new n("tlv.encode: unpadded data");
  const r = e.length / 2, s = Od(r);
  if (s.length / 2 & 128) throw new n("tlv.encode: long form length too big");
  const i = r > 127 ? Od(s.length / 2 | 128) : "";
  return Od(t3) + i + s + e;
}, decode(t3, e) {
  const { Err: n } = Vo;
  let r = 0;
  if (t3 < 0 || t3 > 256) throw new n("tlv.encode: wrong tag");
  if (e.length < 2 || e[r++] !== t3) throw new n("tlv.decode: wrong tlv");
  const s = e[r++];
  let i = 0;
  if (128 & s) {
    const o = 127 & s;
    if (!o) throw new n("tlv.decode(long): indefinite length not supported");
    if (o > 4) throw new n("tlv.decode(long): byte length is too big");
    const f = e.subarray(r, r + o);
    if (f.length !== o) throw new n("tlv.decode: length bytes not complete");
    if (f[0] === 0) throw new n("tlv.decode(long): zero leftmost byte");
    for (const c of f) i = i << 8 | c;
    if (r += o, i < 128) throw new n("tlv.decode(long): not minimal encoding");
  } else i = s;
  const a = e.subarray(r, r + i);
  if (a.length !== i) throw new n("tlv.decode: wrong value length");
  return { v: a, l: e.subarray(r + i) };
} }, _int: { encode(t3) {
  const { Err: e } = Vo;
  if (t3 < Wo) throw new e("integer: negative integers are not allowed");
  let n = Od(t3);
  if (8 & Number.parseInt(n[0], 16) && (n = "00" + n), 1 & n.length) throw new e("unexpected DER parsing assertion: unpadded hex");
  return n;
}, decode(t3) {
  const { Err: e } = Vo;
  if (128 & t3[0]) throw new e("invalid signature integer: negative");
  if (t3[0] === 0 && !(128 & t3[1])) throw new e("invalid signature integer: unnecessary leading zero");
  return _g(t3);
} }, toSig(t3) {
  const { Err: e, _int: n, _tlv: r } = Vo, s = Rn("signature", t3), { v: i, l: a } = r.decode(48, s);
  if (a.length) throw new e("invalid signature: left bytes after parsing");
  const { v: o, l: f } = r.decode(2, i), { v: c, l } = r.decode(2, f);
  if (l.length) throw new e("invalid signature: left bytes after parsing");
  return { r: n.decode(o), s: n.decode(c) };
}, hexFromSig(t3) {
  const { _tlv: e, _int: n } = Vo, r = e.encode(2, n.encode(t3.r)) + e.encode(2, n.encode(t3.s));
  return e.encode(48, r);
} }, Wo = BigInt(0), Z0 = BigInt(1), _I = BigInt(2), qd = BigInt(3), jU = BigInt(4);
function j0(t3, e) {
  const { BYTES: n } = t3;
  let r;
  if (typeof e == "bigint") r = e;
  else {
    let s = Rn("private key", e);
    try {
      r = t3.fromBytes(s);
    } catch {
      throw Error(`invalid private key: expected ui8a of size ${n}, got ${typeof e}`);
    }
  }
  if (!t3.isValidNot0(r)) throw Error("invalid private key: out of range [1..N-1]");
  return r;
}
function XU(t3, e = {}) {
  const n = xI("weierstrass", t3, e), { Fp: r, Fn: s } = n;
  let i = n.CURVE;
  const { h: a, n: o } = i;
  Gu(e, {}, { allowInfinityPoint: "boolean", clearCofactor: "function", isTorsionFree: "function", fromBytes: "function", toBytes: "function", endo: "object", wrapPrivateKey: "boolean" });
  const { endo: f } = e;
  if (f && (!r.is0(i.a) || typeof f.beta != "bigint" || !Array.isArray(f.basises))) throw Error('invalid endo: expected "beta": bigint and "basises": array');
  const c = BI(r, s);
  function l() {
    if (!r.isOdd) throw Error("compression is not supported: Field does not have .isOdd()");
  }
  const h = e.toBytes || function(L, B, u) {
    const { x: p, y: d } = B.toAffine(), y = r.toBytes(p);
    return o0(u, "isCompressed"), u ? (l(), Ba(EI(!r.isOdd(d)), y)) : Ba(Uint8Array.of(4), y, r.toBytes(d));
  }, m = e.fromBytes || function(L) {
    Ia(L, void 0, "Point");
    const { publicKey: B, publicKeyUncompressed: u } = c, p = L.length, d = L[0], y = L.subarray(1);
    if (p !== B || d !== 2 && d !== 3) {
      if (p === u && d === 4) {
        const w = r.BYTES, E = r.fromBytes(y.subarray(0, w)), M = r.fromBytes(y.subarray(w, 2 * w));
        if (!b(E, M)) throw Error("bad point: is not on curve");
        return { x: E, y: M };
      }
      throw Error(`bad point: got length ${p}, expected compressed=${B} or uncompressed=${u}`);
    }
    {
      const w = r.fromBytes(y);
      if (!r.isValid(w)) throw Error("bad point: is not on curve, wrong x");
      const E = v(w);
      let M;
      try {
        M = r.sqrt(E);
      } catch (x) {
        const g = x instanceof Error ? ": " + x.message : "";
        throw Error("bad point: is not on curve, sqrt error" + g);
      }
      return l(), !(1 & ~d) !== r.isOdd(M) && (M = r.neg(M)), { x: w, y: M };
    }
  };
  function v(L) {
    const B = r.sqr(L), u = r.mul(B, L);
    return r.add(r.add(u, r.mul(L, i.a)), i.b);
  }
  function b(L, B) {
    const u = r.sqr(B), p = v(L);
    return r.eql(u, p);
  }
  if (!b(i.Gx, i.Gy)) throw Error("bad curve params: generator point");
  const A = r.mul(r.pow(i.a, qd), jU), _ = r.mul(r.sqr(i.b), BigInt(27));
  if (r.is0(r.add(A, _))) throw Error("bad curve params: a or b");
  function C(L, B, u = false) {
    if (!r.isValid(B) || u && r.is0(B)) throw Error("bad point coordinate " + L);
    return B;
  }
  function I(L) {
    if (!(L instanceof Q)) throw Error("ProjectivePoint expected");
  }
  function S(L) {
    if (!f || !f.basises) throw Error("no endo");
    return function(B, u, p) {
      const [[d, y], [w, E]] = u, M = c5(E * B, p), x = c5(-y * B, p);
      let g = B - M * d - x * w, k = -M * y - x * E;
      const T = g < Wo, O = k < Wo;
      T && (g = -g), O && (k = -k);
      const K = nd(Math.ceil(Xk(p) / 2)) + Z0;
      if (g < Wo || g >= K || k < Wo || k >= K) throw Error("splitScalar (endomorphism): failed, k=" + B);
      return { k1neg: T, k1: g, k2neg: O, k2: k };
    }(L, f.basises, s.ORDER);
  }
  const $ = m1((L, B) => {
    const { X: u, Y: p, Z: d } = L;
    if (r.eql(d, r.ONE)) return { x: u, y: p };
    const y = L.is0();
    B == null && (B = y ? r.ONE : r.inv(d));
    const w = r.mul(u, B), E = r.mul(p, B), M = r.mul(d, B);
    if (y) return { x: r.ZERO, y: r.ZERO };
    if (!r.eql(M, r.ONE)) throw Error("invZ was invalid");
    return { x: w, y: E };
  }), F = m1((L) => {
    if (L.is0()) {
      if (e.allowInfinityPoint && !r.is0(L.Y)) return;
      throw Error("bad point: ZERO");
    }
    const { x: B, y: u } = L.toAffine();
    if (!r.isValid(B) || !r.isValid(u)) throw Error("bad point: x or y not field elements");
    if (!b(B, u)) throw Error("bad point: equation left != right");
    if (!L.isTorsionFree()) throw Error("bad point: not in prime-order subgroup");
    return true;
  });
  function U(L, B, u, p, d) {
    return u = new Q(r.mul(u.X, L), u.Y, u.Z), B = v1(p, B), u = v1(d, u), B.add(u);
  }
  class Q {
    constructor(B, u, p) {
      this.X = C("x", B), this.Y = C("y", u, true), this.Z = C("z", p), Object.freeze(this);
    }
    static CURVE() {
      return i;
    }
    static fromAffine(B) {
      const { x: u, y: p } = B || {};
      if (!B || !r.isValid(u) || !r.isValid(p)) throw Error("invalid affine point");
      if (B instanceof Q) throw Error("projective point not allowed");
      return r.is0(u) && r.is0(p) ? Q.ZERO : new Q(u, p, r.ONE);
    }
    static fromBytes(B) {
      const u = Q.fromAffine(m(Ia(B, void 0, "point")));
      return u.assertValidity(), u;
    }
    static fromHex(B) {
      return Q.fromBytes(Rn("pointHex", B));
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    precompute(B = 8, u = true) {
      return N.createCache(this, B), u || this.multiply(qd), this;
    }
    assertValidity() {
      F(this);
    }
    hasEvenY() {
      const { y: B } = this.toAffine();
      if (!r.isOdd) throw Error("Field doesn't support isOdd");
      return !r.isOdd(B);
    }
    equals(B) {
      I(B);
      const { X: u, Y: p, Z: d } = this, { X: y, Y: w, Z: E } = B, M = r.eql(r.mul(u, E), r.mul(y, d)), x = r.eql(r.mul(p, E), r.mul(w, d));
      return M && x;
    }
    negate() {
      return new Q(this.X, r.neg(this.Y), this.Z);
    }
    double() {
      const { a: B, b: u } = i, p = r.mul(u, qd), { X: d, Y: y, Z: w } = this;
      let E = r.ZERO, M = r.ZERO, x = r.ZERO, g = r.mul(d, d), k = r.mul(y, y), T = r.mul(w, w), O = r.mul(d, y);
      return O = r.add(O, O), x = r.mul(d, w), x = r.add(x, x), E = r.mul(B, x), M = r.mul(p, T), M = r.add(E, M), E = r.sub(k, M), M = r.add(k, M), M = r.mul(E, M), E = r.mul(O, E), x = r.mul(p, x), T = r.mul(B, T), O = r.sub(g, T), O = r.mul(B, O), O = r.add(O, x), x = r.add(g, g), g = r.add(x, g), g = r.add(g, T), g = r.mul(g, O), M = r.add(M, g), T = r.mul(y, w), T = r.add(T, T), g = r.mul(T, O), E = r.sub(E, g), x = r.mul(T, k), x = r.add(x, x), x = r.add(x, x), new Q(E, M, x);
    }
    add(B) {
      I(B);
      const { X: u, Y: p, Z: d } = this, { X: y, Y: w, Z: E } = B;
      let M = r.ZERO, x = r.ZERO, g = r.ZERO;
      const k = i.a, T = r.mul(i.b, qd);
      let O = r.mul(u, y), K = r.mul(p, w), Y = r.mul(d, E), J = r.add(u, p), G = r.add(y, w);
      J = r.mul(J, G), G = r.add(O, K), J = r.sub(J, G), G = r.add(u, d);
      let X = r.add(y, E);
      return G = r.mul(G, X), X = r.add(O, Y), G = r.sub(G, X), X = r.add(p, d), M = r.add(w, E), X = r.mul(X, M), M = r.add(K, Y), X = r.sub(X, M), g = r.mul(k, G), M = r.mul(T, Y), g = r.add(M, g), M = r.sub(K, g), g = r.add(K, g), x = r.mul(M, g), K = r.add(O, O), K = r.add(K, O), Y = r.mul(k, Y), G = r.mul(T, G), K = r.add(K, Y), Y = r.sub(O, Y), Y = r.mul(k, Y), G = r.add(G, Y), O = r.mul(K, G), x = r.add(x, O), O = r.mul(X, G), M = r.mul(J, M), M = r.sub(M, O), O = r.mul(J, K), g = r.mul(X, g), g = r.add(g, O), new Q(M, x, g);
    }
    subtract(B) {
      return this.add(B.negate());
    }
    is0() {
      return this.equals(Q.ZERO);
    }
    multiply(B) {
      const { endo: u } = e;
      if (!s.isValidNot0(B)) throw Error("invalid scalar: out of range");
      let p, d;
      const y = (w) => N.cached(this, w, (E) => ql(Q, E));
      if (u) {
        const { k1neg: w, k1: E, k2neg: M, k2: x } = S(B), { p: g, f: k } = y(E), { p: T, f: O } = y(x);
        d = k.add(O), p = U(u.beta, g, T, w, M);
      } else {
        const { p: w, f: E } = y(B);
        p = w, d = E;
      }
      return ql(Q, [p, d])[0];
    }
    multiplyUnsafe(B) {
      const { endo: u } = e, p = this;
      if (!s.isValid(B)) throw Error("invalid scalar: out of range");
      if (B === Wo || p.is0()) return Q.ZERO;
      if (B === Z0) return p;
      if (N.hasCache(this)) return this.multiply(B);
      if (u) {
        const { k1neg: d, k1: y, k2neg: w, k2: E } = S(B), { p1: M, p2: x } = function(g, k, T, O) {
          let K = k, Y = g.ZERO, J = g.ZERO;
          for (; T > Bu || O > Bu; ) T & Hl && (Y = Y.add(K)), O & Hl && (J = J.add(K)), K = K.double(), T >>= Hl, O >>= Hl;
          return { p1: Y, p2: J };
        }(Q, p, y, E);
        return U(u.beta, M, x, d, w);
      }
      return N.unsafe(p, B);
    }
    multiplyAndAddUnsafe(B, u, p) {
      const d = this.multiplyUnsafe(u).add(B.multiplyUnsafe(p));
      return d.is0() ? void 0 : d;
    }
    toAffine(B) {
      return $(this, B);
    }
    isTorsionFree() {
      const { isTorsionFree: B } = e;
      return a === Z0 || (B ? B(Q, this) : N.unsafe(this, o).is0());
    }
    clearCofactor() {
      const { clearCofactor: B } = e;
      return a === Z0 ? this : B ? B(Q, this) : this.multiplyUnsafe(a);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(a).is0();
    }
    toBytes(B = true) {
      return o0(B, "isCompressed"), this.assertValidity(), h(Q, this, B);
    }
    toHex(B = true) {
      return jl(this.toBytes(B));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
    get px() {
      return this.X;
    }
    get py() {
      return this.X;
    }
    get pz() {
      return this.Z;
    }
    toRawBytes(B = true) {
      return this.toBytes(B);
    }
    _setWindowSize(B) {
      this.precompute(B);
    }
    static normalizeZ(B) {
      return ql(Q, B);
    }
    static msm(B, u) {
      return wI(Q, s, B, u);
    }
    static fromPrivateKey(B) {
      return Q.BASE.multiply(j0(s, B));
    }
  }
  Q.BASE = new Q(i.Gx, i.Gy, r.ONE), Q.ZERO = new Q(r.ZERO, r.ONE, r.ZERO), Q.Fp = r, Q.Fn = s;
  const P = s.BITS, N = new AI(Q, e.endo ? Math.ceil(P / 2) : P);
  return Q.BASE.precompute(8), Q;
}
function EI(t3) {
  return Uint8Array.of(t3 ? 2 : 3);
}
function BI(t3, e) {
  return { secretKey: e.BYTES, publicKey: 1 + t3.BYTES, publicKeyUncompressed: 1 + 2 * t3.BYTES, publicKeyHasPrefix: true, signature: 2 * e.BYTES };
}
function eL(t3, e = {}) {
  const { Fn: n } = t3, r = e.randomBytes || xg, s = Object.assign(BI(t3.Fp, n), { seed: i5(n.ORDER) });
  function i(l) {
    try {
      return !!j0(n, l);
    } catch {
      return false;
    }
  }
  function a(l = r(s.seed)) {
    return function(h, m, v = false) {
      const b = h.length, A = oI(m), _ = i5(m);
      if (b < 16 || b < _ || b > 1024) throw Error("expected " + _ + "-1024 bytes of input, got " + b);
      const C = ui(v ? f0(h) : _g(h), m - us) + us;
      return v ? uA(C, A) : lA(C, A);
    }(Ia(l, s.seed, "seed"), n.ORDER);
  }
  function o(l, h = true) {
    return t3.BASE.multiply(j0(n, l)).toBytes(h);
  }
  function f(l) {
    if (typeof l == "bigint") return false;
    if (l instanceof t3) return true;
    const { secretKey: h, publicKey: m, publicKeyUncompressed: v } = s;
    if (n.allowedLengths || h === m) return;
    const b = Rn("key", l).length;
    return b === m || b === v;
  }
  return Object.freeze({ getPublicKey: o, getSharedSecret: function(l, h, m = true) {
    if (f(l) === true) throw Error("first arg must be private key");
    if (f(h) === false) throw Error("second arg must be public key");
    const v = j0(n, l);
    return t3.fromHex(h).multiply(v).toBytes(m);
  }, keygen: function(l) {
    const h = a(l);
    return { secretKey: h, publicKey: o(h) };
  }, Point: t3, utils: { isValidSecretKey: i, isValidPublicKey: function(l, h) {
    const { publicKey: m, publicKeyUncompressed: v } = s;
    try {
      const b = l.length;
      return (h !== true || b === m) && (h !== false || b === v) && !!t3.fromBytes(l);
    } catch {
      return false;
    }
  }, randomSecretKey: a, isValidPrivateKey: i, randomPrivateKey: a, normPrivateKeyToScalar: (l) => j0(n, l), precompute: (l = 8, h = t3.BASE) => h.precompute(l, false) }, lengths: s });
}
function tL(t3, e, n = {}) {
  Wk(e), Gu(n, {}, { hmac: "function", lowS: "boolean", randomBytes: "function", bits2int: "function", bits2int_modN: "function" });
  const r = n.randomBytes || xg, s = n.hmac || ((P, ...N) => vI(e, P, Ba(...N))), { Fp: i, Fn: a } = t3, { ORDER: o, BITS: f } = a, { keygen: c, getPublicKey: l, getSharedSecret: h, utils: m, lengths: v } = eL(t3, n), b = { prehash: false, lowS: typeof n.lowS == "boolean" && n.lowS, format: void 0, extraEntropy: false }, A = "compact";
  function _(P) {
    return P > o >> Z0;
  }
  function C(P, N) {
    if (!a.isValidNot0(N)) throw Error(`invalid signature ${P}: out of range 1..Point.Fn.ORDER`);
    return N;
  }
  class I {
    constructor(N, L, B) {
      this.r = C("r", N), this.s = C("s", L), B != null && (this.recovery = B), Object.freeze(this);
    }
    static fromBytes(N, L = A) {
      let B;
      if (function(y, w) {
        o3(w);
        const E = v.signature;
        Ia(y, w === "compact" ? E : w === "recovered" ? E + 1 : void 0, w + " signature");
      }(N, L), L === "der") {
        const { r: y, s: w } = Vo.toSig(Ia(N));
        return new I(y, w);
      }
      L === "recovered" && (B = N[0], L = "compact", N = N.subarray(1));
      const u = a.BYTES, p = N.subarray(0, u), d = N.subarray(u, 2 * u);
      return new I(a.fromBytes(p), a.fromBytes(d), B);
    }
    static fromHex(N, L) {
      return this.fromBytes(g1(N), L);
    }
    addRecoveryBit(N) {
      return new I(this.r, this.s, N);
    }
    recoverPublicKey(N) {
      const L = i.ORDER, { r: B, s: u, recovery: p } = this;
      if (p == null || ![0, 1, 2, 3].includes(p)) throw Error("recovery id invalid");
      if (o * _I < L && p > 1) throw Error("recovery id is ambiguous for h>1 curve");
      const d = p === 2 || p === 3 ? B + o : B;
      if (!i.isValid(d)) throw Error("recovery id 2 or 3 invalid");
      const y = i.toBytes(d), w = t3.fromBytes(Ba(EI(!(1 & p)), y)), E = a.inv(d), M = $(Rn("msgHash", N)), x = a.create(-M * E), g = a.create(u * E), k = t3.BASE.multiplyUnsafe(x).add(w.multiplyUnsafe(g));
      if (k.is0()) throw Error("point at infinify");
      return k.assertValidity(), k;
    }
    hasHighS() {
      return _(this.s);
    }
    toBytes(N = A) {
      if (o3(N), N === "der") return g1(Vo.hexFromSig(this));
      const L = a.toBytes(this.r), B = a.toBytes(this.s);
      if (N === "recovered") {
        if (this.recovery == null) throw Error("recovery bit must be present");
        return Ba(Uint8Array.of(this.recovery), L, B);
      }
      return Ba(L, B);
    }
    toHex(N) {
      return jl(this.toBytes(N));
    }
    assertValidity() {
    }
    static fromCompact(N) {
      return I.fromBytes(Rn("sig", N), "compact");
    }
    static fromDER(N) {
      return I.fromBytes(Rn("sig", N), "der");
    }
    normalizeS() {
      return this.hasHighS() ? new I(this.r, a.neg(this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return this.toBytes("der");
    }
    toDERHex() {
      return jl(this.toBytes("der"));
    }
    toCompactRawBytes() {
      return this.toBytes("compact");
    }
    toCompactHex() {
      return jl(this.toBytes("compact"));
    }
  }
  const S = n.bits2int || function(P) {
    if (P.length > 8192) throw Error("input is too large");
    const N = _g(P), L = 8 * P.length - f;
    return L > 0 ? N >> BigInt(L) : N;
  }, $ = n.bits2int_modN || function(P) {
    return a.create(S(P));
  }, F = nd(f);
  function U(P) {
    return $h("num < 2^" + f, P, Wo, F), a.toBytes(P);
  }
  function Q(P, N) {
    return Ia(P, void 0, "message"), N ? Ia(e(P), void 0, "prehashed message") : P;
  }
  return Object.freeze({ keygen: c, getPublicKey: l, getSharedSecret: h, utils: m, lengths: v, Point: t3, sign: function(P, N, L = {}) {
    P = Rn("message", P);
    const { seed: B, k2sig: u } = function(d, y, w) {
      if (["recovered", "canonical"].some((Y) => Y in w)) throw Error("sign() legacy options not supported");
      const { lowS: E, prehash: M, extraEntropy: x } = Zm(w, b);
      d = Q(d, M);
      const g = $(d), k = j0(a, y), T = [U(k), U(g)];
      if (x != null && x !== false) {
        const Y = x === true ? r(v.secretKey) : x;
        T.push(Rn("extraEntropy", Y));
      }
      const O = Ba(...T), K = g;
      return { seed: O, k2sig: function(Y) {
        const J = S(Y);
        if (!a.isValidNot0(J)) return;
        const G = a.inv(J), X = t3.BASE.multiply(J).toAffine(), ie = a.create(X.x);
        if (ie === Wo) return;
        const de = a.create(G * a.create(K + ie * k));
        if (de === Wo) return;
        let se = (X.x === ie ? 0 : 2) | Number(X.y & Z0), te = de;
        return E && _(de) && (te = a.neg(de), se ^= 1), new I(ie, te, se);
      } };
    }(P, N, L);
    return function(d, y, w) {
      if (typeof d != "number" || d < 2) throw Error("hashLen must be a number");
      if (typeof y != "number" || y < 2) throw Error("qByteLen must be a number");
      if (typeof w != "function") throw Error("hmacFn must be a function");
      const E = (J) => new Uint8Array(J), M = (J) => Uint8Array.of(J);
      let x = E(d), g = E(d), k = 0;
      const T = () => {
        x.fill(1), g.fill(0), k = 0;
      }, O = (...J) => w(g, x, ...J), K = (J = E(0)) => {
        g = O(M(0), J), x = O(), J.length !== 0 && (g = O(M(1), J), x = O());
      }, Y = () => {
        if (k++ >= 1e3) throw Error("drbg: tried 1000 values");
        let J = 0;
        const G = [];
        for (; J < y; ) {
          x = O();
          const X = x.slice();
          G.push(X), J += x.length;
        }
        return Ba(...G);
      };
      return (J, G) => {
        let X;
        for (T(), K(J); !(X = G(Y())); ) K();
        return T(), X;
      };
    }(e.outputLen, a.BYTES, s)(B, u);
  }, verify: function(P, N, L, B = {}) {
    const { lowS: u, prehash: p, format: d } = Zm(B, b);
    if (L = Rn("publicKey", L), N = Q(Rn("message", N), p), "strict" in B) throw Error("options.strict was renamed to lowS");
    const y = d === void 0 ? function(w) {
      let E;
      const M = typeof w == "string" || td(w), x = !M && w !== null && typeof w == "object" && typeof w.r == "bigint" && typeof w.s == "bigint";
      if (!M && !x) throw Error("invalid signature, expected Uint8Array, hex string or Signature instance");
      if (x) E = new I(w.r, w.s);
      else if (M) {
        try {
          E = I.fromBytes(Rn("sig", w), "der");
        } catch (g) {
          if (!(g instanceof Vo.Err)) throw g;
        }
        if (!E) try {
          E = I.fromBytes(Rn("sig", w), "compact");
        } catch {
          return false;
        }
      }
      return E || false;
    }(P) : I.fromBytes(Rn("sig", P), d);
    if (y === false) return false;
    try {
      const w = t3.fromBytes(L);
      if (u && y.hasHighS()) return false;
      const { r: E, s: M } = y, x = $(N), g = a.inv(M), k = a.create(x * g), T = a.create(E * g), O = t3.BASE.multiplyUnsafe(k).add(w.multiplyUnsafe(T));
      return O.is0() ? false : a.create(O.x) === E;
    } catch {
      return false;
    }
  }, recoverPublicKey: function(P, N, L = {}) {
    const { prehash: B } = Zm(L, b);
    return N = Q(N, B), I.fromBytes(P, "recovered").recoverPublicKey(N).toBytes();
  }, Signature: I, hash: e });
}
function rL(t3) {
  const { CURVE: e, curveOpts: n } = function(s) {
    const i = { a: s.a, b: s.b, p: s.Fp.ORDER, n: s.n, h: s.h, Gx: s.Gx, Gy: s.Gy }, a = s.Fp;
    let o = s.allowedPrivateKeyLengths ? Array.from(new Set(s.allowedPrivateKeyLengths.map((f) => Math.ceil(f / 2)))) : void 0;
    return { CURVE: i, curveOpts: { Fp: a, Fn: $s(i.n, { BITS: s.nBitLength, allowedLengths: o, modFromBytes: s.wrapPrivateKey }), allowInfinityPoint: s.allowInfinityPoint, endo: s.endo, isTorsionFree: s.isTorsionFree, clearCofactor: s.clearCofactor, fromBytes: s.fromBytes, toBytes: s.toBytes } };
  }(t3), r = { hmac: t3.hmac, randomBytes: t3.randomBytes, lowS: t3.lowS, bits2int: t3.bits2int, bits2int_modN: t3.bits2int_modN };
  return { CURVE: e, curveOpts: n, hash: t3.hash, ecdsaOpts: r };
}
function nL(t3) {
  const { CURVE: e, curveOpts: n, hash: r, ecdsaOpts: s } = rL(t3);
  return function(i, a) {
    const o = a.Point;
    return Object.assign({}, a, { ProjectivePoint: o, CURVE: Object.assign({}, i, aI(o.Fn.ORDER, o.Fn.BITS)) });
  }(t3, tL(XU(e, n), r, s));
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function g0(t3, e) {
  const n = (r) => nL({ ...t3, hash: r });
  return { ...n(e), create: n };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const CI = { p: BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"), n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"), h: BigInt(1), a: BigInt("0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc"), b: BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"), Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"), Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5") }, kI = { p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"), n: BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"), h: BigInt(1), a: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc"), b: BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"), Gx: BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"), Gy: BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f") }, II = { p: BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), n: BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"), h: BigInt(1), a: BigInt("0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc"), b: BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"), Gx: BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"), Gy: BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650") }, iL = $s(CI.p), sL = $s(kI.p), aL = $s(II.p), oL = g0({ ...CI, Fp: iL, lowS: false }, hA), fL = g0({ ...kI, Fp: sL, lowS: false }, gI), lL = g0({ ...II, Fp: aL, lowS: false, allowedPrivateKeyLengths: [130, 131, 132] }, pI), uL = BigInt(0), wc = BigInt(1), cL = BigInt(2), hL = BigInt(7), dL = BigInt(256), pL = BigInt(113), SI = [], MI = [], $I = [];
for (let t3 = 0, e = wc, n = 1, r = 0; t3 < 24; t3++) {
  [n, r] = [r, (2 * n + 3 * r) % 5], SI.push(2 * (5 * r + n)), MI.push((t3 + 1) * (t3 + 2) / 2 % 64);
  let s = uL;
  for (let i = 0; i < 7; i++) e = (e << wc ^ (e >> hL) * pL) % dL, e & cL && (s ^= wc << (wc << BigInt(i)) - wc);
  $I.push(s);
}
const TI = uI($I, true), gL = TI[0], mL = TI[1], h5 = (t3, e, n) => n > 32 ? ((r, s, i) => s << i - 32 | r >>> 64 - i)(t3, e, n) : ((r, s, i) => r << i | s >>> 32 - i)(t3, e, n), d5 = (t3, e, n) => n > 32 ? ((r, s, i) => r << i - 32 | s >>> 64 - i)(t3, e, n) : ((r, s, i) => s << i | r >>> 32 - i)(t3, e, n);
class Eg extends oA {
  constructor(e, n, r, s = false, i = 24) {
    if (super(), this.pos = 0, this.posOut = 0, this.finished = false, this.destroyed = false, this.enableXOF = false, this.blockLen = e, this.suffix = n, this.outputLen = r, this.enableXOF = s, this.rounds = i, Mh(r), !(0 < e && e < 200)) throw Error("only keccak-f1600 function is supported");
    var a;
    this.state = new Uint8Array(200), this.state32 = (a = this.state, new Uint32Array(a.buffer, a.byteOffset, Math.floor(a.byteLength / 4)));
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    Y6(this.state32), function(e, n = 24) {
      const r = new Uint32Array(10);
      for (let s = 24 - n; s < 24; s++) {
        for (let o = 0; o < 10; o++) r[o] = e[o] ^ e[o + 10] ^ e[o + 20] ^ e[o + 30] ^ e[o + 40];
        for (let o = 0; o < 10; o += 2) {
          const f = (o + 8) % 10, c = (o + 2) % 10, l = r[c], h = r[c + 1], m = h5(l, h, 1) ^ r[f], v = d5(l, h, 1) ^ r[f + 1];
          for (let b = 0; b < 50; b += 10) e[o + b] ^= m, e[o + b + 1] ^= v;
        }
        let i = e[2], a = e[3];
        for (let o = 0; o < 24; o++) {
          const f = MI[o], c = h5(i, a, f), l = d5(i, a, f), h = SI[o];
          i = e[h], a = e[h + 1], e[h] = c, e[h + 1] = l;
        }
        for (let o = 0; o < 50; o += 10) {
          for (let f = 0; f < 10; f++) r[f] = e[o + f];
          for (let f = 0; f < 10; f++) e[o + f] ^= ~r[(f + 2) % 10] & r[(f + 4) % 10];
        }
        e[0] ^= gL[s], e[1] ^= mL[s];
      }
      fa(r);
    }(this.state32, this.rounds), Y6(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    Eu(this), Eo(e = rd(e));
    const { blockLen: n, state: r } = this, s = e.length;
    for (let i = 0; i < s; ) {
      const a = Math.min(n - this.pos, s - i);
      for (let o = 0; o < a; o++) r[this.pos++] ^= e[i++];
      this.pos === n && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = true;
    const { state: e, suffix: n, pos: r, blockLen: s } = this;
    e[r] ^= n, 128 & n && r === s - 1 && this.keccak(), e[s - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    Eu(this, false), Eo(e), this.finish();
    const n = this.state, { blockLen: r } = this;
    for (let s = 0, i = e.length; s < i; ) {
      this.posOut >= r && this.keccak();
      const a = Math.min(r - this.posOut, i - s);
      e.set(n.subarray(this.posOut, this.posOut + a), s), this.posOut += a, s += a;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF) throw Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return Mh(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (Jk(e, this), this.finished) throw Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true, fa(this.state);
  }
  _cloneInto(e) {
    const { blockLen: n, suffix: r, outputLen: s, rounds: i, enableXOF: a } = this;
    return e || (e = new Eg(n, r, s, a, i)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = i, e.suffix = r, e.outputLen = s, e.enableXOF = a, e.destroyed = this.destroyed, e;
  }
}
const DI = (t3, e, n) => df(() => new Eg(e, t3, n)), vL = DI(6, 136, 32), yL = DI(6, 72, 64), bL = (t3, e, n) => function(r) {
  const s = (a, o) => r(o).update(rd(a)).digest(), i = r({});
  return s.outputLen = i.outputLen, s.blockLen = i.blockLen, s.create = (a) => r(a), s;
}((r = {}) => new Eg(e, t3, r.dkLen === void 0 ? n : r.dkLen, true)), AL = bL(31, 136, 32), wf = BigInt(0), mi = BigInt(1), jm = BigInt(2), wL = BigInt(8);
function RI(t3, e = {}) {
  const n = xI("edwards", t3, e, e.FpFnLE), { Fp: r, Fn: s } = n;
  let i = n.CURVE;
  const { h: a } = i;
  Gu(e, {}, { uvRatio: "function" });
  const o = jm << BigInt(8 * s.BYTES) - mi, f = (_) => r.create(_), c = e.uvRatio || ((_, C) => {
    try {
      return { isValid: true, value: r.sqrt(r.div(_, C)) };
    } catch {
      return { isValid: false, value: wf };
    }
  });
  if (!function(_, C, I, S) {
    const $ = _.sqr(I), F = _.sqr(S), U = _.add(_.mul(C.a, $), F), Q = _.add(_.ONE, _.mul(C.d, _.mul($, F)));
    return _.eql(U, Q);
  }(r, i, i.Gx, i.Gy)) throw Error("bad curve params: generator point");
  function l(_, C, I = false) {
    return $h("coordinate " + _, C, I ? mi : wf, o), C;
  }
  function h(_) {
    if (!(_ instanceof b)) throw Error("ExtendedPoint expected");
  }
  const m = m1((_, C) => {
    const { X: I, Y: S, Z: $ } = _, F = _.is0();
    C == null && (C = F ? wL : r.inv($));
    const U = f(I * C), Q = f(S * C), P = r.mul($, C);
    if (F) return { x: wf, y: mi };
    if (P !== mi) throw Error("invZ was invalid");
    return { x: U, y: Q };
  }), v = m1((_) => {
    const { a: C, d: I } = i;
    if (_.is0()) throw Error("bad point: ZERO");
    const { X: S, Y: $, Z: F, T: U } = _, Q = f(S * S), P = f($ * $), N = f(F * F), L = f(N * N), B = f(Q * C);
    if (f(N * f(B + P)) !== f(L + f(I * f(Q * P)))) throw Error("bad point: equation left != right (1)");
    if (f(S * $) !== f(F * U)) throw Error("bad point: equation left != right (2)");
    return true;
  });
  class b {
    constructor(C, I, S, $) {
      this.X = l("x", C), this.Y = l("y", I), this.Z = l("z", S, true), this.T = l("t", $), Object.freeze(this);
    }
    static CURVE() {
      return i;
    }
    static fromAffine(C) {
      if (C instanceof b) throw Error("extended point not allowed");
      const { x: I, y: S } = C || {};
      return l("x", I), l("y", S), new b(I, S, mi, f(I * S));
    }
    static fromBytes(C, I = false) {
      const S = r.BYTES, { a: $, d: F } = i;
      C = X6(Ia(C, S, "point")), o0(I, "zip215");
      const U = X6(C), Q = C[S - 1];
      U[S - 1] = -129 & Q;
      const P = f0(U), N = I ? o : r.ORDER;
      $h("point.y", P, wf, N);
      const L = f(P * P), B = f(L - mi), u = f(F * L - $);
      let { isValid: p, value: d } = c(B, u);
      if (!p) throw Error("bad point: invalid y coordinate");
      const y = (d & mi) === mi, w = !!(128 & Q);
      if (!I && d === wf && w) throw Error("bad point: x=0 and x_0=1");
      return w !== y && (d = f(-d)), b.fromAffine({ x: d, y: P });
    }
    static fromHex(C, I = false) {
      return b.fromBytes(Rn("point", C), I);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    precompute(C = 8, I = true) {
      return A.createCache(this, C), I || this.multiply(jm), this;
    }
    assertValidity() {
      v(this);
    }
    equals(C) {
      h(C);
      const { X: I, Y: S, Z: $ } = this, { X: F, Y: U, Z: Q } = C, P = f(I * Q), N = f(F * $), L = f(S * Q), B = f(U * $);
      return P === N && L === B;
    }
    is0() {
      return this.equals(b.ZERO);
    }
    negate() {
      return new b(f(-this.X), this.Y, this.Z, f(-this.T));
    }
    double() {
      const { a: C } = i, { X: I, Y: S, Z: $ } = this, F = f(I * I), U = f(S * S), Q = f(jm * f($ * $)), P = f(C * F), N = I + S, L = f(f(N * N) - F - U), B = P + U, u = B - Q, p = P - U, d = f(L * u), y = f(B * p), w = f(L * p), E = f(u * B);
      return new b(d, y, E, w);
    }
    add(C) {
      h(C);
      const { a: I, d: S } = i, { X: $, Y: F, Z: U, T: Q } = this, { X: P, Y: N, Z: L, T: B } = C, u = f($ * P), p = f(F * N), d = f(Q * S * B), y = f(U * L), w = f(($ + F) * (P + N) - u - p), E = y - d, M = y + d, x = f(p - I * u), g = f(w * E), k = f(M * x), T = f(w * x), O = f(E * M);
      return new b(g, k, O, T);
    }
    subtract(C) {
      return this.add(C.negate());
    }
    multiply(C) {
      if (!s.isValidNot0(C)) throw Error("invalid scalar: expected 1 <= sc < curve.n");
      const { p: I, f: S } = A.cached(this, C, ($) => ql(b, $));
      return ql(b, [I, S])[0];
    }
    multiplyUnsafe(C, I = b.ZERO) {
      if (!s.isValid(C)) throw Error("invalid scalar: expected 0 <= sc < curve.n");
      return C === wf ? b.ZERO : this.is0() || C === mi ? this : A.unsafe(this, C, (S) => ql(b, S), I);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(a).is0();
    }
    isTorsionFree() {
      return A.unsafe(this, i.n).is0();
    }
    toAffine(C) {
      return m(this, C);
    }
    clearCofactor() {
      return a === mi ? this : this.multiplyUnsafe(a);
    }
    toBytes() {
      const { x: C, y: I } = this.toAffine(), S = r.toBytes(I);
      return S[S.length - 1] |= C & mi ? 128 : 0, S;
    }
    toHex() {
      return jl(this.toBytes());
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
    get ex() {
      return this.X;
    }
    get ey() {
      return this.Y;
    }
    get ez() {
      return this.Z;
    }
    get et() {
      return this.T;
    }
    static normalizeZ(C) {
      return ql(b, C);
    }
    static msm(C, I) {
      return wI(b, s, C, I);
    }
    _setWindowSize(C) {
      this.precompute(C);
    }
    toRawBytes() {
      return this.toBytes();
    }
  }
  b.BASE = new b(i.Gx, i.Gy, mi, f(i.Gx * i.Gy)), b.ZERO = new b(wf, mi, mi, wf), b.Fp = r, b.Fn = s;
  const A = new AI(b, s.BITS);
  return b.BASE.precompute(8), b;
}
function xL(t3, e, n = {}) {
  if (typeof e != "function") throw Error('"hash" function param is required');
  Gu(n, {}, { adjustScalarBytes: "function", randomBytes: "function", domain: "function", prehash: "function", mapToCurve: "function" });
  const { prehash: r } = n, { BASE: s, Fp: i, Fn: a } = t3, o = n.randomBytes || xg, f = n.adjustScalarBytes || ((S) => S), c = n.domain || ((S, $, F) => {
    if (o0(F, "phflag"), $.length || F) throw Error("Contexts/pre-hash are not supported");
    return S;
  });
  function l(S) {
    return a.create(f0(S));
  }
  function h(S) {
    const { head: $, prefix: F, scalar: U } = function(N) {
      const L = _.secretKey;
      N = Rn("private key", N, L);
      const B = Rn("hashed private key", e(N), 2 * L), u = f(B.slice(0, L));
      return { head: u, prefix: B.slice(L, 2 * L), scalar: l(u) };
    }(S), Q = s.multiply(U), P = Q.toBytes();
    return { head: $, prefix: F, scalar: U, point: Q, pointBytes: P };
  }
  function m(S) {
    return h(S).pointBytes;
  }
  function v(S = Uint8Array.of(), ...$) {
    const F = Ba(...$);
    return l(e(c(F, Rn("context", S), !!r)));
  }
  const b = { zip215: true }, A = i.BYTES, _ = { secretKey: A, publicKey: A, signature: 2 * A, seed: A };
  function C(S = o(_.seed)) {
    return Ia(S, _.seed, "seed");
  }
  const I = { getExtendedPublicKey: h, randomSecretKey: C, isValidSecretKey: function(S) {
    return td(S) && S.length === a.BYTES;
  }, isValidPublicKey: function(S, $) {
    try {
      return !!t3.fromBytes(S, $);
    } catch {
      return false;
    }
  }, toMontgomery(S) {
    const { y: $ } = t3.fromBytes(S), F = _.publicKey, U = F === 32;
    if (!U && F !== 57) throw Error("only defined for 25519 and 448");
    const Q = U ? i.div(mi + $, mi - $) : i.div($ - mi, $ + mi);
    return i.toBytes(Q);
  }, toMontgomerySecret(S) {
    const $ = _.secretKey;
    Ia(S, $);
    const F = e(S.subarray(0, $));
    return f(F).subarray(0, $);
  }, randomPrivateKey: C, precompute: (S = 8, $ = t3.BASE) => $.precompute(S, false) };
  return Object.freeze({ keygen: function(S) {
    const $ = I.randomSecretKey(S);
    return { secretKey: $, publicKey: m($) };
  }, getPublicKey: m, sign: function(S, $, F = {}) {
    S = Rn("message", S), r && (S = r(S));
    const { prefix: U, scalar: Q, pointBytes: P } = h($), N = v(F.context, U, S), L = s.multiply(N).toBytes(), B = v(F.context, L, P, S), u = a.create(N + B * Q);
    if (!a.isValid(u)) throw Error("sign failed: invalid s");
    return Ia(Ba(L, a.toBytes(u)), _.signature, "result");
  }, verify: function(S, $, F, U = b) {
    const { context: Q, zip215: P } = U, N = _.signature;
    S = Rn("signature", S, N), $ = Rn("message", $), F = Rn("publicKey", F, _.publicKey), P !== void 0 && o0(P, "zip215"), r && ($ = r($));
    const L = N / 2, B = S.subarray(0, L), u = f0(S.subarray(L, N));
    let p, d, y;
    try {
      p = t3.fromBytes(F, P), d = t3.fromBytes(B, P), y = s.multiplyUnsafe(u);
    } catch {
      return false;
    }
    if (!P && p.isSmallOrder()) return false;
    const w = v(Q, d.toBytes(), p.toBytes(), $);
    return d.add(p.multiplyUnsafe(w)).subtract(y).clearCofactor().is0();
  }, utils: I, Point: t3, lengths: _ });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const xc = BigInt(0), T0 = BigInt(1), zd = BigInt(2);
function _L(t3) {
  const e = (Gu(n = t3, { adjustScalarBytes: "function", powPminus2: "function" }), Object.freeze({ ...n }));
  var n;
  const { P: r, type: s, adjustScalarBytes: i, powPminus2: a, randomBytes: o } = e, f = s === "x25519";
  if (!f && s !== "x448") throw Error("invalid type");
  const c = o || xg, l = f ? 255 : 448, h = f ? 32 : 56, m = BigInt(f ? 9 : 5), v = BigInt(f ? 121665 : 39081), b = f ? zd ** BigInt(254) : zd ** BigInt(447), A = f ? BigInt(8) * zd ** BigInt(251) - T0 : BigInt(4) * zd ** BigInt(445) - T0, _ = b + A + T0, C = (N) => ui(N, r), I = S(m);
  function S(N) {
    return uA(C(N), h);
  }
  function $(N, L) {
    const B = function(u, p) {
      $h("u", u, xc, r), $h("scalar", p, b, _);
      const d = p, y = u;
      let w = T0, E = xc, M = u, x = T0, g = xc;
      for (let T = BigInt(l - 1); T >= xc; T--) {
        const O = d >> T & T0;
        g ^= O, { x_2: w, x_3: M } = U(g, w, M), { x_2: E, x_3: x } = U(g, E, x), g = O;
        const K = w + E, Y = C(K * K), J = w - E, G = C(J * J), X = Y - G, ie = M + x, de = C((M - x) * K), se = C(ie * J), te = de + se, le = de - se;
        M = C(te * te), x = C(y * C(le * le)), w = C(Y * G), E = C(X * (Y + C(v * X)));
      }
      ({ x_2: w, x_3: M } = U(g, w, M)), { x_2: E, x_3: x } = U(g, E, x);
      const k = a(E);
      return C(w * k);
    }(function(u) {
      const p = Rn("u coordinate", u, h);
      return f && (p[31] &= 127), C(f0(p));
    }(L), function(u) {
      return f0(i(Rn("scalar", u, h)));
    }(N));
    if (B === xc) throw Error("invalid private or public key received");
    return S(B);
  }
  function F(N) {
    return $(N, I);
  }
  function U(N, L, B) {
    const u = C(N * (L - B));
    return { x_2: L = C(L - u), x_3: B = C(B + u) };
  }
  const Q = { secretKey: h, publicKey: h, seed: h }, P = (N = c(h)) => (Eo(N, Q.seed), N);
  return { keygen: function(N) {
    const L = P(N);
    return { secretKey: L, publicKey: F(L) };
  }, getSharedSecret: (N, L) => $(N, L), getPublicKey: (N) => F(N), scalarMult: $, scalarMultBase: F, utils: { randomSecretKey: P, randomPrivateKey: P }, GuBytes: I.slice(), lengths: Q };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const m0 = { p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), n: BigInt("0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffff7cca23e9c44edb49aed63690216cc2728dc58f552378c292ab5844f3"), h: BigInt(4), a: BigInt(1), d: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffffffffffffffffffffffffffffffffffffffffffffffff6756"), Gx: BigInt("0x4f1970c66bed0ded221d15a622bf36da9e146570470f1767ea6de324a3d3a46412ae1af72ab66511433b80e18b00938e2626a82bc70cc05e"), Gy: BigInt("0x693f46716eb6bc248876203756c9c7624bea73736ca3984087789c1e05a0c2d73ad3ff1ce67c39c4fdbd132c4ed7c8ad9808795bf230fa14") }, EL = Object.assign({}, m0, { d: BigInt("0xd78b4bdc7f0daf19f24f38c29373a2ccad46157242a50f37809b1da3412a12e79ccc9c81264cfe9ad080997058fb61c4243cc32dbaa156b9"), Gx: BigInt("0x79a70b2b70400553ae7c9df416c792c61128751ac92969240c25a07d728bdc93e21f7787ed6972249de732f38496cd11698713093e9c04fc"), Gy: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffff80000000000000000000000000000000000000000000000000000001") }), BL = df(() => AL.create({ dkLen: 114 })), CL = BigInt(1), f3 = BigInt(2), p5 = BigInt(3);
BigInt(4);
const kL = BigInt(11), IL = BigInt(22), g5 = BigInt(44), SL = BigInt(88), ML = BigInt(223);
function FI(t3) {
  const e = m0.p, n = t3 * t3 * t3 % e, r = n * n * t3 % e, s = Dn(r, p5, e) * r % e, i = Dn(s, p5, e) * r % e, a = Dn(i, f3, e) * n % e, o = Dn(a, kL, e) * a % e, f = Dn(o, IL, e) * o % e, c = Dn(f, g5, e) * f % e, l = Dn(c, SL, e) * c % e, h = Dn(l, g5, e) * f % e, m = Dn(h, f3, e) * n % e, v = Dn(m, CL, e) * t3 % e;
  return Dn(v, ML, e) * m % e;
}
function PI(t3) {
  return t3[0] &= 252, t3[55] |= 128, t3[56] = 0, t3;
}
function $L(t3, e) {
  const n = m0.p, r = ui(t3 * t3 * e, n), s = ui(r * t3, n), i = ui(s * r * e, n), a = ui(s * FI(i), n), o = ui(a * a, n);
  return { isValid: ui(o * e, n) === t3, value: a };
}
const TL = $s(m0.p, { BITS: 456, isLE: true }), m5 = $s(m0.n, { BITS: 456, isLE: true });
function DL(t3, e, n) {
  if (e.length > 255) throw Error("context must be smaller than 255, got: " + e.length);
  return Ba((r = "SigEd448", Uint8Array.from(r, (s, i) => {
    const a = s.charCodeAt(0);
    if (s.length !== 1 || a > 127) throw Error(`string contains non-ASCII character "${r[i]}" with code ${a} at position ${i}`);
    return a;
  })), new Uint8Array([n ? 1 : 0, e.length]), e, t3);
  var r;
}
const RL = function(t3) {
  const { CURVE: e, curveOpts: n, hash: r, eddsaOpts: s } = function(i) {
    const a = { a: i.a, d: i.d, p: i.Fp.ORDER, n: i.n, h: i.h, Gx: i.Gx, Gy: i.Gy }, o = { Fp: i.Fp, Fn: $s(a.n, i.nBitLength, true), uvRatio: i.uvRatio }, f = { randomBytes: i.randomBytes, adjustScalarBytes: i.adjustScalarBytes, domain: i.domain, prehash: i.prehash, mapToCurve: i.mapToCurve };
    return { CURVE: a, curveOpts: o, hash: i.hash, eddsaOpts: f };
  }(t3);
  return function(i, a) {
    const o = a.Point;
    return Object.assign({}, a, { ExtendedPoint: o, CURVE: i, nBitLength: o.Fn.BITS, nByteLength: o.Fn.BYTES });
  }(t3, xL(RI(e, n), r, s));
}({ ...m0, Fp: TL, Fn: m5, nBitLength: m5.BITS, hash: BL, adjustScalarBytes: PI, domain: DL, uvRatio: $L });
RI(EL);
const FL = (() => {
  const t3 = m0.p;
  return _L({ P: t3, type: "x448", powPminus2: (e) => ui(Dn(FI(e), f3, t3) * e, t3), adjustScalarBytes: PI });
})(), l3 = { p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), h: BigInt(1), a: BigInt(0), b: BigInt(7), Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8") }, PL = { beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"), basises: [[BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")], [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]] }, v5 = BigInt(2);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u3 = $s(l3.p, { sqrt: function(t3) {
  const e = l3.p, n = BigInt(3), r = BigInt(6), s = BigInt(11), i = BigInt(22), a = BigInt(23), o = BigInt(44), f = BigInt(88), c = t3 * t3 * t3 % e, l = c * c * t3 % e, h = Dn(l, n, e) * l % e, m = Dn(h, n, e) * l % e, v = Dn(m, v5, e) * c % e, b = Dn(v, s, e) * v % e, A = Dn(b, i, e) * b % e, _ = Dn(A, o, e) * A % e, C = Dn(_, f, e) * _ % e, I = Dn(C, o, e) * A % e, S = Dn(I, n, e) * l % e, $ = Dn(S, a, e) * b % e, F = Dn($, r, e) * c % e, U = Dn(F, v5, e);
  if (!u3.eql(u3.sqr(U), t3)) throw Error("Cannot find square root");
  return U;
} }), NL = g0({ ...l3, Fp: u3, lowS: true, endo: PL }, hA), NI = hA, UL = ZU, y5 = $s(BigInt("0xa9fb57dba1eea9bc3e660a909d838d726e3bf623d52620282013481d1f6e5377")), LL = g0({ a: y5.create(BigInt("0x7d5a0975fc2c3057eef67530417affe7fb8055c126dc5c6ce94a4b44f330b5d9")), b: BigInt("0x26dc5c6ce94a4b44f330b5d9bbd77cbf958416295cf7e1ce6bccdc18ff8c07b6"), Fp: y5, n: BigInt("0xa9fb57dba1eea9bc3e660a909d838d718c397aa3b561a6f7901e0e82974856a7"), Gx: BigInt("0x8bd2aeb9cb7e57cb2c4b482ffc81b7afb9de27e1e3bd23c23a4453bd9ace3262"), Gy: BigInt("0x547ef835c3dac4fd97f8461a14611dc9c27745132ded8e545c1d54c72f046997"), h: BigInt(1), lowS: false }, NI), UI = pI, LI = gI, b5 = $s(BigInt("0x8cb91e82a3386d280f5d6f7e50e641df152f7109ed5456b412b1da197fb71123acd3a729901d1a71874700133107ec53")), OL = g0({ a: b5.create(BigInt("0x7bc382c63d8c150c3c72080ace05afa0c2bea28e4fb22787139165efba91f90f8aa5814a503ad4eb04a8c7dd22ce2826")), b: BigInt("0x04a8c7dd22ce28268b39b55416f0447c2fb77de107dcd2a62e880ea53eeb62d57cb4390295dbc9943ab78696fa504c11"), Fp: b5, n: BigInt("0x8cb91e82a3386d280f5d6f7e50e641df152f7109ed5456b31f166e6cac0425a7cf3ab6af6b7fc3103b883202e9046565"), Gx: BigInt("0x1d1c64f068cf45ffa2a63a81b7c13f6b8847a3e77ef14fe3db7fcafe0cbd10e8e826e03436d646aaef87b2e247d4af1e"), Gy: BigInt("0x8abe1d7520f9c2a45cb1eb8e95cfd55262b70b29feec5864e19c054ff99129280e4646217791811142820341263c5315"), h: BigInt(1), lowS: false }, LI), A5 = $s(BigInt("0xaadd9db8dbe9c48b3fd4e6ae33c9fc07cb308db3b3c9d20ed6639cca703308717d4d9b009bc66842aecda12ae6a380e62881ff2f2d82c68528aa6056583a48f3")), QL = g0({ a: A5.create(BigInt("0x7830a3318b603b89e2327145ac234cc594cbdd8d3df91610a83441caea9863bc2ded5d5aa8253aa10a2ef1c98b9ac8b57f1117a72bf2c7b9e7c1ac4d77fc94ca")), b: BigInt("0x3df91610a83441caea9863bc2ded5d5aa8253aa10a2ef1c98b9ac8b57f1117a72bf2c7b9e7c1ac4d77fc94cadc083e67984050b75ebae5dd2809bd638016f723"), Fp: A5, n: BigInt("0xaadd9db8dbe9c48b3fd4e6ae33c9fc07cb308db3b3c9d20ed6639cca70330870553e5c414ca92619418661197fac10471db1d381085ddaddb58796829ca90069"), Gx: BigInt("0x81aee4bdd82ed9645a21322e9c4c6a9385ed9f70b5d916c1b43b62eef4d0098eff3b1f78e2d0d48d50d1687b93b97d5f7c6d5047406a5e688b352209bcb9f822"), Gy: BigInt("0x7dde385d566332ecc0eabfa9cf7822fdf209f70024a57b1aa000c55b881f8111b2dcde494a5f485e5bca4bd88a2763aed1ca2b2fa8f0540678cd1e0f3ad80892"), h: BigInt(1), lowS: false }, UI), KL = new Map(Object.entries({ nistP256: oL, nistP384: fL, nistP521: lL, brainpoolP256r1: LL, brainpoolP384r1: OL, brainpoolP512r1: QL, secp256k1: NL, x448: FL, ed448: RL }));
var HL = Object.freeze({ __proto__: null, nobleCurves: KL });
const _c = Uint32Array.from([1732584193, 4023233417, 2562383102, 271733878, 3285377520]), xf = new Uint32Array(80);
class qL extends id {
  constructor() {
    super(64, 20, 8, false), this.A = 0 | _c[0], this.B = 0 | _c[1], this.C = 0 | _c[2], this.D = 0 | _c[3], this.E = 0 | _c[4];
  }
  get() {
    const { A: e, B: n, C: r, D: s, E: i } = this;
    return [e, n, r, s, i];
  }
  set(e, n, r, s, i) {
    this.A = 0 | e, this.B = 0 | n, this.C = 0 | r, this.D = 0 | s, this.E = 0 | i;
  }
  process(e, n) {
    for (let f = 0; f < 16; f++, n += 4) xf[f] = e.getUint32(n, false);
    for (let f = 16; f < 80; f++) xf[f] = qf(xf[f - 3] ^ xf[f - 8] ^ xf[f - 14] ^ xf[f - 16], 1);
    let { A: r, B: s, C: i, D: a, E: o } = this;
    for (let f = 0; f < 80; f++) {
      let c, l;
      f < 20 ? (c = fI(s, i, a), l = 1518500249) : f < 40 ? (c = s ^ i ^ a, l = 1859775393) : f < 60 ? (c = lI(s, i, a), l = 2400959708) : (c = s ^ i ^ a, l = 3395469782);
      const h = qf(r, 5) + c + o + l + xf[f] | 0;
      o = a, a = i, i = qf(s, 30), s = r, r = h;
    }
    r = r + this.A | 0, s = s + this.B | 0, i = i + this.C | 0, a = a + this.D | 0, o = o + this.E | 0, this.set(r, s, i, a, o);
  }
  roundClean() {
    fa(xf);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0), fa(this.buffer);
  }
}
const zL = df(() => new qL()), GL = Uint8Array.from([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]), OI = Uint8Array.from(Array(16).fill(0).map((t3, e) => e)), VL = OI.map((t3) => (9 * t3 + 5) % 16), QI = (() => {
  const t3 = [[OI], [VL]];
  for (let e = 0; e < 4; e++) for (let n of t3) n.push(n[e].map((r) => GL[r]));
  return t3;
})(), KI = QI[0], HI = QI[1], qI = [[11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8], [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7], [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9], [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6], [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]].map((t3) => Uint8Array.from(t3)), YL = KI.map((t3, e) => t3.map((n) => qI[e][n])), WL = HI.map((t3, e) => t3.map((n) => qI[e][n])), JL = Uint32Array.from([0, 1518500249, 1859775393, 2400959708, 2840853838]), ZL = Uint32Array.from([1352829926, 1548603684, 1836072691, 2053994217, 0]);
function w5(t3, e, n, r) {
  return t3 === 0 ? e ^ n ^ r : t3 === 1 ? e & n | ~e & r : t3 === 2 ? (e | ~n) ^ r : t3 === 3 ? e & r | n & ~r : e ^ (n | ~r);
}
const Gd = new Uint32Array(16);
class jL extends id {
  constructor() {
    super(64, 20, 8, true), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
  }
  get() {
    const { h0: e, h1: n, h2: r, h3: s, h4: i } = this;
    return [e, n, r, s, i];
  }
  set(e, n, r, s, i) {
    this.h0 = 0 | e, this.h1 = 0 | n, this.h2 = 0 | r, this.h3 = 0 | s, this.h4 = 0 | i;
  }
  process(e, n) {
    for (let v = 0; v < 16; v++, n += 4) Gd[v] = e.getUint32(n, true);
    let r = 0 | this.h0, s = r, i = 0 | this.h1, a = i, o = 0 | this.h2, f = o, c = 0 | this.h3, l = c, h = 0 | this.h4, m = h;
    for (let v = 0; v < 5; v++) {
      const b = 4 - v, A = JL[v], _ = ZL[v], C = KI[v], I = HI[v], S = YL[v], $ = WL[v];
      for (let F = 0; F < 16; F++) {
        const U = qf(r + w5(v, i, o, c) + Gd[C[F]] + A, S[F]) + h | 0;
        r = h, h = c, c = 0 | qf(o, 10), o = i, i = U;
      }
      for (let F = 0; F < 16; F++) {
        const U = qf(s + w5(b, a, f, l) + Gd[I[F]] + _, $[F]) + m | 0;
        s = m, m = l, l = 0 | qf(f, 10), f = a, a = U;
      }
    }
    this.set(this.h1 + o + l | 0, this.h2 + c + m | 0, this.h3 + h + s | 0, this.h4 + r + a | 0, this.h0 + i + f | 0);
  }
  roundClean() {
    fa(Gd);
  }
  destroy() {
    this.destroyed = true, fa(this.buffer), this.set(0, 0, 0, 0, 0);
  }
}
const XL = zL, eO = df(() => new jL()), tO = Array.from({ length: 64 }, (t3, e) => Math.floor(2 ** 32 * Math.abs(Math.sin(e + 1)))), x5 = (t3, e, n) => t3 & e ^ ~t3 & n, Vd = new Uint32Array([1732584193, 4023233417, 2562383102, 271733878]), Xm = new Uint32Array(16);
class rO extends id {
  constructor() {
    super(64, 16, 8, true), this.A = 0 | Vd[0], this.B = 0 | Vd[1], this.C = 0 | Vd[2], this.D = 0 | Vd[3];
  }
  get() {
    const { A: e, B: n, C: r, D: s } = this;
    return [e, n, r, s];
  }
  set(e, n, r, s) {
    this.A = 0 | e, this.B = 0 | n, this.C = 0 | r, this.D = 0 | s;
  }
  process(e, n) {
    for (let o = 0; o < 16; o++, n += 4) Xm[o] = e.getUint32(n, true);
    let { A: r, B: s, C: i, D: a } = this;
    for (let o = 0; o < 64; o++) {
      let f, c, l;
      o < 16 ? (f = x5(s, i, a), c = o, l = [7, 12, 17, 22]) : o < 32 ? (f = x5(a, s, i), c = (5 * o + 1) % 16, l = [5, 9, 14, 20]) : o < 48 ? (f = s ^ i ^ a, c = (3 * o + 5) % 16, l = [4, 11, 16, 23]) : (f = i ^ (s | ~a), c = 7 * o % 16, l = [6, 10, 15, 21]), f = f + r + tO[o] + Xm[c], r = a, a = i, i = s, s += qf(f, l[o % 4]);
    }
    r = r + this.A | 0, s = s + this.B | 0, i = i + this.C | 0, a = a + this.D | 0, this.set(r, s, i, a);
  }
  roundClean() {
    Xm.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0), this.buffer.fill(0);
  }
}
const nO = new Map(Object.entries({ md5: DU(() => new rO()), sha1: XL, sha224: UL, sha256: NI, sha384: LI, sha512: UI, sha3_256: vL, sha3_512: yL, ripemd160: eO }));
var iO = Object.freeze({ __proto__: null, nobleHashes: nO });
const e2 = typeof es == "object" && "crypto" in es ? es.crypto : void 0, vs = {};
var dr = function(t3) {
  var e, n = new Float64Array(16);
  if (t3) for (e = 0; e < t3.length; e++) n[e] = t3[e];
  return n;
}, c3 = function() {
  throw Error("no PRNG");
}, zI = new Uint8Array(32);
zI[0] = 9;
var h3 = dr(), y1 = dr([1]), sO = dr([56129, 1]), aO = dr([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), oO = dr([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), _5 = dr([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), E5 = dr([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), fO = dr([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
function B5(t3, e, n, r) {
  t3[e] = n >> 24 & 255, t3[e + 1] = n >> 16 & 255, t3[e + 2] = n >> 8 & 255, t3[e + 3] = 255 & n, t3[e + 4] = r >> 24 & 255, t3[e + 5] = r >> 16 & 255, t3[e + 6] = r >> 8 & 255, t3[e + 7] = 255 & r;
}
function GI(t3, e, n, r) {
  return function(s, i, a, o, f) {
    var c, l = 0;
    for (c = 0; c < f; c++) l |= s[i + c] ^ a[o + c];
    return (1 & l - 1 >>> 8) - 1;
  }(t3, e, n, r, 32);
}
function zf(t3, e) {
  var n;
  for (n = 0; n < 16; n++) t3[n] = 0 | e[n];
}
function t2(t3) {
  var e, n, r = 1;
  for (e = 0; e < 16; e++) n = t3[e] + r + 65535, r = Math.floor(n / 65536), t3[e] = n - 65536 * r;
  t3[0] += r - 1 + 37 * (r - 1);
}
function X0(t3, e, n) {
  for (var r, s = ~(n - 1), i = 0; i < 16; i++) r = s & (t3[i] ^ e[i]), t3[i] ^= r, e[i] ^= r;
}
function Th(t3, e) {
  var n, r, s, i = dr(), a = dr();
  for (n = 0; n < 16; n++) a[n] = e[n];
  for (t2(a), t2(a), t2(a), r = 0; r < 2; r++) {
    for (i[0] = a[0] - 65517, n = 1; n < 15; n++) i[n] = a[n] - 65535 - (i[n - 1] >> 16 & 1), i[n - 1] &= 65535;
    i[15] = a[15] - 32767 - (i[14] >> 16 & 1), s = i[15] >> 16 & 1, i[14] &= 65535, X0(a, i, 1 - s);
  }
  for (n = 0; n < 16; n++) t3[2 * n] = 255 & a[n], t3[2 * n + 1] = a[n] >> 8;
}
function C5(t3, e) {
  var n = new Uint8Array(32), r = new Uint8Array(32);
  return Th(n, t3), Th(r, e), GI(n, 0, r, 0);
}
function VI(t3) {
  var e = new Uint8Array(32);
  return Th(e, t3), 1 & e[0];
}
function YI(t3, e) {
  var n;
  for (n = 0; n < 16; n++) t3[n] = e[2 * n] + (e[2 * n + 1] << 8);
  t3[15] &= 32767;
}
function ro(t3, e, n) {
  for (var r = 0; r < 16; r++) t3[r] = e[r] + n[r];
}
function uo(t3, e, n) {
  for (var r = 0; r < 16; r++) t3[r] = e[r] - n[r];
}
function jr(t3, e, n) {
  var r, s, i = 0, a = 0, o = 0, f = 0, c = 0, l = 0, h = 0, m = 0, v = 0, b = 0, A = 0, _ = 0, C = 0, I = 0, S = 0, $ = 0, F = 0, U = 0, Q = 0, P = 0, N = 0, L = 0, B = 0, u = 0, p = 0, d = 0, y = 0, w = 0, E = 0, M = 0, x = 0, g = n[0], k = n[1], T = n[2], O = n[3], K = n[4], Y = n[5], J = n[6], G = n[7], X = n[8], ie = n[9], de = n[10], se = n[11], te = n[12], le = n[13], Z = n[14], ve = n[15];
  i += (r = e[0]) * g, a += r * k, o += r * T, f += r * O, c += r * K, l += r * Y, h += r * J, m += r * G, v += r * X, b += r * ie, A += r * de, _ += r * se, C += r * te, I += r * le, S += r * Z, $ += r * ve, a += (r = e[1]) * g, o += r * k, f += r * T, c += r * O, l += r * K, h += r * Y, m += r * J, v += r * G, b += r * X, A += r * ie, _ += r * de, C += r * se, I += r * te, S += r * le, $ += r * Z, F += r * ve, o += (r = e[2]) * g, f += r * k, c += r * T, l += r * O, h += r * K, m += r * Y, v += r * J, b += r * G, A += r * X, _ += r * ie, C += r * de, I += r * se, S += r * te, $ += r * le, F += r * Z, U += r * ve, f += (r = e[3]) * g, c += r * k, l += r * T, h += r * O, m += r * K, v += r * Y, b += r * J, A += r * G, _ += r * X, C += r * ie, I += r * de, S += r * se, $ += r * te, F += r * le, U += r * Z, Q += r * ve, c += (r = e[4]) * g, l += r * k, h += r * T, m += r * O, v += r * K, b += r * Y, A += r * J, _ += r * G, C += r * X, I += r * ie, S += r * de, $ += r * se, F += r * te, U += r * le, Q += r * Z, P += r * ve, l += (r = e[5]) * g, h += r * k, m += r * T, v += r * O, b += r * K, A += r * Y, _ += r * J, C += r * G, I += r * X, S += r * ie, $ += r * de, F += r * se, U += r * te, Q += r * le, P += r * Z, N += r * ve, h += (r = e[6]) * g, m += r * k, v += r * T, b += r * O, A += r * K, _ += r * Y, C += r * J, I += r * G, S += r * X, $ += r * ie, F += r * de, U += r * se, Q += r * te, P += r * le, N += r * Z, L += r * ve, m += (r = e[7]) * g, v += r * k, b += r * T, A += r * O, _ += r * K, C += r * Y, I += r * J, S += r * G, $ += r * X, F += r * ie, U += r * de, Q += r * se, P += r * te, N += r * le, L += r * Z, B += r * ve, v += (r = e[8]) * g, b += r * k, A += r * T, _ += r * O, C += r * K, I += r * Y, S += r * J, $ += r * G, F += r * X, U += r * ie, Q += r * de, P += r * se, N += r * te, L += r * le, B += r * Z, u += r * ve, b += (r = e[9]) * g, A += r * k, _ += r * T, C += r * O, I += r * K, S += r * Y, $ += r * J, F += r * G, U += r * X, Q += r * ie, P += r * de, N += r * se, L += r * te, B += r * le, u += r * Z, p += r * ve, A += (r = e[10]) * g, _ += r * k, C += r * T, I += r * O, S += r * K, $ += r * Y, F += r * J, U += r * G, Q += r * X, P += r * ie, N += r * de, L += r * se, B += r * te, u += r * le, p += r * Z, d += r * ve, _ += (r = e[11]) * g, C += r * k, I += r * T, S += r * O, $ += r * K, F += r * Y, U += r * J, Q += r * G, P += r * X, N += r * ie, L += r * de, B += r * se, u += r * te, p += r * le, d += r * Z, y += r * ve, C += (r = e[12]) * g, I += r * k, S += r * T, $ += r * O, F += r * K, U += r * Y, Q += r * J, P += r * G, N += r * X, L += r * ie, B += r * de, u += r * se, p += r * te, d += r * le, y += r * Z, w += r * ve, I += (r = e[13]) * g, S += r * k, $ += r * T, F += r * O, U += r * K, Q += r * Y, P += r * J, N += r * G, L += r * X, B += r * ie, u += r * de, p += r * se, d += r * te, y += r * le, w += r * Z, E += r * ve, S += (r = e[14]) * g, $ += r * k, F += r * T, U += r * O, Q += r * K, P += r * Y, N += r * J, L += r * G, B += r * X, u += r * ie, p += r * de, d += r * se, y += r * te, w += r * le, E += r * Z, M += r * ve, $ += (r = e[15]) * g, a += 38 * (U += r * T), o += 38 * (Q += r * O), f += 38 * (P += r * K), c += 38 * (N += r * Y), l += 38 * (L += r * J), h += 38 * (B += r * G), m += 38 * (u += r * X), v += 38 * (p += r * ie), b += 38 * (d += r * de), A += 38 * (y += r * se), _ += 38 * (w += r * te), C += 38 * (E += r * le), I += 38 * (M += r * Z), S += 38 * (x += r * ve), i = (r = (i += 38 * (F += r * k)) + (s = 1) + 65535) - 65536 * (s = Math.floor(r / 65536)), a = (r = a + s + 65535) - 65536 * (s = Math.floor(r / 65536)), o = (r = o + s + 65535) - 65536 * (s = Math.floor(r / 65536)), f = (r = f + s + 65535) - 65536 * (s = Math.floor(r / 65536)), c = (r = c + s + 65535) - 65536 * (s = Math.floor(r / 65536)), l = (r = l + s + 65535) - 65536 * (s = Math.floor(r / 65536)), h = (r = h + s + 65535) - 65536 * (s = Math.floor(r / 65536)), m = (r = m + s + 65535) - 65536 * (s = Math.floor(r / 65536)), v = (r = v + s + 65535) - 65536 * (s = Math.floor(r / 65536)), b = (r = b + s + 65535) - 65536 * (s = Math.floor(r / 65536)), A = (r = A + s + 65535) - 65536 * (s = Math.floor(r / 65536)), _ = (r = _ + s + 65535) - 65536 * (s = Math.floor(r / 65536)), C = (r = C + s + 65535) - 65536 * (s = Math.floor(r / 65536)), I = (r = I + s + 65535) - 65536 * (s = Math.floor(r / 65536)), S = (r = S + s + 65535) - 65536 * (s = Math.floor(r / 65536)), $ = (r = $ + s + 65535) - 65536 * (s = Math.floor(r / 65536)), i = (r = (i += s - 1 + 37 * (s - 1)) + (s = 1) + 65535) - 65536 * (s = Math.floor(r / 65536)), a = (r = a + s + 65535) - 65536 * (s = Math.floor(r / 65536)), o = (r = o + s + 65535) - 65536 * (s = Math.floor(r / 65536)), f = (r = f + s + 65535) - 65536 * (s = Math.floor(r / 65536)), c = (r = c + s + 65535) - 65536 * (s = Math.floor(r / 65536)), l = (r = l + s + 65535) - 65536 * (s = Math.floor(r / 65536)), h = (r = h + s + 65535) - 65536 * (s = Math.floor(r / 65536)), m = (r = m + s + 65535) - 65536 * (s = Math.floor(r / 65536)), v = (r = v + s + 65535) - 65536 * (s = Math.floor(r / 65536)), b = (r = b + s + 65535) - 65536 * (s = Math.floor(r / 65536)), A = (r = A + s + 65535) - 65536 * (s = Math.floor(r / 65536)), _ = (r = _ + s + 65535) - 65536 * (s = Math.floor(r / 65536)), C = (r = C + s + 65535) - 65536 * (s = Math.floor(r / 65536)), I = (r = I + s + 65535) - 65536 * (s = Math.floor(r / 65536)), S = (r = S + s + 65535) - 65536 * (s = Math.floor(r / 65536)), $ = (r = $ + s + 65535) - 65536 * (s = Math.floor(r / 65536)), i += s - 1 + 37 * (s - 1), t3[0] = i, t3[1] = a, t3[2] = o, t3[3] = f, t3[4] = c, t3[5] = l, t3[6] = h, t3[7] = m, t3[8] = v, t3[9] = b, t3[10] = A, t3[11] = _, t3[12] = C, t3[13] = I, t3[14] = S, t3[15] = $;
}
function Ca(t3, e) {
  jr(t3, e, e);
}
function WI(t3, e) {
  var n, r = dr();
  for (n = 0; n < 16; n++) r[n] = e[n];
  for (n = 253; n >= 0; n--) Ca(r, r), n !== 2 && n !== 4 && jr(r, r, e);
  for (n = 0; n < 16; n++) t3[n] = r[n];
}
function JI(t3, e, n) {
  var r, s, i = new Uint8Array(32), a = new Float64Array(80), o = dr(), f = dr(), c = dr(), l = dr(), h = dr(), m = dr();
  for (s = 0; s < 31; s++) i[s] = e[s];
  for (i[31] = 127 & e[31] | 64, i[0] &= 248, YI(a, n), s = 0; s < 16; s++) f[s] = a[s], l[s] = o[s] = c[s] = 0;
  for (o[0] = l[0] = 1, s = 254; s >= 0; --s) X0(o, f, r = i[s >>> 3] >>> (7 & s) & 1), X0(c, l, r), ro(h, o, c), uo(o, o, c), ro(c, f, l), uo(f, f, l), Ca(l, h), Ca(m, o), jr(o, c, o), jr(c, f, h), ro(h, o, c), uo(o, o, c), Ca(f, o), uo(c, l, m), jr(o, c, sO), ro(o, o, l), jr(c, c, o), jr(o, l, m), jr(l, f, a), Ca(f, h), X0(o, f, r), X0(c, l, r);
  for (s = 0; s < 16; s++) a[s + 16] = o[s], a[s + 32] = c[s], a[s + 48] = f[s], a[s + 64] = l[s];
  var v = a.subarray(32), b = a.subarray(16);
  return WI(v, v), jr(b, b, v), Th(t3, b), 0;
}
function k5(t3, e) {
  return JI(t3, e, zI);
}
var I5 = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
function S5(t3, e, n, r) {
  for (var s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U, Q, P, N, L, B, u, p, d = new Int32Array(16), y = new Int32Array(16), w = t3[0], E = t3[1], M = t3[2], x = t3[3], g = t3[4], k = t3[5], T = t3[6], O = t3[7], K = e[0], Y = e[1], J = e[2], G = e[3], X = e[4], ie = e[5], de = e[6], se = e[7], te = 0; r >= 128; ) {
    for (U = 0; U < 16; U++) Q = 8 * U + te, d[U] = n[Q + 0] << 24 | n[Q + 1] << 16 | n[Q + 2] << 8 | n[Q + 3], y[U] = n[Q + 4] << 24 | n[Q + 5] << 16 | n[Q + 6] << 8 | n[Q + 7];
    for (U = 0; U < 80; U++) if (s = w, i = E, a = M, o = x, f = g, c = k, l = T, m = K, v = Y, b = J, A = G, _ = X, C = ie, I = de, L = 65535 & (N = se), B = N >>> 16, u = 65535 & (P = O), p = P >>> 16, L += 65535 & (N = (X >>> 14 | g << 18) ^ (X >>> 18 | g << 14) ^ (g >>> 9 | X << 23)), B += N >>> 16, u += 65535 & (P = (g >>> 14 | X << 18) ^ (g >>> 18 | X << 14) ^ (X >>> 9 | g << 23)), p += P >>> 16, L += 65535 & (N = X & ie ^ ~X & de), B += N >>> 16, u += 65535 & (P = g & k ^ ~g & T), p += P >>> 16, L += 65535 & (N = I5[2 * U + 1]), B += N >>> 16, u += 65535 & (P = I5[2 * U]), p += P >>> 16, P = d[U % 16], B += (N = y[U % 16]) >>> 16, u += 65535 & P, p += P >>> 16, u += (B += (L += 65535 & N) >>> 16) >>> 16, L = 65535 & (N = F = 65535 & L | B << 16), B = N >>> 16, u = 65535 & (P = $ = 65535 & u | (p += u >>> 16) << 16), p = P >>> 16, L += 65535 & (N = (K >>> 28 | w << 4) ^ (w >>> 2 | K << 30) ^ (w >>> 7 | K << 25)), B += N >>> 16, u += 65535 & (P = (w >>> 28 | K << 4) ^ (K >>> 2 | w << 30) ^ (K >>> 7 | w << 25)), p += P >>> 16, B += (N = K & Y ^ K & J ^ Y & J) >>> 16, u += 65535 & (P = w & E ^ w & M ^ E & M), p += P >>> 16, h = 65535 & (u += (B += (L += 65535 & N) >>> 16) >>> 16) | (p += u >>> 16) << 16, S = 65535 & L | B << 16, L = 65535 & (N = A), B = N >>> 16, u = 65535 & (P = o), p = P >>> 16, B += (N = F) >>> 16, u += 65535 & (P = $), p += P >>> 16, E = s, M = i, x = a, g = o = 65535 & (u += (B += (L += 65535 & N) >>> 16) >>> 16) | (p += u >>> 16) << 16, k = f, T = c, O = l, w = h, Y = m, J = v, G = b, X = A = 65535 & L | B << 16, ie = _, de = C, se = I, K = S, U % 16 == 15) for (Q = 0; Q < 16; Q++) P = d[Q], L = 65535 & (N = y[Q]), B = N >>> 16, u = 65535 & P, p = P >>> 16, P = d[(Q + 9) % 16], L += 65535 & (N = y[(Q + 9) % 16]), B += N >>> 16, u += 65535 & P, p += P >>> 16, $ = d[(Q + 1) % 16], L += 65535 & (N = ((F = y[(Q + 1) % 16]) >>> 1 | $ << 31) ^ (F >>> 8 | $ << 24) ^ (F >>> 7 | $ << 25)), B += N >>> 16, u += 65535 & (P = ($ >>> 1 | F << 31) ^ ($ >>> 8 | F << 24) ^ $ >>> 7), p += P >>> 16, $ = d[(Q + 14) % 16], B += (N = ((F = y[(Q + 14) % 16]) >>> 19 | $ << 13) ^ ($ >>> 29 | F << 3) ^ (F >>> 6 | $ << 26)) >>> 16, u += 65535 & (P = ($ >>> 19 | F << 13) ^ (F >>> 29 | $ << 3) ^ $ >>> 6), p += P >>> 16, p += (u += (B += (L += 65535 & N) >>> 16) >>> 16) >>> 16, d[Q] = 65535 & u | p << 16, y[Q] = 65535 & L | B << 16;
    L = 65535 & (N = K), B = N >>> 16, u = 65535 & (P = w), p = P >>> 16, P = t3[0], B += (N = e[0]) >>> 16, u += 65535 & P, p += P >>> 16, p += (u += (B += (L += 65535 & N) >>> 16) >>> 16) >>> 16, t3[0] = w = 65535 & u | p << 16, e[0] = K = 65535 & L | B << 16, L = 65535 & (N = Y), B = N >>> 16, u = 65535 & (P = E), p = P >>> 16, P = t3[1], B += (N = e[1]) >>> 16, u += 65535 & P, p += P >>> 16, p += (u += (B += (L += 65535 & N) >>> 16) >>> 16) >>> 16, t3[1] = E = 65535 & u | p << 16, e[1] = Y = 65535 & L | B << 16, L = 65535 & (N = J), B = N >>> 16, u = 65535 & (P = M), p = P >>> 16, P = t3[2], B += (N = e[2]) >>> 16, u += 65535 & P, p += P >>> 16, p += (u += (B += (L += 65535 & N) >>> 16) >>> 16) >>> 16, t3[2] = M = 65535 & u | p << 16, e[2] = J = 65535 & L | B << 16, L = 65535 & (N = G), B = N >>> 16, u = 65535 & (P = x), p = P >>> 16, P = t3[3], B += (N = e[3]) >>> 16, u += 65535 & P, p += P >>> 16, p += (u += (B += (L += 65535 & N) >>> 16) >>> 16) >>> 16, t3[3] = x = 65535 & u | p << 16, e[3] = G = 65535 & L | B << 16, L = 65535 & (N = X), B = N >>> 16, u = 65535 & (P = g), p = P >>> 16, P = t3[4], B += (N = e[4]) >>> 16, u += 65535 & P, p += P >>> 16, p += (u += (B += (L += 65535 & N) >>> 16) >>> 16) >>> 16, t3[4] = g = 65535 & u | p << 16, e[4] = X = 65535 & L | B << 16, L = 65535 & (N = ie), B = N >>> 16, u = 65535 & (P = k), p = P >>> 16, P = t3[5], B += (N = e[5]) >>> 16, u += 65535 & P, p += P >>> 16, p += (u += (B += (L += 65535 & N) >>> 16) >>> 16) >>> 16, t3[5] = k = 65535 & u | p << 16, e[5] = ie = 65535 & L | B << 16, L = 65535 & (N = de), B = N >>> 16, u = 65535 & (P = T), p = P >>> 16, P = t3[6], B += (N = e[6]) >>> 16, u += 65535 & P, p += P >>> 16, p += (u += (B += (L += 65535 & N) >>> 16) >>> 16) >>> 16, t3[6] = T = 65535 & u | p << 16, e[6] = de = 65535 & L | B << 16, L = 65535 & (N = se), B = N >>> 16, u = 65535 & (P = O), p = P >>> 16, P = t3[7], B += (N = e[7]) >>> 16, u += 65535 & P, p += P >>> 16, p += (u += (B += (L += 65535 & N) >>> 16) >>> 16) >>> 16, t3[7] = O = 65535 & u | p << 16, e[7] = se = 65535 & L | B << 16, te += 128, r -= 128;
  }
  return r;
}
function zc(t3, e, n) {
  var r, s = new Int32Array(8), i = new Int32Array(8), a = new Uint8Array(256), o = n;
  for (s[0] = 1779033703, s[1] = 3144134277, s[2] = 1013904242, s[3] = 2773480762, s[4] = 1359893119, s[5] = 2600822924, s[6] = 528734635, s[7] = 1541459225, i[0] = 4089235720, i[1] = 2227873595, i[2] = 4271175723, i[3] = 1595750129, i[4] = 2917565137, i[5] = 725511199, i[6] = 4215389547, i[7] = 327033209, S5(s, i, e, n), n %= 128, r = 0; r < n; r++) a[r] = e[o - n + r];
  for (a[n] = 128, a[(n = 256 - 128 * (n < 112 ? 1 : 0)) - 9] = 0, B5(a, n - 8, o / 536870912 | 0, o << 3), S5(s, i, a, n), r = 0; r < 8; r++) B5(t3, 8 * r, s[r], i[r]);
  return 0;
}
function d3(t3, e) {
  var n = dr(), r = dr(), s = dr(), i = dr(), a = dr(), o = dr(), f = dr(), c = dr(), l = dr();
  uo(n, t3[1], t3[0]), uo(l, e[1], e[0]), jr(n, n, l), ro(r, t3[0], t3[1]), ro(l, e[0], e[1]), jr(r, r, l), jr(s, t3[3], e[3]), jr(s, s, oO), jr(i, t3[2], e[2]), ro(i, i, i), uo(a, r, n), uo(o, i, s), ro(f, i, s), ro(c, r, n), jr(t3[0], a, o), jr(t3[1], c, f), jr(t3[2], f, o), jr(t3[3], a, c);
}
function M5(t3, e, n) {
  var r;
  for (r = 0; r < 4; r++) X0(t3[r], e[r], n);
}
function p3(t3, e) {
  var n = dr(), r = dr(), s = dr();
  WI(s, e[2]), jr(n, e[0], s), jr(r, e[1], s), Th(t3, r), t3[31] ^= VI(n) << 7;
}
function ZI(t3, e, n) {
  var r, s;
  for (zf(t3[0], h3), zf(t3[1], y1), zf(t3[2], y1), zf(t3[3], h3), s = 255; s >= 0; --s) M5(t3, e, r = n[s / 8 | 0] >> (7 & s) & 1), d3(e, t3), d3(t3, t3), M5(t3, e, r);
}
function g3(t3, e) {
  var n = [dr(), dr(), dr(), dr()];
  zf(n[0], _5), zf(n[1], E5), zf(n[2], y1), jr(n[3], _5, E5), ZI(t3, n, e);
}
function $5(t3, e, n) {
  var r, s = new Uint8Array(64), i = [dr(), dr(), dr(), dr()];
  for (n || c3(e, 32), zc(s, e, 32), s[0] &= 248, s[31] &= 127, s[31] |= 64, g3(i, s), p3(t3, i), r = 0; r < 32; r++) e[r + 32] = t3[r];
  return 0;
}
var r2 = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
function jI(t3, e) {
  var n, r, s, i;
  for (r = 63; r >= 32; --r) {
    for (n = 0, s = r - 32, i = r - 12; s < i; ++s) e[s] += n - 16 * e[r] * r2[s - (r - 32)], n = Math.floor((e[s] + 128) / 256), e[s] -= 256 * n;
    e[s] += n, e[r] = 0;
  }
  for (n = 0, s = 0; s < 32; s++) e[s] += n - (e[31] >> 4) * r2[s], n = e[s] >> 8, e[s] &= 255;
  for (s = 0; s < 32; s++) e[s] -= n * r2[s];
  for (r = 0; r < 32; r++) e[r + 1] += e[r] >> 8, t3[r] = 255 & e[r];
}
function n2(t3) {
  var e, n = new Float64Array(64);
  for (e = 0; e < 64; e++) n[e] = t3[e];
  for (e = 0; e < 64; e++) t3[e] = 0;
  jI(t3, n);
}
function lO(t3, e) {
  var n = dr(), r = dr(), s = dr(), i = dr(), a = dr(), o = dr(), f = dr();
  return zf(t3[2], y1), YI(t3[1], e), Ca(s, t3[1]), jr(i, s, aO), uo(s, s, t3[2]), ro(i, t3[2], i), Ca(a, i), Ca(o, a), jr(f, o, a), jr(n, f, s), jr(n, n, i), function(c, l) {
    var h, m = dr();
    for (h = 0; h < 16; h++) m[h] = l[h];
    for (h = 250; h >= 0; h--) Ca(m, m), h !== 1 && jr(m, m, l);
    for (h = 0; h < 16; h++) c[h] = m[h];
  }(n, n), jr(n, n, s), jr(n, n, i), jr(n, n, i), jr(t3[0], n, i), Ca(r, t3[0]), jr(r, r, i), C5(r, s) && jr(t3[0], t3[0], fO), Ca(r, t3[0]), jr(r, r, i), C5(r, s) ? -1 : (VI(t3[0]) === e[31] >> 7 && uo(t3[0], h3, t3[0]), jr(t3[3], t3[0], t3[1]), 0);
}
var kl = 64;
function D0() {
  for (var t3 = 0; t3 < arguments.length; t3++) if (!(arguments[t3] instanceof Uint8Array)) throw new TypeError("unexpected type, use Uint8Array");
}
vs.scalarMult = function(t3, e) {
  if (D0(t3, e), t3.length !== 32) throw Error("bad n size");
  if (e.length !== 32) throw Error("bad p size");
  var n = new Uint8Array(32);
  return JI(n, t3, e), n;
}, vs.box = {}, vs.box.keyPair = function() {
  var t3 = new Uint8Array(32), e = new Uint8Array(32);
  return function(n, r) {
    c3(r, 32), k5(n, r);
  }(t3, e), { publicKey: t3, secretKey: e };
}, vs.box.keyPair.fromSecretKey = function(t3) {
  if (D0(t3), t3.length !== 32) throw Error("bad secret key size");
  var e = new Uint8Array(32);
  return k5(e, t3), { publicKey: e, secretKey: new Uint8Array(t3) };
}, vs.sign = function(t3, e) {
  if (D0(t3, e), e.length !== 64) throw Error("bad secret key size");
  var n = new Uint8Array(kl + t3.length);
  return function(r, s, i, a) {
    var o, f, c = new Uint8Array(64), l = new Uint8Array(64), h = new Uint8Array(64), m = new Float64Array(64), v = [dr(), dr(), dr(), dr()];
    for (zc(c, a, 32), c[0] &= 248, c[31] &= 127, c[31] |= 64, o = 0; o < i; o++) r[64 + o] = s[o];
    for (o = 0; o < 32; o++) r[32 + o] = c[32 + o];
    for (zc(h, r.subarray(32), i + 32), n2(h), g3(v, h), p3(r, v), o = 32; o < 64; o++) r[o] = a[o];
    for (zc(l, r, i + 64), n2(l), o = 0; o < 64; o++) m[o] = 0;
    for (o = 0; o < 32; o++) m[o] = h[o];
    for (o = 0; o < 32; o++) for (f = 0; f < 32; f++) m[o + f] += l[o] * c[f];
    jI(r.subarray(32), m);
  }(n, t3, t3.length, e), n;
}, vs.sign.detached = function(t3, e) {
  for (var n = vs.sign(t3, e), r = new Uint8Array(kl), s = 0; s < r.length; s++) r[s] = n[s];
  return r;
}, vs.sign.detached.verify = function(t3, e, n) {
  if (D0(t3, e, n), e.length !== kl) throw Error("bad signature size");
  if (n.length !== 32) throw Error("bad public key size");
  var r, s = new Uint8Array(kl + t3.length), i = new Uint8Array(kl + t3.length);
  for (r = 0; r < kl; r++) s[r] = e[r];
  for (r = 0; r < t3.length; r++) s[r + kl] = t3[r];
  return function(a, o, f, c) {
    var l, h = new Uint8Array(32), m = new Uint8Array(64), v = [dr(), dr(), dr(), dr()], b = [dr(), dr(), dr(), dr()];
    if (f < 64 || lO(b, c)) return -1;
    for (l = 0; l < f; l++) a[l] = o[l];
    for (l = 0; l < 32; l++) a[l + 32] = c[l];
    if (zc(m, a, f), n2(m), ZI(v, b, m), g3(b, o.subarray(32)), d3(v, b), p3(h, v), f -= 64, GI(o, 0, h, 0)) {
      for (l = 0; l < f; l++) a[l] = 0;
      return -1;
    }
    for (l = 0; l < f; l++) a[l] = o[l + 64];
    return f;
  }(i, s, s.length, n) >= 0;
}, vs.sign.keyPair = function() {
  var t3 = new Uint8Array(32), e = new Uint8Array(64);
  return $5(t3, e), { publicKey: t3, secretKey: e };
}, vs.sign.keyPair.fromSecretKey = function(t3) {
  if (D0(t3), t3.length !== 64) throw Error("bad secret key size");
  for (var e = new Uint8Array(32), n = 0; n < e.length; n++) e[n] = t3[32 + n];
  return { publicKey: e, secretKey: new Uint8Array(t3) };
}, vs.sign.keyPair.fromSeed = function(t3) {
  if (D0(t3), t3.length !== 32) throw Error("bad seed size");
  for (var e = new Uint8Array(32), n = new Uint8Array(64), r = 0; r < 32; r++) n[r] = t3[r];
  return $5(e, n, true), { publicKey: e, secretKey: n };
}, vs.setPRNG = function(t3) {
  c3 = t3;
}, function() {
  e2 && e2.getRandomValues && vs.setPRNG(function(t3, e) {
    var n, r = new Uint8Array(e);
    for (n = 0; n < e; n += 65536) e2.getRandomValues(r.subarray(n, n + Math.min(e - n, 65536)));
    for (n = 0; n < e; n++) t3[n] = r[n];
    (function(s) {
      for (var i = 0; i < s.length; i++) s[i] = 0;
    })(r);
  });
}();
var v0 = Object.freeze({ __proto__: null, default: vs });
function i2(t3, e, n, r, s, i) {
  const a = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756], o = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344], f = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584], c = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928], l = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080], h = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312], m = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154], v = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
  let b, A, _, C, I, S, $, F, U, Q, P = 0, N = e.length;
  const L = t3.length === 32 ? 3 : 9;
  F = L === 3 ? n ? [0, 32, 2] : [30, -2, -2] : n ? [0, 32, 2, 62, 30, -2, 64, 96, 2] : [94, 62, -2, 32, 64, 2, 30, -2, -2], n && (e = function(p) {
    const d = 8 - p.length % 8;
    let y;
    if (!(d < 8)) {
      if (d === 8) return p;
      throw Error("des: invalid padding");
    }
    y = 0;
    const w = new Uint8Array(p.length + d);
    for (let E = 0; E < p.length; E++) w[E] = p[E];
    for (let E = 0; E < d; E++) w[p.length + E] = y;
    return w;
  }(e), N = e.length);
  let B = new Uint8Array(N), u = 0;
  for (; P < N; ) {
    for (S = e[P++] << 24 | e[P++] << 16 | e[P++] << 8 | e[P++], $ = e[P++] << 24 | e[P++] << 16 | e[P++] << 8 | e[P++], _ = 252645135 & (S >>> 4 ^ $), $ ^= _, S ^= _ << 4, _ = 65535 & (S >>> 16 ^ $), $ ^= _, S ^= _ << 16, _ = 858993459 & ($ >>> 2 ^ S), S ^= _, $ ^= _ << 2, _ = 16711935 & ($ >>> 8 ^ S), S ^= _, $ ^= _ << 8, _ = 1431655765 & (S >>> 1 ^ $), $ ^= _, S ^= _ << 1, S = S << 1 | S >>> 31, $ = $ << 1 | $ >>> 31, A = 0; A < L; A += 3) {
      for (U = F[A + 1], Q = F[A + 2], b = F[A]; b !== U; b += Q) C = $ ^ t3[b], I = ($ >>> 4 | $ << 28) ^ t3[b + 1], _ = S, S = $, $ = _ ^ (o[C >>> 24 & 63] | c[C >>> 16 & 63] | h[C >>> 8 & 63] | v[63 & C] | a[I >>> 24 & 63] | f[I >>> 16 & 63] | l[I >>> 8 & 63] | m[63 & I]);
      _ = S, S = $, $ = _;
    }
    S = S >>> 1 | S << 31, $ = $ >>> 1 | $ << 31, _ = 1431655765 & (S >>> 1 ^ $), $ ^= _, S ^= _ << 1, _ = 16711935 & ($ >>> 8 ^ S), S ^= _, $ ^= _ << 8, _ = 858993459 & ($ >>> 2 ^ S), S ^= _, $ ^= _ << 2, _ = 65535 & (S >>> 16 ^ $), $ ^= _, S ^= _ << 16, _ = 252645135 & (S >>> 4 ^ $), $ ^= _, S ^= _ << 4, B[u++] = S >>> 24, B[u++] = S >>> 16 & 255, B[u++] = S >>> 8 & 255, B[u++] = 255 & S, B[u++] = $ >>> 24, B[u++] = $ >>> 16 & 255, B[u++] = $ >>> 8 & 255, B[u++] = 255 & $;
  }
  return n || (B = function(p) {
    let d, y = null;
    if (d = 0, !y) {
      for (y = 1; p[p.length - y] === d; ) y++;
      y--;
    }
    return p.subarray(0, p.length - y);
  }(B)), B;
}
function s2(t3) {
  const e = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], n = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], r = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], s = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], i = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], a = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], o = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], f = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], c = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], l = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], h = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], m = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], v = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], b = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261], A = t3.length > 8 ? 3 : 1, _ = Array(32 * A), C = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];
  let I, S, $, F = 0, U = 0;
  for (let Q = 0; Q < A; Q++) {
    let P = t3[F++] << 24 | t3[F++] << 16 | t3[F++] << 8 | t3[F++], N = t3[F++] << 24 | t3[F++] << 16 | t3[F++] << 8 | t3[F++];
    $ = 252645135 & (P >>> 4 ^ N), N ^= $, P ^= $ << 4, $ = 65535 & (N >>> -16 ^ P), P ^= $, N ^= $ << -16, $ = 858993459 & (P >>> 2 ^ N), N ^= $, P ^= $ << 2, $ = 65535 & (N >>> -16 ^ P), P ^= $, N ^= $ << -16, $ = 1431655765 & (P >>> 1 ^ N), N ^= $, P ^= $ << 1, $ = 16711935 & (N >>> 8 ^ P), P ^= $, N ^= $ << 8, $ = 1431655765 & (P >>> 1 ^ N), N ^= $, P ^= $ << 1, $ = P << 8 | N >>> 20 & 240, P = N << 24 | N << 8 & 16711680 | N >>> 8 & 65280 | N >>> 24 & 240, N = $;
    for (let L = 0; L < 16; L++) C[L] ? (P = P << 2 | P >>> 26, N = N << 2 | N >>> 26) : (P = P << 1 | P >>> 27, N = N << 1 | N >>> 27), P &= -15, N &= -15, I = e[P >>> 28] | n[P >>> 24 & 15] | r[P >>> 20 & 15] | s[P >>> 16 & 15] | i[P >>> 12 & 15] | a[P >>> 8 & 15] | o[P >>> 4 & 15], S = f[N >>> 28] | c[N >>> 24 & 15] | l[N >>> 20 & 15] | h[N >>> 16 & 15] | m[N >>> 12 & 15] | v[N >>> 8 & 15] | b[N >>> 4 & 15], $ = 65535 & (S >>> 16 ^ I), _[U++] = I ^ $, _[U++] = S ^ $ << 16;
  }
  return _;
}
function Gc(t3) {
  this.key = [];
  for (let e = 0; e < 3; e++) this.key.push(new Uint8Array(t3.subarray(8 * e, 8 * e + 8)));
  this.encrypt = function(e) {
    return i2(s2(this.key[2]), i2(s2(this.key[1]), i2(s2(this.key[0]), e, true), false), true);
  };
}
function uO() {
  this.BlockSize = 8, this.KeySize = 16, this.setKey = function(a) {
    if (this.masking = Array(16), this.rotate = Array(16), this.reset(), a.length !== this.KeySize) throw Error("CAST-128: keys must be 16 bytes");
    return this.keySchedule(a), true;
  }, this.reset = function() {
    for (let a = 0; a < 16; a++) this.masking[a] = 0, this.rotate[a] = 0;
  }, this.getBlockSize = function() {
    return this.BlockSize;
  }, this.encrypt = function(a) {
    const o = Array(a.length);
    for (let f = 0; f < a.length; f += 8) {
      let c, l = a[f] << 24 | a[f + 1] << 16 | a[f + 2] << 8 | a[f + 3], h = a[f + 4] << 24 | a[f + 5] << 16 | a[f + 6] << 8 | a[f + 7];
      c = h, h = l ^ n(h, this.masking[0], this.rotate[0]), l = c, c = h, h = l ^ r(h, this.masking[1], this.rotate[1]), l = c, c = h, h = l ^ s(h, this.masking[2], this.rotate[2]), l = c, c = h, h = l ^ n(h, this.masking[3], this.rotate[3]), l = c, c = h, h = l ^ r(h, this.masking[4], this.rotate[4]), l = c, c = h, h = l ^ s(h, this.masking[5], this.rotate[5]), l = c, c = h, h = l ^ n(h, this.masking[6], this.rotate[6]), l = c, c = h, h = l ^ r(h, this.masking[7], this.rotate[7]), l = c, c = h, h = l ^ s(h, this.masking[8], this.rotate[8]), l = c, c = h, h = l ^ n(h, this.masking[9], this.rotate[9]), l = c, c = h, h = l ^ r(h, this.masking[10], this.rotate[10]), l = c, c = h, h = l ^ s(h, this.masking[11], this.rotate[11]), l = c, c = h, h = l ^ n(h, this.masking[12], this.rotate[12]), l = c, c = h, h = l ^ r(h, this.masking[13], this.rotate[13]), l = c, c = h, h = l ^ s(h, this.masking[14], this.rotate[14]), l = c, c = h, h = l ^ n(h, this.masking[15], this.rotate[15]), l = c, o[f] = h >>> 24 & 255, o[f + 1] = h >>> 16 & 255, o[f + 2] = h >>> 8 & 255, o[f + 3] = 255 & h, o[f + 4] = l >>> 24 & 255, o[f + 5] = l >>> 16 & 255, o[f + 6] = l >>> 8 & 255, o[f + 7] = 255 & l;
    }
    return o;
  }, this.decrypt = function(a) {
    const o = Array(a.length);
    for (let f = 0; f < a.length; f += 8) {
      let c, l = a[f] << 24 | a[f + 1] << 16 | a[f + 2] << 8 | a[f + 3], h = a[f + 4] << 24 | a[f + 5] << 16 | a[f + 6] << 8 | a[f + 7];
      c = h, h = l ^ n(h, this.masking[15], this.rotate[15]), l = c, c = h, h = l ^ s(h, this.masking[14], this.rotate[14]), l = c, c = h, h = l ^ r(h, this.masking[13], this.rotate[13]), l = c, c = h, h = l ^ n(h, this.masking[12], this.rotate[12]), l = c, c = h, h = l ^ s(h, this.masking[11], this.rotate[11]), l = c, c = h, h = l ^ r(h, this.masking[10], this.rotate[10]), l = c, c = h, h = l ^ n(h, this.masking[9], this.rotate[9]), l = c, c = h, h = l ^ s(h, this.masking[8], this.rotate[8]), l = c, c = h, h = l ^ r(h, this.masking[7], this.rotate[7]), l = c, c = h, h = l ^ n(h, this.masking[6], this.rotate[6]), l = c, c = h, h = l ^ s(h, this.masking[5], this.rotate[5]), l = c, c = h, h = l ^ r(h, this.masking[4], this.rotate[4]), l = c, c = h, h = l ^ n(h, this.masking[3], this.rotate[3]), l = c, c = h, h = l ^ s(h, this.masking[2], this.rotate[2]), l = c, c = h, h = l ^ r(h, this.masking[1], this.rotate[1]), l = c, c = h, h = l ^ n(h, this.masking[0], this.rotate[0]), l = c, o[f] = h >>> 24 & 255, o[f + 1] = h >>> 16 & 255, o[f + 2] = h >>> 8 & 255, o[f + 3] = 255 & h, o[f + 4] = l >>> 24 & 255, o[f + 5] = l >> 16 & 255, o[f + 6] = l >> 8 & 255, o[f + 7] = 255 & l;
    }
    return o;
  };
  const t3 = [, , , ,];
  t3[0] = [, , , ,], t3[0][0] = [4, 0, 13, 15, 12, 14, 8], t3[0][1] = [5, 2, 16, 18, 17, 19, 10], t3[0][2] = [6, 3, 23, 22, 21, 20, 9], t3[0][3] = [7, 1, 26, 25, 27, 24, 11], t3[1] = [, , , ,], t3[1][0] = [0, 6, 21, 23, 20, 22, 16], t3[1][1] = [1, 4, 0, 2, 1, 3, 18], t3[1][2] = [2, 5, 7, 6, 5, 4, 17], t3[1][3] = [3, 7, 10, 9, 11, 8, 19], t3[2] = [, , , ,], t3[2][0] = [4, 0, 13, 15, 12, 14, 8], t3[2][1] = [5, 2, 16, 18, 17, 19, 10], t3[2][2] = [6, 3, 23, 22, 21, 20, 9], t3[2][3] = [7, 1, 26, 25, 27, 24, 11], t3[3] = [, , , ,], t3[3][0] = [0, 6, 21, 23, 20, 22, 16], t3[3][1] = [1, 4, 0, 2, 1, 3, 18], t3[3][2] = [2, 5, 7, 6, 5, 4, 17], t3[3][3] = [3, 7, 10, 9, 11, 8, 19];
  const e = [, , , ,];
  function n(a, o, f) {
    const c = o + a, l = c << f | c >>> 32 - f;
    return (i[0][l >>> 24] ^ i[1][l >>> 16 & 255]) - i[2][l >>> 8 & 255] + i[3][255 & l];
  }
  function r(a, o, f) {
    const c = o ^ a, l = c << f | c >>> 32 - f;
    return i[0][l >>> 24] - i[1][l >>> 16 & 255] + i[2][l >>> 8 & 255] ^ i[3][255 & l];
  }
  function s(a, o, f) {
    const c = o - a, l = c << f | c >>> 32 - f;
    return (i[0][l >>> 24] + i[1][l >>> 16 & 255] ^ i[2][l >>> 8 & 255]) - i[3][255 & l];
  }
  e[0] = [, , , ,], e[0][0] = [24, 25, 23, 22, 18], e[0][1] = [26, 27, 21, 20, 22], e[0][2] = [28, 29, 19, 18, 25], e[0][3] = [30, 31, 17, 16, 28], e[1] = [, , , ,], e[1][0] = [3, 2, 12, 13, 8], e[1][1] = [1, 0, 14, 15, 13], e[1][2] = [7, 6, 8, 9, 3], e[1][3] = [5, 4, 10, 11, 7], e[2] = [, , , ,], e[2][0] = [19, 18, 28, 29, 25], e[2][1] = [17, 16, 30, 31, 28], e[2][2] = [23, 22, 24, 25, 18], e[2][3] = [21, 20, 26, 27, 22], e[3] = [, , , ,], e[3][0] = [8, 9, 7, 6, 3], e[3][1] = [10, 11, 5, 4, 7], e[3][2] = [12, 13, 3, 2, 8], e[3][3] = [14, 15, 1, 0, 13], this.keySchedule = function(a) {
    const o = [, , , , , , , ,], f = Array(32);
    let c;
    for (let v = 0; v < 4; v++) c = 4 * v, o[v] = a[c] << 24 | a[c + 1] << 16 | a[c + 2] << 8 | a[c + 3];
    const l = [6, 7, 4, 5];
    let h, m = 0;
    for (let v = 0; v < 2; v++) for (let b = 0; b < 4; b++) {
      for (c = 0; c < 4; c++) {
        const A = t3[b][c];
        h = o[A[1]], h ^= i[4][o[A[2] >>> 2] >>> 24 - 8 * (3 & A[2]) & 255], h ^= i[5][o[A[3] >>> 2] >>> 24 - 8 * (3 & A[3]) & 255], h ^= i[6][o[A[4] >>> 2] >>> 24 - 8 * (3 & A[4]) & 255], h ^= i[7][o[A[5] >>> 2] >>> 24 - 8 * (3 & A[5]) & 255], h ^= i[l[c]][o[A[6] >>> 2] >>> 24 - 8 * (3 & A[6]) & 255], o[A[0]] = h;
      }
      for (c = 0; c < 4; c++) {
        const A = e[b][c];
        h = i[4][o[A[0] >>> 2] >>> 24 - 8 * (3 & A[0]) & 255], h ^= i[5][o[A[1] >>> 2] >>> 24 - 8 * (3 & A[1]) & 255], h ^= i[6][o[A[2] >>> 2] >>> 24 - 8 * (3 & A[2]) & 255], h ^= i[7][o[A[3] >>> 2] >>> 24 - 8 * (3 & A[3]) & 255], h ^= i[4 + c][o[A[4] >>> 2] >>> 24 - 8 * (3 & A[4]) & 255], f[m] = h, m++;
      }
    }
    for (let v = 0; v < 16; v++) this.masking[v] = f[v], this.rotate[v] = 31 & f[16 + v];
  };
  const i = [, , , , , , , ,];
  i[0] = [821772500, 2678128395, 1810681135, 1059425402, 505495343, 2617265619, 1610868032, 3483355465, 3218386727, 2294005173, 3791863952, 2563806837, 1852023008, 365126098, 3269944861, 584384398, 677919599, 3229601881, 4280515016, 2002735330, 1136869587, 3744433750, 2289869850, 2731719981, 2714362070, 879511577, 1639411079, 575934255, 717107937, 2857637483, 576097850, 2731753936, 1725645e3, 2810460463, 5111599, 767152862, 2543075244, 1251459544, 1383482551, 3052681127, 3089939183, 3612463449, 1878520045, 1510570527, 2189125840, 2431448366, 582008916, 3163445557, 1265446783, 1354458274, 3529918736, 3202711853, 3073581712, 3912963487, 3029263377, 1275016285, 4249207360, 2905708351, 3304509486, 1442611557, 3585198765, 2712415662, 2731849581, 3248163920, 2283946226, 208555832, 2766454743, 1331405426, 1447828783, 3315356441, 3108627284, 2957404670, 2981538698, 3339933917, 1669711173, 286233437, 1465092821, 1782121619, 3862771680, 710211251, 980974943, 1651941557, 430374111, 2051154026, 704238805, 4128970897, 3144820574, 2857402727, 948965521, 3333752299, 2227686284, 718756367, 2269778983, 2731643755, 718440111, 2857816721, 3616097120, 1113355533, 2478022182, 410092745, 1811985197, 1944238868, 2696854588, 1415722873, 1682284203, 1060277122, 1998114690, 1503841958, 82706478, 2315155686, 1068173648, 845149890, 2167947013, 1768146376, 1993038550, 3566826697, 3390574031, 940016341, 3355073782, 2328040721, 904371731, 1205506512, 4094660742, 2816623006, 825647681, 85914773, 2857843460, 1249926541, 1417871568, 3287612, 3211054559, 3126306446, 1975924523, 1353700161, 2814456437, 2438597621, 1800716203, 722146342, 2873936343, 1151126914, 4160483941, 2877670899, 458611604, 2866078500, 3483680063, 770352098, 2652916994, 3367839148, 3940505011, 3585973912, 3809620402, 718646636, 2504206814, 2914927912, 3631288169, 2857486607, 2860018678, 575749918, 2857478043, 718488780, 2069512688, 3548183469, 453416197, 1106044049, 3032691430, 52586708, 3378514636, 3459808877, 3211506028, 1785789304, 218356169, 3571399134, 3759170522, 1194783844, 1523787992, 3007827094, 1975193539, 2555452411, 1341901877, 3045838698, 3776907964, 3217423946, 2802510864, 2889438986, 1057244207, 1636348243, 3761863214, 1462225785, 2632663439, 481089165, 718503062, 24497053, 3332243209, 3344655856, 3655024856, 3960371065, 1195698900, 2971415156, 3710176158, 2115785917, 4027663609, 3525578417, 2524296189, 2745972565, 3564906415, 1372086093, 1452307862, 2780501478, 1476592880, 3389271281, 18495466, 2378148571, 901398090, 891748256, 3279637769, 3157290713, 2560960102, 1447622437, 4284372637, 216884176, 2086908623, 1879786977, 3588903153, 2242455666, 2938092967, 3559082096, 2810645491, 758861177, 1121993112, 215018983, 642190776, 4169236812, 1196255959, 2081185372, 3508738393, 941322904, 4124243163, 2877523539, 1848581667, 2205260958, 3180453958, 2589345134, 3694731276, 550028657, 2519456284, 3789985535, 2973870856, 2093648313, 443148163, 46942275, 2734146937, 1117713533, 1115362972, 1523183689, 3717140224, 1551984063], i[1] = [522195092, 4010518363, 1776537470, 960447360, 4267822970, 4005896314, 1435016340, 1929119313, 2913464185, 1310552629, 3579470798, 3724818106, 2579771631, 1594623892, 417127293, 2715217907, 2696228731, 1508390405, 3994398868, 3925858569, 3695444102, 4019471449, 3129199795, 3770928635, 3520741761, 990456497, 4187484609, 2783367035, 21106139, 3840405339, 631373633, 3783325702, 532942976, 396095098, 3548038825, 4267192484, 2564721535, 2011709262, 2039648873, 620404603, 3776170075, 2898526339, 3612357925, 4159332703, 1645490516, 223693667, 1567101217, 3362177881, 1029951347, 3470931136, 3570957959, 1550265121, 119497089, 972513919, 907948164, 3840628539, 1613718692, 3594177948, 465323573, 2659255085, 654439692, 2575596212, 2699288441, 3127702412, 277098644, 624404830, 4100943870, 2717858591, 546110314, 2403699828, 3655377447, 1321679412, 4236791657, 1045293279, 4010672264, 895050893, 2319792268, 494945126, 1914543101, 2777056443, 3894764339, 2219737618, 311263384, 4275257268, 3458730721, 669096869, 3584475730, 3835122877, 3319158237, 3949359204, 2005142349, 2713102337, 2228954793, 3769984788, 569394103, 3855636576, 1425027204, 108000370, 2736431443, 3671869269, 3043122623, 1750473702, 2211081108, 762237499, 3972989403, 2798899386, 3061857628, 2943854345, 867476300, 964413654, 1591880597, 1594774276, 2179821409, 552026980, 3026064248, 3726140315, 2283577634, 3110545105, 2152310760, 582474363, 1582640421, 1383256631, 2043843868, 3322775884, 1217180674, 463797851, 2763038571, 480777679, 2718707717, 2289164131, 3118346187, 214354409, 200212307, 3810608407, 3025414197, 2674075964, 3997296425, 1847405948, 1342460550, 510035443, 4080271814, 815934613, 833030224, 1620250387, 1945732119, 2703661145, 3966000196, 1388869545, 3456054182, 2687178561, 2092620194, 562037615, 1356438536, 3409922145, 3261847397, 1688467115, 2150901366, 631725691, 3840332284, 549916902, 3455104640, 394546491, 837744717, 2114462948, 751520235, 2221554606, 2415360136, 3999097078, 2063029875, 803036379, 2702586305, 821456707, 3019566164, 360699898, 4018502092, 3511869016, 3677355358, 2402471449, 812317050, 49299192, 2570164949, 3259169295, 2816732080, 3331213574, 3101303564, 2156015656, 3705598920, 3546263921, 143268808, 3200304480, 1638124008, 3165189453, 3341807610, 578956953, 2193977524, 3638120073, 2333881532, 807278310, 658237817, 2969561766, 1641658566, 11683945, 3086995007, 148645947, 1138423386, 4158756760, 1981396783, 2401016740, 3699783584, 380097457, 2680394679, 2803068651, 3334260286, 441530178, 4016580796, 1375954390, 761952171, 891809099, 2183123478, 157052462, 3683840763, 1592404427, 341349109, 2438483839, 1417898363, 644327628, 2233032776, 2353769706, 2201510100, 220455161, 1815641738, 182899273, 2995019788, 3627381533, 3702638151, 2890684138, 1052606899, 588164016, 1681439879, 4038439418, 2405343923, 4229449282, 167996282, 1336969661, 1688053129, 2739224926, 1543734051, 1046297529, 1138201970, 2121126012, 115334942, 1819067631, 1902159161, 1941945968, 2206692869, 1159982321], i[2] = [2381300288, 637164959, 3952098751, 3893414151, 1197506559, 916448331, 2350892612, 2932787856, 3199334847, 4009478890, 3905886544, 1373570990, 2450425862, 4037870920, 3778841987, 2456817877, 286293407, 124026297, 3001279700, 1028597854, 3115296800, 4208886496, 2691114635, 2188540206, 1430237888, 1218109995, 3572471700, 308166588, 570424558, 2187009021, 2455094765, 307733056, 1310360322, 3135275007, 1384269543, 2388071438, 863238079, 2359263624, 2801553128, 3380786597, 2831162807, 1470087780, 1728663345, 4072488799, 1090516929, 532123132, 2389430977, 1132193179, 2578464191, 3051079243, 1670234342, 1434557849, 2711078940, 1241591150, 3314043432, 3435360113, 3091448339, 1812415473, 2198440252, 267246943, 796911696, 3619716990, 38830015, 1526438404, 2806502096, 374413614, 2943401790, 1489179520, 1603809326, 1920779204, 168801282, 260042626, 2358705581, 1563175598, 2397674057, 1356499128, 2217211040, 514611088, 2037363785, 2186468373, 4022173083, 2792511869, 2913485016, 1173701892, 4200428547, 3896427269, 1334932762, 2455136706, 602925377, 2835607854, 1613172210, 41346230, 2499634548, 2457437618, 2188827595, 41386358, 4172255629, 1313404830, 2405527007, 3801973774, 2217704835, 873260488, 2528884354, 2478092616, 4012915883, 2555359016, 2006953883, 2463913485, 575479328, 2218240648, 2099895446, 660001756, 2341502190, 3038761536, 3888151779, 3848713377, 3286851934, 1022894237, 1620365795, 3449594689, 1551255054, 15374395, 3570825345, 4249311020, 4151111129, 3181912732, 310226346, 1133119310, 530038928, 136043402, 2476768958, 3107506709, 2544909567, 1036173560, 2367337196, 1681395281, 1758231547, 3641649032, 306774401, 1575354324, 3716085866, 1990386196, 3114533736, 2455606671, 1262092282, 3124342505, 2768229131, 4210529083, 1833535011, 423410938, 660763973, 2187129978, 1639812e3, 3508421329, 3467445492, 310289298, 272797111, 2188552562, 2456863912, 310240523, 677093832, 1013118031, 901835429, 3892695601, 1116285435, 3036471170, 1337354835, 243122523, 520626091, 277223598, 4244441197, 4194248841, 1766575121, 594173102, 316590669, 742362309, 3536858622, 4176435350, 3838792410, 2501204839, 1229605004, 3115755532, 1552908988, 2312334149, 979407927, 3959474601, 1148277331, 176638793, 3614686272, 2083809052, 40992502, 1340822838, 2731552767, 3535757508, 3560899520, 1354035053, 122129617, 7215240, 2732932949, 3118912700, 2718203926, 2539075635, 3609230695, 3725561661, 1928887091, 2882293555, 1988674909, 2063640240, 2491088897, 1459647954, 4189817080, 2302804382, 1113892351, 2237858528, 1927010603, 4002880361, 1856122846, 1594404395, 2944033133, 3855189863, 3474975698, 1643104450, 4054590833, 3431086530, 1730235576, 2984608721, 3084664418, 2131803598, 4178205752, 267404349, 1617849798, 1616132681, 1462223176, 736725533, 2327058232, 551665188, 2945899023, 1749386277, 2575514597, 1611482493, 674206544, 2201269090, 3642560800, 728599968, 1680547377, 2620414464, 1388111496, 453204106, 4156223445, 1094905244, 2754698257, 2201108165, 3757000246, 2704524545, 3922940700, 3996465027], i[3] = [2645754912, 532081118, 2814278639, 3530793624, 1246723035, 1689095255, 2236679235, 4194438865, 2116582143, 3859789411, 157234593, 2045505824, 4245003587, 1687664561, 4083425123, 605965023, 672431967, 1336064205, 3376611392, 214114848, 4258466608, 3232053071, 489488601, 605322005, 3998028058, 264917351, 1912574028, 756637694, 436560991, 202637054, 135989450, 85393697, 2152923392, 3896401662, 2895836408, 2145855233, 3535335007, 115294817, 3147733898, 1922296357, 3464822751, 4117858305, 1037454084, 2725193275, 2127856640, 1417604070, 1148013728, 1827919605, 642362335, 2929772533, 909348033, 1346338451, 3547799649, 297154785, 1917849091, 4161712827, 2883604526, 3968694238, 1469521537, 3780077382, 3375584256, 1763717519, 136166297, 4290970789, 1295325189, 2134727907, 2798151366, 1566297257, 3672928234, 2677174161, 2672173615, 965822077, 2780786062, 289653839, 1133871874, 3491843819, 35685304, 1068898316, 418943774, 672553190, 642281022, 2346158704, 1954014401, 3037126780, 4079815205, 2030668546, 3840588673, 672283427, 1776201016, 359975446, 3750173538, 555499703, 2769985273, 1324923, 69110472, 152125443, 3176785106, 3822147285, 1340634837, 798073664, 1434183902, 15393959, 216384236, 1303690150, 3881221631, 3711134124, 3960975413, 106373927, 2578434224, 1455997841, 1801814300, 1578393881, 1854262133, 3188178946, 3258078583, 2302670060, 1539295533, 3505142565, 3078625975, 2372746020, 549938159, 3278284284, 2620926080, 181285381, 2865321098, 3970029511, 68876850, 488006234, 1728155692, 2608167508, 836007927, 2435231793, 919367643, 3339422534, 3655756360, 1457871481, 40520939, 1380155135, 797931188, 234455205, 2255801827, 3990488299, 397000196, 739833055, 3077865373, 2871719860, 4022553888, 772369276, 390177364, 3853951029, 557662966, 740064294, 1640166671, 1699928825, 3535942136, 622006121, 3625353122, 68743880, 1742502, 219489963, 1664179233, 1577743084, 1236991741, 410585305, 2366487942, 823226535, 1050371084, 3426619607, 3586839478, 212779912, 4147118561, 1819446015, 1911218849, 530248558, 3486241071, 3252585495, 2886188651, 3410272728, 2342195030, 20547779, 2982490058, 3032363469, 3631753222, 312714466, 1870521650, 1493008054, 3491686656, 615382978, 4103671749, 2534517445, 1932181, 2196105170, 278426614, 6369430, 3274544417, 2913018367, 697336853, 2143000447, 2946413531, 701099306, 1558357093, 2805003052, 3500818408, 2321334417, 3567135975, 216290473, 3591032198, 23009561, 1996984579, 3735042806, 2024298078, 3739440863, 569400510, 2339758983, 3016033873, 3097871343, 3639523026, 3844324983, 3256173865, 795471839, 2951117563, 4101031090, 4091603803, 3603732598, 971261452, 534414648, 428311343, 3389027175, 2844869880, 694888862, 1227866773, 2456207019, 3043454569, 2614353370, 3749578031, 3676663836, 459166190, 4132644070, 1794958188, 51825668, 2252611902, 3084671440, 2036672799, 3436641603, 1099053433, 2469121526, 3059204941, 1323291266, 2061838604, 1018778475, 2233344254, 2553501054, 334295216, 3556750194, 1065731521, 183467730], i[4] = [2127105028, 745436345, 2601412319, 2788391185, 3093987327, 500390133, 1155374404, 389092991, 150729210, 3891597772, 3523549952, 1935325696, 716645080, 946045387, 2901812282, 1774124410, 3869435775, 4039581901, 3293136918, 3438657920, 948246080, 363898952, 3867875531, 1286266623, 1598556673, 68334250, 630723836, 1104211938, 1312863373, 613332731, 2377784574, 1101634306, 441780740, 3129959883, 1917973735, 2510624549, 3238456535, 2544211978, 3308894634, 1299840618, 4076074851, 1756332096, 3977027158, 297047435, 3790297736, 2265573040, 3621810518, 1311375015, 1667687725, 47300608, 3299642885, 2474112369, 201668394, 1468347890, 576830978, 3594690761, 3742605952, 1958042578, 1747032512, 3558991340, 1408974056, 3366841779, 682131401, 1033214337, 1545599232, 4265137049, 206503691, 103024618, 2855227313, 1337551222, 2428998917, 2963842932, 4015366655, 3852247746, 2796956967, 3865723491, 3747938335, 247794022, 3755824572, 702416469, 2434691994, 397379957, 851939612, 2314769512, 218229120, 1380406772, 62274761, 214451378, 3170103466, 2276210409, 3845813286, 28563499, 446592073, 1693330814, 3453727194, 29968656, 3093872512, 220656637, 2470637031, 77972100, 1667708854, 1358280214, 4064765667, 2395616961, 325977563, 4277240721, 4220025399, 3605526484, 3355147721, 811859167, 3069544926, 3962126810, 652502677, 3075892249, 4132761541, 3498924215, 1217549313, 3250244479, 3858715919, 3053989961, 1538642152, 2279026266, 2875879137, 574252750, 3324769229, 2651358713, 1758150215, 141295887, 2719868960, 3515574750, 4093007735, 4194485238, 1082055363, 3417560400, 395511885, 2966884026, 179534037, 3646028556, 3738688086, 1092926436, 2496269142, 257381841, 3772900718, 1636087230, 1477059743, 2499234752, 3811018894, 2675660129, 3285975680, 90732309, 1684827095, 1150307763, 1723134115, 3237045386, 1769919919, 1240018934, 815675215, 750138730, 2239792499, 1234303040, 1995484674, 138143821, 675421338, 1145607174, 1936608440, 3238603024, 2345230278, 2105974004, 323969391, 779555213, 3004902369, 2861610098, 1017501463, 2098600890, 2628620304, 2940611490, 2682542546, 1171473753, 3656571411, 3687208071, 4091869518, 393037935, 159126506, 1662887367, 1147106178, 391545844, 3452332695, 1891500680, 3016609650, 1851642611, 546529401, 1167818917, 3194020571, 2848076033, 3953471836, 575554290, 475796850, 4134673196, 450035699, 2351251534, 844027695, 1080539133, 86184846, 1554234488, 3692025454, 1972511363, 2018339607, 1491841390, 1141460869, 1061690759, 4244549243, 2008416118, 2351104703, 2868147542, 1598468138, 722020353, 1027143159, 212344630, 1387219594, 1725294528, 3745187956, 2500153616, 458938280, 4129215917, 1828119673, 544571780, 3503225445, 2297937496, 1241802790, 267843827, 2694610800, 1397140384, 1558801448, 3782667683, 1806446719, 929573330, 2234912681, 400817706, 616011623, 4121520928, 3603768725, 1761550015, 1968522284, 4053731006, 4192232858, 4005120285, 872482584, 3140537016, 3894607381, 2287405443, 1963876937, 3663887957, 1584857e3, 2975024454, 1833426440, 4025083860], i[5] = [4143615901, 749497569, 1285769319, 3795025788, 2514159847, 23610292, 3974978748, 844452780, 3214870880, 3751928557, 2213566365, 1676510905, 448177848, 3730751033, 4086298418, 2307502392, 871450977, 3222878141, 4110862042, 3831651966, 2735270553, 1310974780, 2043402188, 1218528103, 2736035353, 4274605013, 2702448458, 3936360550, 2693061421, 162023535, 2827510090, 687910808, 23484817, 3784910947, 3371371616, 779677500, 3503626546, 3473927188, 4157212626, 3500679282, 4248902014, 2466621104, 3899384794, 1958663117, 925738300, 1283408968, 3669349440, 1840910019, 137959847, 2679828185, 1239142320, 1315376211, 1547541505, 1690155329, 739140458, 3128809933, 3933172616, 3876308834, 905091803, 1548541325, 4040461708, 3095483362, 144808038, 451078856, 676114313, 2861728291, 2469707347, 993665471, 373509091, 2599041286, 4025009006, 4170239449, 2149739950, 3275793571, 3749616649, 2794760199, 1534877388, 572371878, 2590613551, 1753320020, 3467782511, 1405125690, 4270405205, 633333386, 3026356924, 3475123903, 632057672, 2846462855, 1404951397, 3882875879, 3915906424, 195638627, 2385783745, 3902872553, 1233155085, 3355999740, 2380578713, 2702246304, 2144565621, 3663341248, 3894384975, 2502479241, 4248018925, 3094885567, 1594115437, 572884632, 3385116731, 767645374, 1331858858, 1475698373, 3793881790, 3532746431, 1321687957, 619889600, 1121017241, 3440213920, 2070816767, 2833025776, 1933951238, 4095615791, 890643334, 3874130214, 859025556, 360630002, 925594799, 1764062180, 3920222280, 4078305929, 979562269, 2810700344, 4087740022, 1949714515, 546639971, 1165388173, 3069891591, 1495988560, 922170659, 1291546247, 2107952832, 1813327274, 3406010024, 3306028637, 4241950635, 153207855, 2313154747, 1608695416, 1150242611, 1967526857, 721801357, 1220138373, 3691287617, 3356069787, 2112743302, 3281662835, 1111556101, 1778980689, 250857638, 2298507990, 673216130, 2846488510, 3207751581, 3562756981, 3008625920, 3417367384, 2198807050, 529510932, 3547516680, 3426503187, 2364944742, 102533054, 2294910856, 1617093527, 1204784762, 3066581635, 1019391227, 1069574518, 1317995090, 1691889997, 3661132003, 510022745, 3238594800, 1362108837, 1817929911, 2184153760, 805817662, 1953603311, 3699844737, 120799444, 2118332377, 207536705, 2282301548, 4120041617, 145305846, 2508124933, 3086745533, 3261524335, 1877257368, 2977164480, 3160454186, 2503252186, 4221677074, 759945014, 254147243, 2767453419, 3801518371, 629083197, 2471014217, 907280572, 3900796746, 940896768, 2751021123, 2625262786, 3161476951, 3661752313, 3260732218, 1425318020, 2977912069, 1496677566, 3988592072, 2140652971, 3126511541, 3069632175, 977771578, 1392695845, 1698528874, 1411812681, 1369733098, 1343739227, 3620887944, 1142123638, 67414216, 3102056737, 3088749194, 1626167401, 2546293654, 3941374235, 697522451, 33404913, 143560186, 2595682037, 994885535, 1247667115, 3859094837, 2699155541, 3547024625, 4114935275, 2968073508, 3199963069, 2732024527, 1237921620, 951448369, 1898488916, 1211705605, 2790989240, 2233243581, 3598044975], i[6] = [2246066201, 858518887, 1714274303, 3485882003, 713916271, 2879113490, 3730835617, 539548191, 36158695, 1298409750, 419087104, 1358007170, 749914897, 2989680476, 1261868530, 2995193822, 2690628854, 3443622377, 3780124940, 3796824509, 2976433025, 4259637129, 1551479e3, 512490819, 1296650241, 951993153, 2436689437, 2460458047, 144139966, 3136204276, 310820559, 3068840729, 643875328, 1969602020, 1680088954, 2185813161, 3283332454, 672358534, 198762408, 896343282, 276269502, 3014846926, 84060815, 197145886, 376173866, 3943890818, 3813173521, 3545068822, 1316698879, 1598252827, 2633424951, 1233235075, 859989710, 2358460855, 3503838400, 3409603720, 1203513385, 1193654839, 2792018475, 2060853022, 207403770, 1144516871, 3068631394, 1121114134, 177607304, 3785736302, 326409831, 1929119770, 2983279095, 4183308101, 3474579288, 3200513878, 3228482096, 119610148, 1170376745, 3378393471, 3163473169, 951863017, 3337026068, 3135789130, 2907618374, 1183797387, 2015970143, 4045674555, 2182986399, 2952138740, 3928772205, 384012900, 2454997643, 10178499, 2879818989, 2596892536, 111523738, 2995089006, 451689641, 3196290696, 235406569, 1441906262, 3890558523, 3013735005, 4158569349, 1644036924, 376726067, 1006849064, 3664579700, 2041234796, 1021632941, 1374734338, 2566452058, 371631263, 4007144233, 490221539, 206551450, 3140638584, 1053219195, 1853335209, 3412429660, 3562156231, 735133835, 1623211703, 3104214392, 2738312436, 4096837757, 3366392578, 3110964274, 3956598718, 3196820781, 2038037254, 3877786376, 2339753847, 300912036, 3766732888, 2372630639, 1516443558, 4200396704, 1574567987, 4069441456, 4122592016, 2699739776, 146372218, 2748961456, 2043888151, 35287437, 2596680554, 655490400, 1132482787, 110692520, 1031794116, 2188192751, 1324057718, 1217253157, 919197030, 686247489, 3261139658, 1028237775, 3135486431, 3059715558, 2460921700, 986174950, 2661811465, 4062904701, 2752986992, 3709736643, 367056889, 1353824391, 731860949, 1650113154, 1778481506, 784341916, 357075625, 3608602432, 1074092588, 2480052770, 3811426202, 92751289, 877911070, 3600361838, 1231880047, 480201094, 3756190983, 3094495953, 434011822, 87971354, 363687820, 1717726236, 1901380172, 3926403882, 2481662265, 400339184, 1490350766, 2661455099, 1389319756, 2558787174, 784598401, 1983468483, 30828846, 3550527752, 2716276238, 3841122214, 1765724805, 1955612312, 1277890269, 1333098070, 1564029816, 2704417615, 1026694237, 3287671188, 1260819201, 3349086767, 1016692350, 1582273796, 1073413053, 1995943182, 694588404, 1025494639, 3323872702, 3551898420, 4146854327, 453260480, 1316140391, 1435673405, 3038941953, 3486689407, 1622062951, 403978347, 817677117, 950059133, 4246079218, 3278066075, 1486738320, 1417279718, 481875527, 2549965225, 3933690356, 760697757, 1452955855, 3897451437, 1177426808, 1702951038, 4085348628, 2447005172, 1084371187, 3516436277, 3068336338, 1073369276, 1027665953, 3284188590, 1230553676, 1368340146, 2226246512, 267243139, 2274220762, 4070734279, 2497715176, 2423353163, 2504755875], i[7] = [3793104909, 3151888380, 2817252029, 895778965, 2005530807, 3871412763, 237245952, 86829237, 296341424, 3851759377, 3974600970, 2475086196, 709006108, 1994621201, 2972577594, 937287164, 3734691505, 168608556, 3189338153, 2225080640, 3139713551, 3033610191, 3025041904, 77524477, 185966941, 1208824168, 2344345178, 1721625922, 3354191921, 1066374631, 1927223579, 1971335949, 2483503697, 1551748602, 2881383779, 2856329572, 3003241482, 48746954, 1398218158, 2050065058, 313056748, 4255789917, 393167848, 1912293076, 940740642, 3465845460, 3091687853, 2522601570, 2197016661, 1727764327, 364383054, 492521376, 1291706479, 3264136376, 1474851438, 1685747964, 2575719748, 1619776915, 1814040067, 970743798, 1561002147, 2925768690, 2123093554, 1880132620, 3151188041, 697884420, 2550985770, 2607674513, 2659114323, 110200136, 1489731079, 997519150, 1378877361, 3527870668, 478029773, 2766872923, 1022481122, 431258168, 1112503832, 897933369, 2635587303, 669726182, 3383752315, 918222264, 163866573, 3246985393, 3776823163, 114105080, 1903216136, 761148244, 3571337562, 1690750982, 3166750252, 1037045171, 1888456500, 2010454850, 642736655, 616092351, 365016990, 1185228132, 4174898510, 1043824992, 2023083429, 2241598885, 3863320456, 3279669087, 3674716684, 108438443, 2132974366, 830746235, 606445527, 4173263986, 2204105912, 1844756978, 2532684181, 4245352700, 2969441100, 3796921661, 1335562986, 4061524517, 2720232303, 2679424040, 634407289, 885462008, 3294724487, 3933892248, 2094100220, 339117932, 4048830727, 3202280980, 1458155303, 2689246273, 1022871705, 2464987878, 3714515309, 353796843, 2822958815, 4256850100, 4052777845, 551748367, 618185374, 3778635579, 4020649912, 1904685140, 3069366075, 2670879810, 3407193292, 2954511620, 4058283405, 2219449317, 3135758300, 1120655984, 3447565834, 1474845562, 3577699062, 550456716, 3466908712, 2043752612, 881257467, 869518812, 2005220179, 938474677, 3305539448, 3850417126, 1315485940, 3318264702, 226533026, 965733244, 321539988, 1136104718, 804158748, 573969341, 3708209826, 937399083, 3290727049, 2901666755, 1461057207, 4013193437, 4066861423, 3242773476, 2421326174, 1581322155, 3028952165, 786071460, 3900391652, 3918438532, 1485433313, 4023619836, 3708277595, 3678951060, 953673138, 1467089153, 1930354364, 1533292819, 2492563023, 1346121658, 1685000834, 1965281866, 3765933717, 4190206607, 2052792609, 3515332758, 690371149, 3125873887, 2180283551, 2903598061, 3933952357, 436236910, 289419410, 14314871, 1242357089, 2904507907, 1616633776, 2666382180, 585885352, 3471299210, 2699507360, 1432659641, 277164553, 3354103607, 770115018, 2303809295, 3741942315, 3177781868, 2853364978, 2269453327, 3774259834, 987383833, 1290892879, 225909803, 1741533526, 890078084, 1496906255, 1111072499, 916028167, 243534141, 1252605537, 2204162171, 531204876, 290011180, 3916834213, 102027703, 237315147, 209093447, 1486785922, 220223953, 2758195998, 4175039106, 82940208, 3127791296, 2569425252, 518464269, 1353887104, 3941492737, 2377294467, 3935040926];
}
function Vc(t3) {
  this.cast5 = new uO(), this.cast5.setKey(t3), this.encrypt = function(e) {
    return this.cast5.encrypt(e);
  };
}
Gc.keySize = Gc.prototype.keySize = 24, Gc.blockSize = Gc.prototype.blockSize = 8, Vc.blockSize = Vc.prototype.blockSize = 8, Vc.keySize = Vc.prototype.keySize = 16;
const Ws = 4294967295;
function Qa(t3, e) {
  return (t3 << e | t3 >>> 32 - e) & Ws;
}
function No(t3, e) {
  return t3[e] | t3[e + 1] << 8 | t3[e + 2] << 16 | t3[e + 3] << 24;
}
function _f(t3, e, n) {
  t3.splice(e, 4, 255 & n, n >>> 8 & 255, n >>> 16 & 255, n >>> 24 & 255);
}
function Er(t3, e) {
  return t3 >>> 8 * e & 255;
}
function Yc(t3) {
  this.tf = /* @__PURE__ */ function() {
    let e = null, n = null, r = -1, s = [], i = [[], [], [], []];
    function a(l) {
      return i[0][Er(l, 0)] ^ i[1][Er(l, 1)] ^ i[2][Er(l, 2)] ^ i[3][Er(l, 3)];
    }
    function o(l) {
      return i[0][Er(l, 3)] ^ i[1][Er(l, 0)] ^ i[2][Er(l, 1)] ^ i[3][Er(l, 2)];
    }
    function f(l, h) {
      let m = a(h[0]), v = o(h[1]);
      h[2] = Qa(h[2] ^ m + v + s[4 * l + 8] & Ws, 31), h[3] = Qa(h[3], 1) ^ m + 2 * v + s[4 * l + 9] & Ws, m = a(h[2]), v = o(h[3]), h[0] = Qa(h[0] ^ m + v + s[4 * l + 10] & Ws, 31), h[1] = Qa(h[1], 1) ^ m + 2 * v + s[4 * l + 11] & Ws;
    }
    function c(l, h) {
      let m = a(h[0]), v = o(h[1]);
      h[2] = Qa(h[2], 1) ^ m + v + s[4 * l + 10] & Ws, h[3] = Qa(h[3] ^ m + 2 * v + s[4 * l + 11] & Ws, 31), m = a(h[2]), v = o(h[3]), h[0] = Qa(h[0], 1) ^ m + v + s[4 * l + 8] & Ws, h[1] = Qa(h[1] ^ m + 2 * v + s[4 * l + 9] & Ws, 31);
    }
    return { name: "twofish", blocksize: 16, open: function(l) {
      let h, m, v, b, A;
      e = l;
      const _ = [], C = [], I = [];
      let S;
      const $ = [];
      let F, U, Q;
      const P = [[8, 1, 7, 13, 6, 15, 3, 2, 0, 11, 5, 9, 14, 12, 10, 4], [2, 8, 11, 13, 15, 7, 6, 14, 3, 1, 9, 4, 0, 10, 12, 5]], N = [[14, 12, 11, 8, 1, 2, 3, 5, 15, 4, 10, 6, 7, 0, 9, 13], [1, 14, 2, 11, 4, 12, 3, 7, 6, 13, 10, 5, 15, 9, 0, 8]], L = [[11, 10, 5, 14, 6, 13, 9, 0, 12, 8, 15, 3, 2, 4, 7, 1], [4, 12, 7, 5, 1, 6, 9, 10, 0, 14, 13, 8, 2, 11, 3, 15]], B = [[13, 7, 15, 4, 1, 2, 6, 14, 9, 11, 3, 0, 8, 5, 12, 10], [11, 9, 5, 1, 12, 3, 13, 14, 6, 4, 7, 15, 2, 0, 8, 10]], u = [0, 8, 1, 9, 2, 10, 3, 11, 4, 12, 5, 13, 6, 14, 7, 15], p = [0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 5, 14, 7], d = [[], []], y = [[], [], [], []];
      function w(k) {
        return k ^ k >> 2 ^ [0, 90, 180, 238][3 & k];
      }
      function E(k) {
        return k ^ k >> 1 ^ k >> 2 ^ [0, 238, 180, 90][3 & k];
      }
      function M(k, T) {
        let O, K, Y;
        for (O = 0; O < 8; O++) K = T >>> 24, T = T << 8 & Ws | k >>> 24, k = k << 8 & Ws, Y = K << 1, 128 & K && (Y ^= 333), T ^= K ^ Y << 16, Y ^= K >>> 1, 1 & K && (Y ^= 166), T ^= Y << 24 | Y << 8;
        return T;
      }
      function x(k, T) {
        const O = T >> 4, K = 15 & T, Y = P[k][O ^ K], J = N[k][u[K] ^ p[O]];
        return B[k][u[J] ^ p[Y]] << 4 | L[k][Y ^ J];
      }
      function g(k, T) {
        let O = Er(k, 0), K = Er(k, 1), Y = Er(k, 2), J = Er(k, 3);
        switch (S) {
          case 4:
            O = d[1][O] ^ Er(T[3], 0), K = d[0][K] ^ Er(T[3], 1), Y = d[0][Y] ^ Er(T[3], 2), J = d[1][J] ^ Er(T[3], 3);
          case 3:
            O = d[1][O] ^ Er(T[2], 0), K = d[1][K] ^ Er(T[2], 1), Y = d[0][Y] ^ Er(T[2], 2), J = d[0][J] ^ Er(T[2], 3);
          case 2:
            O = d[0][d[0][O] ^ Er(T[1], 0)] ^ Er(T[0], 0), K = d[0][d[1][K] ^ Er(T[1], 1)] ^ Er(T[0], 1), Y = d[1][d[0][Y] ^ Er(T[1], 2)] ^ Er(T[0], 2), J = d[1][d[1][J] ^ Er(T[1], 3)] ^ Er(T[0], 3);
        }
        return y[0][O] ^ y[1][K] ^ y[2][Y] ^ y[3][J];
      }
      for (e = e.slice(0, 32), h = e.length; h !== 16 && h !== 24 && h !== 32; ) e[h++] = 0;
      for (h = 0; h < e.length; h += 4) I[h >> 2] = No(e, h);
      for (h = 0; h < 256; h++) d[0][h] = x(0, h), d[1][h] = x(1, h);
      for (h = 0; h < 256; h++) F = d[1][h], U = w(F), Q = E(F), y[0][h] = F + (U << 8) + (Q << 16) + (Q << 24), y[2][h] = U + (Q << 8) + (F << 16) + (Q << 24), F = d[0][h], U = w(F), Q = E(F), y[1][h] = Q + (Q << 8) + (U << 16) + (F << 24), y[3][h] = U + (F << 8) + (Q << 16) + (U << 24);
      for (S = I.length / 2, h = 0; h < S; h++) m = I[h + h], _[h] = m, v = I[h + h + 1], C[h] = v, $[S - h - 1] = M(m, v);
      for (h = 0; h < 40; h += 2) m = 16843009 * h, v = m + 16843009, m = g(m, _), v = Qa(g(v, C), 8), s[h] = m + v & Ws, s[h + 1] = Qa(m + 2 * v, 9);
      for (h = 0; h < 256; h++) switch (m = v = b = A = h, S) {
        case 4:
          m = d[1][m] ^ Er($[3], 0), v = d[0][v] ^ Er($[3], 1), b = d[0][b] ^ Er($[3], 2), A = d[1][A] ^ Er($[3], 3);
        case 3:
          m = d[1][m] ^ Er($[2], 0), v = d[1][v] ^ Er($[2], 1), b = d[0][b] ^ Er($[2], 2), A = d[0][A] ^ Er($[2], 3);
        case 2:
          i[0][h] = y[0][d[0][d[0][m] ^ Er($[1], 0)] ^ Er($[0], 0)], i[1][h] = y[1][d[0][d[1][v] ^ Er($[1], 1)] ^ Er($[0], 1)], i[2][h] = y[2][d[1][d[0][b] ^ Er($[1], 2)] ^ Er($[0], 2)], i[3][h] = y[3][d[1][d[1][A] ^ Er($[1], 3)] ^ Er($[0], 3)];
      }
    }, close: function() {
      s = [], i = [[], [], [], []];
    }, encrypt: function(l, h) {
      n = l, r = h;
      const m = [No(n, r) ^ s[0], No(n, r + 4) ^ s[1], No(n, r + 8) ^ s[2], No(n, r + 12) ^ s[3]];
      for (let v = 0; v < 8; v++) f(v, m);
      return _f(n, r, m[2] ^ s[4]), _f(n, r + 4, m[3] ^ s[5]), _f(n, r + 8, m[0] ^ s[6]), _f(n, r + 12, m[1] ^ s[7]), r += 16, n;
    }, decrypt: function(l, h) {
      n = l, r = h;
      const m = [No(n, r) ^ s[4], No(n, r + 4) ^ s[5], No(n, r + 8) ^ s[6], No(n, r + 12) ^ s[7]];
      for (let v = 7; v >= 0; v--) c(v, m);
      _f(n, r, m[2] ^ s[0]), _f(n, r + 4, m[3] ^ s[1]), _f(n, r + 8, m[0] ^ s[2]), _f(n, r + 12, m[1] ^ s[3]), r += 16;
    }, finalize: function() {
      return n;
    } };
  }(), this.tf.open(Array.from(t3), 0), this.encrypt = function(e) {
    return this.tf.encrypt(Array.from(e), 0);
  };
}
function Aa() {
}
function Wc(t3) {
  this.bf = new Aa(), this.bf.init(t3), this.encrypt = function(e) {
    return this.bf.encryptBlock(e);
  };
}
Yc.keySize = Yc.prototype.keySize = 32, Yc.blockSize = Yc.prototype.blockSize = 16, Aa.prototype.BLOCKSIZE = 8, Aa.prototype.SBOXES = [[3509652390, 2564797868, 805139163, 3491422135, 3101798381, 1780907670, 3128725573, 4046225305, 614570311, 3012652279, 134345442, 2240740374, 1667834072, 1901547113, 2757295779, 4103290238, 227898511, 1921955416, 1904987480, 2182433518, 2069144605, 3260701109, 2620446009, 720527379, 3318853667, 677414384, 3393288472, 3101374703, 2390351024, 1614419982, 1822297739, 2954791486, 3608508353, 3174124327, 2024746970, 1432378464, 3864339955, 2857741204, 1464375394, 1676153920, 1439316330, 715854006, 3033291828, 289532110, 2706671279, 2087905683, 3018724369, 1668267050, 732546397, 1947742710, 3462151702, 2609353502, 2950085171, 1814351708, 2050118529, 680887927, 999245976, 1800124847, 3300911131, 1713906067, 1641548236, 4213287313, 1216130144, 1575780402, 4018429277, 3917837745, 3693486850, 3949271944, 596196993, 3549867205, 258830323, 2213823033, 772490370, 2760122372, 1774776394, 2652871518, 566650946, 4142492826, 1728879713, 2882767088, 1783734482, 3629395816, 2517608232, 2874225571, 1861159788, 326777828, 3124490320, 2130389656, 2716951837, 967770486, 1724537150, 2185432712, 2364442137, 1164943284, 2105845187, 998989502, 3765401048, 2244026483, 1075463327, 1455516326, 1322494562, 910128902, 469688178, 1117454909, 936433444, 3490320968, 3675253459, 1240580251, 122909385, 2157517691, 634681816, 4142456567, 3825094682, 3061402683, 2540495037, 79693498, 3249098678, 1084186820, 1583128258, 426386531, 1761308591, 1047286709, 322548459, 995290223, 1845252383, 2603652396, 3431023940, 2942221577, 3202600964, 3727903485, 1712269319, 422464435, 3234572375, 1170764815, 3523960633, 3117677531, 1434042557, 442511882, 3600875718, 1076654713, 1738483198, 4213154764, 2393238008, 3677496056, 1014306527, 4251020053, 793779912, 2902807211, 842905082, 4246964064, 1395751752, 1040244610, 2656851899, 3396308128, 445077038, 3742853595, 3577915638, 679411651, 2892444358, 2354009459, 1767581616, 3150600392, 3791627101, 3102740896, 284835224, 4246832056, 1258075500, 768725851, 2589189241, 3069724005, 3532540348, 1274779536, 3789419226, 2764799539, 1660621633, 3471099624, 4011903706, 913787905, 3497959166, 737222580, 2514213453, 2928710040, 3937242737, 1804850592, 3499020752, 2949064160, 2386320175, 2390070455, 2415321851, 4061277028, 2290661394, 2416832540, 1336762016, 1754252060, 3520065937, 3014181293, 791618072, 3188594551, 3933548030, 2332172193, 3852520463, 3043980520, 413987798, 3465142937, 3030929376, 4245938359, 2093235073, 3534596313, 375366246, 2157278981, 2479649556, 555357303, 3870105701, 2008414854, 3344188149, 4221384143, 3956125452, 2067696032, 3594591187, 2921233993, 2428461, 544322398, 577241275, 1471733935, 610547355, 4027169054, 1432588573, 1507829418, 2025931657, 3646575487, 545086370, 48609733, 2200306550, 1653985193, 298326376, 1316178497, 3007786442, 2064951626, 458293330, 2589141269, 3591329599, 3164325604, 727753846, 2179363840, 146436021, 1461446943, 4069977195, 705550613, 3059967265, 3887724982, 4281599278, 3313849956, 1404054877, 2845806497, 146425753, 1854211946], [1266315497, 3048417604, 3681880366, 3289982499, 290971e4, 1235738493, 2632868024, 2414719590, 3970600049, 1771706367, 1449415276, 3266420449, 422970021, 1963543593, 2690192192, 3826793022, 1062508698, 1531092325, 1804592342, 2583117782, 2714934279, 4024971509, 1294809318, 4028980673, 1289560198, 2221992742, 1669523910, 35572830, 157838143, 1052438473, 1016535060, 1802137761, 1753167236, 1386275462, 3080475397, 2857371447, 1040679964, 2145300060, 2390574316, 1461121720, 2956646967, 4031777805, 4028374788, 33600511, 2920084762, 1018524850, 629373528, 3691585981, 3515945977, 2091462646, 2486323059, 586499841, 988145025, 935516892, 3367335476, 2599673255, 2839830854, 265290510, 3972581182, 2759138881, 3795373465, 1005194799, 847297441, 406762289, 1314163512, 1332590856, 1866599683, 4127851711, 750260880, 613907577, 1450815602, 3165620655, 3734664991, 3650291728, 3012275730, 3704569646, 1427272223, 778793252, 1343938022, 2676280711, 2052605720, 1946737175, 3164576444, 3914038668, 3967478842, 3682934266, 1661551462, 3294938066, 4011595847, 840292616, 3712170807, 616741398, 312560963, 711312465, 1351876610, 322626781, 1910503582, 271666773, 2175563734, 1594956187, 70604529, 3617834859, 1007753275, 1495573769, 4069517037, 2549218298, 2663038764, 504708206, 2263041392, 3941167025, 2249088522, 1514023603, 1998579484, 1312622330, 694541497, 2582060303, 2151582166, 1382467621, 776784248, 2618340202, 3323268794, 2497899128, 2784771155, 503983604, 4076293799, 907881277, 423175695, 432175456, 1378068232, 4145222326, 3954048622, 3938656102, 3820766613, 2793130115, 2977904593, 26017576, 3274890735, 3194772133, 1700274565, 1756076034, 4006520079, 3677328699, 720338349, 1533947780, 354530856, 688349552, 3973924725, 1637815568, 332179504, 3949051286, 53804574, 2852348879, 3044236432, 1282449977, 3583942155, 3416972820, 4006381244, 1617046695, 2628476075, 3002303598, 1686838959, 431878346, 2686675385, 1700445008, 1080580658, 1009431731, 832498133, 3223435511, 2605976345, 2271191193, 2516031870, 1648197032, 4164389018, 2548247927, 300782431, 375919233, 238389289, 3353747414, 2531188641, 2019080857, 1475708069, 455242339, 2609103871, 448939670, 3451063019, 1395535956, 2413381860, 1841049896, 1491858159, 885456874, 4264095073, 4001119347, 1565136089, 3898914787, 1108368660, 540939232, 1173283510, 2745871338, 3681308437, 4207628240, 3343053890, 4016749493, 1699691293, 1103962373, 3625875870, 2256883143, 3830138730, 1031889488, 3479347698, 1535977030, 4236805024, 3251091107, 2132092099, 1774941330, 1199868427, 1452454533, 157007616, 2904115357, 342012276, 595725824, 1480756522, 206960106, 497939518, 591360097, 863170706, 2375253569, 3596610801, 1814182875, 2094937945, 3421402208, 1082520231, 3463918190, 2785509508, 435703966, 3908032597, 1641649973, 2842273706, 3305899714, 1510255612, 2148256476, 2655287854, 3276092548, 4258621189, 236887753, 3681803219, 274041037, 1734335097, 3815195456, 3317970021, 1899903192, 1026095262, 4050517792, 356393447, 2410691914, 3873677099, 3682840055], [3913112168, 2491498743, 4132185628, 2489919796, 1091903735, 1979897079, 3170134830, 3567386728, 3557303409, 857797738, 1136121015, 1342202287, 507115054, 2535736646, 337727348, 3213592640, 1301675037, 2528481711, 1895095763, 1721773893, 3216771564, 62756741, 2142006736, 835421444, 2531993523, 1442658625, 3659876326, 2882144922, 676362277, 1392781812, 170690266, 3921047035, 1759253602, 3611846912, 1745797284, 664899054, 1329594018, 3901205900, 3045908486, 2062866102, 2865634940, 3543621612, 3464012697, 1080764994, 553557557, 3656615353, 3996768171, 991055499, 499776247, 1265440854, 648242737, 3940784050, 980351604, 3713745714, 1749149687, 3396870395, 4211799374, 3640570775, 1161844396, 3125318951, 1431517754, 545492359, 4268468663, 3499529547, 1437099964, 2702547544, 3433638243, 2581715763, 2787789398, 1060185593, 1593081372, 2418618748, 4260947970, 69676912, 2159744348, 86519011, 2512459080, 3838209314, 1220612927, 3339683548, 133810670, 1090789135, 1078426020, 1569222167, 845107691, 3583754449, 4072456591, 1091646820, 628848692, 1613405280, 3757631651, 526609435, 236106946, 48312990, 2942717905, 3402727701, 1797494240, 859738849, 992217954, 4005476642, 2243076622, 3870952857, 3732016268, 765654824, 3490871365, 2511836413, 1685915746, 3888969200, 1414112111, 2273134842, 3281911079, 4080962846, 172450625, 2569994100, 980381355, 4109958455, 2819808352, 2716589560, 2568741196, 3681446669, 3329971472, 1835478071, 660984891, 3704678404, 4045999559, 3422617507, 3040415634, 1762651403, 1719377915, 3470491036, 2693910283, 3642056355, 3138596744, 1364962596, 2073328063, 1983633131, 926494387, 3423689081, 2150032023, 4096667949, 1749200295, 3328846651, 309677260, 2016342300, 1779581495, 3079819751, 111262694, 1274766160, 443224088, 298511866, 1025883608, 3806446537, 1145181785, 168956806, 3641502830, 3584813610, 1689216846, 3666258015, 3200248200, 1692713982, 2646376535, 4042768518, 1618508792, 1610833997, 3523052358, 4130873264, 2001055236, 3610705100, 2202168115, 4028541809, 2961195399, 1006657119, 2006996926, 3186142756, 1430667929, 3210227297, 1314452623, 4074634658, 4101304120, 2273951170, 1399257539, 3367210612, 3027628629, 1190975929, 2062231137, 2333990788, 2221543033, 2438960610, 1181637006, 548689776, 2362791313, 3372408396, 3104550113, 3145860560, 296247880, 1970579870, 3078560182, 3769228297, 1714227617, 3291629107, 3898220290, 166772364, 1251581989, 493813264, 448347421, 195405023, 2709975567, 677966185, 3703036547, 1463355134, 2715995803, 1338867538, 1343315457, 2802222074, 2684532164, 233230375, 2599980071, 2000651841, 3277868038, 1638401717, 4028070440, 3237316320, 6314154, 819756386, 300326615, 590932579, 1405279636, 3267499572, 3150704214, 2428286686, 3959192993, 3461946742, 1862657033, 1266418056, 963775037, 2089974820, 2263052895, 1917689273, 448879540, 3550394620, 3981727096, 150775221, 3627908307, 1303187396, 508620638, 2975983352, 2726630617, 1817252668, 1876281319, 1457606340, 908771278, 3720792119, 3617206836, 2455994898, 1729034894, 1080033504], [976866871, 3556439503, 2881648439, 1522871579, 1555064734, 1336096578, 3548522304, 2579274686, 3574697629, 3205460757, 3593280638, 3338716283, 3079412587, 564236357, 2993598910, 1781952180, 1464380207, 3163844217, 3332601554, 1699332808, 1393555694, 1183702653, 3581086237, 1288719814, 691649499, 2847557200, 2895455976, 3193889540, 2717570544, 1781354906, 1676643554, 2592534050, 3230253752, 1126444790, 2770207658, 2633158820, 2210423226, 2615765581, 2414155088, 3127139286, 673620729, 2805611233, 1269405062, 4015350505, 3341807571, 4149409754, 1057255273, 2012875353, 2162469141, 2276492801, 2601117357, 993977747, 3918593370, 2654263191, 753973209, 36408145, 2530585658, 25011837, 3520020182, 2088578344, 530523599, 2918365339, 1524020338, 1518925132, 3760827505, 3759777254, 1202760957, 3985898139, 3906192525, 674977740, 4174734889, 2031300136, 2019492241, 3983892565, 4153806404, 3822280332, 352677332, 2297720250, 60907813, 90501309, 3286998549, 1016092578, 2535922412, 2839152426, 457141659, 509813237, 4120667899, 652014361, 1966332200, 2975202805, 55981186, 2327461051, 676427537, 3255491064, 2882294119, 3433927263, 1307055953, 942726286, 933058658, 2468411793, 3933900994, 4215176142, 1361170020, 2001714738, 2830558078, 3274259782, 1222529897, 1679025792, 2729314320, 3714953764, 1770335741, 151462246, 3013232138, 1682292957, 1483529935, 471910574, 1539241949, 458788160, 3436315007, 1807016891, 3718408830, 978976581, 1043663428, 3165965781, 1927990952, 4200891579, 2372276910, 3208408903, 3533431907, 1412390302, 2931980059, 4132332400, 1947078029, 3881505623, 4168226417, 2941484381, 1077988104, 1320477388, 886195818, 18198404, 3786409e3, 2509781533, 112762804, 3463356488, 1866414978, 891333506, 18488651, 661792760, 1628790961, 3885187036, 3141171499, 876946877, 2693282273, 1372485963, 791857591, 2686433993, 3759982718, 3167212022, 3472953795, 2716379847, 445679433, 3561995674, 3504004811, 3574258232, 54117162, 3331405415, 2381918588, 3769707343, 4154350007, 1140177722, 4074052095, 668550556, 3214352940, 367459370, 261225585, 2610173221, 4209349473, 3468074219, 3265815641, 314222801, 3066103646, 3808782860, 282218597, 3406013506, 3773591054, 379116347, 1285071038, 846784868, 2669647154, 3771962079, 3550491691, 2305946142, 453669953, 1268987020, 3317592352, 3279303384, 3744833421, 2610507566, 3859509063, 266596637, 3847019092, 517658769, 3462560207, 3443424879, 370717030, 4247526661, 2224018117, 4143653529, 4112773975, 2788324899, 2477274417, 1456262402, 2901442914, 1517677493, 1846949527, 2295493580, 3734397586, 2176403920, 1280348187, 1908823572, 3871786941, 846861322, 1172426758, 3287448474, 3383383037, 1655181056, 3139813346, 901632758, 1897031941, 2986607138, 3066810236, 3447102507, 1393639104, 373351379, 950779232, 625454576, 3124240540, 4148612726, 2007998917, 544563296, 2244738638, 2330496472, 2058025392, 1291430526, 424198748, 50039436, 29584100, 3605783033, 2429876329, 2791104160, 1057563949, 3255363231, 3075367218, 3463963227, 1469046755, 985887462]], Aa.prototype.PARRAY = [608135816, 2242054355, 320440878, 57701188, 2752067618, 698298832, 137296536, 3964562569, 1160258022, 953160567, 3193202383, 887688300, 3232508343, 3380367581, 1065670069, 3041331479, 2450970073, 2306472731], Aa.prototype.NN = 16, Aa.prototype._clean = function(t3) {
  return t3 < 0 && (t3 = (2147483647 & t3) + 2147483648), t3;
}, Aa.prototype._F = function(t3) {
  let e;
  const n = 255 & t3, r = 255 & (t3 >>>= 8), s = 255 & (t3 >>>= 8), i = 255 & (t3 >>>= 8);
  return e = this.sboxes[0][i] + this.sboxes[1][s], e ^= this.sboxes[2][r], e += this.sboxes[3][n], e;
}, Aa.prototype._encryptBlock = function(t3) {
  let e, n = t3[0], r = t3[1];
  for (e = 0; e < this.NN; ++e) {
    n ^= this.parray[e], r = this._F(n) ^ r;
    const s = n;
    n = r, r = s;
  }
  n ^= this.parray[this.NN + 0], r ^= this.parray[this.NN + 1], t3[0] = this._clean(r), t3[1] = this._clean(n);
}, Aa.prototype.encryptBlock = function(t3) {
  let e;
  const n = [0, 0], r = this.BLOCKSIZE / 2;
  for (e = 0; e < this.BLOCKSIZE / 2; ++e) n[0] = n[0] << 8 | 255 & t3[e + 0], n[1] = n[1] << 8 | 255 & t3[e + r];
  this._encryptBlock(n);
  const s = [];
  for (e = 0; e < this.BLOCKSIZE / 2; ++e) s[e + 0] = n[0] >>> 24 - 8 * e & 255, s[e + r] = n[1] >>> 24 - 8 * e & 255;
  return s;
}, Aa.prototype._decryptBlock = function(t3) {
  let e, n = t3[0], r = t3[1];
  for (e = this.NN + 1; e > 1; --e) {
    n ^= this.parray[e], r = this._F(n) ^ r;
    const s = n;
    n = r, r = s;
  }
  n ^= this.parray[1], r ^= this.parray[0], t3[0] = this._clean(r), t3[1] = this._clean(n);
}, Aa.prototype.init = function(t3) {
  let e, n = 0;
  for (this.parray = [], e = 0; e < this.NN + 2; ++e) {
    let s = 0;
    for (let i = 0; i < 4; ++i) s = s << 8 | 255 & t3[n], ++n >= t3.length && (n = 0);
    this.parray[e] = this.PARRAY[e] ^ s;
  }
  for (this.sboxes = [], e = 0; e < 4; ++e) for (this.sboxes[e] = [], n = 0; n < 256; ++n) this.sboxes[e][n] = this.SBOXES[e][n];
  const r = [0, 0];
  for (e = 0; e < this.NN + 2; e += 2) this._encryptBlock(r), this.parray[e + 0] = r[0], this.parray[e + 1] = r[1];
  for (e = 0; e < 4; ++e) for (n = 0; n < 256; n += 2) this._encryptBlock(r), this.sboxes[e][n + 0] = r[0], this.sboxes[e][n + 1] = r[1];
}, Wc.keySize = Wc.prototype.keySize = 16, Wc.blockSize = Wc.prototype.blockSize = 8;
const cO = new Map(Object.entries({ tripledes: Gc, cast5: Vc, twofish: Yc, blowfish: Wc }));
var hO = Object.freeze({ __proto__: null, legacyCiphers: cO });
function R0(t3, e, n, r) {
  t3[e] += n[r], t3[e + 1] += n[r + 1] + (t3[e] < n[r]);
}
function T5(t3, e) {
  t3[0] += e, t3[1] += t3[0] < e;
}
function Ef(t3, e, n, r, s, i, a, o) {
  R0(t3, n, t3, r), R0(t3, n, e, a);
  let f = t3[i] ^ t3[n], c = t3[i + 1] ^ t3[n + 1];
  t3[i] = c, t3[i + 1] = f, R0(t3, s, t3, i), f = t3[r] ^ t3[s], c = t3[r + 1] ^ t3[s + 1], t3[r] = f >>> 24 ^ c << 8, t3[r + 1] = c >>> 24 ^ f << 8, R0(t3, n, t3, r), R0(t3, n, e, o), f = t3[i] ^ t3[n], c = t3[i + 1] ^ t3[n + 1], t3[i] = f >>> 16 ^ c << 16, t3[i + 1] = c >>> 16 ^ f << 16, R0(t3, s, t3, i), f = t3[r] ^ t3[s], c = t3[r + 1] ^ t3[s + 1], t3[r] = c >>> 31 ^ f << 1, t3[r + 1] = f >>> 31 ^ c << 1;
}
const XI = new Uint32Array([4089235720, 1779033703, 2227873595, 3144134277, 4271175723, 1013904242, 1595750129, 2773480762, 2917565137, 1359893119, 725511199, 2600822924, 4215389547, 528734635, 327033209, 1541459225]), Vi = new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3].map((t3) => 2 * t3));
function D5(t3, e) {
  const n = new Uint32Array(32), r = new Uint32Array(t3.b.buffer, t3.b.byteOffset, 32);
  for (let i = 0; i < 16; i++) n[i] = t3.h[i], n[i + 16] = XI[i];
  n[24] ^= t3.t0[0], n[25] ^= t3.t0[1];
  const s = e ? 4294967295 : 0;
  n[28] ^= s, n[29] ^= s;
  for (let i = 0; i < 12; i++) {
    const a = i << 4;
    Ef(n, r, 0, 8, 16, 24, Vi[a + 0], Vi[a + 1]), Ef(n, r, 2, 10, 18, 26, Vi[a + 2], Vi[a + 3]), Ef(n, r, 4, 12, 20, 28, Vi[a + 4], Vi[a + 5]), Ef(n, r, 6, 14, 22, 30, Vi[a + 6], Vi[a + 7]), Ef(n, r, 0, 10, 20, 30, Vi[a + 8], Vi[a + 9]), Ef(n, r, 2, 12, 22, 24, Vi[a + 10], Vi[a + 11]), Ef(n, r, 4, 14, 16, 26, Vi[a + 12], Vi[a + 13]), Ef(n, r, 6, 8, 18, 28, Vi[a + 14], Vi[a + 15]);
  }
  for (let i = 0; i < 16; i++) t3.h[i] ^= n[i] ^ n[i + 16];
}
class dO {
  constructor(e, n, r, s) {
    const i = new Uint8Array(64);
    this.S = { b: new Uint8Array(Ec), h: new Uint32Array(m3 / 4), t0: new Uint32Array(2), c: 0, outlen: e }, i[0] = e, n && (i[1] = n.length), i[2] = 1, i[3] = 1, r && i.set(r, 32), s && i.set(s, 48);
    const a = new Uint32Array(i.buffer, i.byteOffset, i.length / Uint32Array.BYTES_PER_ELEMENT);
    for (let o = 0; o < 16; o++) this.S.h[o] = XI[o] ^ a[o];
    if (n) {
      const o = new Uint8Array(Ec);
      o.set(n), this.update(o);
    }
  }
  update(e) {
    if (!(e instanceof Uint8Array)) throw Error("Input must be Uint8Array or Buffer");
    let n = 0;
    for (; n < e.length; ) {
      this.S.c === Ec && (T5(this.S.t0, this.S.c), D5(this.S, false), this.S.c = 0);
      let r = Ec - this.S.c;
      this.S.b.set(e.subarray(n, n + r), this.S.c);
      const s = Math.min(r, e.length - n);
      this.S.c += s, n += s;
    }
    return this;
  }
  digest(e) {
    T5(this.S.t0, this.S.c), this.S.b.fill(0, this.S.c), this.S.c = Ec, D5(this.S, true);
    const n = e || new Uint8Array(this.S.outlen);
    for (let r = 0; r < this.S.outlen; r++) n[r] = this.S.h[r >> 2] >> 8 * (3 & r);
    return this.S.h = null, n.buffer;
  }
}
function $p(t3, e, n, r) {
  if (t3 > m3) throw Error(`outlen must be at most ${m3} (given: ${t3})`);
  return new dO(t3, e, n, r);
}
const m3 = 64, Ec = 128, Uo = 1024, pO = new Uint8Array(new Uint16Array([43981]).buffer)[0] === 205;
function ys(t3, e, n) {
  return t3[n + 0] = e, t3[n + 1] = e >> 8, t3[n + 2] = e >> 16, t3[n + 3] = e >> 24, t3;
}
function Il(t3, e, n) {
  if (e > Number.MAX_SAFE_INTEGER) throw Error("LE64: large numbers unsupported");
  let r = e;
  for (let s = n; s < n + 7; s++) t3[s] = r, r = (r - t3[s]) / 256;
  return t3;
}
function a2(t3, e, n) {
  const r = new Uint8Array(64), s = new Uint8Array(4 + e.length);
  if (ys(s, t3, 0), s.set(e, 4), t3 <= 64) return $p(t3).update(s).digest(n), n;
  const i = Math.ceil(t3 / 32) - 2;
  for (let o = 0; o < i; o++) $p(64).update(o === 0 ? s : r).digest(r), n.set(r.subarray(0, 32), 32 * o);
  const a = new Uint8Array($p(t3 - 32 * i).update(r).digest());
  return n.set(a, 32 * i), n;
}
function R5(t3, e, n, r) {
  return t3.fn.XOR(e.byteOffset, n.byteOffset, r.byteOffset), e;
}
function gO(t3, e, n, r) {
  return t3.fn.G(e.byteOffset, n.byteOffset, r.byteOffset, t3.refs.gZ.byteOffset), r;
}
function mO(t3, e, n, r) {
  return t3.fn.G2(e.byteOffset, n.byteOffset, r.byteOffset, t3.refs.gZ.byteOffset), r;
}
function* vO(t3, e, n, r, s, i, a, o) {
  t3.refs.prngTmp.fill(0);
  const f = t3.refs.prngTmp.subarray(0, 48);
  Il(f, e, 0), Il(f, n, 8), Il(f, r, 16), Il(f, s, 24), Il(f, i, 32), Il(f, 2, 40);
  for (let c = 1; c <= a; c++) {
    Il(t3.refs.prngTmp, c, f.length);
    const l = mO(t3, t3.refs.ZERO1024, t3.refs.prngTmp, t3.refs.prngR);
    for (let h = c === 1 ? 8 * o : 0; h < l.length; h += 8) yield l.subarray(h, h + 8);
  }
  return [];
}
function yO(t3, { memory: e, instance: n }) {
  if (!pO) throw Error("BigEndian system not supported");
  const r = function({ type: N, version: L, tagLength: B, password: u, salt: p, ad: d, secret: y, parallelism: w, memorySize: E, passes: M }) {
    const x = (g, k, T, O) => {
      if (k < T || k > O) throw Error(`${g} size should be between ${T} and ${O} bytes`);
    };
    if (N !== 2 || L !== 19) throw Error("Unsupported type or version");
    return x("password", u, 8, 4294967295), x("salt", p, 8, 4294967295), x("tag", B, 4, 4294967295), x("memory", E, 8 * w, 4294967295), d && x("associated data", d, 0, 4294967295), y && x("secret", y, 0, 32), { type: N, version: L, tagLength: B, password: u, salt: p, ad: d, secret: y, lanes: w, memorySize: E, passes: M };
  }({ type: 2, version: 19, ...t3 }), { G: s, G2: i, xor: a, getLZ: o } = n.exports, f = {}, c = {};
  c.G = s, c.G2 = i, c.XOR = a;
  const l = 4 * r.lanes * Math.floor(r.memorySize / (4 * r.lanes)), h = l * Uo + 10240;
  if (e.buffer.byteLength < h) {
    const N = Math.ceil((h - e.buffer.byteLength) / 65536);
    e.grow(N);
  }
  let m = 0;
  f.gZ = new Uint8Array(e.buffer, m, Uo), m += f.gZ.length, f.prngR = new Uint8Array(e.buffer, m, Uo), m += f.prngR.length, f.prngTmp = new Uint8Array(e.buffer, m, Uo), m += f.prngTmp.length, f.ZERO1024 = new Uint8Array(e.buffer, m, 1024), m += f.ZERO1024.length;
  const v = new Uint32Array(e.buffer, m, 2);
  m += v.length * Uint32Array.BYTES_PER_ELEMENT;
  const b = { fn: c, refs: f }, A = new Uint8Array(e.buffer, m, Uo);
  m += A.length;
  const _ = new Uint8Array(e.buffer, m, r.memorySize * Uo), C = new Uint8Array(e.buffer, 0, m), I = function(N) {
    const L = $p(64), B = new Uint8Array(4), u = new Uint8Array(24);
    ys(u, N.lanes, 0), ys(u, N.tagLength, 4), ys(u, N.memorySize, 8), ys(u, N.passes, 12), ys(u, N.version, 16), ys(u, N.type, 20);
    const p = [u];
    N.password ? (p.push(ys(new Uint8Array(4), N.password.length, 0)), p.push(N.password)) : p.push(B), N.salt ? (p.push(ys(new Uint8Array(4), N.salt.length, 0)), p.push(N.salt)) : p.push(B), N.secret ? (p.push(ys(new Uint8Array(4), N.secret.length, 0)), p.push(N.secret)) : p.push(B), N.ad ? (p.push(ys(new Uint8Array(4), N.ad.length, 0)), p.push(N.ad)) : p.push(B), L.update(function(y) {
      if (y.length === 1) return y[0];
      let w = 0;
      for (let x = 0; x < y.length; x++) {
        if (!(y[x] instanceof Uint8Array)) throw Error("concatArrays: Data must be in the form of a Uint8Array");
        w += y[x].length;
      }
      const E = new Uint8Array(w);
      let M = 0;
      return y.forEach((x) => {
        E.set(x, M), M += x.length;
      }), E;
    }(p));
    const d = L.digest();
    return new Uint8Array(d);
  }(r), S = l / r.lanes, $ = Array(r.lanes).fill(null).map(() => Array(S)), F = (N, L) => ($[N][L] = _.subarray(N * S * 1024 + 1024 * L, N * S * 1024 + 1024 * L + Uo), $[N][L]);
  for (let N = 0; N < r.lanes; N++) {
    const L = new Uint8Array(I.length + 8);
    L.set(I), ys(L, 0, I.length), ys(L, N, I.length + 4), a2(Uo, L, F(N, 0)), ys(L, 1, I.length), a2(Uo, L, F(N, 1));
  }
  const U = S / 4;
  for (let N = 0; N < r.passes; N++) for (let L = 0; L < 4; L++) {
    const B = N === 0 && L <= 1;
    for (let u = 0; u < r.lanes; u++) {
      let p = L === 0 && N === 0 ? 2 : 0;
      const d = B ? vO(b, N, u, L, l, r.passes, U, p) : null;
      for (; p < U; p++) {
        const y = L * U + p, w = y > 0 ? $[u][y - 1] : $[u][S - 1], E = B ? d.next().value : w;
        o(v.byteOffset, E.byteOffset, u, r.lanes, N, L, p, 4, U);
        const M = v[0], x = v[1];
        N === 0 && F(u, y), gO(b, w, $[M][x], N > 0 ? A : $[u][y]), N > 0 && R5(b, $[u][y], A, $[u][y]);
      }
    }
  }
  const Q = $[0][S - 1];
  for (let N = 1; N < r.lanes; N++) R5(b, Q, Q, $[N][S - 1]);
  const P = a2(r.tagLength, Q, new Uint8Array(r.tagLength));
  return C.fill(0), e.grow(0), P;
}
let Yd;
async function bO(t3, e) {
  const n = new WebAssembly.Memory({ initial: 1040, maximum: 65536 }), r = await async function(s, i, a) {
    const o = { env: { memory: s } };
    if (Yd === void 0) try {
      const f = await i(o);
      return Yd = true, f;
    } catch {
      Yd = false;
    }
    return (Yd ? i : a)(o);
  }(n, t3, e);
  return (s) => yO(s, { instance: r.instance, memory: n });
}
function F5(t3, e, n, r) {
  var s = null, i = es.atob(n), a = i.length;
  s = new Uint8Array(new ArrayBuffer(a));
  for (var o = 0; o < a; o++) s[o] = i.charCodeAt(o);
  return function(f, c, l) {
    var h = WebAssembly.instantiate, m = WebAssembly.compile;
    return c ? h(f, c) : m(f);
  }(s, r);
}
var P5, N5, U5, L5, O5, Q5, AO = Object.freeze({ __proto__: null, default: async () => bO((t3) => F5(0, 0, "AGFzbQEAAAABKwdgBH9/f38AYAABf2AAAGADf39/AGAJf39/f39/f39/AX9gAX8AYAF/AX8CEwEDZW52Bm1lbW9yeQIBkAiAgAQDCgkCAwAABAEFBgEEBQFwAQICBgkBfwFBkIjAAgsHfQoDeG9yAAEBRwACAkcyAAMFZ2V0TFoABBlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALX2luaXRpYWxpemUAABBfX2Vycm5vX2xvY2F0aW9uAAgJc3RhY2tTYXZlAAUMc3RhY2tSZXN0b3JlAAYKc3RhY2tBbGxvYwAHCQcBAEEBCwEACs0gCQMAAQtYAQJ/A0AgACAEQQR0IgNqIAIgA2r9AAQAIAEgA2r9AAQA/VH9CwQAIAAgA0EQciIDaiACIANq/QAEACABIANq/QAEAP1R/QsEACAEQQJqIgRBwABHDQALC7ceAgt7A38DQCADIBFBBHQiD2ogASAPav0ABAAgACAPav0ABAD9USIF/QsEACACIA9qIAX9CwQAIAMgD0EQciIPaiABIA9q/QAEACAAIA9q/QAEAP1RIgX9CwQAIAIgD2ogBf0LBAAgEUECaiIRQcAARw0ACwNAIAMgEEEHdGoiAEEQaiAA/QAEcCAA/QAEMCIFIAD9AAQQIgT9zgEgBSAF/Q0AAQIDCAkKCwABAgMICQoLIAQgBP0NAAECAwgJCgsAAQIDCAkKC/3eAUEB/csB/c4BIgT9USIJQSD9ywEgCUEg/c0B/VAiCSAA/QAEUCIG/c4BIAkgCf0NAAECAwgJCgsAAQIDCAkKCyAGIAb9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIGIAX9USIFQSj9ywEgBUEY/c0B/VAiCCAE/c4BIAggCP0NAAECAwgJCgsAAQIDCAkKCyAEIAT9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIKIAogCf1RIgVBMP3LASAFQRD9zQH9UCIFIAb9zgEgBSAF/Q0AAQIDCAkKCwABAgMICQoLIAYgBv0NAAECAwgJCgsAAQIDCAkKC/3eAUEB/csB/c4BIgkgCP1RIgRBAf3LASAEQT/9zQH9UCIMIAD9AARgIAD9AAQgIgQgAP0ABAAiBv3OASAEIAT9DQABAgMICQoLAAECAwgJCgsgBiAG/Q0AAQIDCAkKCwABAgMICQoL/d4BQQH9ywH9zgEiBv1RIghBIP3LASAIQSD9zQH9UCIIIABBQGsiAf0ABAAiB/3OASAIIAj9DQABAgMICQoLAAECAwgJCgsgByAH/Q0AAQIDCAkKCwABAgMICQoL/d4BQQH9ywH9zgEiByAE/VEiBEEo/csBIARBGP3NAf1QIgsgBv3OASALIAv9DQABAgMICQoLAAECAwgJCgsgBiAG/Q0AAQIDCAkKCwABAgMICQoL/d4BQQH9ywH9zgEiBiAI/VEiBEEw/csBIARBEP3NAf1QIgQgB/3OASAEIAT9DQABAgMICQoLAAECAwgJCgsgByAH/Q0AAQIDCAkKCwABAgMICQoL/d4BQQH9ywH9zgEiCCAL/VEiB0EB/csBIAdBP/3NAf1QIg0gDf0NAAECAwQFBgcQERITFBUWF/0NCAkKCwwNDg8YGRobHB0eHyIH/c4BIAcgB/0NAAECAwgJCgsAAQIDCAkKCyAKIAr9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIKIAQgBSAF/Q0AAQIDBAUGBxAREhMUFRYX/Q0ICQoLDA0ODxgZGhscHR4f/VEiC0Eg/csBIAtBIP3NAf1QIgsgCP3OASALIAv9DQABAgMICQoLAAECAwgJCgsgCCAI/Q0AAQIDCAkKCwABAgMICQoL/d4BQQH9ywH9zgEiCCAH/VEiB0Eo/csBIAdBGP3NAf1QIgcgCv3OASAHIAf9DQABAgMICQoLAAECAwgJCgsgCiAK/Q0AAQIDCAkKCwABAgMICQoL/d4BQQH9ywH9zgEiDv0LBAAgACAGIA0gDCAM/Q0AAQIDBAUGBxAREhMUFRYX/Q0ICQoLDA0ODxgZGhscHR4fIgr9zgEgCiAK/Q0AAQIDCAkKCwABAgMICQoLIAYgBv0NAAECAwgJCgsAAQIDCAkKC/3eAUEB/csB/c4BIgYgBSAEIAT9DQABAgMEBQYHEBESExQVFhf9DQgJCgsMDQ4PGBkaGxwdHh/9USIFQSD9ywEgBUEg/c0B/VAiBSAJ/c4BIAUgBf0NAAECAwgJCgsAAQIDCAkKCyAJIAn9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIJIAr9USIEQSj9ywEgBEEY/c0B/VAiCiAG/c4BIAogCv0NAAECAwgJCgsAAQIDCAkKCyAGIAb9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIE/QsEACAAIAQgBf1RIgVBMP3LASAFQRD9zQH9UCIFIA4gC/1RIgRBMP3LASAEQRD9zQH9UCIEIAT9DQABAgMEBQYHEBESExQVFhf9DQgJCgsMDQ4PGBkaGxwdHh/9CwRgIAAgBCAFIAX9DQABAgMEBQYHEBESExQVFhf9DQgJCgsMDQ4PGBkaGxwdHh/9CwRwIAEgBCAI/c4BIAQgBP0NAAECAwgJCgsAAQIDCAkKCyAIIAj9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIE/QsEACAAIAUgCf3OASAFIAX9DQABAgMICQoLAAECAwgJCgsgCSAJ/Q0AAQIDCAkKCwABAgMICQoL/d4BQQH9ywH9zgEiCf0LBFAgACAEIAf9USIFQQH9ywEgBUE//c0B/VAiBSAJIAr9USIEQQH9ywEgBEE//c0B/VAiBCAE/Q0AAQIDBAUGBxAREhMUFRYX/Q0ICQoLDA0ODxgZGhscHR4f/QsEICAAIAQgBSAF/Q0AAQIDBAUGBxAREhMUFRYX/Q0ICQoLDA0ODxgZGhscHR4f/QsEMCAQQQFqIhBBCEcNAAtBACEQA0AgAyAQQQR0aiIAQYABaiAA/QAEgAcgAP0ABIADIgUgAP0ABIABIgT9zgEgBSAF/Q0AAQIDCAkKCwABAgMICQoLIAQgBP0NAAECAwgJCgsAAQIDCAkKC/3eAUEB/csB/c4BIgT9USIJQSD9ywEgCUEg/c0B/VAiCSAA/QAEgAUiBv3OASAJIAn9DQABAgMICQoLAAECAwgJCgsgBiAG/Q0AAQIDCAkKCwABAgMICQoL/d4BQQH9ywH9zgEiBiAF/VEiBUEo/csBIAVBGP3NAf1QIgggBP3OASAIIAj9DQABAgMICQoLAAECAwgJCgsgBCAE/Q0AAQIDCAkKCwABAgMICQoL/d4BQQH9ywH9zgEiCiAKIAn9USIFQTD9ywEgBUEQ/c0B/VAiBSAG/c4BIAUgBf0NAAECAwgJCgsAAQIDCAkKCyAGIAb9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIJIAj9USIEQQH9ywEgBEE//c0B/VAiDCAA/QAEgAYgAP0ABIACIgQgAP0ABAAiBv3OASAEIAT9DQABAgMICQoLAAECAwgJCgsgBiAG/Q0AAQIDCAkKCwABAgMICQoL/d4BQQH9ywH9zgEiBv1RIghBIP3LASAIQSD9zQH9UCIIIAD9AASABCIH/c4BIAggCP0NAAECAwgJCgsAAQIDCAkKCyAHIAf9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIHIAT9USIEQSj9ywEgBEEY/c0B/VAiCyAG/c4BIAsgC/0NAAECAwgJCgsAAQIDCAkKCyAGIAb9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIGIAj9USIEQTD9ywEgBEEQ/c0B/VAiBCAH/c4BIAQgBP0NAAECAwgJCgsAAQIDCAkKCyAHIAf9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIIIAv9USIHQQH9ywEgB0E//c0B/VAiDSAN/Q0AAQIDBAUGBxAREhMUFRYX/Q0ICQoLDA0ODxgZGhscHR4fIgf9zgEgByAH/Q0AAQIDCAkKCwABAgMICQoLIAogCv0NAAECAwgJCgsAAQIDCAkKC/3eAUEB/csB/c4BIgogBCAFIAX9DQABAgMEBQYHEBESExQVFhf9DQgJCgsMDQ4PGBkaGxwdHh/9USILQSD9ywEgC0Eg/c0B/VAiCyAI/c4BIAsgC/0NAAECAwgJCgsAAQIDCAkKCyAIIAj9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIIIAf9USIHQSj9ywEgB0EY/c0B/VAiByAK/c4BIAcgB/0NAAECAwgJCgsAAQIDCAkKCyAKIAr9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIO/QsEACAAIAYgDSAMIAz9DQABAgMEBQYHEBESExQVFhf9DQgJCgsMDQ4PGBkaGxwdHh8iCv3OASAKIAr9DQABAgMICQoLAAECAwgJCgsgBiAG/Q0AAQIDCAkKCwABAgMICQoL/d4BQQH9ywH9zgEiBiAFIAQgBP0NAAECAwQFBgcQERITFBUWF/0NCAkKCwwNDg8YGRobHB0eH/1RIgVBIP3LASAFQSD9zQH9UCIFIAn9zgEgBSAF/Q0AAQIDCAkKCwABAgMICQoLIAkgCf0NAAECAwgJCgsAAQIDCAkKC/3eAUEB/csB/c4BIgkgCv1RIgRBKP3LASAEQRj9zQH9UCIKIAb9zgEgCiAK/Q0AAQIDCAkKCwABAgMICQoLIAYgBv0NAAECAwgJCgsAAQIDCAkKC/3eAUEB/csB/c4BIgT9CwQAIAAgBCAF/VEiBUEw/csBIAVBEP3NAf1QIgUgDiAL/VEiBEEw/csBIARBEP3NAf1QIgQgBP0NAAECAwQFBgcQERITFBUWF/0NCAkKCwwNDg8YGRobHB0eH/0LBIAGIAAgBCAFIAX9DQABAgMEBQYHEBESExQVFhf9DQgJCgsMDQ4PGBkaGxwdHh/9CwSAByAAIAQgCP3OASAEIAT9DQABAgMICQoLAAECAwgJCgsgCCAI/Q0AAQIDCAkKCwABAgMICQoL/d4BQQH9ywH9zgEiBP0LBIAEIAAgBSAJ/c4BIAUgBf0NAAECAwgJCgsAAQIDCAkKCyAJIAn9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIJ/QsEgAUgACAEIAf9USIFQQH9ywEgBUE//c0B/VAiBSAJIAr9USIEQQH9ywEgBEE//c0B/VAiBCAE/Q0AAQIDBAUGBxAREhMUFRYX/Q0ICQoLDA0ODxgZGhscHR4f/QsEgAIgACAEIAUgBf0NAAECAwQFBgcQERITFBUWF/0NCAkKCwwNDg8YGRobHB0eH/0LBIADIBBBAWoiEEEIRw0AC0EAIRADQCACIBBBBHQiAGoiASAAIANq/QAEACAB/QAEAP1R/QsEACACIABBEHIiAWoiDyABIANq/QAEACAP/QAEAP1R/QsEACACIABBIHIiAWoiDyABIANq/QAEACAP/QAEAP1R/QsEACACIABBMHIiAGoiASAAIANq/QAEACAB/QAEAP1R/QsEACAQQQRqIhBBwABHDQALCxYAIAAgASACIAMQAiAAIAIgAiADEAILewIBfwF+IAIhCSABNQIAIQogBCAFcgRAIAEoAgQgA3AhCQsgACAJNgIAIAAgB0EBayAFIAQbIAhsIAZBAWtBAEF/IAYbIAIgCUYbaiIBIAVBAWogCGxBACAEG2ogAa0gCiAKfkIgiH5CIIinQX9zaiAHIAhscDYCBCAACwQAIwALBgAgACQACxAAIwAgAGtBcHEiACQAIAALBQBBgAgL", t3), (t3) => F5(0, 0, "AGFzbQEAAAABPwhgBH9/f38AYAABf2AAAGADf39/AGARf39/f39/f39/f39/f39/f38AYAl/f39/f39/f38Bf2ABfwBgAX8BfwITAQNlbnYGbWVtb3J5AgGQCICABAMLCgIDBAAABQEGBwEEBQFwAQICBgkBfwFBkIjAAgsHfQoDeG9yAAEBRwADAkcyAAQFZ2V0TFoABRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALX2luaXRpYWxpemUAABBfX2Vycm5vX2xvY2F0aW9uAAkJc3RhY2tTYXZlAAYMc3RhY2tSZXN0b3JlAAcKc3RhY2tBbGxvYwAICQcBAEEBCwEACssaCgMAAQtQAQJ/A0AgACAEQQN0IgNqIAIgA2opAwAgASADaikDAIU3AwAgACADQQhyIgNqIAIgA2opAwAgASADaikDAIU3AwAgBEECaiIEQYABRw0ACwveDwICfgF/IAAgAUEDdGoiEyATKQMAIhEgACAFQQN0aiIBKQMAIhJ8IBFCAYZC/v///x+DIBJC/////w+DfnwiETcDACAAIA1BA3RqIgUgESAFKQMAhUIgiSIRNwMAIAAgCUEDdGoiCSARIAkpAwAiEnwgEUL/////D4MgEkIBhkL+////H4N+fCIRNwMAIAEgESABKQMAhUIoiSIRNwMAIBMgESATKQMAIhJ8IBFC/////w+DIBJCAYZC/v///x+DfnwiETcDACAFIBEgBSkDAIVCMIkiETcDACAJIBEgCSkDACISfCARQv////8PgyASQgGGQv7///8fg358IhE3AwAgASARIAEpAwCFQgGJNwMAIAAgAkEDdGoiDSANKQMAIhEgACAGQQN0aiICKQMAIhJ8IBFCAYZC/v///x+DIBJC/////w+DfnwiETcDACAAIA5BA3RqIgYgESAGKQMAhUIgiSIRNwMAIAAgCkEDdGoiCiARIAopAwAiEnwgEUL/////D4MgEkIBhkL+////H4N+fCIRNwMAIAIgESACKQMAhUIoiSIRNwMAIA0gESANKQMAIhJ8IBFC/////w+DIBJCAYZC/v///x+DfnwiETcDACAGIBEgBikDAIVCMIkiETcDACAKIBEgCikDACISfCARQv////8PgyASQgGGQv7///8fg358IhE3AwAgAiARIAIpAwCFQgGJNwMAIAAgA0EDdGoiDiAOKQMAIhEgACAHQQN0aiIDKQMAIhJ8IBFCAYZC/v///x+DIBJC/////w+DfnwiETcDACAAIA9BA3RqIgcgESAHKQMAhUIgiSIRNwMAIAAgC0EDdGoiCyARIAspAwAiEnwgEUL/////D4MgEkIBhkL+////H4N+fCIRNwMAIAMgESADKQMAhUIoiSIRNwMAIA4gESAOKQMAIhJ8IBFC/////w+DIBJCAYZC/v///x+DfnwiETcDACAHIBEgBykDAIVCMIkiETcDACALIBEgCykDACISfCARQv////8PgyASQgGGQv7///8fg358IhE3AwAgAyARIAMpAwCFQgGJNwMAIAAgBEEDdGoiDyAPKQMAIhEgACAIQQN0aiIEKQMAIhJ8IBFCAYZC/v///x+DIBJC/////w+DfnwiETcDACAAIBBBA3RqIgggESAIKQMAhUIgiSIRNwMAIAAgDEEDdGoiACARIAApAwAiEnwgEUL/////D4MgEkIBhkL+////H4N+fCIRNwMAIAQgESAEKQMAhUIoiSIRNwMAIA8gESAPKQMAIhJ8IBFC/////w+DIBJCAYZC/v///x+DfnwiETcDACAIIBEgCCkDAIVCMIkiETcDACAAIBEgACkDACISfCARQv////8PgyASQgGGQv7///8fg358IhE3AwAgBCARIAQpAwCFQgGJNwMAIBMgEykDACIRIAIpAwAiEnwgEUIBhkL+////H4MgEkL/////D4N+fCIRNwMAIAggESAIKQMAhUIgiSIRNwMAIAsgESALKQMAIhJ8IBFC/////w+DIBJCAYZC/v///x+DfnwiETcDACACIBEgAikDAIVCKIkiETcDACATIBEgEykDACISfCARQv////8PgyASQgGGQv7///8fg358IhE3AwAgCCARIAgpAwCFQjCJIhE3AwAgCyARIAspAwAiEnwgEUL/////D4MgEkIBhkL+////H4N+fCIRNwMAIAIgESACKQMAhUIBiTcDACANIA0pAwAiESADKQMAIhJ8IBFCAYZC/v///x+DIBJC/////w+DfnwiETcDACAFIBEgBSkDAIVCIIkiETcDACAAIBEgACkDACISfCARQv////8PgyASQgGGQv7///8fg358IhE3AwAgAyARIAMpAwCFQiiJIhE3AwAgDSARIA0pAwAiEnwgEUL/////D4MgEkIBhkL+////H4N+fCIRNwMAIAUgESAFKQMAhUIwiSIRNwMAIAAgESAAKQMAIhJ8IBFC/////w+DIBJCAYZC/v///x+DfnwiETcDACADIBEgAykDAIVCAYk3AwAgDiAOKQMAIhEgBCkDACISfCARQgGGQv7///8fgyASQv////8Pg358IhE3AwAgBiARIAYpAwCFQiCJIhE3AwAgCSARIAkpAwAiEnwgEUL/////D4MgEkIBhkL+////H4N+fCIRNwMAIAQgESAEKQMAhUIoiSIRNwMAIA4gESAOKQMAIhJ8IBFC/////w+DIBJCAYZC/v///x+DfnwiETcDACAGIBEgBikDAIVCMIkiETcDACAJIBEgCSkDACISfCARQv////8PgyASQgGGQv7///8fg358IhE3AwAgBCARIAQpAwCFQgGJNwMAIA8gDykDACIRIAEpAwAiEnwgEUIBhkL+////H4MgEkL/////D4N+fCIRNwMAIAcgESAHKQMAhUIgiSIRNwMAIAogESAKKQMAIhJ8IBFC/////w+DIBJCAYZC/v///x+DfnwiETcDACABIBEgASkDAIVCKIkiETcDACAPIBEgDykDACISfCARQv////8PgyASQgGGQv7///8fg358IhE3AwAgByARIAcpAwCFQjCJIhE3AwAgCiARIAopAwAiEnwgEUL/////D4MgEkIBhkL+////H4N+fCIRNwMAIAEgESABKQMAhUIBiTcDAAvdCAEPfwNAIAIgBUEDdCIGaiABIAZqKQMAIAAgBmopAwCFNwMAIAIgBkEIciIGaiABIAZqKQMAIAAgBmopAwCFNwMAIAVBAmoiBUGAAUcNAAsDQCADIARBA3QiAGogACACaikDADcDACADIARBAXIiAEEDdCIBaiABIAJqKQMANwMAIAMgBEECciIBQQN0IgVqIAIgBWopAwA3AwAgAyAEQQNyIgVBA3QiBmogAiAGaikDADcDACADIARBBHIiBkEDdCIHaiACIAdqKQMANwMAIAMgBEEFciIHQQN0IghqIAIgCGopAwA3AwAgAyAEQQZyIghBA3QiCWogAiAJaikDADcDACADIARBB3IiCUEDdCIKaiACIApqKQMANwMAIAMgBEEIciIKQQN0IgtqIAIgC2opAwA3AwAgAyAEQQlyIgtBA3QiDGogAiAMaikDADcDACADIARBCnIiDEEDdCINaiACIA1qKQMANwMAIAMgBEELciINQQN0Ig5qIAIgDmopAwA3AwAgAyAEQQxyIg5BA3QiD2ogAiAPaikDADcDACADIARBDXIiD0EDdCIQaiACIBBqKQMANwMAIAMgBEEOciIQQQN0IhFqIAIgEWopAwA3AwAgAyAEQQ9yIhFBA3QiEmogAiASaikDADcDACADIARB//8DcSAAQf//A3EgAUH//wNxIAVB//8DcSAGQf//A3EgB0H//wNxIAhB//8DcSAJQf//A3EgCkH//wNxIAtB//8DcSAMQf//A3EgDUH//wNxIA5B//8DcSAPQf//A3EgEEH//wNxIBFB//8DcRACIARB8ABJIQAgBEEQaiEEIAANAAtBACEBIANBAEEBQRBBEUEgQSFBMEExQcAAQcEAQdAAQdEAQeAAQeEAQfAAQfEAEAIgA0ECQQNBEkETQSJBI0EyQTNBwgBBwwBB0gBB0wBB4gBB4wBB8gBB8wAQAiADQQRBBUEUQRVBJEElQTRBNUHEAEHFAEHUAEHVAEHkAEHlAEH0AEH1ABACIANBBkEHQRZBF0EmQSdBNkE3QcYAQccAQdYAQdcAQeYAQecAQfYAQfcAEAIgA0EIQQlBGEEZQShBKUE4QTlByABByQBB2ABB2QBB6ABB6QBB+ABB+QAQAiADQQpBC0EaQRtBKkErQTpBO0HKAEHLAEHaAEHbAEHqAEHrAEH6AEH7ABACIANBDEENQRxBHUEsQS1BPEE9QcwAQc0AQdwAQd0AQewAQe0AQfwAQf0AEAIgA0EOQQ9BHkEfQS5BL0E+QT9BzgBBzwBB3gBB3wBB7gBB7wBB/gBB/wAQAgNAIAIgAUEDdCIAaiIEIAAgA2opAwAgBCkDAIU3AwAgAiAAQQhyIgRqIgUgAyAEaikDACAFKQMAhTcDACACIABBEHIiBGoiBSADIARqKQMAIAUpAwCFNwMAIAIgAEEYciIAaiIEIAAgA2opAwAgBCkDAIU3AwAgAUEEaiIBQYABRw0ACwsWACAAIAEgAiADEAMgACACIAIgAxADC3sCAX8BfiACIQkgATUCACEKIAQgBXIEQCABKAIEIANwIQkLIAAgCTYCACAAIAdBAWsgBSAEGyAIbCAGQQFrQQBBfyAGGyACIAlGG2oiASAFQQFqIAhsQQAgBBtqIAGtIAogCn5CIIh+QiCIp0F/c2ogByAIbHA2AgQgAAsEACMACwYAIAAkAAsQACMAIABrQXBxIgAkACAACwUAQYAICw==", t3)) });
function wO(t3) {
  return t3 && t3.__esModule && Object.prototype.hasOwnProperty.call(t3, "default") ? t3.default : t3;
}
var xO = function() {
  if (Q5) return O5;
  Q5 = 1;
  const t3 = function() {
    if (N5) return P5;
    function n(i) {
      this.name = "Bzip2Error", this.message = i, this.stack = Error().stack;
    }
    N5 = 1, n.prototype = Error();
    var r = function(i) {
      throw new n(i);
    }, s = {};
    return s.Bzip2Error = n, s.crcTable = [0, 79764919, 159529838, 222504665, 319059676, 398814059, 445009330, 507990021, 638119352, 583659535, 797628118, 726387553, 890018660, 835552979, 1015980042, 944750013, 1276238704, 1221641927, 1167319070, 1095957929, 1595256236, 1540665371, 1452775106, 1381403509, 1780037320, 1859660671, 1671105958, 1733955601, 2031960084, 2111593891, 1889500026, 1952343757, 2552477408, 2632100695, 2443283854, 2506133561, 2334638140, 2414271883, 2191915858, 2254759653, 3190512472, 3135915759, 3081330742, 3009969537, 2905550212, 2850959411, 2762807018, 2691435357, 3560074640, 3505614887, 3719321342, 3648080713, 3342211916, 3287746299, 3467911202, 3396681109, 4063920168, 4143685023, 4223187782, 4286162673, 3779000052, 3858754371, 3904687514, 3967668269, 881225847, 809987520, 1023691545, 969234094, 662832811, 591600412, 771767749, 717299826, 311336399, 374308984, 453813921, 533576470, 25881363, 88864420, 134795389, 214552010, 2023205639, 2086057648, 1897238633, 1976864222, 1804852699, 1867694188, 1645340341, 1724971778, 1587496639, 1516133128, 1461550545, 1406951526, 1302016099, 1230646740, 1142491917, 1087903418, 2896545431, 2825181984, 2770861561, 2716262478, 3215044683, 3143675388, 3055782693, 3001194130, 2326604591, 2389456536, 2200899649, 2280525302, 2578013683, 2640855108, 2418763421, 2498394922, 3769900519, 3832873040, 3912640137, 3992402750, 4088425275, 4151408268, 4197601365, 4277358050, 3334271071, 3263032808, 3476998961, 3422541446, 3585640067, 3514407732, 3694837229, 3640369242, 1762451694, 1842216281, 1619975040, 1682949687, 2047383090, 2127137669, 1938468188, 2001449195, 1325665622, 1271206113, 1183200824, 1111960463, 1543535498, 1489069629, 1434599652, 1363369299, 622672798, 568075817, 748617968, 677256519, 907627842, 853037301, 1067152940, 995781531, 51762726, 131386257, 177728840, 240578815, 269590778, 349224269, 429104020, 491947555, 4046411278, 4126034873, 4172115296, 4234965207, 3794477266, 3874110821, 3953728444, 4016571915, 3609705398, 3555108353, 3735388376, 3664026991, 3290680682, 3236090077, 3449943556, 3378572211, 3174993278, 3120533705, 3032266256, 2961025959, 2923101090, 2868635157, 2813903052, 2742672763, 2604032198, 2683796849, 2461293480, 2524268063, 2284983834, 2364738477, 2175806836, 2238787779, 1569362073, 1498123566, 1409854455, 1355396672, 1317987909, 1246755826, 1192025387, 1137557660, 2072149281, 2135122070, 1912620623, 1992383480, 1753615357, 1816598090, 1627664531, 1707420964, 295390185, 358241886, 404320391, 483945776, 43990325, 106832002, 186451547, 266083308, 932423249, 861060070, 1041341759, 986742920, 613929101, 542559546, 756411363, 701822548, 3316196985, 3244833742, 3425377559, 3370778784, 3601682597, 3530312978, 3744426955, 3689838204, 3819031489, 3881883254, 3928223919, 4007849240, 4037393693, 4100235434, 4180117107, 4259748804, 2310601993, 2373574846, 2151335527, 2231098320, 2596047829, 2659030626, 2470359227, 2550115596, 2947551409, 2876312838, 2788305887, 2733848168, 3165939309, 3094707162, 3040238851, 2985771188], s.array = function(i) {
      var a = 0, o = 0, f = [0, 1, 3, 7, 15, 31, 63, 127, 255];
      return function(c) {
        for (var l = 0; c > 0; ) {
          var h = 8 - a;
          c >= h ? (l <<= h, l |= f[h] & i[o++], a = 0, c -= h) : (l <<= c, l |= (i[o] & f[c] << 8 - c - a) >> 8 - c - a, a += c, c = 0);
        }
        return l;
      };
    }, s.simple = function(i, a) {
      var o = s.array(i), f = false, c = 1e5 * s.header(o), l = new Int32Array(c);
      do
        f = s.decompress(o, a, l, c);
      while (!f);
    }, s.header = function(i) {
      this.byteCount = new Int32Array(256), this.symToByte = new Uint8Array(256), this.mtfSymbol = new Int32Array(256), this.selectors = new Uint8Array(32768), i(24) != 4348520 && r("No magic number found");
      var a = i(8) - 48;
      return (a < 1 || a > 9) && r("Not a BZIP archive"), a;
    }, s.decompress = function(i, a, o, f, c) {
      for (var l = -1, h = "", m = 0; m < 6; m++) h += i(8).toString(16);
      if (h == "177245385090") return (0 | i(32)) !== c && r("Error in bzip2: crc32 do not match"), i(null), null;
      h != "314159265359" && r("Invalid bzip data");
      var v = 0 | i(32);
      i(1) && r("unsupported obsolete version");
      var b = i(24);
      b > f && r("Initial position larger than buffer size");
      var A = i(16), _ = 0;
      for (m = 0; m < 16; m++) if (A & 1 << 15 - m) {
        var C = i(16);
        for ($ = 0; $ < 16; $++) C & 1 << 15 - $ && (this.symToByte[_++] = 16 * m + $);
      }
      var I = i(3);
      (I < 2 || I > 6) && r("Invalid bzip data");
      var S = i(15);
      for (S == 0 && r("Invalid bzip data"), m = 0; m < I; m++) this.mtfSymbol[m] = m;
      for (m = 0; m < S; m++) {
        for (var $ = 0; i(1); $++) $ >= I && r("Invalid bzip data");
        var F = this.mtfSymbol[$];
        for (C = $ - 1; C >= 0; C--) this.mtfSymbol[C + 1] = this.mtfSymbol[C];
        this.mtfSymbol[0] = F, this.selectors[m] = F;
      }
      var U, Q, P, N, L = _ + 2, B = [], u = new Uint8Array(258), p = new Uint16Array(21);
      for ($ = 0; $ < I; $++) {
        for (A = i(5), m = 0; m < L; m++) {
          for (; (A < 1 || A > 20) && r("Invalid bzip data"), i(1); ) i(1) ? A-- : A++;
          u[m] = A;
        }
        var d, y;
        for (d = y = u[0], m = 1; m < L; m++) u[m] > y ? y = u[m] : u[m] < d && (d = u[m]);
        (U = B[$] = {}).permute = new Int32Array(258), U.limit = new Int32Array(21), U.base = new Int32Array(21), U.minLen = d, U.maxLen = y;
        var w = U.base, E = U.limit, M = 0;
        for (m = d; m <= y; m++) for (A = 0; A < L; A++) u[A] == m && (U.permute[M++] = A);
        for (m = d; m <= y; m++) p[m] = E[m] = 0;
        for (m = 0; m < L; m++) p[u[m]]++;
        for (M = A = 0, m = d; m < y; m++) M += p[m], E[m] = M - 1, M <<= 1, w[m + 1] = M - (A += p[m]);
        E[y] = M + p[y] - 1, w[d] = 0;
      }
      for (m = 0; m < 256; m++) this.mtfSymbol[m] = m, this.byteCount[m] = 0;
      for (Q = P = L = N = 0; ; ) {
        for (L-- || (L = 49, N >= S && r("Invalid bzip data"), w = (U = B[this.selectors[N++]]).base, E = U.limit), $ = i(m = U.minLen); m > U.maxLen && r("Invalid bzip data"), !($ <= E[m]); ) m++, $ = $ << 1 | i(1);
        (($ -= w[m]) < 0 || $ >= 258) && r("Invalid bzip data");
        var x = U.permute[$];
        if (x != 0 && x != 1) {
          if (Q) for (Q = 0, P + A > f && r("Invalid bzip data"), F = this.symToByte[this.mtfSymbol[0]], this.byteCount[F] += A; A--; ) o[P++] = F;
          if (x > _) break;
          for (P >= f && r("Invalid bzip data"), m = x - 1, F = this.mtfSymbol[m], C = m - 1; C >= 0; C--) this.mtfSymbol[C + 1] = this.mtfSymbol[C];
          this.mtfSymbol[0] = F, F = this.symToByte[F], this.byteCount[F]++, o[P++] = F;
        } else Q || (Q = 1, A = 0), A += x == 0 ? Q : 2 * Q, Q <<= 1;
      }
      for ((b < 0 || b >= P) && r("Invalid bzip data"), $ = 0, m = 0; m < 256; m++) C = $ + this.byteCount[m], this.byteCount[m] = $, $ = C;
      for (m = 0; m < P; m++) F = 255 & o[m], o[this.byteCount[F]] |= m << 8, this.byteCount[F]++;
      var g, k, T, O = 0, K = 0, Y = 0;
      for (P && (K = 255 & (O = o[b]), O >>= 8, Y = -1); P; ) {
        for (P--, k = K, K = 255 & (O = o[O]), O >>= 8, Y++ == 3 ? (g = K, T = k, K = -1) : (g = 1, T = K); g--; ) l = 4294967295 & (l << 8 ^ this.crcTable[255 & (l >> 24 ^ T)]), a(T);
        K != k && (Y = 0);
      }
      return (0 | (l = ~l >>> 0)) != (0 | v) && r("Error in bzip2: crc32 do not match"), 4294967295 & (l ^ (c << 1 | c >>> 31));
    }, P5 = s;
  }(), e = function() {
    if (L5) return U5;
    L5 = 1;
    var n = [0, 1, 3, 7, 15, 31, 63, 127, 255];
    return U5 = function(r) {
      var s = 0, i = 0, a = r(), o = function(f) {
        if (f === null && s != 0) return s = 0, void i++;
        for (var c = 0; f > 0; ) {
          i >= a.length && (i = 0, a = r());
          var l = 8 - s;
          s === 0 && f > 0 && o.bytesRead++, f >= l ? (c <<= l, c |= n[l] & a[i++], s = 0, f -= l) : (c <<= f, c |= (a[i] & n[f] << 8 - f - s) >> 8 - f - s, s += f, f = 0);
        }
        return c;
      };
      return o.bytesRead = 0, o;
    };
  }();
  return O5 = function(n) {
    const r = [];
    let s = 0, i = 0, a = false, o = false, f = null, c = null, l, h = 0;
    function m(v) {
      if (!a) try {
        return function(b) {
          if (i) {
            const A = 1e5 * i, _ = new Int32Array(A), C = [], I = function(S) {
              C.push(S);
            };
            return c = t3.decompress(f, I, _, A, c), c === null ? (i = 0, false) : (b(new Uint8Array(C)), true);
          }
          return i = t3.header(f), c = 0, false;
        }(function(b) {
          v.enqueue(b), b !== null && (h += b.length);
        });
      } catch (b) {
        return v.error(b), a = true, true;
      }
    }
    return new ReadableStream({ start() {
      l = n.getReader();
    }, async pull(v) {
      try {
        for (; ; ) {
          for (; !(o || f && s - f.bytesRead + 1 >= 25e3 + 1e5 * (i || 4)); ) {
            const { value: b, done: A } = await l.read();
            A ? o = true : (r.push(b), s += b.length, f === null && (f = e(function() {
              return r.shift();
            })));
          }
          for (; o ? f && s > f.bytesRead : f && s - f.bytesRead + 1 >= 25e3 + 1e5 * (i || 4); ) if (m(v)) return;
          if (o && !a && (!f || s <= f.bytesRead)) return void (c === null ? v.close() : v.error(Error("input stream ended prematurely")));
        }
      } catch (b) {
        v.error(b);
      }
    }, async cancel(v) {
      await l.abort(v);
    } }, { highWaterMark: 0 });
  };
}(), _O = Object.freeze({ __proto__: null, default: wO(xO) });
async function EO(t3, e) {
  try {
    const n = await mU({ armoredKey: e }), r = await wU({ binary: t3 });
    return await EU({ message: r, encryptionKeys: n, format: "armored" });
  } catch (n) {
    throw new Error(`Encryption failed: ${n.message}`);
  }
}
async function BO(t3, e, n = "") {
  try {
    let r = await vU({ armoredKey: e });
    if (!r.isDecrypted()) {
      if (!n) throw new Error("Private key is encrypted. Please enter a passphrase.");
      try {
        r = await _U({ privateKey: r, passphrase: n });
      } catch {
        throw new Error("Incorrect passphrase for private key.");
      }
    }
    let s;
    try {
      const a = new TextDecoder(), o = typeof t3 == "string" ? t3 : a.decode(t3);
      if (o.includes("-----BEGIN PGP MESSAGE-----")) s = await G6({ armoredMessage: o });
      else throw new Error("Not text");
    } catch {
      s = await G6({ binaryMessage: t3 });
    }
    const { data: i } = await BU({ message: s, decryptionKeys: r, format: "binary" });
    return i;
  } catch (r) {
    throw new Error(`Decryption failed: ${r.message}`);
  }
}
function CO(t3) {
  let e, n, r, s, i, a;
  const o = t3[2].default, f = Ob(o, t3, t3[1], null);
  return { c() {
    e = H("div"), n = H("h2"), r = we(t3[0]), s = z(), i = H("div"), f && f.c(), V(n, "class", "svelte-kbs9d0"), V(i, "class", "card-content svelte-kbs9d0"), V(e, "class", "card svelte-kbs9d0");
  }, m(c, l) {
    R(c, e, l), q(e, n), q(n, r), q(e, s), q(e, i), f && f.m(i, null), a = true;
  }, p(c, [l]) {
    (!a || l & 1) && Ze(r, c[0]), f && f.p && (!a || l & 2) && Kb(f, o, c, c[1], a ? Qb(o, c[1], l, null) : Hb(c[1]), null);
  }, i(c) {
    a || (W(f, c), a = true);
  }, o(c) {
    j(f, c), a = false;
  }, d(c) {
    c && D(e), f && f.d(c);
  } };
}
function kO(t3, e, n) {
  let { $$slots: r = {}, $$scope: s } = e, { title: i = "Tool" } = e;
  return t3.$$set = (a) => {
    "title" in a && n(0, i = a.title), "$$scope" in a && n(1, s = a.$$scope);
  }, [i, s, r];
}
class ar extends xt {
  constructor(e) {
    super(), wt(this, e, kO, CO, At, { title: 0 });
  }
}
function K5(t3, e, n) {
  const r = t3.slice();
  return r[4] = e[n], r;
}
function H5(t3) {
  let e, n, r, s, i = Mr(t3[1]), a = [];
  for (let o = 0; o < i.length; o += 1) a[o] = q5(K5(t3, i, o));
  return { c() {
    e = H("div"), n = H("h4"), n.textContent = "Useful Links:", r = z(), s = H("ul");
    for (let o = 0; o < a.length; o += 1) a[o].c();
    V(n, "class", "svelte-1ja6d9q"), V(e, "class", "links-section svelte-1ja6d9q");
  }, m(o, f) {
    R(o, e, f), q(e, n), q(e, r), q(e, s);
    for (let c = 0; c < a.length; c += 1) a[c] && a[c].m(s, null);
  }, p(o, f) {
    if (f & 2) {
      i = Mr(o[1]);
      let c;
      for (c = 0; c < i.length; c += 1) {
        const l = K5(o, i, c);
        a[c] ? a[c].p(l, f) : (a[c] = q5(l), a[c].c(), a[c].m(s, null));
      }
      for (; c < a.length; c += 1) a[c].d(1);
      a.length = i.length;
    }
  }, d(o) {
    o && D(e), jn(a, o);
  } };
}
function q5(t3) {
  let e, n, r = t3[4].text + "", s, i, a;
  return { c() {
    e = H("li"), n = H("a"), s = we(r), a = z(), V(n, "href", i = t3[4].url), V(n, "target", "_blank"), V(n, "rel", "noopener noreferrer"), V(n, "class", "svelte-1ja6d9q");
  }, m(o, f) {
    R(o, e, f), q(e, n), q(n, s), q(e, a);
  }, p(o, f) {
    f & 2 && r !== (r = o[4].text + "") && Ze(s, r), f & 2 && i !== (i = o[4].url) && V(n, "href", i);
  }, d(o) {
    o && D(e);
  } };
}
function IO(t3) {
  let e, n, r, s, i, a, o;
  const f = t3[3].default, c = Ob(f, t3, t3[2], null);
  let l = t3[1].length > 0 && H5(t3);
  return { c() {
    e = H("div"), n = H("h3"), r = we(t3[0]), s = z(), i = H("div"), c && c.c(), a = z(), l && l.c(), V(n, "class", "svelte-1ja6d9q"), V(i, "class", "about-content svelte-1ja6d9q"), V(e, "class", "about-section svelte-1ja6d9q");
  }, m(h, m) {
    R(h, e, m), q(e, n), q(n, r), q(e, s), q(e, i), c && c.m(i, null), q(e, a), l && l.m(e, null), o = true;
  }, p(h, [m]) {
    (!o || m & 1) && Ze(r, h[0]), c && c.p && (!o || m & 4) && Kb(c, f, h, h[2], o ? Qb(f, h[2], m, null) : Hb(h[2]), null), h[1].length > 0 ? l ? l.p(h, m) : (l = H5(h), l.c(), l.m(e, null)) : l && (l.d(1), l = null);
  }, i(h) {
    o || (W(c, h), o = true);
  }, o(h) {
    j(c, h), o = false;
  }, d(h) {
    h && D(e), c && c.d(h), l && l.d();
  } };
}
function SO(t3, e, n) {
  let { $$slots: r = {}, $$scope: s } = e, { title: i = "About" } = e, { links: a = [] } = e;
  return t3.$$set = (o) => {
    "title" in o && n(0, i = o.title), "links" in o && n(1, a = o.links), "$$scope" in o && n(2, s = o.$$scope);
  }, [i, a, s, r];
}
class Rt extends xt {
  constructor(e) {
    super(), wt(this, e, SO, IO, At, { title: 0, links: 1 });
  }
}
function MO(t3) {
  let e, n, r;
  return { c() {
    e = H("input"), V(e, "type", "file"), V(e, "accept", t3[0]), e.multiple = t3[1], St(e, "display", "none");
  }, m(s, i) {
    R(s, e, i), t3[12](e), n || (r = Kt(e, "change", t3[10]), n = true);
  }, p(s, i) {
    i & 1 && V(e, "accept", s[0]), i & 2 && (e.multiple = s[1]);
  }, d(s) {
    s && D(e), t3[12](null), n = false, r();
  } };
}
function $O(t3) {
  let e, n, r;
  return { c() {
    e = H("input"), V(e, "type", "file"), V(e, "webkitdirectory", ""), V(e, "directory", ""), St(e, "display", "none");
  }, m(s, i) {
    R(s, e, i), t3[11](e), n || (r = Kt(e, "change", t3[10]), n = true);
  }, p: dt, d(s) {
    s && D(e), t3[11](null), n = false, r();
  } };
}
function TO(t3) {
  let e;
  return { c() {
    e = we("\u{1F4C4}");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function DO(t3) {
  let e;
  return { c() {
    e = we("\u{1F4C2}");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function RO(t3) {
  let e, n, r, s, i, a, o, f, c, l, h = t3[2] ? "(Drag a folder here)" : "(or drag files here)", m, v, b;
  function A(F, U) {
    return F[2] ? $O : MO;
  }
  let _ = A(t3), C = _(t3);
  function I(F, U) {
    return F[2] ? DO : TO;
  }
  let S = I(t3), $ = S(t3);
  return { c() {
    e = H("div"), C.c(), n = z(), r = H("div"), s = H("div"), $.c(), i = z(), a = H("div"), o = H("strong"), f = we(t3[3]), c = z(), l = H("span"), m = we(h), V(s, "class", "icon svelte-iphccp"), V(l, "class", "subtext svelte-iphccp"), V(a, "class", "text svelte-iphccp"), V(r, "class", "content svelte-iphccp"), V(e, "class", "drop-zone svelte-iphccp"), V(e, "role", "button"), V(e, "tabindex", "0"), Zt(e, "active", t3[5]);
  }, m(F, U) {
    R(F, e, U), C.m(e, null), q(e, n), q(e, r), q(r, s), $.m(s, null), q(r, i), q(r, a), q(a, o), q(o, f), q(a, c), q(a, l), q(l, m), v || (b = [Kt(e, "dragover", t3[6]), Kt(e, "dragleave", t3[7]), Kt(e, "drop", t3[8]), Kt(e, "click", t3[9]), Kt(e, "keydown", t3[13])], v = true);
  }, p(F, [U]) {
    _ === (_ = A(F)) && C ? C.p(F, U) : (C.d(1), C = _(F), C && (C.c(), C.m(e, n))), S !== (S = I(F)) && ($.d(1), $ = S(F), $ && ($.c(), $.m(s, null))), U & 8 && Ze(f, F[3]), U & 4 && h !== (h = F[2] ? "(Drag a folder here)" : "(or drag files here)") && Ze(m, h), U & 32 && Zt(e, "active", F[5]);
  }, i: dt, o: dt, d(F) {
    F && D(e), C.d(), $.d(), v = false, Mn(b);
  } };
}
function FO(t3, e, n) {
  let { accept: r = "*" } = e, { multiple: s = false } = e, { directory: i = false } = e, { label: a = "Drop file here or click to upload" } = e;
  const o = Vh();
  let f, c = false;
  function l(S) {
    S.preventDefault(), n(5, c = true);
  }
  function h() {
    n(5, c = false);
  }
  function m(S) {
    S.preventDefault(), n(5, c = false), S.dataTransfer.files && S.dataTransfer.files.length > 0 && A(S.dataTransfer.files);
  }
  function v() {
    f.click();
  }
  function b(S) {
    S.target.files && S.target.files.length > 0 && A(S.target.files);
  }
  function A(S) {
    o("change", S);
  }
  function _(S) {
    Qe[S ? "unshift" : "push"](() => {
      f = S, n(4, f);
    });
  }
  function C(S) {
    Qe[S ? "unshift" : "push"](() => {
      f = S, n(4, f);
    });
  }
  const I = (S) => S.key === "Enter" && v();
  return t3.$$set = (S) => {
    "accept" in S && n(0, r = S.accept), "multiple" in S && n(1, s = S.multiple), "directory" in S && n(2, i = S.directory), "label" in S && n(3, a = S.label);
  }, [r, s, i, a, f, c, l, h, m, v, b, _, C, I];
}
class la extends xt {
  constructor(e) {
    super(), wt(this, e, FO, RO, At, { accept: 0, multiple: 1, directory: 2, label: 3 });
  }
}
function PO(t3) {
  let e, n, r, s, i;
  const a = t3[3].default, o = Ob(a, t3, t3[2], null);
  return { c() {
    e = H("button"), o && o.c(), V(e, "class", n = "btn " + t3[1] + " svelte-8ut522"), e.disabled = t3[0];
  }, m(f, c) {
    R(f, e, c), o && o.m(e, null), r = true, s || (i = Kt(e, "click", t3[4]), s = true);
  }, p(f, [c]) {
    o && o.p && (!r || c & 4) && Kb(o, a, f, f[2], r ? Qb(a, f[2], c, null) : Hb(f[2]), null), (!r || c & 2 && n !== (n = "btn " + f[1] + " svelte-8ut522")) && V(e, "class", n), (!r || c & 1) && (e.disabled = f[0]);
  }, i(f) {
    r || (W(o, f), r = true);
  }, o(f) {
    j(o, f), r = false;
  }, d(f) {
    f && D(e), o && o.d(f), s = false, i();
  } };
}
function NO(t3, e, n) {
  let { $$slots: r = {}, $$scope: s } = e, { disabled: i = false } = e, { variant: a = "primary" } = e;
  function o(f) {
    Ds.call(this, t3, f);
  }
  return t3.$$set = (f) => {
    "disabled" in f && n(0, i = f.disabled), "variant" in f && n(1, a = f.variant), "$$scope" in f && n(2, s = f.$$scope);
  }, [i, a, s, r, o];
}
class ut extends xt {
  constructor(e) {
    super(), wt(this, e, NO, PO, At, { disabled: 0, variant: 1 });
  }
}
function UO(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b;
  s = new la({ props: { label: "Drop Encrypted File" } }), s.$on("change", t3[10]);
  let A = t3[6] && z5(t3);
  l = new la({ props: { label: "Drop Private Key (.asc)", accept: ".asc,.txt,.key" } }), l.$on("change", t3[11]);
  let _ = t3[7] && G5(t3);
  return v = new ut({ props: { disabled: t3[1], $$slots: { default: [OO] }, $$scope: { ctx: t3 } } }), v.$on("click", t3[13]), { c() {
    e = H("div"), n = H("span"), n.textContent = "1. Select Encrypted File (.enc, .pgp)", r = z(), fe(s.$$.fragment), i = z(), A && A.c(), a = z(), o = H("div"), f = H("span"), f.textContent = "2. Your Private Key (.asc)", c = z(), fe(l.$$.fragment), h = z(), _ && _.c(), m = z(), fe(v.$$.fragment), St(n, "font-weight", "bold"), V(e, "class", "form-group svelte-14emnwp"), St(f, "font-weight", "bold"), V(o, "class", "form-group svelte-14emnwp");
  }, m(C, I) {
    R(C, e, I), q(e, n), q(e, r), ae(s, e, null), q(e, i), A && A.m(e, null), R(C, a, I), R(C, o, I), q(o, f), q(o, c), ae(l, o, null), q(o, h), _ && _.m(o, null), R(C, m, I), ae(v, C, I), b = true;
  }, p(C, I) {
    C[6] ? A ? A.p(C, I) : (A = z5(C), A.c(), A.m(e, null)) : A && (A.d(1), A = null), C[7] ? _ ? _.p(C, I) : (_ = G5(C), _.c(), _.m(o, null)) : _ && (_.d(1), _ = null);
    const S = {};
    I & 2 && (S.disabled = C[1]), I & 4194306 && (S.$$scope = { dirty: I, ctx: C }), v.$set(S);
  }, i(C) {
    b || (W(s.$$.fragment, C), W(l.$$.fragment, C), W(v.$$.fragment, C), b = true);
  }, o(C) {
    j(s.$$.fragment, C), j(l.$$.fragment, C), j(v.$$.fragment, C), b = false;
  }, d(C) {
    C && (D(e), D(a), D(o), D(m)), oe(s), A && A.d(), oe(l), _ && _.d(), oe(v, C);
  } };
}
function LO(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b;
  s = new la({ props: { label: "Drop File Here" } }), s.$on("change", t3[8]);
  let A = t3[4] && V5(t3);
  l = new la({ props: { label: "Drop Public Key (.asc)", accept: ".asc,.txt,.key" } }), l.$on("change", t3[9]);
  let _ = t3[5] && Y5(t3);
  return v = new ut({ props: { disabled: t3[1], $$slots: { default: [QO] }, $$scope: { ctx: t3 } } }), v.$on("click", t3[12]), { c() {
    e = H("div"), n = H("span"), n.textContent = "1. Select File to Encrypt", r = z(), fe(s.$$.fragment), i = z(), A && A.c(), a = z(), o = H("div"), f = H("span"), f.textContent = "2. Recipient's Public Key (.asc)", c = z(), fe(l.$$.fragment), h = z(), _ && _.c(), m = z(), fe(v.$$.fragment), St(n, "font-weight", "bold"), V(e, "class", "form-group svelte-14emnwp"), St(f, "font-weight", "bold"), V(o, "class", "form-group svelte-14emnwp");
  }, m(C, I) {
    R(C, e, I), q(e, n), q(e, r), ae(s, e, null), q(e, i), A && A.m(e, null), R(C, a, I), R(C, o, I), q(o, f), q(o, c), ae(l, o, null), q(o, h), _ && _.m(o, null), R(C, m, I), ae(v, C, I), b = true;
  }, p(C, I) {
    C[4] ? A ? A.p(C, I) : (A = V5(C), A.c(), A.m(e, null)) : A && (A.d(1), A = null), C[5] ? _ ? _.p(C, I) : (_ = Y5(C), _.c(), _.m(o, null)) : _ && (_.d(1), _ = null);
    const S = {};
    I & 2 && (S.disabled = C[1]), I & 4194306 && (S.$$scope = { dirty: I, ctx: C }), v.$set(S);
  }, i(C) {
    b || (W(s.$$.fragment, C), W(l.$$.fragment, C), W(v.$$.fragment, C), b = true);
  }, o(C) {
    j(s.$$.fragment, C), j(l.$$.fragment, C), j(v.$$.fragment, C), b = false;
  }, d(C) {
    C && (D(e), D(a), D(o), D(m)), oe(s), A && A.d(), oe(l), _ && _.d(), oe(v, C);
  } };
}
function z5(t3) {
  let e, n, r = t3[6].name + "", s;
  return { c() {
    e = H("div"), n = H("strong"), s = we(r), V(e, "class", "file-status svelte-14emnwp");
  }, m(i, a) {
    R(i, e, a), q(e, n), q(n, s);
  }, p(i, a) {
    a & 64 && r !== (r = i[6].name + "") && Ze(s, r);
  }, d(i) {
    i && D(e);
  } };
}
function G5(t3) {
  let e, n, r, s = t3[7].name + "", i;
  return { c() {
    e = H("div"), n = we("\u{1F511} "), r = H("strong"), i = we(s), V(e, "class", "file-status key-status svelte-14emnwp");
  }, m(a, o) {
    R(a, e, o), q(e, n), q(e, r), q(r, i);
  }, p(a, o) {
    o & 128 && s !== (s = a[7].name + "") && Ze(i, s);
  }, d(a) {
    a && D(e);
  } };
}
function OO(t3) {
  let e = t3[1] ? "Decrypting..." : "Decrypt & Download", n;
  return { c() {
    n = we(e);
  }, m(r, s) {
    R(r, n, s);
  }, p(r, s) {
    s & 2 && e !== (e = r[1] ? "Decrypting..." : "Decrypt & Download") && Ze(n, e);
  }, d(r) {
    r && D(n);
  } };
}
function V5(t3) {
  let e, n, r, s = t3[4].name + "", i;
  return { c() {
    e = H("div"), n = we("\u{1F4C4} "), r = H("strong"), i = we(s), V(e, "class", "file-status svelte-14emnwp");
  }, m(a, o) {
    R(a, e, o), q(e, n), q(e, r), q(r, i);
  }, p(a, o) {
    o & 16 && s !== (s = a[4].name + "") && Ze(i, s);
  }, d(a) {
    a && D(e);
  } };
}
function Y5(t3) {
  let e, n, r, s = t3[5].name + "", i;
  return { c() {
    e = H("div"), n = we("\u{1F511} "), r = H("strong"), i = we(s), V(e, "class", "file-status key-status svelte-14emnwp");
  }, m(a, o) {
    R(a, e, o), q(e, n), q(e, r), q(r, i);
  }, p(a, o) {
    o & 32 && s !== (s = a[5].name + "") && Ze(i, s);
  }, d(a) {
    a && D(e);
  } };
}
function QO(t3) {
  let e = t3[1] ? "Encrypting..." : "Encrypt & Download", n;
  return { c() {
    n = we(e);
  }, m(r, s) {
    R(r, n, s);
  }, p(r, s) {
    s & 2 && e !== (e = r[1] ? "Encrypting..." : "Encrypt & Download") && Ze(n, e);
  }, d(r) {
    r && D(n);
  } };
}
function W5(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[2]), V(e, "class", "msg"), Zt(e, "error", t3[3] === "error"), Zt(e, "success", t3[3] === "success");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 4 && Ze(n, r[2]), s & 8 && Zt(e, "error", r[3] === "error"), s & 8 && Zt(e, "success", r[3] === "success");
  }, d(r) {
    r && D(e);
  } };
}
function KO(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m;
  const v = [LO, UO], b = [];
  function A(C, I) {
    return C[0] === "encrypt" ? 0 : 1;
  }
  o = A(t3), f = b[o] = v[o](t3);
  let _ = t3[2] && W5(t3);
  return { c() {
    e = H("div"), n = H("button"), n.textContent = "Encrypt Mode", r = z(), s = H("button"), s.textContent = "Decrypt Mode", i = z(), a = H("div"), f.c(), c = z(), _ && _.c(), V(n, "class", "svelte-14emnwp"), Zt(n, "active", t3[0] === "encrypt"), V(s, "class", "svelte-14emnwp"), Zt(s, "active", t3[0] === "decrypt"), V(e, "class", "tabs svelte-14emnwp"), V(a, "class", "tool-body");
  }, m(C, I) {
    R(C, e, I), q(e, n), q(e, r), q(e, s), R(C, i, I), R(C, a, I), b[o].m(a, null), q(a, c), _ && _.m(a, null), l = true, h || (m = [Kt(n, "click", t3[15]), Kt(s, "click", t3[16])], h = true);
  }, p(C, I) {
    (!l || I & 1) && Zt(n, "active", C[0] === "encrypt"), (!l || I & 1) && Zt(s, "active", C[0] === "decrypt");
    let S = o;
    o = A(C), o === S ? b[o].p(C, I) : (Xt(), j(b[S], 1, 1, () => {
      b[S] = null;
    }), er(), f = b[o], f ? f.p(C, I) : (f = b[o] = v[o](C), f.c()), W(f, 1), f.m(a, c)), C[2] ? _ ? _.p(C, I) : (_ = W5(C), _.c(), _.m(a, null)) : _ && (_.d(1), _ = null);
  }, i(C) {
    l || (W(f), l = true);
  }, o(C) {
    j(f), l = false;
  }, d(C) {
    C && (D(e), D(i), D(a)), b[o].d(), _ && _.d(), h = false, Mn(m);
  } };
}
function HO(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S;
  return { c() {
    e = H("p"), e.innerHTML = `The <b>PGP Encryption Tool</b> is an encryption utility that allows users to securely encrypt files using the 
        recipient&#39;s <b>PGP public key</b>. It provides a simple graphical interface for selecting files and keys, 
        and performs fast encryption using the OpenPGP standard.`, n = z(), r = H("h4"), r.textContent = "Key Features:", s = z(), i = H("ul"), i.innerHTML = "<li><b>File Selection:</b> Choose any file on your system to encrypt.</li> <li><b>Public Key Loading:</b> Import a recipient&#39;s public key (.asc) for secure encryption.</li> <li><b>Encryption:</b> Encrypt your file using strong OpenPGP encryption.</li> <li><b>Download Location:</b> Encrypted files are automatically saved to your <b>Downloads</b> folder.</li>", a = z(), o = H("p"), o.innerHTML = `The <b>PGP Decryption Tool</b> is a utility designed to <b>decrypt files</b> that were previously encrypted using a PGP public key. 
        It requires the matching <b>PGP private key</b> and passphrase (if protected) to decrypt the contents successfully.`, f = z(), c = H("h4"), c.textContent = "Key Features:", l = z(), h = H("ul"), h.innerHTML = "<li><b>Encrypted File Selection:</b> Easily choose any PGP-encrypted file (.enc) from your system.</li> <li><b>Private Key Loading:</b> Load your personal private key (.asc format) securely.</li> <li><b>Passphrase Support:</b> Decrypts keys protected by a passphrase via a secure input prompt.</li> <li><b>Decryption:</b> Extracts and saves the decrypted content into your <b>Downloads</b> folder.</li>", m = z(), v = H("h3"), v.textContent = "Security Notice:", b = z(), A = H("p"), A.innerHTML = `This tool assumes that you are the legitimate owner of the private key being used. For your safety, 
        make sure to <b>never share your private key or passphrase</b> with untrusted sources.`, _ = z(), C = H("h3"), C.textContent = "Note:", I = z(), S = H("p"), S.textContent = `Supports PGP public keys in ASCII-armored format (.asc). Make sure to verify the recipient's key 
        authenticity before use.`;
  }, m($, F) {
    R($, e, F), R($, n, F), R($, r, F), R($, s, F), R($, i, F), R($, a, F), R($, o, F), R($, f, F), R($, c, F), R($, l, F), R($, h, F), R($, m, F), R($, v, F), R($, b, F), R($, A, F), R($, _, F), R($, C, F), R($, I, F), R($, S, F);
  }, p: dt, d($) {
    $ && (D(e), D(n), D(r), D(s), D(i), D(a), D(o), D(f), D(c), D(l), D(h), D(m), D(v), D(b), D(A), D(_), D(C), D(I), D(S));
  } };
}
function qO(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "PGP Encryption Tool", $$slots: { default: [KO] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About OpenPGP", links: t3[14], $$slots: { default: [HO] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 4194559 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 4194304 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
let zO = "";
function GO(t3, e, n) {
  let r = "encrypt", s = false, i = "", a = "", o = null, f = null, c = "", l = null, h = null, m = "";
  const v = (N) => new Promise((L, B) => {
    const u = new FileReader();
    u.onload = () => L(new Uint8Array(u.result)), u.onerror = B, u.readAsArrayBuffer(N);
  }), b = (N) => new Promise((L, B) => {
    const u = new FileReader();
    u.onload = () => L(u.result), u.onerror = B, u.readAsText(N);
  }), A = (N, L, B = false) => {
    const u = new Blob([N], { type: B ? "application/octet-stream" : "text/plain" }), p = URL.createObjectURL(u), d = document.createElement("a");
    d.href = p, d.download = L, document.body.appendChild(d), d.click(), document.body.removeChild(d), URL.revokeObjectURL(p);
  };
  function _(N) {
    N.detail && N.detail.length > 0 && n(4, o = N.detail[0]);
  }
  async function C(N) {
    if (N.detail && N.detail.length > 0) {
      const L = N.detail[0];
      n(5, f = L), c = await b(L);
    }
  }
  function I(N) {
    N.detail && N.detail.length > 0 && n(6, l = N.detail[0]);
  }
  async function S(N) {
    if (N.detail && N.detail.length > 0) {
      const L = N.detail[0];
      n(7, h = L), m = await b(L);
    }
  }
  async function $() {
    if (n(2, i = ""), !o || !c) {
      n(2, i = "Please upload both a file and a public key."), n(3, a = "error");
      return;
    }
    try {
      n(1, s = true);
      const N = await v(o), L = await EO(N, c);
      A(L, `${o.name}.enc`, false), n(2, i = `Success! ${o.name}.enc downloaded.`), n(3, a = "success");
    } catch (N) {
      n(2, i = N.message), n(3, a = "error");
    } finally {
      n(1, s = false);
    }
  }
  async function F() {
    if (n(2, i = ""), !l || !m) {
      n(2, i = "Please upload both an encrypted file and a private key."), n(3, a = "error");
      return;
    }
    try {
      n(1, s = true);
      const N = await v(l), L = await BO(N, m, zO);
      let B = l.name.replace(/\.(enc|pgp|gpg|asc)$/i, "");
      B === l.name && (B += ".dec"), A(L, B, true), n(2, i = `Success! ${B} downloaded.`), n(3, a = "success");
    } catch (N) {
      n(2, i = N.message), n(3, a = "error");
    } finally {
      n(1, s = false);
    }
  }
  return [r, s, i, a, o, f, l, h, _, C, I, S, $, F, [{ text: "Wikipedia", url: "https://en.wikipedia.org/wiki/Pretty_Good_Privacy" }, { text: "OpenPGP", url: "https://www.openpgp.org/about/" }, { text: "Geeks for Geeks", url: "https://www.geeksforgeeks.org/computer-networks/pgp-authentication-and-confidentiality/" }], () => {
    n(0, r = "encrypt"), n(2, i = "");
  }, () => {
    n(0, r = "decrypt"), n(2, i = "");
  }];
}
class VO extends xt {
  constructor(e) {
    super(), wt(this, e, GO, qO, At, {});
  }
}
function J5(t3, e, n) {
  const r = t3.slice();
  return r[16] = e[n], r[18] = n, r;
}
function Z5(t3, e, n) {
  const r = t3.slice();
  return r[13] = e[n], r;
}
function j5(t3, e, n) {
  const r = t3.slice();
  return r[13] = e[n], r;
}
function X5(t3) {
  let e, n, r;
  return { c() {
    e = H("button"), e.textContent = "\u2715", V(e, "class", "clear-btn svelte-111ac2q");
  }, m(s, i) {
    R(s, e, i), n || (r = Kt(e, "click", t3[9]), n = true);
  }, p: dt, d(s) {
    s && D(e), n = false, r();
  } };
}
function YO(t3) {
  let e, n = Mr(t3[0]), r = [];
  for (let s = 0; s < n.length; s += 1) r[s] = r8(J5(t3, n, s));
  return { c() {
    for (let s = 0; s < r.length; s += 1) r[s].c();
    e = Lt();
  }, m(s, i) {
    for (let a = 0; a < r.length; a += 1) r[a] && r[a].m(s, i);
    R(s, e, i);
  }, p(s, i) {
    if (i & 19) {
      n = Mr(s[0]);
      let a;
      for (a = 0; a < n.length; a += 1) {
        const o = J5(s, n, a);
        r[a] ? r[a].p(o, i) : (r[a] = r8(o), r[a].c(), r[a].m(e.parentNode, e));
      }
      for (; a < r.length; a += 1) r[a].d(1);
      r.length = n.length;
    }
  }, d(s) {
    s && D(e), jn(r, s);
  } };
}
function WO(t3) {
  let e;
  function n(i, a) {
    return i[3].length > 0 ? ZO : JO;
  }
  let r = n(t3), s = r(t3);
  return { c() {
    e = H("div"), s.c(), V(e, "class", "results-container");
  }, m(i, a) {
    R(i, e, a), s.m(e, null);
  }, p(i, a) {
    r === (r = n(i)) && s ? s.p(i, a) : (s.d(1), s = r(i), s && (s.c(), s.m(e, null)));
  }, d(i) {
    i && D(e), s.d();
  } };
}
function e8(t3) {
  let e, n = Mr(t3[16].items), r = [];
  for (let s = 0; s < n.length; s += 1) r[s] = t8(Z5(t3, n, s));
  return { c() {
    e = H("div");
    for (let s = 0; s < r.length; s += 1) r[s].c();
    V(e, "class", "dropdown-content svelte-111ac2q");
  }, m(s, i) {
    R(s, e, i);
    for (let a = 0; a < r.length; a += 1) r[a] && r[a].m(e, null);
  }, p(s, i) {
    if (i & 19) {
      n = Mr(s[16].items);
      let a;
      for (a = 0; a < n.length; a += 1) {
        const o = Z5(s, n, a);
        r[a] ? r[a].p(o, i) : (r[a] = t8(o), r[a].c(), r[a].m(e, null));
      }
      for (; a < r.length; a += 1) r[a].d(1);
      r.length = n.length;
    }
  }, d(s) {
    s && D(e), jn(r, s);
  } };
}
function t8(t3) {
  let e, n = t3[13].name + "", r, s, i, a;
  function o() {
    return t3[12](t3[13]);
  }
  return { c() {
    e = H("button"), r = we(n), s = z(), V(e, "class", "tool-btn svelte-111ac2q"), Zt(e, "active", t3[1] === t3[13]);
  }, m(f, c) {
    R(f, e, c), q(e, r), q(e, s), i || (a = Kt(e, "click", o), i = true);
  }, p(f, c) {
    t3 = f, c & 1 && n !== (n = t3[13].name + "") && Ze(r, n), c & 3 && Zt(e, "active", t3[1] === t3[13]);
  }, d(f) {
    f && D(e), i = false, a();
  } };
}
function r8(t3) {
  let e, n, r = t3[16].icon + "", s, i, a = t3[16].category + "", o, f, c, l, h, m, v, b;
  function A() {
    return t3[11](t3[18]);
  }
  let _ = t3[16].expanded && e8(t3);
  return { c() {
    e = H("button"), n = H("span"), s = we(r), i = z(), o = we(a), f = z(), c = H("span"), c.textContent = "\u25B6", l = z(), _ && _.c(), h = z(), m = H("div"), V(n, "class", "section-title"), V(c, "class", "arrow svelte-111ac2q"), Zt(c, "rotated", t3[16].expanded), V(e, "class", "section-header svelte-111ac2q"), V(m, "class", "divider svelte-111ac2q");
  }, m(C, I) {
    R(C, e, I), q(e, n), q(n, s), q(n, i), q(n, o), q(e, f), q(e, c), R(C, l, I), _ && _.m(C, I), R(C, h, I), R(C, m, I), v || (b = Kt(e, "click", A), v = true);
  }, p(C, I) {
    t3 = C, I & 1 && r !== (r = t3[16].icon + "") && Ze(s, r), I & 1 && a !== (a = t3[16].category + "") && Ze(o, a), I & 1 && Zt(c, "rotated", t3[16].expanded), t3[16].expanded ? _ ? _.p(t3, I) : (_ = e8(t3), _.c(), _.m(h.parentNode, h)) : _ && (_.d(1), _ = null);
  }, d(C) {
    C && (D(e), D(l), D(h), D(m)), _ && _.d(C), v = false, b();
  } };
}
function JO(t3) {
  let e, n, r, s;
  return { c() {
    e = H("div"), n = we('No tools found for "'), r = we(t3[2]), s = we('"'), V(e, "class", "no-results svelte-111ac2q");
  }, m(i, a) {
    R(i, e, a), q(e, n), q(e, r), q(e, s);
  }, p(i, a) {
    a & 4 && Ze(r, i[2]);
  }, d(i) {
    i && D(e);
  } };
}
function ZO(t3) {
  let e, n, r, s = Mr(t3[3]), i = [];
  for (let a = 0; a < s.length; a += 1) i[a] = n8(j5(t3, s, a));
  return { c() {
    e = H("div"), e.textContent = "Search Results", n = z(), r = H("div");
    for (let a = 0; a < i.length; a += 1) i[a].c();
    V(e, "class", "section-header svelte-111ac2q"), St(e, "cursor", "default"), V(r, "class", "dropdown-content svelte-111ac2q"), St(r, "display", "flex");
  }, m(a, o) {
    R(a, e, o), R(a, n, o), R(a, r, o);
    for (let f = 0; f < i.length; f += 1) i[f] && i[f].m(r, null);
  }, p(a, o) {
    if (o & 42) {
      s = Mr(a[3]);
      let f;
      for (f = 0; f < s.length; f += 1) {
        const c = j5(a, s, f);
        i[f] ? i[f].p(c, o) : (i[f] = n8(c), i[f].c(), i[f].m(r, null));
      }
      for (; f < i.length; f += 1) i[f].d(1);
      i.length = s.length;
    }
  }, d(a) {
    a && (D(e), D(n), D(r)), jn(i, a);
  } };
}
function n8(t3) {
  let e, n = t3[13].name + "", r, s, i, a;
  function o() {
    return t3[10](t3[13]);
  }
  return { c() {
    e = H("button"), r = we(n), s = z(), V(e, "class", "tool-btn svelte-111ac2q"), Zt(e, "active", t3[1] === t3[13]);
  }, m(f, c) {
    R(f, e, c), q(e, r), q(e, s), i || (a = Kt(e, "click", o), i = true);
  }, p(f, c) {
    t3 = f, c & 8 && n !== (n = t3[13].name + "") && Ze(r, n), c & 10 && Zt(e, "active", t3[1] === t3[13]);
  }, d(f) {
    f && D(e), i = false, a();
  } };
}
function jO(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _ = t3[2] && X5(t3);
  function C($, F) {
    return F & 4 && (v = null), v == null && (v = $[2].trim() !== ""), v ? WO : YO;
  }
  let I = C(t3, -1), S = I(t3);
  return { c() {
    e = H("nav"), n = H("button"), n.innerHTML = '<h2 class="svelte-111ac2q">Cryptology&#39;s Playground</h2>', r = z(), s = H("button"), s.textContent = ">_", i = z(), a = H("div"), o = H("div"), f = H("span"), f.textContent = "\u{1F50D}", c = z(), l = H("input"), h = z(), _ && _.c(), m = z(), S.c(), V(n, "class", "home-btn svelte-111ac2q"), V(s, "class", "terminal-btn svelte-111ac2q"), V(s, "title", "Open Terminal"), V(f, "class", "search-icon svelte-111ac2q"), V(l, "type", "text"), V(l, "placeholder", "Search for a tool..."), V(l, "class", "svelte-111ac2q"), V(o, "class", "search-box svelte-111ac2q"), V(a, "class", "search-wrapper svelte-111ac2q"), V(e, "class", "sidebar svelte-111ac2q");
  }, m($, F) {
    R($, e, F), q(e, n), q(e, r), q(e, s), q(e, i), q(e, a), q(a, o), q(o, f), q(o, c), q(o, l), yr(l, t3[2]), q(o, h), _ && _.m(o, null), q(e, m), S.m(e, null), b || (A = [Kt(n, "click", t3[6]), Kt(s, "click", t3[7]), Kt(l, "input", t3[8])], b = true);
  }, p($, [F]) {
    F & 4 && l.value !== $[2] && yr(l, $[2]), $[2] ? _ ? _.p($, F) : (_ = X5($), _.c(), _.m(o, null)) : _ && (_.d(1), _ = null), I === (I = C($, F)) && S ? S.p($, F) : (S.d(1), S = I($), S && (S.c(), S.m(e, null)));
  }, i: dt, o: dt, d($) {
    $ && D(e), _ && _.d(), S.d(), b = false, Mn(A);
  } };
}
function XO(t3, e, n) {
  let { menuStructure: r = [] } = e, { activeTool: s = null } = e;
  const i = Vh();
  let a = "", o = [];
  function f(_) {
    i("select", _);
  }
  const c = () => i("home"), l = () => i("openTerminal");
  function h() {
    a = this.value, n(2, a);
  }
  const m = () => n(2, a = ""), v = (_) => f(_), b = (_) => i("toggle", _), A = (_) => i("select", _);
  return t3.$$set = (_) => {
    "menuStructure" in _ && n(0, r = _.menuStructure), "activeTool" in _ && n(1, s = _.activeTool);
  }, t3.$$.update = () => {
    if (t3.$$.dirty & 5) {
      const _ = a.toLowerCase().trim();
      _ === "" ? n(3, o = []) : n(3, o = r.flatMap((C) => C.items.filter((I) => I.name.toLowerCase().includes(_))));
    }
  }, [r, s, a, o, i, f, c, l, h, m, v, b, A];
}
class eQ extends xt {
  constructor(e) {
    super(), wt(this, e, XO, jO, At, { menuStructure: 0, activeTool: 1 });
  }
}
function tQ(t3) {
  let e;
  return { c() {
    e = H("div"), e.innerHTML = `<div class="header-section svelte-iq0qf9"><h1 class="svelte-iq0qf9">Welcome to Cryptology&#39;s Playground</h1></div> <div class="content-grid svelte-iq0qf9"><div class="info-card svelte-iq0qf9"><h3 class="svelte-iq0qf9">About this project</h3> <p class="svelte-iq0qf9">This web application gives the opportunity to Cryptography enthusiasts to explore and learn
        (in a friendly environment) various concepts about Cryptanalysis and Cryptography in general.</p> <p class="svelte-iq0qf9">You can test various tools used in cryptography and learn their purpose in the world of security and hiding information.
        From simple ciphers to key generation and secure file transfer, you can dive into how cryptography tools operate.</p> <p class="svelte-iq0qf9">Each section is designed to be educational. Each tool will eventually provide information and instructions 
        about how to use the specific tool.</p>
      
        Tinker, test, and learn in a sandbox environment with no risk.
        Designed with educational clarity and practical use in mind.
        All tools are modular and instant.
        Explore the left-hand menu to get started:
        <ul><li>Classical &amp; Modern Ciphers</li> <li>Hashing &amp; Encoding Algorithms</li> <li>Asymmetric &amp; Symmetric Encryption</li> <li>File Security Operations</li> <li>Entropy Testing &amp; Key Generation</li></ul> <div class="warning-box svelte-iq0qf9"><strong>Note:</strong> Do not use sensitive information or real secrets in any of the tools provided.
        You are here to learn and explore. Use the tools carefully and under consideration.</div></div> <div class="info-card svelte-iq0qf9"><h3 class="svelte-iq0qf9">A few words</h3> <p class="svelte-iq0qf9">The terms cryptography and cryptanalysis are related but not identical. 
        <b>Cryptology</b> is the broader scientific study of secret communication, 
        which includes both cryptography and cryptanalysis. Both fields rely heavily on mathematics (number theory, algebra, probability).</p> <div class="definition svelte-iq0qf9"><h4 class="svelte-iq0qf9">Cryptography</h4> <p class="svelte-iq0qf9">The art and science of creating secure communication systems that prevent unauthorized access to information.
          It mainly deals with designing encryption algorithms and protocols to protect data, ensure integrity, and authenticate users/messages.</p></div> <div class="definition svelte-iq0qf9"><h4 class="svelte-iq0qf9">Cryptanalysis</h4> <p class="svelte-iq0qf9">The science of analyzing (or breaking) cryptographic systems to find weaknesses. 
          Examples include: bypassing encryption without the key, key recovery, plaintext recovery, identifying flaws,
          and various attacks like brute force or side-channel attacks.</p></div> <p class="analogy svelte-iq0qf9">&quot;Cryptography is like building a strong, secure lock, while Cryptanalysis is like being a lockpicker trying to open it without the key.&quot;</p></div></div>`, V(e, "class", "home-container svelte-iq0qf9");
  }, m(n, r) {
    R(n, e, r);
  }, p: dt, i: dt, o: dt, d(n) {
    n && D(e);
  } };
}
class rQ extends xt {
  constructor(e) {
    super(), wt(this, e, null, tQ, At, {});
  }
}
const nQ = (t3) => {
  if (!t3.length) return { type: "error", text: "Usage: base64 [text] OR base64 -d [encoded_text]" };
  const e = t3[0], n = t3.slice(1).join(" ");
  if (e === "-d" || e === "--decode") try {
    return { type: "response", text: atob(n || t3[1]) };
  } catch {
    return { type: "error", text: "Invalid Base64 string." };
  }
  else try {
    const r = t3.join(" ");
    return { type: "response", text: btoa(r) };
  } catch {
    return { type: "error", text: "Encoding error." };
  }
}, iQ = (t3, e = {}) => {
  if (t3[0] === "--help") return { type: "info", text: `Usage: xxd [filename]
        
    Description:
      Creates a hexdump of a binary or text file.
        
    Options:
      filename    The name of the file (must be loaded via drag & drop).` };
  if (!t3.length) return { type: "error", text: "Usage: xxd [filename]" };
  const n = t3[0], r = e[n];
  if (!r) return { type: "error", text: `xxd: ${n}: No such file.` };
  let s = [];
  for (let i = 0; i < r.length; i += 16) {
    const a = r.slice(i, i + 16), o = i.toString(16).padStart(8, "0");
    let f = "";
    for (let l = 0; l < 16; l++) l < a.length ? f += a[l].toString(16).padStart(2, "0") : f += "  ", l % 2 === 1 && (f += " ");
    let c = "";
    for (let l = 0; l < a.length; l++) {
      const h = a[l];
      c += h >= 32 && h <= 126 ? String.fromCharCode(h) : ".";
    }
    s.push(`${o}: ${f}  ${c}`);
  }
  return { type: "code", text: s.join(`
`) };
}, sQ = (t3, e = {}) => {
  if (t3[0] === "--help") return { type: "info", text: `Usage: strings [options] [filename]

Description:
  Print the sequences of printable characters in files.
  Useful for finding hidden text in binary files.

Options:
  -n [number]   Specify the minimum string length (default: 4).
  filename      The file to analyze.` };
  if (!t3.length) return { type: "error", text: "Usage: strings [filename] (optional: -n [min_length])" };
  let n = t3[0], r = 4;
  t3[0] === "-n" && t3.length >= 3 && (r = parseInt(t3[1], 10) || 4, n = t3[2]);
  const s = e[n];
  if (!s) return { type: "error", text: `strings: '${n}': No such file` };
  let i = [], a = "";
  for (let o = 0; o < s.length; o++) {
    const f = s[o];
    f >= 32 && f <= 126 || f === 9 ? a += String.fromCharCode(f) : (a.length >= r && i.push(a), a = "");
  }
  return a.length >= r && i.push(a), i.length === 0 ? { type: "info", text: "(No strings found)" } : { type: "code", text: i.join(`
`) };
}, aQ = (t3, e, n) => {
  if (t3[0] === "--help") return { type: "info", text: `Usage: grep [pattern] [filename?]

Description:
  Searches for a pattern in a file or input text (stdin).
  Can be used with pipes (|).

Examples:
  grep "password" myfile.txt
  strings image.png | grep "flag{"` };
  if (!t3.length) return { type: "error", text: "Usage: grep [pattern] [file?]" };
  let r = t3[0];
  (r.startsWith('"') && r.endsWith('"') || r.startsWith("'") && r.endsWith("'")) && (r = r.slice(1, -1));
  let s = "";
  if (n) s = n;
  else if (t3[1]) {
    const o = t3[1];
    if (e[o]) e[o] instanceof Uint8Array ? s = new TextDecoder().decode(e[o]) : s = e[o];
    else return { type: "error", text: `grep: ${o}: No such file` };
  } else return { type: "error", text: 'Usage: command | grep "pattern" OR grep "pattern" filename' };
  const a = s.split(`
`).filter((o) => o.includes(r));
  return a.length === 0 ? null : { type: "code", text: a.join(`
`) };
}, oQ = (t3, e = {}) => {
  if (t3[0] === "--help") return { type: "info", text: `Usage: ls

Description:
  Lists all files currently loaded in the virtual memory (dragged & dropped).` };
  const n = Object.keys(e);
  return n.length === 0 ? { type: "info", text: "(No files loaded. Drag & drop files here)" } : { type: "response", text: n.join(`
`) };
}, fQ = () => ({ type: "response", text: `
  *Drag & Drop utility: You can drag and drop any file you want in the terminal.
  The files are stored in the virtual memory of the browser and you can use any
  command you want to process them, like xxd [filename], objdump [filename], etc.
  Once you refresh the page or quit the webapp, all the files are vanished.

  Note: Type [command name] --help for more information on a command.

            AVAILABLE COMMANDS 

  whoami              : Username of the current user
  date                : View current date - mm/dd/yy, h/m/s
  ls                  : List current uploaded files
  clear               : Clear screen
  base64 [txt]        : Encode Base64 string
  base64 -d [txt]     : Decode base64 string
  xxd [filename]      : Hexdump
  strings [filename]  : See text inside a binary or data file
  grep [filename]     : Search for specific words, phrases or patterns inside files
  
  ` }), i8 = { base64: nQ, xxd: iQ, help: fQ, whoami: () => ({ type: "success", text: "root@crypto-playground" }), date: () => ({ type: "response", text: (/* @__PURE__ */ new Date()).toLocaleString() }), strings: sQ, grep: aQ, ls: oQ };
function s8(t3, e, n) {
  const r = t3.slice();
  return r[23] = e[n], r;
}
function lQ(t3) {
  let e, n = t3[23].text + "", r, s;
  return { c() {
    e = H("div"), r = we(n), V(e, "class", s = "line " + t3[23].type + " svelte-jegbwc");
  }, m(i, a) {
    R(i, e, a), q(e, r);
  }, p(i, a) {
    a & 4 && n !== (n = i[23].text + "") && Ze(r, n), a & 4 && s !== (s = "line " + i[23].type + " svelte-jegbwc") && V(e, "class", s);
  }, d(i) {
    i && D(e);
  } };
}
function uQ(t3) {
  let e, n = t3[23].text + "", r;
  return { c() {
    e = H("div"), r = we(n), V(e, "class", "line code svelte-jegbwc");
  }, m(s, i) {
    R(s, e, i), q(e, r);
  }, p(s, i) {
    i & 4 && n !== (n = s[23].text + "") && Ze(r, n);
  }, d(s) {
    s && D(e);
  } };
}
function cQ(t3) {
  let e;
  return { c() {
    e = H("br");
  }, m(n, r) {
    R(n, e, r);
  }, p: dt, d(n) {
    n && D(e);
  } };
}
function hQ(t3) {
  let e, n, r, s, i, a, o = t3[23].text + "", f;
  return { c() {
    e = H("div"), n = H("span"), n.textContent = "\u279C", r = z(), s = H("span"), s.textContent = "~", i = z(), a = H("span"), f = we(o), V(n, "class", "prompt svelte-jegbwc"), V(s, "class", "path svelte-jegbwc"), V(a, "class", "cmd svelte-jegbwc"), St(a, "white-space", "pre-wrap"), V(e, "class", "line user svelte-jegbwc");
  }, m(c, l) {
    R(c, e, l), q(e, n), q(e, r), q(e, s), q(e, i), q(e, a), q(a, f);
  }, p(c, l) {
    l & 4 && o !== (o = c[23].text + "") && Ze(f, o);
  }, d(c) {
    c && D(e);
  } };
}
function a8(t3) {
  let e;
  function n(i, a) {
    return i[23].type === "user" ? hQ : i[23].type === "br" ? cQ : i[23].type === "code" ? uQ : lQ;
  }
  let r = n(t3), s = r(t3);
  return { c() {
    s.c(), e = Lt();
  }, m(i, a) {
    s.m(i, a), R(i, e, a);
  }, p(i, a) {
    r === (r = n(i)) && s ? s.p(i, a) : (s.d(1), s = r(i), s && (s.c(), s.m(e.parentNode, e)));
  }, d(i) {
    i && D(e), s.d(i);
  } };
}
function dQ(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U = Mr(t3[2]), Q = [];
  for (let P = 0; P < U.length; P += 1) Q[P] = a8(s8(t3, U, P));
  return { c() {
    e = H("div"), n = H("div"), r = H("div"), s = H("span"), i = z(), a = H("span"), o = z(), f = H("span"), c = z(), l = H("div"), l.textContent = "user@crypto-playground:~", h = z(), m = H("div");
    for (let P = 0; P < Q.length; P += 1) Q[P].c();
    v = z(), b = H("div"), A = H("span"), A.textContent = "\u279C", _ = z(), C = H("span"), C.textContent = "~", I = z(), S = H("textarea"), V(s, "class", "dot red svelte-jegbwc"), V(s, "title", "Close"), V(a, "class", "dot yellow svelte-jegbwc"), V(f, "class", "dot green svelte-jegbwc"), V(r, "class", "buttons svelte-jegbwc"), V(l, "class", "title svelte-jegbwc"), V(n, "class", "terminal-header svelte-jegbwc"), V(A, "class", "prompt svelte-jegbwc"), V(C, "class", "path svelte-jegbwc"), V(S, "rows", "1"), V(S, "spellcheck", "false"), V(S, "autocomplete", "off"), V(S, "class", "svelte-jegbwc"), V(b, "class", "input-line svelte-jegbwc"), V(m, "class", "terminal-body svelte-jegbwc"), V(e, "class", "terminal-wrapper svelte-jegbwc"), Zt(e, "dragging", t3[4]);
  }, m(P, N) {
    R(P, e, N), q(e, n), q(n, r), q(r, s), q(r, i), q(r, a), q(r, o), q(r, f), q(n, c), q(n, l), q(e, h), q(e, m);
    for (let L = 0; L < Q.length; L += 1) Q[L] && Q[L].m(m, null);
    q(m, v), q(m, b), q(b, A), q(b, _), q(b, C), q(b, I), q(b, S), t3[13](S), yr(S, t3[3]), t3[15](m), $ || (F = [Kt(s, "click", t3[12]), Kt(S, "input", t3[14]), Kt(S, "keydown", t3[10]), Kt(S, "input", t3[6]), Kt(m, "click", t3[11]), Kt(e, "dragover", t3[7]), Kt(e, "dragleave", t3[8]), Kt(e, "drop", t3[9])], $ = true);
  }, p(P, [N]) {
    if (N & 4) {
      U = Mr(P[2]);
      let L;
      for (L = 0; L < U.length; L += 1) {
        const B = s8(P, U, L);
        Q[L] ? Q[L].p(B, N) : (Q[L] = a8(B), Q[L].c(), Q[L].m(m, v));
      }
      for (; L < Q.length; L += 1) Q[L].d(1);
      Q.length = U.length;
    }
    N & 8 && yr(S, P[3]), N & 16 && Zt(e, "dragging", P[4]);
  }, i: dt, o: dt, d(P) {
    P && D(e), jn(Q, P), t3[13](null), t3[15](null), $ = false, Mn(F);
  } };
}
function pQ(t3, e, n) {
  const r = Vh();
  let s, i, a = {}, o = [{ type: "info", text: "Cryptology Playground Terminal [Version 1.0.0]" }, { type: "info", text: "(c) 2025 Cryptology Inc. All rights reserved." }, { type: "info", text: "Type `help` to view the available commands" }, { type: "br", text: "" }], f = "", c = [], l = -1, h = false;
  const m = 50 * 1024 * 1024;
  qb(() => {
    s.focus(), v();
  });
  async function v() {
    await dc(), i && n(1, i.scrollTop = i.scrollHeight, i);
  }
  function b() {
    s && (n(0, s.style.height = "auto", s), n(0, s.style.height = s.scrollHeight + "px", s));
  }
  function A(L) {
    L.preventDefault(), n(4, h = true);
  }
  function _(L) {
    n(4, h = false);
  }
  async function C(L) {
    if (L.preventDefault(), n(4, h = false), L.dataTransfer.items) {
      for (let B = 0; B < L.dataTransfer.items.length; B++) if (L.dataTransfer.items[B].kind === "file") {
        const u = L.dataTransfer.items[B].getAsFile();
        if (u.size > m) {
          n(2, o = [...o, { type: "error", text: `[-] Error: "${u.name}" is too large (${(u.size / 1024 / 1024).toFixed(2)} MB). Limit is 50MB.` }]);
          continue;
        }
        try {
          const p = await u.arrayBuffer(), d = new Uint8Array(p);
          a[u.name] = d, n(2, o = [...o, { type: "success", text: `[+] Loaded file: ${u.name} (${u.size} bytes)` }]);
        } catch {
          n(2, o = [...o, { type: "error", text: `[-] Failed to load ${u.name}` }]);
        }
      }
    }
    v();
  }
  function I(L) {
    L.preventDefault();
    const B = f.lastIndexOf(" "), u = B === -1 ? f : f.substring(B + 1);
    if (!u) return;
    const d = Object.keys(a).filter((y) => y.startsWith(u));
    if (d.length === 1) {
      const y = d[0];
      B === -1 ? n(3, f = y) : n(3, f = f.substring(0, B + 1) + y);
    } else d.length > 1;
  }
  async function S() {
    const L = f.trim();
    if (!L) {
      n(3, f = ""), s && n(0, s.style.height = "auto", s);
      return;
    }
    n(2, o = [...o, { type: "user", text: L }]), c.push(L), l = c.length;
    const B = L.split("|");
    let u = null, p = null, d = false;
    for (let y = 0; y < B.length; y++) {
      const E = B[y].trim().match(/(?:[^\s"]+|"[^"]*")+/g) || [];
      if (E.length === 0) continue;
      const M = E[0].toLowerCase(), x = E.slice(1);
      if (y === 0) {
        if (M === "clear") {
          n(2, o = []), n(3, f = ""), s && n(0, s.style.height = "auto", s);
          return;
        }
        if (M === "exit") {
          r("close");
          return;
        }
      }
      if (i8[M]) {
        const g = i8[M](x, a, u);
        if (g && g.type === "error") {
          n(2, o = [...o, g]), d = true;
          break;
        }
        g && g.text ? (u = g.text, p = g) : (u = "", p = null);
      } else {
        n(2, o = [...o, { type: "error", text: `Command not found: ${M}` }]), d = true;
        break;
      }
    }
    !d && p && n(2, o = [...o, p]), n(3, f = ""), s && n(0, s.style.height = "auto", s), v();
  }
  function $(L) {
    L.key === "Enter" ? L.shiftKey ? dc().then(b) : (L.preventDefault(), S()) : L.key === "Tab" ? I(L) : L.key === "ArrowUp" ? l > 0 && (L.preventDefault(), l--, n(3, f = c[l]), dc().then(b)) : L.key === "ArrowDown" && (l < c.length - 1 ? (L.preventDefault(), l++, n(3, f = c[l]), dc().then(b)) : (l = c.length, n(3, f = ""), dc().then(b)));
  }
  function F() {
    s.focus();
  }
  const U = () => r("close");
  function Q(L) {
    Qe[L ? "unshift" : "push"](() => {
      s = L, n(0, s);
    });
  }
  function P() {
    f = this.value, n(3, f);
  }
  function N(L) {
    Qe[L ? "unshift" : "push"](() => {
      i = L, n(1, i);
    });
  }
  return [s, i, o, f, h, r, b, A, _, C, $, F, U, Q, P, N];
}
class gQ extends xt {
  constructor(e) {
    super(), wt(this, e, pQ, dQ, At, {});
  }
}
function o8(t3) {
  let e, n;
  return { c() {
    e = H("label"), n = we(t3[2]), V(e, "for", "input-field"), V(e, "class", "svelte-1i00nte");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 4 && Ze(n, r[2]);
  }, d(r) {
    r && D(e);
  } };
}
function mQ(t3) {
  let e, n, r;
  return { c() {
    e = H("input"), V(e, "id", "input-field"), V(e, "type", "text"), V(e, "placeholder", t3[3]), e.readOnly = t3[5], V(e, "class", "svelte-1i00nte"), Zt(e, "has-action", t3[7] || t3[8]), Zt(e, "has-double-action", t3[7] && t3[8]);
  }, m(s, i) {
    R(s, e, i), yr(e, t3[0]), n || (r = [Kt(e, "input", t3[30]), Kt(e, "input", t3[23]), Kt(e, "change", t3[24])], n = true);
  }, p(s, i) {
    i & 8 && V(e, "placeholder", s[3]), i & 32 && (e.readOnly = s[5]), i & 1 && e.value !== s[0] && yr(e, s[0]), i & 384 && Zt(e, "has-action", s[7] || s[8]), i & 384 && Zt(e, "has-double-action", s[7] && s[8]);
  }, d(s) {
    s && D(e), n = false, Mn(r);
  } };
}
function vQ(t3) {
  let e, n, r;
  return { c() {
    e = H("input"), V(e, "id", "input-field"), V(e, "type", "email"), V(e, "placeholder", t3[3]), e.readOnly = t3[5], V(e, "class", "svelte-1i00nte"), Zt(e, "has-action", t3[7] || t3[8]), Zt(e, "has-double-action", t3[7] && t3[8]);
  }, m(s, i) {
    R(s, e, i), yr(e, t3[0]), n || (r = [Kt(e, "input", t3[29]), Kt(e, "input", t3[21]), Kt(e, "change", t3[22])], n = true);
  }, p(s, i) {
    i & 8 && V(e, "placeholder", s[3]), i & 32 && (e.readOnly = s[5]), i & 1 && e.value !== s[0] && yr(e, s[0]), i & 384 && Zt(e, "has-action", s[7] || s[8]), i & 384 && Zt(e, "has-double-action", s[7] && s[8]);
  }, d(s) {
    s && D(e), n = false, Mn(r);
  } };
}
function yQ(t3) {
  let e, n, r;
  return { c() {
    e = H("input"), V(e, "id", "input-field"), V(e, "type", "number"), V(e, "placeholder", t3[3]), e.readOnly = t3[5], V(e, "class", "svelte-1i00nte"), Zt(e, "has-action", t3[7] || t3[8]), Zt(e, "has-double-action", t3[7] && t3[8]);
  }, m(s, i) {
    R(s, e, i), yr(e, t3[0]), n || (r = [Kt(e, "input", t3[28]), Kt(e, "input", t3[19]), Kt(e, "change", t3[20])], n = true);
  }, p(s, i) {
    i & 8 && V(e, "placeholder", s[3]), i & 32 && (e.readOnly = s[5]), i & 1 && Nn(e.value) !== s[0] && yr(e, s[0]), i & 384 && Zt(e, "has-action", s[7] || s[8]), i & 384 && Zt(e, "has-double-action", s[7] && s[8]);
  }, d(s) {
    s && D(e), n = false, Mn(r);
  } };
}
function bQ(t3) {
  let e, n, r;
  return { c() {
    e = H("input"), V(e, "id", "input-field"), V(e, "type", "password"), V(e, "placeholder", t3[3]), e.readOnly = t3[5], V(e, "class", "svelte-1i00nte"), Zt(e, "has-action", t3[7] || t3[8]), Zt(e, "has-double-action", t3[7] && t3[8]);
  }, m(s, i) {
    R(s, e, i), yr(e, t3[0]), n || (r = [Kt(e, "input", t3[27]), Kt(e, "input", t3[17]), Kt(e, "change", t3[18])], n = true);
  }, p(s, i) {
    i & 8 && V(e, "placeholder", s[3]), i & 32 && (e.readOnly = s[5]), i & 1 && e.value !== s[0] && yr(e, s[0]), i & 384 && Zt(e, "has-action", s[7] || s[8]), i & 384 && Zt(e, "has-double-action", s[7] && s[8]);
  }, d(s) {
    s && D(e), n = false, Mn(r);
  } };
}
function AQ(t3) {
  let e, n, r;
  return { c() {
    e = H("textarea"), V(e, "id", "input-field"), V(e, "placeholder", t3[3]), e.readOnly = t3[5], V(e, "rows", "1"), V(e, "class", "svelte-1i00nte"), Zt(e, "has-action", t3[7] || t3[8]), Zt(e, "has-double-action", t3[7] && t3[8]);
  }, m(s, i) {
    R(s, e, i), yr(e, t3[0]), n || (r = [Kt(e, "input", t3[26]), Kt(e, "input", t3[15]), Kt(e, "change", t3[16])], n = true);
  }, p(s, i) {
    i & 8 && V(e, "placeholder", s[3]), i & 32 && (e.readOnly = s[5]), i & 1 && yr(e, s[0]), i & 384 && Zt(e, "has-action", s[7] || s[8]), i & 384 && Zt(e, "has-double-action", s[7] && s[8]);
  }, d(s) {
    s && D(e), n = false, Mn(r);
  } };
}
function wQ(t3) {
  let e, n, r;
  return { c() {
    e = H("input"), V(e, "id", "input-field"), V(e, "type", "file"), V(e, "class", "svelte-1i00nte");
  }, m(s, i) {
    R(s, e, i), n || (r = [Kt(e, "change", t3[25]), Kt(e, "change", t3[14])], n = true);
  }, p: dt, d(s) {
    s && D(e), n = false, Mn(r);
  } };
}
function f8(t3) {
  let e, n, r = t3[7] && l8(t3), s = t3[8] && u8(t3);
  return { c() {
    e = H("div"), r && r.c(), n = z(), s && s.c(), V(e, "class", "actions svelte-1i00nte");
  }, m(i, a) {
    R(i, e, a), r && r.m(e, null), q(e, n), s && s.m(e, null);
  }, p(i, a) {
    i[7] ? r ? r.p(i, a) : (r = l8(i), r.c(), r.m(e, n)) : r && (r.d(1), r = null), i[8] ? s ? s.p(i, a) : (s = u8(i), s.c(), s.m(e, null)) : s && (s.d(1), s = null);
  }, d(i) {
    i && D(e), r && r.d(), s && s.d();
  } };
}
function l8(t3) {
  let e, n, r;
  function s(o, f) {
    return o[9] ? _Q : xQ;
  }
  let i = s(t3), a = i(t3);
  return { c() {
    e = H("button"), a.c(), V(e, "class", "action-btn svelte-1i00nte"), V(e, "title", "Copy to clipboard"), V(e, "type", "button"), Zt(e, "success", t3[9]);
  }, m(o, f) {
    R(o, e, f), a.m(e, null), n || (r = Kt(e, "click", t3[11]), n = true);
  }, p(o, f) {
    i !== (i = s(o)) && (a.d(1), a = i(o), a && (a.c(), a.m(e, null))), f & 512 && Zt(e, "success", o[9]);
  }, d(o) {
    o && D(e), a.d(), n = false, r();
  } };
}
function xQ(t3) {
  let e, n, r;
  return { c() {
    e = Nr("svg"), n = Nr("rect"), r = Nr("path"), V(n, "x", "9"), V(n, "y", "9"), V(n, "width", "13"), V(n, "height", "13"), V(n, "rx", "2"), V(n, "ry", "2"), V(r, "d", "M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"), V(e, "viewBox", "0 0 24 24"), V(e, "width", "14"), V(e, "height", "14"), V(e, "fill", "none"), V(e, "stroke", "currentColor"), V(e, "stroke-width", "2");
  }, m(s, i) {
    R(s, e, i), q(e, n), q(e, r);
  }, d(s) {
    s && D(e);
  } };
}
function _Q(t3) {
  let e;
  return { c() {
    e = H("span"), e.textContent = "\u2713";
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function u8(t3) {
  let e, n, r;
  function s(o, f) {
    return o[10] ? BQ : EQ;
  }
  let i = s(t3), a = i(t3);
  return { c() {
    e = H("button"), a.c(), V(e, "class", "action-btn svelte-1i00nte"), V(e, "title", "Download as file"), V(e, "type", "button"), Zt(e, "success", t3[10]);
  }, m(o, f) {
    R(o, e, f), a.m(e, null), n || (r = Kt(e, "click", t3[12]), n = true);
  }, p(o, f) {
    i !== (i = s(o)) && (a.d(1), a = i(o), a && (a.c(), a.m(e, null))), f & 1024 && Zt(e, "success", o[10]);
  }, d(o) {
    o && D(e), a.d(), n = false, r();
  } };
}
function EQ(t3) {
  let e, n, r, s;
  return { c() {
    e = Nr("svg"), n = Nr("path"), r = Nr("polyline"), s = Nr("line"), V(n, "d", "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"), V(r, "points", "7 10 12 15 17 10"), V(s, "x1", "12"), V(s, "y1", "15"), V(s, "x2", "12"), V(s, "y2", "3"), V(e, "viewBox", "0 0 24 24"), V(e, "width", "14"), V(e, "height", "14"), V(e, "fill", "none"), V(e, "stroke", "currentColor"), V(e, "stroke-width", "2");
  }, m(i, a) {
    R(i, e, a), q(e, n), q(e, r), q(e, s);
  }, d(i) {
    i && D(e);
  } };
}
function BQ(t3) {
  let e;
  return { c() {
    e = H("span"), e.textContent = "\u2713";
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function CQ(t3) {
  let e, n, r, s, i = t3[2] && o8(t3);
  function a(l, h) {
    return l[4] === "file" ? wQ : l[6] ? AQ : l[4] === "password" ? bQ : l[4] === "number" ? yQ : l[4] === "email" ? vQ : mQ;
  }
  let o = a(t3), f = o(t3), c = (t3[7] || t3[8]) && t3[4] !== "file" && f8(t3);
  return { c() {
    e = H("div"), i && i.c(), n = z(), r = H("div"), f.c(), s = z(), c && c.c(), V(r, "class", "input-wrapper svelte-1i00nte"), V(e, "class", "input-group svelte-1i00nte");
  }, m(l, h) {
    R(l, e, h), i && i.m(e, null), q(e, n), q(e, r), f.m(r, null), q(r, s), c && c.m(r, null);
  }, p(l, [h]) {
    l[2] ? i ? i.p(l, h) : (i = o8(l), i.c(), i.m(e, n)) : i && (i.d(1), i = null), o === (o = a(l)) && f ? f.p(l, h) : (f.d(1), f = o(l), f && (f.c(), f.m(r, s))), (l[7] || l[8]) && l[4] !== "file" ? c ? c.p(l, h) : (c = f8(l), c.c(), c.m(r, null)) : c && (c.d(1), c = null);
  }, i: dt, o: dt, d(l) {
    l && D(e), i && i.d(), f.d(), c && c.d();
  } };
}
function kQ(t3, e, n) {
  let { label: r = "" } = e, { value: s = "" } = e, { files: i = null } = e, { placeholder: a = "" } = e, { type: o = "text" } = e, { readonly: f = false } = e, { expandable: c = false } = e, { withCopy: l = false } = e, { withDownload: h = false } = e, { downloadName: m = "output.txt" } = e, v = false, b = false;
  async function A() {
    if (s) try {
      await navigator.clipboard.writeText(s), n(9, v = true), setTimeout(() => n(9, v = false), 2e3);
    } catch (M) {
      console.error("Failed to copy!", M);
    }
  }
  function _() {
    if (s) try {
      const M = new Blob([s], { type: "text/plain" }), x = URL.createObjectURL(M), g = document.createElement("a");
      g.href = x, g.download = m, document.body.appendChild(g), g.click(), document.body.removeChild(g), URL.revokeObjectURL(x), n(10, b = true), setTimeout(() => n(10, b = false), 2e3);
    } catch (M) {
      console.error("Failed to download!", M);
    }
  }
  function C(M) {
    Ds.call(this, t3, M);
  }
  function I(M) {
    Ds.call(this, t3, M);
  }
  function S(M) {
    Ds.call(this, t3, M);
  }
  function $(M) {
    Ds.call(this, t3, M);
  }
  function F(M) {
    Ds.call(this, t3, M);
  }
  function U(M) {
    Ds.call(this, t3, M);
  }
  function Q(M) {
    Ds.call(this, t3, M);
  }
  function P(M) {
    Ds.call(this, t3, M);
  }
  function N(M) {
    Ds.call(this, t3, M);
  }
  function L(M) {
    Ds.call(this, t3, M);
  }
  function B(M) {
    Ds.call(this, t3, M);
  }
  function u() {
    i = this.files, n(1, i);
  }
  function p() {
    s = this.value, n(0, s);
  }
  function d() {
    s = this.value, n(0, s);
  }
  function y() {
    s = Nn(this.value), n(0, s);
  }
  function w() {
    s = this.value, n(0, s);
  }
  function E() {
    s = this.value, n(0, s);
  }
  return t3.$$set = (M) => {
    "label" in M && n(2, r = M.label), "value" in M && n(0, s = M.value), "files" in M && n(1, i = M.files), "placeholder" in M && n(3, a = M.placeholder), "type" in M && n(4, o = M.type), "readonly" in M && n(5, f = M.readonly), "expandable" in M && n(6, c = M.expandable), "withCopy" in M && n(7, l = M.withCopy), "withDownload" in M && n(8, h = M.withDownload), "downloadName" in M && n(13, m = M.downloadName);
  }, [s, i, r, a, o, f, c, l, h, v, b, A, _, m, C, I, S, $, F, U, Q, P, N, L, B, u, p, d, y, w, E];
}
class et extends xt {
  constructor(e) {
    super(), wt(this, e, kQ, CQ, At, { label: 2, value: 0, files: 1, placeholder: 3, type: 4, readonly: 5, expandable: 6, withCopy: 7, withDownload: 8, downloadName: 13 });
  }
}
function c8(t3, e, n) {
  const r = t3.slice();
  return r[6] = e[n], r;
}
function h8(t3) {
  let e, n;
  return { c() {
    e = H("label"), n = we(t3[1]), V(e, "for", t3[3]), V(e, "class", "svelte-so55vi");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 2 && Ze(n, r[1]), s & 8 && V(e, "for", r[3]);
  }, d(r) {
    r && D(e);
  } };
}
function IQ(t3) {
  let e, n = t3[6] + "", r, s;
  return { c() {
    e = H("option"), r = we(n), e.__value = s = t3[6], yr(e, e.__value);
  }, m(i, a) {
    R(i, e, a), q(e, r);
  }, p(i, a) {
    a & 4 && n !== (n = i[6] + "") && Ze(r, n), a & 4 && s !== (s = i[6]) && (e.__value = s, yr(e, e.__value));
  }, d(i) {
    i && D(e);
  } };
}
function SQ(t3) {
  let e, n = t3[6].label + "", r, s;
  return { c() {
    e = H("option"), r = we(n), e.__value = s = t3[6].value, yr(e, e.__value);
  }, m(i, a) {
    R(i, e, a), q(e, r);
  }, p(i, a) {
    a & 4 && n !== (n = i[6].label + "") && Ze(r, n), a & 4 && s !== (s = i[6].value) && (e.__value = s, yr(e, e.__value));
  }, d(i) {
    i && D(e);
  } };
}
function d8(t3) {
  let e;
  function n(i, a) {
    return typeof i[6] == "object" && i[6] !== null ? SQ : IQ;
  }
  let r = n(t3), s = r(t3);
  return { c() {
    s.c(), e = Lt();
  }, m(i, a) {
    s.m(i, a), R(i, e, a);
  }, p(i, a) {
    r === (r = n(i)) && s ? s.p(i, a) : (s.d(1), s = r(i), s && (s.c(), s.m(e.parentNode, e)));
  }, d(i) {
    i && D(e), s.d(i);
  } };
}
function MQ(t3) {
  let e, n, r, s, i, a = t3[1] && h8(t3), o = Mr(t3[2]), f = [];
  for (let c = 0; c < o.length; c += 1) f[c] = d8(c8(t3, o, c));
  return { c() {
    e = H("div"), a && a.c(), n = z(), r = H("select");
    for (let c = 0; c < f.length; c += 1) f[c].c();
    V(r, "class", "svelte-so55vi"), t3[0] === void 0 && Xp(() => t3[5].call(r)), V(e, "class", "input-group svelte-so55vi");
  }, m(c, l) {
    R(c, e, l), a && a.m(e, null), q(e, n), q(e, r);
    for (let h = 0; h < f.length; h += 1) f[h] && f[h].m(r, null);
    i6(r, t3[0], true), s || (i = [Kt(r, "change", t3[5]), Kt(r, "change", t3[4])], s = true);
  }, p(c, [l]) {
    if (c[1] ? a ? a.p(c, l) : (a = h8(c), a.c(), a.m(e, n)) : a && (a.d(1), a = null), l & 4) {
      o = Mr(c[2]);
      let h;
      for (h = 0; h < o.length; h += 1) {
        const m = c8(c, o, h);
        f[h] ? f[h].p(m, l) : (f[h] = d8(m), f[h].c(), f[h].m(r, null));
      }
      for (; h < f.length; h += 1) f[h].d(1);
      f.length = o.length;
    }
    l & 5 && i6(r, c[0]);
  }, i: dt, o: dt, d(c) {
    c && D(e), a && a.d(), jn(f, c), s = false, Mn(i);
  } };
}
function $Q(t3, e, n) {
  let { label: r = "" } = e, { value: s = "" } = e, { options: i = [] } = e, { id: a = "select-" + Math.random().toString(36).slice(2) } = e;
  function o(c) {
    Ds.call(this, t3, c);
  }
  function f() {
    s = RP(this), n(0, s), n(2, i);
  }
  return t3.$$set = (c) => {
    "label" in c && n(1, r = c.label), "value" in c && n(0, s = c.value), "options" in c && n(2, i = c.options), "id" in c && n(3, a = c.id);
  }, [s, r, i, a, o, f];
}
class Ht extends xt {
  constructor(e) {
    super(), wt(this, e, $Q, MQ, At, { label: 1, value: 0, options: 2, id: 3 });
  }
}
var di = {}, Bg = {};
Bg.byteLength = RQ;
Bg.toByteArray = PQ;
Bg.fromByteArray = LQ;
var no = [], Js = [], TQ = typeof Uint8Array < "u" ? Uint8Array : Array, o2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var F0 = 0, DQ = o2.length; F0 < DQ; ++F0) no[F0] = o2[F0], Js[o2.charCodeAt(F0)] = F0;
Js[45] = 62;
Js[95] = 63;
function eS(t3) {
  var e = t3.length;
  if (e % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
  var n = t3.indexOf("=");
  n === -1 && (n = e);
  var r = n === e ? 0 : 4 - n % 4;
  return [n, r];
}
function RQ(t3) {
  var e = eS(t3), n = e[0], r = e[1];
  return (n + r) * 3 / 4 - r;
}
function FQ(t3, e, n) {
  return (e + n) * 3 / 4 - n;
}
function PQ(t3) {
  var e, n = eS(t3), r = n[0], s = n[1], i = new TQ(FQ(t3, r, s)), a = 0, o = s > 0 ? r - 4 : r, f;
  for (f = 0; f < o; f += 4) e = Js[t3.charCodeAt(f)] << 18 | Js[t3.charCodeAt(f + 1)] << 12 | Js[t3.charCodeAt(f + 2)] << 6 | Js[t3.charCodeAt(f + 3)], i[a++] = e >> 16 & 255, i[a++] = e >> 8 & 255, i[a++] = e & 255;
  return s === 2 && (e = Js[t3.charCodeAt(f)] << 2 | Js[t3.charCodeAt(f + 1)] >> 4, i[a++] = e & 255), s === 1 && (e = Js[t3.charCodeAt(f)] << 10 | Js[t3.charCodeAt(f + 1)] << 4 | Js[t3.charCodeAt(f + 2)] >> 2, i[a++] = e >> 8 & 255, i[a++] = e & 255), i;
}
function NQ(t3) {
  return no[t3 >> 18 & 63] + no[t3 >> 12 & 63] + no[t3 >> 6 & 63] + no[t3 & 63];
}
function UQ(t3, e, n) {
  for (var r, s = [], i = e; i < n; i += 3) r = (t3[i] << 16 & 16711680) + (t3[i + 1] << 8 & 65280) + (t3[i + 2] & 255), s.push(NQ(r));
  return s.join("");
}
function LQ(t3) {
  for (var e, n = t3.length, r = n % 3, s = [], i = 16383, a = 0, o = n - r; a < o; a += i) s.push(UQ(t3, a, a + i > o ? o : a + i));
  return r === 1 ? (e = t3[n - 1], s.push(no[e >> 2] + no[e << 4 & 63] + "==")) : r === 2 && (e = (t3[n - 2] << 8) + t3[n - 1], s.push(no[e >> 10] + no[e >> 4 & 63] + no[e << 2 & 63] + "=")), s.join("");
}
var dA = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
dA.read = function(t3, e, n, r, s) {
  var i, a, o = s * 8 - r - 1, f = (1 << o) - 1, c = f >> 1, l = -7, h = n ? s - 1 : 0, m = n ? -1 : 1, v = t3[e + h];
  for (h += m, i = v & (1 << -l) - 1, v >>= -l, l += o; l > 0; i = i * 256 + t3[e + h], h += m, l -= 8) ;
  for (a = i & (1 << -l) - 1, i >>= -l, l += r; l > 0; a = a * 256 + t3[e + h], h += m, l -= 8) ;
  if (i === 0) i = 1 - c;
  else {
    if (i === f) return a ? NaN : (v ? -1 : 1) * (1 / 0);
    a = a + Math.pow(2, r), i = i - c;
  }
  return (v ? -1 : 1) * a * Math.pow(2, i - r);
};
dA.write = function(t3, e, n, r, s, i) {
  var a, o, f, c = i * 8 - s - 1, l = (1 << c) - 1, h = l >> 1, m = s === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, v = r ? 0 : i - 1, b = r ? 1 : -1, A = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
  for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (o = isNaN(e) ? 1 : 0, a = l) : (a = Math.floor(Math.log(e) / Math.LN2), e * (f = Math.pow(2, -a)) < 1 && (a--, f *= 2), a + h >= 1 ? e += m / f : e += m * Math.pow(2, 1 - h), e * f >= 2 && (a++, f /= 2), a + h >= l ? (o = 0, a = l) : a + h >= 1 ? (o = (e * f - 1) * Math.pow(2, s), a = a + h) : (o = e * Math.pow(2, h - 1) * Math.pow(2, s), a = 0)); s >= 8; t3[n + v] = o & 255, v += b, o /= 256, s -= 8) ;
  for (a = a << s | o, c += s; c > 0; t3[n + v] = a & 255, v += b, a /= 256, c -= 8) ;
  t3[n + v - b] |= A * 128;
};
/*!
* The buffer module from node.js, for the browser.
*
* @author   Feross Aboukhadijeh <https://feross.org>
* @license  MIT
*/
(function(t3) {
  const e = Bg, n = dA, r = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  t3.Buffer = l, t3.SlowBuffer = F, t3.INSPECT_MAX_BYTES = 50;
  const s = 2147483647;
  t3.kMaxLength = s;
  const { Uint8Array: i, ArrayBuffer: a, SharedArrayBuffer: o } = globalThis;
  l.TYPED_ARRAY_SUPPORT = f(), !l.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  function f() {
    try {
      const pe = new i(1), re = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(re, i.prototype), Object.setPrototypeOf(pe, re), pe.foo() === 42;
    } catch {
      return false;
    }
  }
  Object.defineProperty(l.prototype, "parent", { enumerable: true, get: function() {
    if (l.isBuffer(this)) return this.buffer;
  } }), Object.defineProperty(l.prototype, "offset", { enumerable: true, get: function() {
    if (l.isBuffer(this)) return this.byteOffset;
  } });
  function c(pe) {
    if (pe > s) throw new RangeError('The value "' + pe + '" is invalid for option "size"');
    const re = new i(pe);
    return Object.setPrototypeOf(re, l.prototype), re;
  }
  function l(pe, re, ue) {
    if (typeof pe == "number") {
      if (typeof re == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
      return b(pe);
    }
    return h(pe, re, ue);
  }
  l.poolSize = 8192;
  function h(pe, re, ue) {
    if (typeof pe == "string") return A(pe, re);
    if (a.isView(pe)) return C(pe);
    if (pe == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof pe);
    if (Re(pe, a) || pe && Re(pe.buffer, a) || typeof o < "u" && (Re(pe, o) || pe && Re(pe.buffer, o))) return I(pe, re, ue);
    if (typeof pe == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
    const xe = pe.valueOf && pe.valueOf();
    if (xe != null && xe !== pe) return l.from(xe, re, ue);
    const Me = S(pe);
    if (Me) return Me;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof pe[Symbol.toPrimitive] == "function") return l.from(pe[Symbol.toPrimitive]("string"), re, ue);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof pe);
  }
  l.from = function(pe, re, ue) {
    return h(pe, re, ue);
  }, Object.setPrototypeOf(l.prototype, i.prototype), Object.setPrototypeOf(l, i);
  function m(pe) {
    if (typeof pe != "number") throw new TypeError('"size" argument must be of type number');
    if (pe < 0) throw new RangeError('The value "' + pe + '" is invalid for option "size"');
  }
  function v(pe, re, ue) {
    return m(pe), pe <= 0 ? c(pe) : re !== void 0 ? typeof ue == "string" ? c(pe).fill(re, ue) : c(pe).fill(re) : c(pe);
  }
  l.alloc = function(pe, re, ue) {
    return v(pe, re, ue);
  };
  function b(pe) {
    return m(pe), c(pe < 0 ? 0 : $(pe) | 0);
  }
  l.allocUnsafe = function(pe) {
    return b(pe);
  }, l.allocUnsafeSlow = function(pe) {
    return b(pe);
  };
  function A(pe, re) {
    if ((typeof re != "string" || re === "") && (re = "utf8"), !l.isEncoding(re)) throw new TypeError("Unknown encoding: " + re);
    const ue = U(pe, re) | 0;
    let xe = c(ue);
    const Me = xe.write(pe, re);
    return Me !== ue && (xe = xe.slice(0, Me)), xe;
  }
  function _(pe) {
    const re = pe.length < 0 ? 0 : $(pe.length) | 0, ue = c(re);
    for (let xe = 0; xe < re; xe += 1) ue[xe] = pe[xe] & 255;
    return ue;
  }
  function C(pe) {
    if (Re(pe, i)) {
      const re = new i(pe);
      return I(re.buffer, re.byteOffset, re.byteLength);
    }
    return _(pe);
  }
  function I(pe, re, ue) {
    if (re < 0 || pe.byteLength < re) throw new RangeError('"offset" is outside of buffer bounds');
    if (pe.byteLength < re + (ue || 0)) throw new RangeError('"length" is outside of buffer bounds');
    let xe;
    return re === void 0 && ue === void 0 ? xe = new i(pe) : ue === void 0 ? xe = new i(pe, re) : xe = new i(pe, re, ue), Object.setPrototypeOf(xe, l.prototype), xe;
  }
  function S(pe) {
    if (l.isBuffer(pe)) {
      const re = $(pe.length) | 0, ue = c(re);
      return ue.length === 0 || pe.copy(ue, 0, 0, re), ue;
    }
    if (pe.length !== void 0) return typeof pe.length != "number" || Ge(pe.length) ? c(0) : _(pe);
    if (pe.type === "Buffer" && Array.isArray(pe.data)) return _(pe.data);
  }
  function $(pe) {
    if (pe >= s) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + s.toString(16) + " bytes");
    return pe | 0;
  }
  function F(pe) {
    return +pe != pe && (pe = 0), l.alloc(+pe);
  }
  l.isBuffer = function(re) {
    return re != null && re._isBuffer === true && re !== l.prototype;
  }, l.compare = function(re, ue) {
    if (Re(re, i) && (re = l.from(re, re.offset, re.byteLength)), Re(ue, i) && (ue = l.from(ue, ue.offset, ue.byteLength)), !l.isBuffer(re) || !l.isBuffer(ue)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (re === ue) return 0;
    let xe = re.length, Me = ue.length;
    for (let We = 0, De = Math.min(xe, Me); We < De; ++We) if (re[We] !== ue[We]) {
      xe = re[We], Me = ue[We];
      break;
    }
    return xe < Me ? -1 : Me < xe ? 1 : 0;
  }, l.isEncoding = function(re) {
    switch (String(re).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  }, l.concat = function(re, ue) {
    if (!Array.isArray(re)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (re.length === 0) return l.alloc(0);
    let xe;
    if (ue === void 0) for (ue = 0, xe = 0; xe < re.length; ++xe) ue += re[xe].length;
    const Me = l.allocUnsafe(ue);
    let We = 0;
    for (xe = 0; xe < re.length; ++xe) {
      let De = re[xe];
      if (Re(De, i)) We + De.length > Me.length ? (l.isBuffer(De) || (De = l.from(De)), De.copy(Me, We)) : i.prototype.set.call(Me, De, We);
      else if (l.isBuffer(De)) De.copy(Me, We);
      else throw new TypeError('"list" argument must be an Array of Buffers');
      We += De.length;
    }
    return Me;
  };
  function U(pe, re) {
    if (l.isBuffer(pe)) return pe.length;
    if (a.isView(pe) || Re(pe, a)) return pe.byteLength;
    if (typeof pe != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof pe);
    const ue = pe.length, xe = arguments.length > 2 && arguments[2] === true;
    if (!xe && ue === 0) return 0;
    let Me = false;
    for (; ; ) switch (re) {
      case "ascii":
      case "latin1":
      case "binary":
        return ue;
      case "utf8":
      case "utf-8":
        return Oe(pe).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ue * 2;
      case "hex":
        return ue >>> 1;
      case "base64":
        return Ne(pe).length;
      default:
        if (Me) return xe ? -1 : Oe(pe).length;
        re = ("" + re).toLowerCase(), Me = true;
    }
  }
  l.byteLength = U;
  function Q(pe, re, ue) {
    let xe = false;
    if ((re === void 0 || re < 0) && (re = 0), re > this.length || ((ue === void 0 || ue > this.length) && (ue = this.length), ue <= 0) || (ue >>>= 0, re >>>= 0, ue <= re)) return "";
    for (pe || (pe = "utf8"); ; ) switch (pe) {
      case "hex":
        return T(this, re, ue);
      case "utf8":
      case "utf-8":
        return E(this, re, ue);
      case "ascii":
        return g(this, re, ue);
      case "latin1":
      case "binary":
        return k(this, re, ue);
      case "base64":
        return w(this, re, ue);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return O(this, re, ue);
      default:
        if (xe) throw new TypeError("Unknown encoding: " + pe);
        pe = (pe + "").toLowerCase(), xe = true;
    }
  }
  l.prototype._isBuffer = true;
  function P(pe, re, ue) {
    const xe = pe[re];
    pe[re] = pe[ue], pe[ue] = xe;
  }
  l.prototype.swap16 = function() {
    const re = this.length;
    if (re % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let ue = 0; ue < re; ue += 2) P(this, ue, ue + 1);
    return this;
  }, l.prototype.swap32 = function() {
    const re = this.length;
    if (re % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let ue = 0; ue < re; ue += 4) P(this, ue, ue + 3), P(this, ue + 1, ue + 2);
    return this;
  }, l.prototype.swap64 = function() {
    const re = this.length;
    if (re % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let ue = 0; ue < re; ue += 8) P(this, ue, ue + 7), P(this, ue + 1, ue + 6), P(this, ue + 2, ue + 5), P(this, ue + 3, ue + 4);
    return this;
  }, l.prototype.toString = function() {
    const re = this.length;
    return re === 0 ? "" : arguments.length === 0 ? E(this, 0, re) : Q.apply(this, arguments);
  }, l.prototype.toLocaleString = l.prototype.toString, l.prototype.equals = function(re) {
    if (!l.isBuffer(re)) throw new TypeError("Argument must be a Buffer");
    return this === re ? true : l.compare(this, re) === 0;
  }, l.prototype.inspect = function() {
    let re = "";
    const ue = t3.INSPECT_MAX_BYTES;
    return re = this.toString("hex", 0, ue).replace(/(.{2})/g, "$1 ").trim(), this.length > ue && (re += " ... "), "<Buffer " + re + ">";
  }, r && (l.prototype[r] = l.prototype.inspect), l.prototype.compare = function(re, ue, xe, Me, We) {
    if (Re(re, i) && (re = l.from(re, re.offset, re.byteLength)), !l.isBuffer(re)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof re);
    if (ue === void 0 && (ue = 0), xe === void 0 && (xe = re ? re.length : 0), Me === void 0 && (Me = 0), We === void 0 && (We = this.length), ue < 0 || xe > re.length || Me < 0 || We > this.length) throw new RangeError("out of range index");
    if (Me >= We && ue >= xe) return 0;
    if (Me >= We) return -1;
    if (ue >= xe) return 1;
    if (ue >>>= 0, xe >>>= 0, Me >>>= 0, We >>>= 0, this === re) return 0;
    let De = We - Me, je = xe - ue;
    const ir = Math.min(De, je), Xe = this.slice(Me, We), st = re.slice(ue, xe);
    for (let Vt = 0; Vt < ir; ++Vt) if (Xe[Vt] !== st[Vt]) {
      De = Xe[Vt], je = st[Vt];
      break;
    }
    return De < je ? -1 : je < De ? 1 : 0;
  };
  function N(pe, re, ue, xe, Me) {
    if (pe.length === 0) return -1;
    if (typeof ue == "string" ? (xe = ue, ue = 0) : ue > 2147483647 ? ue = 2147483647 : ue < -2147483648 && (ue = -2147483648), ue = +ue, Ge(ue) && (ue = Me ? 0 : pe.length - 1), ue < 0 && (ue = pe.length + ue), ue >= pe.length) {
      if (Me) return -1;
      ue = pe.length - 1;
    } else if (ue < 0) if (Me) ue = 0;
    else return -1;
    if (typeof re == "string" && (re = l.from(re, xe)), l.isBuffer(re)) return re.length === 0 ? -1 : L(pe, re, ue, xe, Me);
    if (typeof re == "number") return re = re & 255, typeof i.prototype.indexOf == "function" ? Me ? i.prototype.indexOf.call(pe, re, ue) : i.prototype.lastIndexOf.call(pe, re, ue) : L(pe, [re], ue, xe, Me);
    throw new TypeError("val must be string, number or Buffer");
  }
  function L(pe, re, ue, xe, Me) {
    let We = 1, De = pe.length, je = re.length;
    if (xe !== void 0 && (xe = String(xe).toLowerCase(), xe === "ucs2" || xe === "ucs-2" || xe === "utf16le" || xe === "utf-16le")) {
      if (pe.length < 2 || re.length < 2) return -1;
      We = 2, De /= 2, je /= 2, ue /= 2;
    }
    function ir(st, Vt) {
      return We === 1 ? st[Vt] : st.readUInt16BE(Vt * We);
    }
    let Xe;
    if (Me) {
      let st = -1;
      for (Xe = ue; Xe < De; Xe++) if (ir(pe, Xe) === ir(re, st === -1 ? 0 : Xe - st)) {
        if (st === -1 && (st = Xe), Xe - st + 1 === je) return st * We;
      } else st !== -1 && (Xe -= Xe - st), st = -1;
    } else for (ue + je > De && (ue = De - je), Xe = ue; Xe >= 0; Xe--) {
      let st = true;
      for (let Vt = 0; Vt < je; Vt++) if (ir(pe, Xe + Vt) !== ir(re, Vt)) {
        st = false;
        break;
      }
      if (st) return Xe;
    }
    return -1;
  }
  l.prototype.includes = function(re, ue, xe) {
    return this.indexOf(re, ue, xe) !== -1;
  }, l.prototype.indexOf = function(re, ue, xe) {
    return N(this, re, ue, xe, true);
  }, l.prototype.lastIndexOf = function(re, ue, xe) {
    return N(this, re, ue, xe, false);
  };
  function B(pe, re, ue, xe) {
    ue = Number(ue) || 0;
    const Me = pe.length - ue;
    xe ? (xe = Number(xe), xe > Me && (xe = Me)) : xe = Me;
    const We = re.length;
    xe > We / 2 && (xe = We / 2);
    let De;
    for (De = 0; De < xe; ++De) {
      const je = parseInt(re.substr(De * 2, 2), 16);
      if (Ge(je)) return De;
      pe[ue + De] = je;
    }
    return De;
  }
  function u(pe, re, ue, xe) {
    return $e(Oe(re, pe.length - ue), pe, ue, xe);
  }
  function p(pe, re, ue, xe) {
    return $e(Se(re), pe, ue, xe);
  }
  function d(pe, re, ue, xe) {
    return $e(Ne(re), pe, ue, xe);
  }
  function y(pe, re, ue, xe) {
    return $e(Ce(re, pe.length - ue), pe, ue, xe);
  }
  l.prototype.write = function(re, ue, xe, Me) {
    if (ue === void 0) Me = "utf8", xe = this.length, ue = 0;
    else if (xe === void 0 && typeof ue == "string") Me = ue, xe = this.length, ue = 0;
    else if (isFinite(ue)) ue = ue >>> 0, isFinite(xe) ? (xe = xe >>> 0, Me === void 0 && (Me = "utf8")) : (Me = xe, xe = void 0);
    else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    const We = this.length - ue;
    if ((xe === void 0 || xe > We) && (xe = We), re.length > 0 && (xe < 0 || ue < 0) || ue > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    Me || (Me = "utf8");
    let De = false;
    for (; ; ) switch (Me) {
      case "hex":
        return B(this, re, ue, xe);
      case "utf8":
      case "utf-8":
        return u(this, re, ue, xe);
      case "ascii":
      case "latin1":
      case "binary":
        return p(this, re, ue, xe);
      case "base64":
        return d(this, re, ue, xe);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return y(this, re, ue, xe);
      default:
        if (De) throw new TypeError("Unknown encoding: " + Me);
        Me = ("" + Me).toLowerCase(), De = true;
    }
  }, l.prototype.toJSON = function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  function w(pe, re, ue) {
    return re === 0 && ue === pe.length ? e.fromByteArray(pe) : e.fromByteArray(pe.slice(re, ue));
  }
  function E(pe, re, ue) {
    ue = Math.min(pe.length, ue);
    const xe = [];
    let Me = re;
    for (; Me < ue; ) {
      const We = pe[Me];
      let De = null, je = We > 239 ? 4 : We > 223 ? 3 : We > 191 ? 2 : 1;
      if (Me + je <= ue) {
        let ir, Xe, st, Vt;
        switch (je) {
          case 1:
            We < 128 && (De = We);
            break;
          case 2:
            ir = pe[Me + 1], (ir & 192) === 128 && (Vt = (We & 31) << 6 | ir & 63, Vt > 127 && (De = Vt));
            break;
          case 3:
            ir = pe[Me + 1], Xe = pe[Me + 2], (ir & 192) === 128 && (Xe & 192) === 128 && (Vt = (We & 15) << 12 | (ir & 63) << 6 | Xe & 63, Vt > 2047 && (Vt < 55296 || Vt > 57343) && (De = Vt));
            break;
          case 4:
            ir = pe[Me + 1], Xe = pe[Me + 2], st = pe[Me + 3], (ir & 192) === 128 && (Xe & 192) === 128 && (st & 192) === 128 && (Vt = (We & 15) << 18 | (ir & 63) << 12 | (Xe & 63) << 6 | st & 63, Vt > 65535 && Vt < 1114112 && (De = Vt));
        }
      }
      De === null ? (De = 65533, je = 1) : De > 65535 && (De -= 65536, xe.push(De >>> 10 & 1023 | 55296), De = 56320 | De & 1023), xe.push(De), Me += je;
    }
    return x(xe);
  }
  const M = 4096;
  function x(pe) {
    const re = pe.length;
    if (re <= M) return String.fromCharCode.apply(String, pe);
    let ue = "", xe = 0;
    for (; xe < re; ) ue += String.fromCharCode.apply(String, pe.slice(xe, xe += M));
    return ue;
  }
  function g(pe, re, ue) {
    let xe = "";
    ue = Math.min(pe.length, ue);
    for (let Me = re; Me < ue; ++Me) xe += String.fromCharCode(pe[Me] & 127);
    return xe;
  }
  function k(pe, re, ue) {
    let xe = "";
    ue = Math.min(pe.length, ue);
    for (let Me = re; Me < ue; ++Me) xe += String.fromCharCode(pe[Me]);
    return xe;
  }
  function T(pe, re, ue) {
    const xe = pe.length;
    (!re || re < 0) && (re = 0), (!ue || ue < 0 || ue > xe) && (ue = xe);
    let Me = "";
    for (let We = re; We < ue; ++We) Me += Fe[pe[We]];
    return Me;
  }
  function O(pe, re, ue) {
    const xe = pe.slice(re, ue);
    let Me = "";
    for (let We = 0; We < xe.length - 1; We += 2) Me += String.fromCharCode(xe[We] + xe[We + 1] * 256);
    return Me;
  }
  l.prototype.slice = function(re, ue) {
    const xe = this.length;
    re = ~~re, ue = ue === void 0 ? xe : ~~ue, re < 0 ? (re += xe, re < 0 && (re = 0)) : re > xe && (re = xe), ue < 0 ? (ue += xe, ue < 0 && (ue = 0)) : ue > xe && (ue = xe), ue < re && (ue = re);
    const Me = this.subarray(re, ue);
    return Object.setPrototypeOf(Me, l.prototype), Me;
  };
  function K(pe, re, ue) {
    if (pe % 1 !== 0 || pe < 0) throw new RangeError("offset is not uint");
    if (pe + re > ue) throw new RangeError("Trying to access beyond buffer length");
  }
  l.prototype.readUintLE = l.prototype.readUIntLE = function(re, ue, xe) {
    re = re >>> 0, ue = ue >>> 0, xe || K(re, ue, this.length);
    let Me = this[re], We = 1, De = 0;
    for (; ++De < ue && (We *= 256); ) Me += this[re + De] * We;
    return Me;
  }, l.prototype.readUintBE = l.prototype.readUIntBE = function(re, ue, xe) {
    re = re >>> 0, ue = ue >>> 0, xe || K(re, ue, this.length);
    let Me = this[re + --ue], We = 1;
    for (; ue > 0 && (We *= 256); ) Me += this[re + --ue] * We;
    return Me;
  }, l.prototype.readUint8 = l.prototype.readUInt8 = function(re, ue) {
    return re = re >>> 0, ue || K(re, 1, this.length), this[re];
  }, l.prototype.readUint16LE = l.prototype.readUInt16LE = function(re, ue) {
    return re = re >>> 0, ue || K(re, 2, this.length), this[re] | this[re + 1] << 8;
  }, l.prototype.readUint16BE = l.prototype.readUInt16BE = function(re, ue) {
    return re = re >>> 0, ue || K(re, 2, this.length), this[re] << 8 | this[re + 1];
  }, l.prototype.readUint32LE = l.prototype.readUInt32LE = function(re, ue) {
    return re = re >>> 0, ue || K(re, 4, this.length), (this[re] | this[re + 1] << 8 | this[re + 2] << 16) + this[re + 3] * 16777216;
  }, l.prototype.readUint32BE = l.prototype.readUInt32BE = function(re, ue) {
    return re = re >>> 0, ue || K(re, 4, this.length), this[re] * 16777216 + (this[re + 1] << 16 | this[re + 2] << 8 | this[re + 3]);
  }, l.prototype.readBigUInt64LE = Ue(function(re) {
    re = re >>> 0, he(re, "offset");
    const ue = this[re], xe = this[re + 7];
    (ue === void 0 || xe === void 0) && me(re, this.length - 8);
    const Me = ue + this[++re] * 2 ** 8 + this[++re] * 2 ** 16 + this[++re] * 2 ** 24, We = this[++re] + this[++re] * 2 ** 8 + this[++re] * 2 ** 16 + xe * 2 ** 24;
    return BigInt(Me) + (BigInt(We) << BigInt(32));
  }), l.prototype.readBigUInt64BE = Ue(function(re) {
    re = re >>> 0, he(re, "offset");
    const ue = this[re], xe = this[re + 7];
    (ue === void 0 || xe === void 0) && me(re, this.length - 8);
    const Me = ue * 2 ** 24 + this[++re] * 2 ** 16 + this[++re] * 2 ** 8 + this[++re], We = this[++re] * 2 ** 24 + this[++re] * 2 ** 16 + this[++re] * 2 ** 8 + xe;
    return (BigInt(Me) << BigInt(32)) + BigInt(We);
  }), l.prototype.readIntLE = function(re, ue, xe) {
    re = re >>> 0, ue = ue >>> 0, xe || K(re, ue, this.length);
    let Me = this[re], We = 1, De = 0;
    for (; ++De < ue && (We *= 256); ) Me += this[re + De] * We;
    return We *= 128, Me >= We && (Me -= Math.pow(2, 8 * ue)), Me;
  }, l.prototype.readIntBE = function(re, ue, xe) {
    re = re >>> 0, ue = ue >>> 0, xe || K(re, ue, this.length);
    let Me = ue, We = 1, De = this[re + --Me];
    for (; Me > 0 && (We *= 256); ) De += this[re + --Me] * We;
    return We *= 128, De >= We && (De -= Math.pow(2, 8 * ue)), De;
  }, l.prototype.readInt8 = function(re, ue) {
    return re = re >>> 0, ue || K(re, 1, this.length), this[re] & 128 ? (255 - this[re] + 1) * -1 : this[re];
  }, l.prototype.readInt16LE = function(re, ue) {
    re = re >>> 0, ue || K(re, 2, this.length);
    const xe = this[re] | this[re + 1] << 8;
    return xe & 32768 ? xe | 4294901760 : xe;
  }, l.prototype.readInt16BE = function(re, ue) {
    re = re >>> 0, ue || K(re, 2, this.length);
    const xe = this[re + 1] | this[re] << 8;
    return xe & 32768 ? xe | 4294901760 : xe;
  }, l.prototype.readInt32LE = function(re, ue) {
    return re = re >>> 0, ue || K(re, 4, this.length), this[re] | this[re + 1] << 8 | this[re + 2] << 16 | this[re + 3] << 24;
  }, l.prototype.readInt32BE = function(re, ue) {
    return re = re >>> 0, ue || K(re, 4, this.length), this[re] << 24 | this[re + 1] << 16 | this[re + 2] << 8 | this[re + 3];
  }, l.prototype.readBigInt64LE = Ue(function(re) {
    re = re >>> 0, he(re, "offset");
    const ue = this[re], xe = this[re + 7];
    (ue === void 0 || xe === void 0) && me(re, this.length - 8);
    const Me = this[re + 4] + this[re + 5] * 2 ** 8 + this[re + 6] * 2 ** 16 + (xe << 24);
    return (BigInt(Me) << BigInt(32)) + BigInt(ue + this[++re] * 2 ** 8 + this[++re] * 2 ** 16 + this[++re] * 2 ** 24);
  }), l.prototype.readBigInt64BE = Ue(function(re) {
    re = re >>> 0, he(re, "offset");
    const ue = this[re], xe = this[re + 7];
    (ue === void 0 || xe === void 0) && me(re, this.length - 8);
    const Me = (ue << 24) + this[++re] * 2 ** 16 + this[++re] * 2 ** 8 + this[++re];
    return (BigInt(Me) << BigInt(32)) + BigInt(this[++re] * 2 ** 24 + this[++re] * 2 ** 16 + this[++re] * 2 ** 8 + xe);
  }), l.prototype.readFloatLE = function(re, ue) {
    return re = re >>> 0, ue || K(re, 4, this.length), n.read(this, re, true, 23, 4);
  }, l.prototype.readFloatBE = function(re, ue) {
    return re = re >>> 0, ue || K(re, 4, this.length), n.read(this, re, false, 23, 4);
  }, l.prototype.readDoubleLE = function(re, ue) {
    return re = re >>> 0, ue || K(re, 8, this.length), n.read(this, re, true, 52, 8);
  }, l.prototype.readDoubleBE = function(re, ue) {
    return re = re >>> 0, ue || K(re, 8, this.length), n.read(this, re, false, 52, 8);
  };
  function Y(pe, re, ue, xe, Me, We) {
    if (!l.isBuffer(pe)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (re > Me || re < We) throw new RangeError('"value" argument is out of bounds');
    if (ue + xe > pe.length) throw new RangeError("Index out of range");
  }
  l.prototype.writeUintLE = l.prototype.writeUIntLE = function(re, ue, xe, Me) {
    if (re = +re, ue = ue >>> 0, xe = xe >>> 0, !Me) {
      const je = Math.pow(2, 8 * xe) - 1;
      Y(this, re, ue, xe, je, 0);
    }
    let We = 1, De = 0;
    for (this[ue] = re & 255; ++De < xe && (We *= 256); ) this[ue + De] = re / We & 255;
    return ue + xe;
  }, l.prototype.writeUintBE = l.prototype.writeUIntBE = function(re, ue, xe, Me) {
    if (re = +re, ue = ue >>> 0, xe = xe >>> 0, !Me) {
      const je = Math.pow(2, 8 * xe) - 1;
      Y(this, re, ue, xe, je, 0);
    }
    let We = xe - 1, De = 1;
    for (this[ue + We] = re & 255; --We >= 0 && (De *= 256); ) this[ue + We] = re / De & 255;
    return ue + xe;
  }, l.prototype.writeUint8 = l.prototype.writeUInt8 = function(re, ue, xe) {
    return re = +re, ue = ue >>> 0, xe || Y(this, re, ue, 1, 255, 0), this[ue] = re & 255, ue + 1;
  }, l.prototype.writeUint16LE = l.prototype.writeUInt16LE = function(re, ue, xe) {
    return re = +re, ue = ue >>> 0, xe || Y(this, re, ue, 2, 65535, 0), this[ue] = re & 255, this[ue + 1] = re >>> 8, ue + 2;
  }, l.prototype.writeUint16BE = l.prototype.writeUInt16BE = function(re, ue, xe) {
    return re = +re, ue = ue >>> 0, xe || Y(this, re, ue, 2, 65535, 0), this[ue] = re >>> 8, this[ue + 1] = re & 255, ue + 2;
  }, l.prototype.writeUint32LE = l.prototype.writeUInt32LE = function(re, ue, xe) {
    return re = +re, ue = ue >>> 0, xe || Y(this, re, ue, 4, 4294967295, 0), this[ue + 3] = re >>> 24, this[ue + 2] = re >>> 16, this[ue + 1] = re >>> 8, this[ue] = re & 255, ue + 4;
  }, l.prototype.writeUint32BE = l.prototype.writeUInt32BE = function(re, ue, xe) {
    return re = +re, ue = ue >>> 0, xe || Y(this, re, ue, 4, 4294967295, 0), this[ue] = re >>> 24, this[ue + 1] = re >>> 16, this[ue + 2] = re >>> 8, this[ue + 3] = re & 255, ue + 4;
  };
  function J(pe, re, ue, xe, Me) {
    ve(re, xe, Me, pe, ue, 7);
    let We = Number(re & BigInt(4294967295));
    pe[ue++] = We, We = We >> 8, pe[ue++] = We, We = We >> 8, pe[ue++] = We, We = We >> 8, pe[ue++] = We;
    let De = Number(re >> BigInt(32) & BigInt(4294967295));
    return pe[ue++] = De, De = De >> 8, pe[ue++] = De, De = De >> 8, pe[ue++] = De, De = De >> 8, pe[ue++] = De, ue;
  }
  function G(pe, re, ue, xe, Me) {
    ve(re, xe, Me, pe, ue, 7);
    let We = Number(re & BigInt(4294967295));
    pe[ue + 7] = We, We = We >> 8, pe[ue + 6] = We, We = We >> 8, pe[ue + 5] = We, We = We >> 8, pe[ue + 4] = We;
    let De = Number(re >> BigInt(32) & BigInt(4294967295));
    return pe[ue + 3] = De, De = De >> 8, pe[ue + 2] = De, De = De >> 8, pe[ue + 1] = De, De = De >> 8, pe[ue] = De, ue + 8;
  }
  l.prototype.writeBigUInt64LE = Ue(function(re, ue = 0) {
    return J(this, re, ue, BigInt(0), BigInt("0xffffffffffffffff"));
  }), l.prototype.writeBigUInt64BE = Ue(function(re, ue = 0) {
    return G(this, re, ue, BigInt(0), BigInt("0xffffffffffffffff"));
  }), l.prototype.writeIntLE = function(re, ue, xe, Me) {
    if (re = +re, ue = ue >>> 0, !Me) {
      const ir = Math.pow(2, 8 * xe - 1);
      Y(this, re, ue, xe, ir - 1, -ir);
    }
    let We = 0, De = 1, je = 0;
    for (this[ue] = re & 255; ++We < xe && (De *= 256); ) re < 0 && je === 0 && this[ue + We - 1] !== 0 && (je = 1), this[ue + We] = (re / De >> 0) - je & 255;
    return ue + xe;
  }, l.prototype.writeIntBE = function(re, ue, xe, Me) {
    if (re = +re, ue = ue >>> 0, !Me) {
      const ir = Math.pow(2, 8 * xe - 1);
      Y(this, re, ue, xe, ir - 1, -ir);
    }
    let We = xe - 1, De = 1, je = 0;
    for (this[ue + We] = re & 255; --We >= 0 && (De *= 256); ) re < 0 && je === 0 && this[ue + We + 1] !== 0 && (je = 1), this[ue + We] = (re / De >> 0) - je & 255;
    return ue + xe;
  }, l.prototype.writeInt8 = function(re, ue, xe) {
    return re = +re, ue = ue >>> 0, xe || Y(this, re, ue, 1, 127, -128), re < 0 && (re = 255 + re + 1), this[ue] = re & 255, ue + 1;
  }, l.prototype.writeInt16LE = function(re, ue, xe) {
    return re = +re, ue = ue >>> 0, xe || Y(this, re, ue, 2, 32767, -32768), this[ue] = re & 255, this[ue + 1] = re >>> 8, ue + 2;
  }, l.prototype.writeInt16BE = function(re, ue, xe) {
    return re = +re, ue = ue >>> 0, xe || Y(this, re, ue, 2, 32767, -32768), this[ue] = re >>> 8, this[ue + 1] = re & 255, ue + 2;
  }, l.prototype.writeInt32LE = function(re, ue, xe) {
    return re = +re, ue = ue >>> 0, xe || Y(this, re, ue, 4, 2147483647, -2147483648), this[ue] = re & 255, this[ue + 1] = re >>> 8, this[ue + 2] = re >>> 16, this[ue + 3] = re >>> 24, ue + 4;
  }, l.prototype.writeInt32BE = function(re, ue, xe) {
    return re = +re, ue = ue >>> 0, xe || Y(this, re, ue, 4, 2147483647, -2147483648), re < 0 && (re = 4294967295 + re + 1), this[ue] = re >>> 24, this[ue + 1] = re >>> 16, this[ue + 2] = re >>> 8, this[ue + 3] = re & 255, ue + 4;
  }, l.prototype.writeBigInt64LE = Ue(function(re, ue = 0) {
    return J(this, re, ue, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), l.prototype.writeBigInt64BE = Ue(function(re, ue = 0) {
    return G(this, re, ue, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function X(pe, re, ue, xe, Me, We) {
    if (ue + xe > pe.length) throw new RangeError("Index out of range");
    if (ue < 0) throw new RangeError("Index out of range");
  }
  function ie(pe, re, ue, xe, Me) {
    return re = +re, ue = ue >>> 0, Me || X(pe, re, ue, 4), n.write(pe, re, ue, xe, 23, 4), ue + 4;
  }
  l.prototype.writeFloatLE = function(re, ue, xe) {
    return ie(this, re, ue, true, xe);
  }, l.prototype.writeFloatBE = function(re, ue, xe) {
    return ie(this, re, ue, false, xe);
  };
  function de(pe, re, ue, xe, Me) {
    return re = +re, ue = ue >>> 0, Me || X(pe, re, ue, 8), n.write(pe, re, ue, xe, 52, 8), ue + 8;
  }
  l.prototype.writeDoubleLE = function(re, ue, xe) {
    return de(this, re, ue, true, xe);
  }, l.prototype.writeDoubleBE = function(re, ue, xe) {
    return de(this, re, ue, false, xe);
  }, l.prototype.copy = function(re, ue, xe, Me) {
    if (!l.isBuffer(re)) throw new TypeError("argument should be a Buffer");
    if (xe || (xe = 0), !Me && Me !== 0 && (Me = this.length), ue >= re.length && (ue = re.length), ue || (ue = 0), Me > 0 && Me < xe && (Me = xe), Me === xe || re.length === 0 || this.length === 0) return 0;
    if (ue < 0) throw new RangeError("targetStart out of bounds");
    if (xe < 0 || xe >= this.length) throw new RangeError("Index out of range");
    if (Me < 0) throw new RangeError("sourceEnd out of bounds");
    Me > this.length && (Me = this.length), re.length - ue < Me - xe && (Me = re.length - ue + xe);
    const We = Me - xe;
    return this === re && typeof i.prototype.copyWithin == "function" ? this.copyWithin(ue, xe, Me) : i.prototype.set.call(re, this.subarray(xe, Me), ue), We;
  }, l.prototype.fill = function(re, ue, xe, Me) {
    if (typeof re == "string") {
      if (typeof ue == "string" ? (Me = ue, ue = 0, xe = this.length) : typeof xe == "string" && (Me = xe, xe = this.length), Me !== void 0 && typeof Me != "string") throw new TypeError("encoding must be a string");
      if (typeof Me == "string" && !l.isEncoding(Me)) throw new TypeError("Unknown encoding: " + Me);
      if (re.length === 1) {
        const De = re.charCodeAt(0);
        (Me === "utf8" && De < 128 || Me === "latin1") && (re = De);
      }
    } else typeof re == "number" ? re = re & 255 : typeof re == "boolean" && (re = Number(re));
    if (ue < 0 || this.length < ue || this.length < xe) throw new RangeError("Out of range index");
    if (xe <= ue) return this;
    ue = ue >>> 0, xe = xe === void 0 ? this.length : xe >>> 0, re || (re = 0);
    let We;
    if (typeof re == "number") for (We = ue; We < xe; ++We) this[We] = re;
    else {
      const De = l.isBuffer(re) ? re : l.from(re, Me), je = De.length;
      if (je === 0) throw new TypeError('The value "' + re + '" is invalid for argument "value"');
      for (We = 0; We < xe - ue; ++We) this[We + ue] = De[We % je];
    }
    return this;
  };
  const se = {};
  function te(pe, re, ue) {
    se[pe] = class extends ue {
      constructor() {
        super(), Object.defineProperty(this, "message", { value: re.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${pe}]`, this.stack, delete this.name;
      }
      get code() {
        return pe;
      }
      set code(Me) {
        Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: Me, writable: true });
      }
      toString() {
        return `${this.name} [${pe}]: ${this.message}`;
      }
    };
  }
  te("ERR_BUFFER_OUT_OF_BOUNDS", function(pe) {
    return pe ? `${pe} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
  }, RangeError), te("ERR_INVALID_ARG_TYPE", function(pe, re) {
    return `The "${pe}" argument must be of type number. Received type ${typeof re}`;
  }, TypeError), te("ERR_OUT_OF_RANGE", function(pe, re, ue) {
    let xe = `The value of "${pe}" is out of range.`, Me = ue;
    return Number.isInteger(ue) && Math.abs(ue) > 2 ** 32 ? Me = le(String(ue)) : typeof ue == "bigint" && (Me = String(ue), (ue > BigInt(2) ** BigInt(32) || ue < -(BigInt(2) ** BigInt(32))) && (Me = le(Me)), Me += "n"), xe += ` It must be ${re}. Received ${Me}`, xe;
  }, RangeError);
  function le(pe) {
    let re = "", ue = pe.length;
    const xe = pe[0] === "-" ? 1 : 0;
    for (; ue >= xe + 4; ue -= 3) re = `_${pe.slice(ue - 3, ue)}${re}`;
    return `${pe.slice(0, ue)}${re}`;
  }
  function Z(pe, re, ue) {
    he(re, "offset"), (pe[re] === void 0 || pe[re + ue] === void 0) && me(re, pe.length - (ue + 1));
  }
  function ve(pe, re, ue, xe, Me, We) {
    if (pe > ue || pe < re) {
      const De = typeof re == "bigint" ? "n" : "";
      let je;
      throw re === 0 || re === BigInt(0) ? je = `>= 0${De} and < 2${De} ** ${(We + 1) * 8}${De}` : je = `>= -(2${De} ** ${(We + 1) * 8 - 1}${De}) and < 2 ** ${(We + 1) * 8 - 1}${De}`, new se.ERR_OUT_OF_RANGE("value", je, pe);
    }
    Z(xe, Me, We);
  }
  function he(pe, re) {
    if (typeof pe != "number") throw new se.ERR_INVALID_ARG_TYPE(re, "number", pe);
  }
  function me(pe, re, ue) {
    throw Math.floor(pe) !== pe ? (he(pe, ue), new se.ERR_OUT_OF_RANGE("offset", "an integer", pe)) : re < 0 ? new se.ERR_BUFFER_OUT_OF_BOUNDS() : new se.ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${re}`, pe);
  }
  const ce = /[^+/0-9A-Za-z-_]/g;
  function ye(pe) {
    if (pe = pe.split("=")[0], pe = pe.trim().replace(ce, ""), pe.length < 2) return "";
    for (; pe.length % 4 !== 0; ) pe = pe + "=";
    return pe;
  }
  function Oe(pe, re) {
    re = re || 1 / 0;
    let ue;
    const xe = pe.length;
    let Me = null;
    const We = [];
    for (let De = 0; De < xe; ++De) {
      if (ue = pe.charCodeAt(De), ue > 55295 && ue < 57344) {
        if (!Me) {
          if (ue > 56319) {
            (re -= 3) > -1 && We.push(239, 191, 189);
            continue;
          } else if (De + 1 === xe) {
            (re -= 3) > -1 && We.push(239, 191, 189);
            continue;
          }
          Me = ue;
          continue;
        }
        if (ue < 56320) {
          (re -= 3) > -1 && We.push(239, 191, 189), Me = ue;
          continue;
        }
        ue = (Me - 55296 << 10 | ue - 56320) + 65536;
      } else Me && (re -= 3) > -1 && We.push(239, 191, 189);
      if (Me = null, ue < 128) {
        if ((re -= 1) < 0) break;
        We.push(ue);
      } else if (ue < 2048) {
        if ((re -= 2) < 0) break;
        We.push(ue >> 6 | 192, ue & 63 | 128);
      } else if (ue < 65536) {
        if ((re -= 3) < 0) break;
        We.push(ue >> 12 | 224, ue >> 6 & 63 | 128, ue & 63 | 128);
      } else if (ue < 1114112) {
        if ((re -= 4) < 0) break;
        We.push(ue >> 18 | 240, ue >> 12 & 63 | 128, ue >> 6 & 63 | 128, ue & 63 | 128);
      } else throw new Error("Invalid code point");
    }
    return We;
  }
  function Se(pe) {
    const re = [];
    for (let ue = 0; ue < pe.length; ++ue) re.push(pe.charCodeAt(ue) & 255);
    return re;
  }
  function Ce(pe, re) {
    let ue, xe, Me;
    const We = [];
    for (let De = 0; De < pe.length && !((re -= 2) < 0); ++De) ue = pe.charCodeAt(De), xe = ue >> 8, Me = ue % 256, We.push(Me), We.push(xe);
    return We;
  }
  function Ne(pe) {
    return e.toByteArray(ye(pe));
  }
  function $e(pe, re, ue, xe) {
    let Me;
    for (Me = 0; Me < xe && !(Me + ue >= re.length || Me >= pe.length); ++Me) re[Me + ue] = pe[Me];
    return Me;
  }
  function Re(pe, re) {
    return pe instanceof re || pe != null && pe.constructor != null && pe.constructor.name != null && pe.constructor.name === re.name;
  }
  function Ge(pe) {
    return pe !== pe;
  }
  const Fe = function() {
    const pe = "0123456789abcdef", re = new Array(256);
    for (let ue = 0; ue < 16; ++ue) {
      const xe = ue * 16;
      for (let Me = 0; Me < 16; ++Me) re[xe + Me] = pe[ue] + pe[Me];
    }
    return re;
  }();
  function Ue(pe) {
    return typeof BigInt > "u" ? kt : pe;
  }
  function kt() {
    throw new Error("BigInt not supported");
  }
})(di);
const hr = di.Buffer, OQ = di.Blob, QQ = di.BlobOptions, KQ = di.Buffer, HQ = di.File, qQ = di.FileOptions, zQ = di.INSPECT_MAX_BYTES, GQ = di.SlowBuffer, VQ = di.TranscodeEncoding, YQ = di.atob, WQ = di.btoa, JQ = di.constants, ZQ = di.isAscii, jQ = di.isUtf8, XQ = di.kMaxLength, eK = di.kStringMaxLength, tK = di.resolveObjectURL, rK = di.transcode, nK = Object.freeze(Object.defineProperty({ __proto__: null, Blob: OQ, BlobOptions: QQ, Buffer: KQ, File: HQ, FileOptions: qQ, INSPECT_MAX_BYTES: zQ, SlowBuffer: GQ, TranscodeEncoding: VQ, atob: YQ, btoa: WQ, constants: JQ, default: hr, isAscii: ZQ, isUtf8: jQ, kMaxLength: XQ, kStringMaxLength: eK, resolveObjectURL: tK, transcode: rK }, Symbol.toStringTag, { value: "Module" }));
function iK(t3) {
  return t3 && t3.__esModule && Object.prototype.hasOwnProperty.call(t3, "default") ? t3.default : t3;
}
var tS = { exports: {} }, Xn = tS.exports = {}, Ja, Za;
function v3() {
  throw new Error("setTimeout has not been defined");
}
function y3() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? Ja = setTimeout : Ja = v3;
  } catch {
    Ja = v3;
  }
  try {
    typeof clearTimeout == "function" ? Za = clearTimeout : Za = y3;
  } catch {
    Za = y3;
  }
})();
function rS(t3) {
  if (Ja === setTimeout) return setTimeout(t3, 0);
  if ((Ja === v3 || !Ja) && setTimeout) return Ja = setTimeout, setTimeout(t3, 0);
  try {
    return Ja(t3, 0);
  } catch {
    try {
      return Ja.call(null, t3, 0);
    } catch {
      return Ja.call(this, t3, 0);
    }
  }
}
function sK(t3) {
  if (Za === clearTimeout) return clearTimeout(t3);
  if ((Za === y3 || !Za) && clearTimeout) return Za = clearTimeout, clearTimeout(t3);
  try {
    return Za(t3);
  } catch {
    try {
      return Za.call(null, t3);
    } catch {
      return Za.call(this, t3);
    }
  }
}
var Jo = [], uu = false, zl, Tp = -1;
function aK() {
  !uu || !zl || (uu = false, zl.length ? Jo = zl.concat(Jo) : Tp = -1, Jo.length && nS());
}
function nS() {
  if (!uu) {
    var t3 = rS(aK);
    uu = true;
    for (var e = Jo.length; e; ) {
      for (zl = Jo, Jo = []; ++Tp < e; ) zl && zl[Tp].run();
      Tp = -1, e = Jo.length;
    }
    zl = null, uu = false, sK(t3);
  }
}
Xn.nextTick = function(t3) {
  var e = new Array(arguments.length - 1);
  if (arguments.length > 1) for (var n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
  Jo.push(new iS(t3, e)), Jo.length === 1 && !uu && rS(nS);
};
function iS(t3, e) {
  this.fun = t3, this.array = e;
}
iS.prototype.run = function() {
  this.fun.apply(null, this.array);
};
Xn.title = "browser";
Xn.browser = true;
Xn.env = {};
Xn.argv = [];
Xn.version = "";
Xn.versions = {};
function pf() {
}
Xn.on = pf;
Xn.addListener = pf;
Xn.once = pf;
Xn.off = pf;
Xn.removeListener = pf;
Xn.removeAllListeners = pf;
Xn.emit = pf;
Xn.prependListener = pf;
Xn.prependOnceListener = pf;
Xn.listeners = function(t3) {
  return [];
};
Xn.binding = function(t3) {
  throw new Error("process.binding is not supported");
};
Xn.cwd = function() {
  return "/";
};
Xn.chdir = function(t3) {
  throw new Error("process.chdir is not supported");
};
Xn.umask = function() {
  return 0;
};
var oK = tS.exports;
const jt = iK(oK);
var mt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Fa(t3) {
  return t3 && t3.__esModule && Object.prototype.hasOwnProperty.call(t3, "default") ? t3.default : t3;
}
function sS(t3) {
  if (t3.__esModule) return t3;
  var e = t3.default;
  if (typeof e == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    n.prototype = e.prototype;
  } else n = {};
  return Object.defineProperty(n, "__esModule", { value: true }), Object.keys(t3).forEach(function(r) {
    var s = Object.getOwnPropertyDescriptor(t3, r);
    Object.defineProperty(n, r, s.get ? s : { enumerable: true, get: function() {
      return t3[r];
    } });
  }), n;
}
function Gl(t3) {
  throw new Error('Could not dynamically require "' + t3 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var aS = { exports: {} };
(function(t3, e) {
  (function(n) {
    t3.exports = n();
  })(function() {
    return function n(r, s, i) {
      function a(c, l) {
        if (!s[c]) {
          if (!r[c]) {
            var h = typeof Gl == "function" && Gl;
            if (!l && h) return h(c, true);
            if (o) return o(c, true);
            var m = new Error("Cannot find module '" + c + "'");
            throw m.code = "MODULE_NOT_FOUND", m;
          }
          var v = s[c] = { exports: {} };
          r[c][0].call(v.exports, function(b) {
            var A = r[c][1][b];
            return a(A || b);
          }, v, v.exports, n, r, s, i);
        }
        return s[c].exports;
      }
      for (var o = typeof Gl == "function" && Gl, f = 0; f < i.length; f++) a(i[f]);
      return a;
    }({ 1: [function(n, r, s) {
      var i = n("./utils"), a = n("./support"), o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      s.encode = function(f) {
        for (var c, l, h, m, v, b, A, _ = [], C = 0, I = f.length, S = I, $ = i.getTypeOf(f) !== "string"; C < f.length; ) S = I - C, h = $ ? (c = f[C++], l = C < I ? f[C++] : 0, C < I ? f[C++] : 0) : (c = f.charCodeAt(C++), l = C < I ? f.charCodeAt(C++) : 0, C < I ? f.charCodeAt(C++) : 0), m = c >> 2, v = (3 & c) << 4 | l >> 4, b = 1 < S ? (15 & l) << 2 | h >> 6 : 64, A = 2 < S ? 63 & h : 64, _.push(o.charAt(m) + o.charAt(v) + o.charAt(b) + o.charAt(A));
        return _.join("");
      }, s.decode = function(f) {
        var c, l, h, m, v, b, A = 0, _ = 0, C = "data:";
        if (f.substr(0, C.length) === C) throw new Error("Invalid base64 input, it looks like a data url.");
        var I, S = 3 * (f = f.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (f.charAt(f.length - 1) === o.charAt(64) && S--, f.charAt(f.length - 2) === o.charAt(64) && S--, S % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
        for (I = a.uint8array ? new Uint8Array(0 | S) : new Array(0 | S); A < f.length; ) c = o.indexOf(f.charAt(A++)) << 2 | (m = o.indexOf(f.charAt(A++))) >> 4, l = (15 & m) << 4 | (v = o.indexOf(f.charAt(A++))) >> 2, h = (3 & v) << 6 | (b = o.indexOf(f.charAt(A++))), I[_++] = c, v !== 64 && (I[_++] = l), b !== 64 && (I[_++] = h);
        return I;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(n, r, s) {
      var i = n("./external"), a = n("./stream/DataWorker"), o = n("./stream/Crc32Probe"), f = n("./stream/DataLengthProbe");
      function c(l, h, m, v, b) {
        this.compressedSize = l, this.uncompressedSize = h, this.crc32 = m, this.compression = v, this.compressedContent = b;
      }
      c.prototype = { getContentWorker: function() {
        var l = new a(i.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new f("data_length")), h = this;
        return l.on("end", function() {
          if (this.streamInfo.data_length !== h.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
        }), l;
      }, getCompressedWorker: function() {
        return new a(i.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, c.createWorkerFrom = function(l, h, m) {
        return l.pipe(new o()).pipe(new f("uncompressedSize")).pipe(h.compressWorker(m)).pipe(new f("compressedSize")).withStreamInfo("compression", h);
      }, r.exports = c;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(n, r, s) {
      var i = n("./stream/GenericWorker");
      s.STORE = { magic: "\0\0", compressWorker: function() {
        return new i("STORE compression");
      }, uncompressWorker: function() {
        return new i("STORE decompression");
      } }, s.DEFLATE = n("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(n, r, s) {
      var i = n("./utils"), a = function() {
        for (var o, f = [], c = 0; c < 256; c++) {
          o = c;
          for (var l = 0; l < 8; l++) o = 1 & o ? 3988292384 ^ o >>> 1 : o >>> 1;
          f[c] = o;
        }
        return f;
      }();
      r.exports = function(o, f) {
        return o !== void 0 && o.length ? i.getTypeOf(o) !== "string" ? function(c, l, h, m) {
          var v = a, b = m + h;
          c ^= -1;
          for (var A = m; A < b; A++) c = c >>> 8 ^ v[255 & (c ^ l[A])];
          return -1 ^ c;
        }(0 | f, o, o.length, 0) : function(c, l, h, m) {
          var v = a, b = m + h;
          c ^= -1;
          for (var A = m; A < b; A++) c = c >>> 8 ^ v[255 & (c ^ l.charCodeAt(A))];
          return -1 ^ c;
        }(0 | f, o, o.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(n, r, s) {
      s.base64 = false, s.binary = false, s.dir = false, s.createFolders = true, s.date = null, s.compression = null, s.compressionOptions = null, s.comment = null, s.unixPermissions = null, s.dosPermissions = null;
    }, {}], 6: [function(n, r, s) {
      var i = null;
      i = typeof Promise < "u" ? Promise : n("lie"), r.exports = { Promise: i };
    }, { lie: 37 }], 7: [function(n, r, s) {
      var i = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", a = n("pako"), o = n("./utils"), f = n("./stream/GenericWorker"), c = i ? "uint8array" : "array";
      function l(h, m) {
        f.call(this, "FlateWorker/" + h), this._pako = null, this._pakoAction = h, this._pakoOptions = m, this.meta = {};
      }
      s.magic = "\b\0", o.inherits(l, f), l.prototype.processChunk = function(h) {
        this.meta = h.meta, this._pako === null && this._createPako(), this._pako.push(o.transformTo(c, h.data), false);
      }, l.prototype.flush = function() {
        f.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], true);
      }, l.prototype.cleanUp = function() {
        f.prototype.cleanUp.call(this), this._pako = null;
      }, l.prototype._createPako = function() {
        this._pako = new a[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
        var h = this;
        this._pako.onData = function(m) {
          h.push({ data: m, meta: h.meta });
        };
      }, s.compressWorker = function(h) {
        return new l("Deflate", h);
      }, s.uncompressWorker = function() {
        return new l("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(n, r, s) {
      function i(v, b) {
        var A, _ = "";
        for (A = 0; A < b; A++) _ += String.fromCharCode(255 & v), v >>>= 8;
        return _;
      }
      function a(v, b, A, _, C, I) {
        var S, $, F = v.file, U = v.compression, Q = I !== c.utf8encode, P = o.transformTo("string", I(F.name)), N = o.transformTo("string", c.utf8encode(F.name)), L = F.comment, B = o.transformTo("string", I(L)), u = o.transformTo("string", c.utf8encode(L)), p = N.length !== F.name.length, d = u.length !== L.length, y = "", w = "", E = "", M = F.dir, x = F.date, g = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        b && !A || (g.crc32 = v.crc32, g.compressedSize = v.compressedSize, g.uncompressedSize = v.uncompressedSize);
        var k = 0;
        b && (k |= 8), Q || !p && !d || (k |= 2048);
        var T = 0, O = 0;
        M && (T |= 16), C === "UNIX" ? (O = 798, T |= function(Y, J) {
          var G = Y;
          return Y || (G = J ? 16893 : 33204), (65535 & G) << 16;
        }(F.unixPermissions, M)) : (O = 20, T |= function(Y) {
          return 63 & (Y || 0);
        }(F.dosPermissions)), S = x.getUTCHours(), S <<= 6, S |= x.getUTCMinutes(), S <<= 5, S |= x.getUTCSeconds() / 2, $ = x.getUTCFullYear() - 1980, $ <<= 4, $ |= x.getUTCMonth() + 1, $ <<= 5, $ |= x.getUTCDate(), p && (w = i(1, 1) + i(l(P), 4) + N, y += "up" + i(w.length, 2) + w), d && (E = i(1, 1) + i(l(B), 4) + u, y += "uc" + i(E.length, 2) + E);
        var K = "";
        return K += `
\0`, K += i(k, 2), K += U.magic, K += i(S, 2), K += i($, 2), K += i(g.crc32, 4), K += i(g.compressedSize, 4), K += i(g.uncompressedSize, 4), K += i(P.length, 2), K += i(y.length, 2), { fileRecord: h.LOCAL_FILE_HEADER + K + P + y, dirRecord: h.CENTRAL_FILE_HEADER + i(O, 2) + K + i(B.length, 2) + "\0\0\0\0" + i(T, 4) + i(_, 4) + P + y + B };
      }
      var o = n("../utils"), f = n("../stream/GenericWorker"), c = n("../utf8"), l = n("../crc32"), h = n("../signature");
      function m(v, b, A, _) {
        f.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = b, this.zipPlatform = A, this.encodeFileName = _, this.streamFiles = v, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      o.inherits(m, f), m.prototype.push = function(v) {
        var b = v.meta.percent || 0, A = this.entriesCount, _ = this._sources.length;
        this.accumulate ? this.contentBuffer.push(v) : (this.bytesWritten += v.data.length, f.prototype.push.call(this, { data: v.data, meta: { currentFile: this.currentFile, percent: A ? (b + 100 * (A - _ - 1)) / A : 100 } }));
      }, m.prototype.openedSource = function(v) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = v.file.name;
        var b = this.streamFiles && !v.file.dir;
        if (b) {
          var A = a(v, b, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: A.fileRecord, meta: { percent: 0 } });
        } else this.accumulate = true;
      }, m.prototype.closedSource = function(v) {
        this.accumulate = false;
        var b = this.streamFiles && !v.file.dir, A = a(v, b, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(A.dirRecord), b) this.push({ data: function(_) {
          return h.DATA_DESCRIPTOR + i(_.crc32, 4) + i(_.compressedSize, 4) + i(_.uncompressedSize, 4);
        }(v), meta: { percent: 100 } });
        else for (this.push({ data: A.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, m.prototype.flush = function() {
        for (var v = this.bytesWritten, b = 0; b < this.dirRecords.length; b++) this.push({ data: this.dirRecords[b], meta: { percent: 100 } });
        var A = this.bytesWritten - v, _ = function(C, I, S, $, F) {
          var U = o.transformTo("string", F($));
          return h.CENTRAL_DIRECTORY_END + "\0\0\0\0" + i(C, 2) + i(C, 2) + i(I, 4) + i(S, 4) + i(U.length, 2) + U;
        }(this.dirRecords.length, A, v, this.zipComment, this.encodeFileName);
        this.push({ data: _, meta: { percent: 100 } });
      }, m.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, m.prototype.registerPrevious = function(v) {
        this._sources.push(v);
        var b = this;
        return v.on("data", function(A) {
          b.processChunk(A);
        }), v.on("end", function() {
          b.closedSource(b.previous.streamInfo), b._sources.length ? b.prepareNextSource() : b.end();
        }), v.on("error", function(A) {
          b.error(A);
        }), this;
      }, m.prototype.resume = function() {
        return !!f.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
      }, m.prototype.error = function(v) {
        var b = this._sources;
        if (!f.prototype.error.call(this, v)) return false;
        for (var A = 0; A < b.length; A++) try {
          b[A].error(v);
        } catch {
        }
        return true;
      }, m.prototype.lock = function() {
        f.prototype.lock.call(this);
        for (var v = this._sources, b = 0; b < v.length; b++) v[b].lock();
      }, r.exports = m;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(n, r, s) {
      var i = n("../compressions"), a = n("./ZipFileWorker");
      s.generateWorker = function(o, f, c) {
        var l = new a(f.streamFiles, c, f.platform, f.encodeFileName), h = 0;
        try {
          o.forEach(function(m, v) {
            h++;
            var b = function(I, S) {
              var $ = I || S, F = i[$];
              if (!F) throw new Error($ + " is not a valid compression method !");
              return F;
            }(v.options.compression, f.compression), A = v.options.compressionOptions || f.compressionOptions || {}, _ = v.dir, C = v.date;
            v._compressWorker(b, A).withStreamInfo("file", { name: m, dir: _, date: C, comment: v.comment || "", unixPermissions: v.unixPermissions, dosPermissions: v.dosPermissions }).pipe(l);
          }), l.entriesCount = h;
        } catch (m) {
          l.error(m);
        }
        return l;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(n, r, s) {
      function i() {
        if (!(this instanceof i)) return new i();
        if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var a = new i();
          for (var o in this) typeof this[o] != "function" && (a[o] = this[o]);
          return a;
        };
      }
      (i.prototype = n("./object")).loadAsync = n("./load"), i.support = n("./support"), i.defaults = n("./defaults"), i.version = "3.10.1", i.loadAsync = function(a, o) {
        return new i().loadAsync(a, o);
      }, i.external = n("./external"), r.exports = i;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(n, r, s) {
      var i = n("./utils"), a = n("./external"), o = n("./utf8"), f = n("./zipEntries"), c = n("./stream/Crc32Probe"), l = n("./nodejsUtils");
      function h(m) {
        return new a.Promise(function(v, b) {
          var A = m.decompressed.getContentWorker().pipe(new c());
          A.on("error", function(_) {
            b(_);
          }).on("end", function() {
            A.streamInfo.crc32 !== m.decompressed.crc32 ? b(new Error("Corrupted zip : CRC32 mismatch")) : v();
          }).resume();
        });
      }
      r.exports = function(m, v) {
        var b = this;
        return v = i.extend(v || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: o.utf8decode }), l.isNode && l.isStream(m) ? a.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : i.prepareContent("the loaded zip file", m, true, v.optimizedBinaryString, v.base64).then(function(A) {
          var _ = new f(v);
          return _.load(A), _;
        }).then(function(A) {
          var _ = [a.Promise.resolve(A)], C = A.files;
          if (v.checkCRC32) for (var I = 0; I < C.length; I++) _.push(h(C[I]));
          return a.Promise.all(_);
        }).then(function(A) {
          for (var _ = A.shift(), C = _.files, I = 0; I < C.length; I++) {
            var S = C[I], $ = S.fileNameStr, F = i.resolve(S.fileNameStr);
            b.file(F, S.decompressed, { binary: true, optimizedBinaryString: true, date: S.date, dir: S.dir, comment: S.fileCommentStr.length ? S.fileCommentStr : null, unixPermissions: S.unixPermissions, dosPermissions: S.dosPermissions, createFolders: v.createFolders }), S.dir || (b.file(F).unsafeOriginalName = $);
          }
          return _.zipComment.length && (b.comment = _.zipComment), b;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(n, r, s) {
      var i = n("../utils"), a = n("../stream/GenericWorker");
      function o(f, c) {
        a.call(this, "Nodejs stream input adapter for " + f), this._upstreamEnded = false, this._bindStream(c);
      }
      i.inherits(o, a), o.prototype._bindStream = function(f) {
        var c = this;
        (this._stream = f).pause(), f.on("data", function(l) {
          c.push({ data: l, meta: { percent: 0 } });
        }).on("error", function(l) {
          c.isPaused ? this.generatedError = l : c.error(l);
        }).on("end", function() {
          c.isPaused ? c._upstreamEnded = true : c.end();
        });
      }, o.prototype.pause = function() {
        return !!a.prototype.pause.call(this) && (this._stream.pause(), true);
      }, o.prototype.resume = function() {
        return !!a.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
      }, r.exports = o;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(n, r, s) {
      var i = n("readable-stream").Readable;
      function a(o, f, c) {
        i.call(this, f), this._helper = o;
        var l = this;
        o.on("data", function(h, m) {
          l.push(h) || l._helper.pause(), c && c(m);
        }).on("error", function(h) {
          l.emit("error", h);
        }).on("end", function() {
          l.push(null);
        });
      }
      n("../utils").inherits(a, i), a.prototype._read = function() {
        this._helper.resume();
      }, r.exports = a;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(n, r, s) {
      r.exports = { isNode: typeof hr < "u", newBufferFrom: function(i, a) {
        if (hr.from && hr.from !== Uint8Array.from) return hr.from(i, a);
        if (typeof i == "number") throw new Error('The "data" argument must not be a number');
        return new hr(i, a);
      }, allocBuffer: function(i) {
        if (hr.alloc) return hr.alloc(i);
        var a = new hr(i);
        return a.fill(0), a;
      }, isBuffer: function(i) {
        return hr.isBuffer(i);
      }, isStream: function(i) {
        return i && typeof i.on == "function" && typeof i.pause == "function" && typeof i.resume == "function";
      } };
    }, {}], 15: [function(n, r, s) {
      function i(F, U, Q) {
        var P, N = o.getTypeOf(U), L = o.extend(Q || {}, l);
        L.date = L.date || /* @__PURE__ */ new Date(), L.compression !== null && (L.compression = L.compression.toUpperCase()), typeof L.unixPermissions == "string" && (L.unixPermissions = parseInt(L.unixPermissions, 8)), L.unixPermissions && 16384 & L.unixPermissions && (L.dir = true), L.dosPermissions && 16 & L.dosPermissions && (L.dir = true), L.dir && (F = C(F)), L.createFolders && (P = _(F)) && I.call(this, P, true);
        var B = N === "string" && L.binary === false && L.base64 === false;
        Q && Q.binary !== void 0 || (L.binary = !B), (U instanceof h && U.uncompressedSize === 0 || L.dir || !U || U.length === 0) && (L.base64 = false, L.binary = true, U = "", L.compression = "STORE", N = "string");
        var u = null;
        u = U instanceof h || U instanceof f ? U : b.isNode && b.isStream(U) ? new A(F, U) : o.prepareContent(F, U, L.binary, L.optimizedBinaryString, L.base64);
        var p = new m(F, u, L);
        this.files[F] = p;
      }
      var a = n("./utf8"), o = n("./utils"), f = n("./stream/GenericWorker"), c = n("./stream/StreamHelper"), l = n("./defaults"), h = n("./compressedObject"), m = n("./zipObject"), v = n("./generate"), b = n("./nodejsUtils"), A = n("./nodejs/NodejsStreamInputAdapter"), _ = function(F) {
        F.slice(-1) === "/" && (F = F.substring(0, F.length - 1));
        var U = F.lastIndexOf("/");
        return 0 < U ? F.substring(0, U) : "";
      }, C = function(F) {
        return F.slice(-1) !== "/" && (F += "/"), F;
      }, I = function(F, U) {
        return U = U !== void 0 ? U : l.createFolders, F = C(F), this.files[F] || i.call(this, F, null, { dir: true, createFolders: U }), this.files[F];
      };
      function S(F) {
        return Object.prototype.toString.call(F) === "[object RegExp]";
      }
      var $ = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(F) {
        var U, Q, P;
        for (U in this.files) P = this.files[U], (Q = U.slice(this.root.length, U.length)) && U.slice(0, this.root.length) === this.root && F(Q, P);
      }, filter: function(F) {
        var U = [];
        return this.forEach(function(Q, P) {
          F(Q, P) && U.push(P);
        }), U;
      }, file: function(F, U, Q) {
        if (arguments.length !== 1) return F = this.root + F, i.call(this, F, U, Q), this;
        if (S(F)) {
          var P = F;
          return this.filter(function(L, B) {
            return !B.dir && P.test(L);
          });
        }
        var N = this.files[this.root + F];
        return N && !N.dir ? N : null;
      }, folder: function(F) {
        if (!F) return this;
        if (S(F)) return this.filter(function(N, L) {
          return L.dir && F.test(N);
        });
        var U = this.root + F, Q = I.call(this, U), P = this.clone();
        return P.root = Q.name, P;
      }, remove: function(F) {
        F = this.root + F;
        var U = this.files[F];
        if (U || (F.slice(-1) !== "/" && (F += "/"), U = this.files[F]), U && !U.dir) delete this.files[F];
        else for (var Q = this.filter(function(N, L) {
          return L.name.slice(0, F.length) === F;
        }), P = 0; P < Q.length; P++) delete this.files[Q[P].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(F) {
        var U, Q = {};
        try {
          if ((Q = o.extend(F || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: a.utf8encode })).type = Q.type.toLowerCase(), Q.compression = Q.compression.toUpperCase(), Q.type === "binarystring" && (Q.type = "string"), !Q.type) throw new Error("No output type specified.");
          o.checkSupport(Q.type), Q.platform !== "darwin" && Q.platform !== "freebsd" && Q.platform !== "linux" && Q.platform !== "sunos" || (Q.platform = "UNIX"), Q.platform === "win32" && (Q.platform = "DOS");
          var P = Q.comment || this.comment || "";
          U = v.generateWorker(this, Q, P);
        } catch (N) {
          (U = new f("error")).error(N);
        }
        return new c(U, Q.type || "string", Q.mimeType);
      }, generateAsync: function(F, U) {
        return this.generateInternalStream(F).accumulate(U);
      }, generateNodeStream: function(F, U) {
        return (F = F || {}).type || (F.type = "nodebuffer"), this.generateInternalStream(F).toNodejsStream(U);
      } };
      r.exports = $;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(n, r, s) {
      r.exports = n("stream");
    }, { stream: void 0 }], 17: [function(n, r, s) {
      var i = n("./DataReader");
      function a(o) {
        i.call(this, o);
        for (var f = 0; f < this.data.length; f++) o[f] = 255 & o[f];
      }
      n("../utils").inherits(a, i), a.prototype.byteAt = function(o) {
        return this.data[this.zero + o];
      }, a.prototype.lastIndexOfSignature = function(o) {
        for (var f = o.charCodeAt(0), c = o.charCodeAt(1), l = o.charCodeAt(2), h = o.charCodeAt(3), m = this.length - 4; 0 <= m; --m) if (this.data[m] === f && this.data[m + 1] === c && this.data[m + 2] === l && this.data[m + 3] === h) return m - this.zero;
        return -1;
      }, a.prototype.readAndCheckSignature = function(o) {
        var f = o.charCodeAt(0), c = o.charCodeAt(1), l = o.charCodeAt(2), h = o.charCodeAt(3), m = this.readData(4);
        return f === m[0] && c === m[1] && l === m[2] && h === m[3];
      }, a.prototype.readData = function(o) {
        if (this.checkOffset(o), o === 0) return [];
        var f = this.data.slice(this.zero + this.index, this.zero + this.index + o);
        return this.index += o, f;
      }, r.exports = a;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(n, r, s) {
      var i = n("../utils");
      function a(o) {
        this.data = o, this.length = o.length, this.index = 0, this.zero = 0;
      }
      a.prototype = { checkOffset: function(o) {
        this.checkIndex(this.index + o);
      }, checkIndex: function(o) {
        if (this.length < this.zero + o || o < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + o + "). Corrupted zip ?");
      }, setIndex: function(o) {
        this.checkIndex(o), this.index = o;
      }, skip: function(o) {
        this.setIndex(this.index + o);
      }, byteAt: function() {
      }, readInt: function(o) {
        var f, c = 0;
        for (this.checkOffset(o), f = this.index + o - 1; f >= this.index; f--) c = (c << 8) + this.byteAt(f);
        return this.index += o, c;
      }, readString: function(o) {
        return i.transformTo("string", this.readData(o));
      }, readData: function() {
      }, lastIndexOfSignature: function() {
      }, readAndCheckSignature: function() {
      }, readDate: function() {
        var o = this.readInt(4);
        return new Date(Date.UTC(1980 + (o >> 25 & 127), (o >> 21 & 15) - 1, o >> 16 & 31, o >> 11 & 31, o >> 5 & 63, (31 & o) << 1));
      } }, r.exports = a;
    }, { "../utils": 32 }], 19: [function(n, r, s) {
      var i = n("./Uint8ArrayReader");
      function a(o) {
        i.call(this, o);
      }
      n("../utils").inherits(a, i), a.prototype.readData = function(o) {
        this.checkOffset(o);
        var f = this.data.slice(this.zero + this.index, this.zero + this.index + o);
        return this.index += o, f;
      }, r.exports = a;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(n, r, s) {
      var i = n("./DataReader");
      function a(o) {
        i.call(this, o);
      }
      n("../utils").inherits(a, i), a.prototype.byteAt = function(o) {
        return this.data.charCodeAt(this.zero + o);
      }, a.prototype.lastIndexOfSignature = function(o) {
        return this.data.lastIndexOf(o) - this.zero;
      }, a.prototype.readAndCheckSignature = function(o) {
        return o === this.readData(4);
      }, a.prototype.readData = function(o) {
        this.checkOffset(o);
        var f = this.data.slice(this.zero + this.index, this.zero + this.index + o);
        return this.index += o, f;
      }, r.exports = a;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(n, r, s) {
      var i = n("./ArrayReader");
      function a(o) {
        i.call(this, o);
      }
      n("../utils").inherits(a, i), a.prototype.readData = function(o) {
        if (this.checkOffset(o), o === 0) return new Uint8Array(0);
        var f = this.data.subarray(this.zero + this.index, this.zero + this.index + o);
        return this.index += o, f;
      }, r.exports = a;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(n, r, s) {
      var i = n("../utils"), a = n("../support"), o = n("./ArrayReader"), f = n("./StringReader"), c = n("./NodeBufferReader"), l = n("./Uint8ArrayReader");
      r.exports = function(h) {
        var m = i.getTypeOf(h);
        return i.checkSupport(m), m !== "string" || a.uint8array ? m === "nodebuffer" ? new c(h) : a.uint8array ? new l(i.transformTo("uint8array", h)) : new o(i.transformTo("array", h)) : new f(h);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(n, r, s) {
      s.LOCAL_FILE_HEADER = "PK", s.CENTRAL_FILE_HEADER = "PK", s.CENTRAL_DIRECTORY_END = "PK", s.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", s.ZIP64_CENTRAL_DIRECTORY_END = "PK", s.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(n, r, s) {
      var i = n("./GenericWorker"), a = n("../utils");
      function o(f) {
        i.call(this, "ConvertWorker to " + f), this.destType = f;
      }
      a.inherits(o, i), o.prototype.processChunk = function(f) {
        this.push({ data: a.transformTo(this.destType, f.data), meta: f.meta });
      }, r.exports = o;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(n, r, s) {
      var i = n("./GenericWorker"), a = n("../crc32");
      function o() {
        i.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      n("../utils").inherits(o, i), o.prototype.processChunk = function(f) {
        this.streamInfo.crc32 = a(f.data, this.streamInfo.crc32 || 0), this.push(f);
      }, r.exports = o;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(n, r, s) {
      var i = n("../utils"), a = n("./GenericWorker");
      function o(f) {
        a.call(this, "DataLengthProbe for " + f), this.propName = f, this.withStreamInfo(f, 0);
      }
      i.inherits(o, a), o.prototype.processChunk = function(f) {
        if (f) {
          var c = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = c + f.data.length;
        }
        a.prototype.processChunk.call(this, f);
      }, r.exports = o;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(n, r, s) {
      var i = n("../utils"), a = n("./GenericWorker");
      function o(f) {
        a.call(this, "DataWorker");
        var c = this;
        this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, f.then(function(l) {
          c.dataIsReady = true, c.data = l, c.max = l && l.length || 0, c.type = i.getTypeOf(l), c.isPaused || c._tickAndRepeat();
        }, function(l) {
          c.error(l);
        });
      }
      i.inherits(o, a), o.prototype.cleanUp = function() {
        a.prototype.cleanUp.call(this), this.data = null;
      }, o.prototype.resume = function() {
        return !!a.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, i.delay(this._tickAndRepeat, [], this)), true);
      }, o.prototype._tickAndRepeat = function() {
        this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (i.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
      }, o.prototype._tick = function() {
        if (this.isPaused || this.isFinished) return false;
        var f = null, c = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max) return this.end();
        switch (this.type) {
          case "string":
            f = this.data.substring(this.index, c);
            break;
          case "uint8array":
            f = this.data.subarray(this.index, c);
            break;
          case "array":
          case "nodebuffer":
            f = this.data.slice(this.index, c);
        }
        return this.index = c, this.push({ data: f, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, r.exports = o;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(n, r, s) {
      function i(a) {
        this.name = a || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      i.prototype = { push: function(a) {
        this.emit("data", a);
      }, end: function() {
        if (this.isFinished) return false;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = true;
        } catch (a) {
          this.emit("error", a);
        }
        return true;
      }, error: function(a) {
        return !this.isFinished && (this.isPaused ? this.generatedError = a : (this.isFinished = true, this.emit("error", a), this.previous && this.previous.error(a), this.cleanUp()), true);
      }, on: function(a, o) {
        return this._listeners[a].push(o), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(a, o) {
        if (this._listeners[a]) for (var f = 0; f < this._listeners[a].length; f++) this._listeners[a][f].call(this, o);
      }, pipe: function(a) {
        return a.registerPrevious(this);
      }, registerPrevious: function(a) {
        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = a.streamInfo, this.mergeStreamInfo(), this.previous = a;
        var o = this;
        return a.on("data", function(f) {
          o.processChunk(f);
        }), a.on("end", function() {
          o.end();
        }), a.on("error", function(f) {
          o.error(f);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
      }, resume: function() {
        if (!this.isPaused || this.isFinished) return false;
        var a = this.isPaused = false;
        return this.generatedError && (this.error(this.generatedError), a = true), this.previous && this.previous.resume(), !a;
      }, flush: function() {
      }, processChunk: function(a) {
        this.push(a);
      }, withStreamInfo: function(a, o) {
        return this.extraStreamInfo[a] = o, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var a in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, a) && (this.streamInfo[a] = this.extraStreamInfo[a]);
      }, lock: function() {
        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = true, this.previous && this.previous.lock();
      }, toString: function() {
        var a = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + a : a;
      } }, r.exports = i;
    }, {}], 29: [function(n, r, s) {
      var i = n("../utils"), a = n("./ConvertWorker"), o = n("./GenericWorker"), f = n("../base64"), c = n("../support"), l = n("../external"), h = null;
      if (c.nodestream) try {
        h = n("../nodejs/NodejsStreamOutputAdapter");
      } catch {
      }
      function m(b, A) {
        return new l.Promise(function(_, C) {
          var I = [], S = b._internalType, $ = b._outputType, F = b._mimeType;
          b.on("data", function(U, Q) {
            I.push(U), A && A(Q);
          }).on("error", function(U) {
            I = [], C(U);
          }).on("end", function() {
            try {
              var U = function(Q, P, N) {
                switch (Q) {
                  case "blob":
                    return i.newBlob(i.transformTo("arraybuffer", P), N);
                  case "base64":
                    return f.encode(P);
                  default:
                    return i.transformTo(Q, P);
                }
              }($, function(Q, P) {
                var N, L = 0, B = null, u = 0;
                for (N = 0; N < P.length; N++) u += P[N].length;
                switch (Q) {
                  case "string":
                    return P.join("");
                  case "array":
                    return Array.prototype.concat.apply([], P);
                  case "uint8array":
                    for (B = new Uint8Array(u), N = 0; N < P.length; N++) B.set(P[N], L), L += P[N].length;
                    return B;
                  case "nodebuffer":
                    return hr.concat(P);
                  default:
                    throw new Error("concat : unsupported type '" + Q + "'");
                }
              }(S, I), F);
              _(U);
            } catch (Q) {
              C(Q);
            }
            I = [];
          }).resume();
        });
      }
      function v(b, A, _) {
        var C = A;
        switch (A) {
          case "blob":
          case "arraybuffer":
            C = "uint8array";
            break;
          case "base64":
            C = "string";
        }
        try {
          this._internalType = C, this._outputType = A, this._mimeType = _, i.checkSupport(C), this._worker = b.pipe(new a(C)), b.lock();
        } catch (I) {
          this._worker = new o("error"), this._worker.error(I);
        }
      }
      v.prototype = { accumulate: function(b) {
        return m(this, b);
      }, on: function(b, A) {
        var _ = this;
        return b === "data" ? this._worker.on(b, function(C) {
          A.call(_, C.data, C.meta);
        }) : this._worker.on(b, function() {
          i.delay(A, arguments, _);
        }), this;
      }, resume: function() {
        return i.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(b) {
        if (i.checkSupport("nodestream"), this._outputType !== "nodebuffer") throw new Error(this._outputType + " is not supported by this method");
        return new h(this, { objectMode: this._outputType !== "nodebuffer" }, b);
      } }, r.exports = v;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(n, r, s) {
      if (s.base64 = true, s.array = true, s.string = true, s.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", s.nodebuffer = typeof hr < "u", s.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u") s.blob = false;
      else {
        var i = new ArrayBuffer(0);
        try {
          s.blob = new Blob([i], { type: "application/zip" }).size === 0;
        } catch {
          try {
            var a = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            a.append(i), s.blob = a.getBlob("application/zip").size === 0;
          } catch {
            s.blob = false;
          }
        }
      }
      try {
        s.nodestream = !!n("readable-stream").Readable;
      } catch {
        s.nodestream = false;
      }
    }, { "readable-stream": 16 }], 31: [function(n, r, s) {
      for (var i = n("./utils"), a = n("./support"), o = n("./nodejsUtils"), f = n("./stream/GenericWorker"), c = new Array(256), l = 0; l < 256; l++) c[l] = 252 <= l ? 6 : 248 <= l ? 5 : 240 <= l ? 4 : 224 <= l ? 3 : 192 <= l ? 2 : 1;
      c[254] = c[254] = 1;
      function h() {
        f.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function m() {
        f.call(this, "utf-8 encode");
      }
      s.utf8encode = function(v) {
        return a.nodebuffer ? o.newBufferFrom(v, "utf-8") : function(b) {
          var A, _, C, I, S, $ = b.length, F = 0;
          for (I = 0; I < $; I++) (64512 & (_ = b.charCodeAt(I))) == 55296 && I + 1 < $ && (64512 & (C = b.charCodeAt(I + 1))) == 56320 && (_ = 65536 + (_ - 55296 << 10) + (C - 56320), I++), F += _ < 128 ? 1 : _ < 2048 ? 2 : _ < 65536 ? 3 : 4;
          for (A = a.uint8array ? new Uint8Array(F) : new Array(F), I = S = 0; S < F; I++) (64512 & (_ = b.charCodeAt(I))) == 55296 && I + 1 < $ && (64512 & (C = b.charCodeAt(I + 1))) == 56320 && (_ = 65536 + (_ - 55296 << 10) + (C - 56320), I++), _ < 128 ? A[S++] = _ : (_ < 2048 ? A[S++] = 192 | _ >>> 6 : (_ < 65536 ? A[S++] = 224 | _ >>> 12 : (A[S++] = 240 | _ >>> 18, A[S++] = 128 | _ >>> 12 & 63), A[S++] = 128 | _ >>> 6 & 63), A[S++] = 128 | 63 & _);
          return A;
        }(v);
      }, s.utf8decode = function(v) {
        return a.nodebuffer ? i.transformTo("nodebuffer", v).toString("utf-8") : function(b) {
          var A, _, C, I, S = b.length, $ = new Array(2 * S);
          for (A = _ = 0; A < S; ) if ((C = b[A++]) < 128) $[_++] = C;
          else if (4 < (I = c[C])) $[_++] = 65533, A += I - 1;
          else {
            for (C &= I === 2 ? 31 : I === 3 ? 15 : 7; 1 < I && A < S; ) C = C << 6 | 63 & b[A++], I--;
            1 < I ? $[_++] = 65533 : C < 65536 ? $[_++] = C : (C -= 65536, $[_++] = 55296 | C >> 10 & 1023, $[_++] = 56320 | 1023 & C);
          }
          return $.length !== _ && ($.subarray ? $ = $.subarray(0, _) : $.length = _), i.applyFromCharCode($);
        }(v = i.transformTo(a.uint8array ? "uint8array" : "array", v));
      }, i.inherits(h, f), h.prototype.processChunk = function(v) {
        var b = i.transformTo(a.uint8array ? "uint8array" : "array", v.data);
        if (this.leftOver && this.leftOver.length) {
          if (a.uint8array) {
            var A = b;
            (b = new Uint8Array(A.length + this.leftOver.length)).set(this.leftOver, 0), b.set(A, this.leftOver.length);
          } else b = this.leftOver.concat(b);
          this.leftOver = null;
        }
        var _ = function(I, S) {
          var $;
          for ((S = S || I.length) > I.length && (S = I.length), $ = S - 1; 0 <= $ && (192 & I[$]) == 128; ) $--;
          return $ < 0 || $ === 0 ? S : $ + c[I[$]] > S ? $ : S;
        }(b), C = b;
        _ !== b.length && (a.uint8array ? (C = b.subarray(0, _), this.leftOver = b.subarray(_, b.length)) : (C = b.slice(0, _), this.leftOver = b.slice(_, b.length))), this.push({ data: s.utf8decode(C), meta: v.meta });
      }, h.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, s.Utf8DecodeWorker = h, i.inherits(m, f), m.prototype.processChunk = function(v) {
        this.push({ data: s.utf8encode(v.data), meta: v.meta });
      }, s.Utf8EncodeWorker = m;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(n, r, s) {
      var i = n("./support"), a = n("./base64"), o = n("./nodejsUtils"), f = n("./external");
      function c(A) {
        return A;
      }
      function l(A, _) {
        for (var C = 0; C < A.length; ++C) _[C] = 255 & A.charCodeAt(C);
        return _;
      }
      n("setimmediate"), s.newBlob = function(A, _) {
        s.checkSupport("blob");
        try {
          return new Blob([A], { type: _ });
        } catch {
          try {
            var C = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return C.append(A), C.getBlob(_);
          } catch {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var h = { stringifyByChunk: function(A, _, C) {
        var I = [], S = 0, $ = A.length;
        if ($ <= C) return String.fromCharCode.apply(null, A);
        for (; S < $; ) _ === "array" || _ === "nodebuffer" ? I.push(String.fromCharCode.apply(null, A.slice(S, Math.min(S + C, $)))) : I.push(String.fromCharCode.apply(null, A.subarray(S, Math.min(S + C, $)))), S += C;
        return I.join("");
      }, stringifyByChar: function(A) {
        for (var _ = "", C = 0; C < A.length; C++) _ += String.fromCharCode(A[C]);
        return _;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return i.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch {
          return false;
        }
      }(), nodebuffer: function() {
        try {
          return i.nodebuffer && String.fromCharCode.apply(null, o.allocBuffer(1)).length === 1;
        } catch {
          return false;
        }
      }() } };
      function m(A) {
        var _ = 65536, C = s.getTypeOf(A), I = true;
        if (C === "uint8array" ? I = h.applyCanBeUsed.uint8array : C === "nodebuffer" && (I = h.applyCanBeUsed.nodebuffer), I) for (; 1 < _; ) try {
          return h.stringifyByChunk(A, C, _);
        } catch {
          _ = Math.floor(_ / 2);
        }
        return h.stringifyByChar(A);
      }
      function v(A, _) {
        for (var C = 0; C < A.length; C++) _[C] = A[C];
        return _;
      }
      s.applyFromCharCode = m;
      var b = {};
      b.string = { string: c, array: function(A) {
        return l(A, new Array(A.length));
      }, arraybuffer: function(A) {
        return b.string.uint8array(A).buffer;
      }, uint8array: function(A) {
        return l(A, new Uint8Array(A.length));
      }, nodebuffer: function(A) {
        return l(A, o.allocBuffer(A.length));
      } }, b.array = { string: m, array: c, arraybuffer: function(A) {
        return new Uint8Array(A).buffer;
      }, uint8array: function(A) {
        return new Uint8Array(A);
      }, nodebuffer: function(A) {
        return o.newBufferFrom(A);
      } }, b.arraybuffer = { string: function(A) {
        return m(new Uint8Array(A));
      }, array: function(A) {
        return v(new Uint8Array(A), new Array(A.byteLength));
      }, arraybuffer: c, uint8array: function(A) {
        return new Uint8Array(A);
      }, nodebuffer: function(A) {
        return o.newBufferFrom(new Uint8Array(A));
      } }, b.uint8array = { string: m, array: function(A) {
        return v(A, new Array(A.length));
      }, arraybuffer: function(A) {
        return A.buffer;
      }, uint8array: c, nodebuffer: function(A) {
        return o.newBufferFrom(A);
      } }, b.nodebuffer = { string: m, array: function(A) {
        return v(A, new Array(A.length));
      }, arraybuffer: function(A) {
        return b.nodebuffer.uint8array(A).buffer;
      }, uint8array: function(A) {
        return v(A, new Uint8Array(A.length));
      }, nodebuffer: c }, s.transformTo = function(A, _) {
        if (_ = _ || "", !A) return _;
        s.checkSupport(A);
        var C = s.getTypeOf(_);
        return b[C][A](_);
      }, s.resolve = function(A) {
        for (var _ = A.split("/"), C = [], I = 0; I < _.length; I++) {
          var S = _[I];
          S === "." || S === "" && I !== 0 && I !== _.length - 1 || (S === ".." ? C.pop() : C.push(S));
        }
        return C.join("/");
      }, s.getTypeOf = function(A) {
        return typeof A == "string" ? "string" : Object.prototype.toString.call(A) === "[object Array]" ? "array" : i.nodebuffer && o.isBuffer(A) ? "nodebuffer" : i.uint8array && A instanceof Uint8Array ? "uint8array" : i.arraybuffer && A instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, s.checkSupport = function(A) {
        if (!i[A.toLowerCase()]) throw new Error(A + " is not supported by this platform");
      }, s.MAX_VALUE_16BITS = 65535, s.MAX_VALUE_32BITS = -1, s.pretty = function(A) {
        var _, C, I = "";
        for (C = 0; C < (A || "").length; C++) I += "\\x" + ((_ = A.charCodeAt(C)) < 16 ? "0" : "") + _.toString(16).toUpperCase();
        return I;
      }, s.delay = function(A, _, C) {
        setImmediate(function() {
          A.apply(C || null, _ || []);
        });
      }, s.inherits = function(A, _) {
        function C() {
        }
        C.prototype = _.prototype, A.prototype = new C();
      }, s.extend = function() {
        var A, _, C = {};
        for (A = 0; A < arguments.length; A++) for (_ in arguments[A]) Object.prototype.hasOwnProperty.call(arguments[A], _) && C[_] === void 0 && (C[_] = arguments[A][_]);
        return C;
      }, s.prepareContent = function(A, _, C, I, S) {
        return f.Promise.resolve(_).then(function($) {
          return i.blob && ($ instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call($)) !== -1) && typeof FileReader < "u" ? new f.Promise(function(F, U) {
            var Q = new FileReader();
            Q.onload = function(P) {
              F(P.target.result);
            }, Q.onerror = function(P) {
              U(P.target.error);
            }, Q.readAsArrayBuffer($);
          }) : $;
        }).then(function($) {
          var F = s.getTypeOf($);
          return F ? (F === "arraybuffer" ? $ = s.transformTo("uint8array", $) : F === "string" && (S ? $ = a.decode($) : C && I !== true && ($ = function(U) {
            return l(U, i.uint8array ? new Uint8Array(U.length) : new Array(U.length));
          }($))), $) : f.Promise.reject(new Error("Can't read the data of '" + A + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(n, r, s) {
      var i = n("./reader/readerFor"), a = n("./utils"), o = n("./signature"), f = n("./zipEntry"), c = n("./support");
      function l(h) {
        this.files = [], this.loadOptions = h;
      }
      l.prototype = { checkSignature: function(h) {
        if (!this.reader.readAndCheckSignature(h)) {
          this.reader.index -= 4;
          var m = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + a.pretty(m) + ", expected " + a.pretty(h) + ")");
        }
      }, isSignature: function(h, m) {
        var v = this.reader.index;
        this.reader.setIndex(h);
        var b = this.reader.readString(4) === m;
        return this.reader.setIndex(v), b;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var h = this.reader.readData(this.zipCommentLength), m = c.uint8array ? "uint8array" : "array", v = a.transformTo(m, h);
        this.zipComment = this.loadOptions.decodeFileName(v);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var h, m, v, b = this.zip64EndOfCentralSize - 44; 0 < b; ) h = this.reader.readInt(2), m = this.reader.readInt(4), v = this.reader.readData(m), this.zip64ExtensibleData[h] = { id: h, length: m, value: v };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var h, m;
        for (h = 0; h < this.files.length; h++) m = this.files[h], this.reader.setIndex(m.localHeaderOffset), this.checkSignature(o.LOCAL_FILE_HEADER), m.readLocalPart(this.reader), m.handleUTF8(), m.processAttributes();
      }, readCentralDir: function() {
        var h;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(o.CENTRAL_FILE_HEADER); ) (h = new f({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(h);
        if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var h = this.reader.lastIndexOfSignature(o.CENTRAL_DIRECTORY_END);
        if (h < 0) throw this.isSignature(0, o.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        this.reader.setIndex(h);
        var m = h;
        if (this.checkSignature(o.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === a.MAX_VALUE_16BITS || this.diskWithCentralDirStart === a.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === a.MAX_VALUE_16BITS || this.centralDirRecords === a.MAX_VALUE_16BITS || this.centralDirSize === a.MAX_VALUE_32BITS || this.centralDirOffset === a.MAX_VALUE_32BITS) {
          if (this.zip64 = true, (h = this.reader.lastIndexOfSignature(o.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(h), this.checkSignature(o.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, o.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(o.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(o.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var v = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (v += 20, v += 12 + this.zip64EndOfCentralSize);
        var b = m - v;
        if (0 < b) this.isSignature(m, o.CENTRAL_FILE_HEADER) || (this.reader.zero = b);
        else if (b < 0) throw new Error("Corrupted zip: missing " + Math.abs(b) + " bytes.");
      }, prepareReader: function(h) {
        this.reader = i(h);
      }, load: function(h) {
        this.prepareReader(h), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, r.exports = l;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(n, r, s) {
      var i = n("./reader/readerFor"), a = n("./utils"), o = n("./compressedObject"), f = n("./crc32"), c = n("./utf8"), l = n("./compressions"), h = n("./support");
      function m(v, b) {
        this.options = v, this.loadOptions = b;
      }
      m.prototype = { isEncrypted: function() {
        return (1 & this.bitFlag) == 1;
      }, useUTF8: function() {
        return (2048 & this.bitFlag) == 2048;
      }, readLocalPart: function(v) {
        var b, A;
        if (v.skip(22), this.fileNameLength = v.readInt(2), A = v.readInt(2), this.fileName = v.readData(this.fileNameLength), v.skip(A), this.compressedSize === -1 || this.uncompressedSize === -1) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if ((b = function(_) {
          for (var C in l) if (Object.prototype.hasOwnProperty.call(l, C) && l[C].magic === _) return l[C];
          return null;
        }(this.compressionMethod)) === null) throw new Error("Corrupted zip : compression " + a.pretty(this.compressionMethod) + " unknown (inner file : " + a.transformTo("string", this.fileName) + ")");
        this.decompressed = new o(this.compressedSize, this.uncompressedSize, this.crc32, b, v.readData(this.compressedSize));
      }, readCentralPart: function(v) {
        this.versionMadeBy = v.readInt(2), v.skip(2), this.bitFlag = v.readInt(2), this.compressionMethod = v.readString(2), this.date = v.readDate(), this.crc32 = v.readInt(4), this.compressedSize = v.readInt(4), this.uncompressedSize = v.readInt(4);
        var b = v.readInt(2);
        if (this.extraFieldsLength = v.readInt(2), this.fileCommentLength = v.readInt(2), this.diskNumberStart = v.readInt(2), this.internalFileAttributes = v.readInt(2), this.externalFileAttributes = v.readInt(4), this.localHeaderOffset = v.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
        v.skip(b), this.readExtraFields(v), this.parseZIP64ExtraField(v), this.fileComment = v.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var v = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), v == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), v == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = true);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var v = i(this.extraFields[1].value);
          this.uncompressedSize === a.MAX_VALUE_32BITS && (this.uncompressedSize = v.readInt(8)), this.compressedSize === a.MAX_VALUE_32BITS && (this.compressedSize = v.readInt(8)), this.localHeaderOffset === a.MAX_VALUE_32BITS && (this.localHeaderOffset = v.readInt(8)), this.diskNumberStart === a.MAX_VALUE_32BITS && (this.diskNumberStart = v.readInt(4));
        }
      }, readExtraFields: function(v) {
        var b, A, _, C = v.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); v.index + 4 < C; ) b = v.readInt(2), A = v.readInt(2), _ = v.readData(A), this.extraFields[b] = { id: b, length: A, value: _ };
        v.setIndex(C);
      }, handleUTF8: function() {
        var v = h.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) this.fileNameStr = c.utf8decode(this.fileName), this.fileCommentStr = c.utf8decode(this.fileComment);
        else {
          var b = this.findExtraFieldUnicodePath();
          if (b !== null) this.fileNameStr = b;
          else {
            var A = a.transformTo(v, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(A);
          }
          var _ = this.findExtraFieldUnicodeComment();
          if (_ !== null) this.fileCommentStr = _;
          else {
            var C = a.transformTo(v, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(C);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var v = this.extraFields[28789];
        if (v) {
          var b = i(v.value);
          return b.readInt(1) !== 1 || f(this.fileName) !== b.readInt(4) ? null : c.utf8decode(b.readData(v.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var v = this.extraFields[25461];
        if (v) {
          var b = i(v.value);
          return b.readInt(1) !== 1 || f(this.fileComment) !== b.readInt(4) ? null : c.utf8decode(b.readData(v.length - 5));
        }
        return null;
      } }, r.exports = m;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(n, r, s) {
      function i(b, A, _) {
        this.name = b, this.dir = _.dir, this.date = _.date, this.comment = _.comment, this.unixPermissions = _.unixPermissions, this.dosPermissions = _.dosPermissions, this._data = A, this._dataBinary = _.binary, this.options = { compression: _.compression, compressionOptions: _.compressionOptions };
      }
      var a = n("./stream/StreamHelper"), o = n("./stream/DataWorker"), f = n("./utf8"), c = n("./compressedObject"), l = n("./stream/GenericWorker");
      i.prototype = { internalStream: function(b) {
        var A = null, _ = "string";
        try {
          if (!b) throw new Error("No output type specified.");
          var C = (_ = b.toLowerCase()) === "string" || _ === "text";
          _ !== "binarystring" && _ !== "text" || (_ = "string"), A = this._decompressWorker();
          var I = !this._dataBinary;
          I && !C && (A = A.pipe(new f.Utf8EncodeWorker())), !I && C && (A = A.pipe(new f.Utf8DecodeWorker()));
        } catch (S) {
          (A = new l("error")).error(S);
        }
        return new a(A, _, "");
      }, async: function(b, A) {
        return this.internalStream(b).accumulate(A);
      }, nodeStream: function(b, A) {
        return this.internalStream(b || "nodebuffer").toNodejsStream(A);
      }, _compressWorker: function(b, A) {
        if (this._data instanceof c && this._data.compression.magic === b.magic) return this._data.getCompressedWorker();
        var _ = this._decompressWorker();
        return this._dataBinary || (_ = _.pipe(new f.Utf8EncodeWorker())), c.createWorkerFrom(_, b, A);
      }, _decompressWorker: function() {
        return this._data instanceof c ? this._data.getContentWorker() : this._data instanceof l ? this._data : new o(this._data);
      } };
      for (var h = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], m = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, v = 0; v < h.length; v++) i.prototype[h[v]] = m;
      r.exports = i;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(n, r, s) {
      (function(i) {
        var a, o, f = i.MutationObserver || i.WebKitMutationObserver;
        if (f) {
          var c = 0, l = new f(b), h = i.document.createTextNode("");
          l.observe(h, { characterData: true }), a = function() {
            h.data = c = ++c % 2;
          };
        } else if (i.setImmediate || i.MessageChannel === void 0) a = "document" in i && "onreadystatechange" in i.document.createElement("script") ? function() {
          var A = i.document.createElement("script");
          A.onreadystatechange = function() {
            b(), A.onreadystatechange = null, A.parentNode.removeChild(A), A = null;
          }, i.document.documentElement.appendChild(A);
        } : function() {
          setTimeout(b, 0);
        };
        else {
          var m = new i.MessageChannel();
          m.port1.onmessage = b, a = function() {
            m.port2.postMessage(0);
          };
        }
        var v = [];
        function b() {
          var A, _;
          o = true;
          for (var C = v.length; C; ) {
            for (_ = v, v = [], A = -1; ++A < C; ) _[A]();
            C = v.length;
          }
          o = false;
        }
        r.exports = function(A) {
          v.push(A) !== 1 || o || a();
        };
      }).call(this, typeof mt < "u" ? mt : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 37: [function(n, r, s) {
      var i = n("immediate");
      function a() {
      }
      var o = {}, f = ["REJECTED"], c = ["FULFILLED"], l = ["PENDING"];
      function h(C) {
        if (typeof C != "function") throw new TypeError("resolver must be a function");
        this.state = l, this.queue = [], this.outcome = void 0, C !== a && A(this, C);
      }
      function m(C, I, S) {
        this.promise = C, typeof I == "function" && (this.onFulfilled = I, this.callFulfilled = this.otherCallFulfilled), typeof S == "function" && (this.onRejected = S, this.callRejected = this.otherCallRejected);
      }
      function v(C, I, S) {
        i(function() {
          var $;
          try {
            $ = I(S);
          } catch (F) {
            return o.reject(C, F);
          }
          $ === C ? o.reject(C, new TypeError("Cannot resolve promise with itself")) : o.resolve(C, $);
        });
      }
      function b(C) {
        var I = C && C.then;
        if (C && (typeof C == "object" || typeof C == "function") && typeof I == "function") return function() {
          I.apply(C, arguments);
        };
      }
      function A(C, I) {
        var S = false;
        function $(Q) {
          S || (S = true, o.reject(C, Q));
        }
        function F(Q) {
          S || (S = true, o.resolve(C, Q));
        }
        var U = _(function() {
          I(F, $);
        });
        U.status === "error" && $(U.value);
      }
      function _(C, I) {
        var S = {};
        try {
          S.value = C(I), S.status = "success";
        } catch ($) {
          S.status = "error", S.value = $;
        }
        return S;
      }
      (r.exports = h).prototype.finally = function(C) {
        if (typeof C != "function") return this;
        var I = this.constructor;
        return this.then(function(S) {
          return I.resolve(C()).then(function() {
            return S;
          });
        }, function(S) {
          return I.resolve(C()).then(function() {
            throw S;
          });
        });
      }, h.prototype.catch = function(C) {
        return this.then(null, C);
      }, h.prototype.then = function(C, I) {
        if (typeof C != "function" && this.state === c || typeof I != "function" && this.state === f) return this;
        var S = new this.constructor(a);
        return this.state !== l ? v(S, this.state === c ? C : I, this.outcome) : this.queue.push(new m(S, C, I)), S;
      }, m.prototype.callFulfilled = function(C) {
        o.resolve(this.promise, C);
      }, m.prototype.otherCallFulfilled = function(C) {
        v(this.promise, this.onFulfilled, C);
      }, m.prototype.callRejected = function(C) {
        o.reject(this.promise, C);
      }, m.prototype.otherCallRejected = function(C) {
        v(this.promise, this.onRejected, C);
      }, o.resolve = function(C, I) {
        var S = _(b, I);
        if (S.status === "error") return o.reject(C, S.value);
        var $ = S.value;
        if ($) A(C, $);
        else {
          C.state = c, C.outcome = I;
          for (var F = -1, U = C.queue.length; ++F < U; ) C.queue[F].callFulfilled(I);
        }
        return C;
      }, o.reject = function(C, I) {
        C.state = f, C.outcome = I;
        for (var S = -1, $ = C.queue.length; ++S < $; ) C.queue[S].callRejected(I);
        return C;
      }, h.resolve = function(C) {
        return C instanceof this ? C : o.resolve(new this(a), C);
      }, h.reject = function(C) {
        var I = new this(a);
        return o.reject(I, C);
      }, h.all = function(C) {
        var I = this;
        if (Object.prototype.toString.call(C) !== "[object Array]") return this.reject(new TypeError("must be an array"));
        var S = C.length, $ = false;
        if (!S) return this.resolve([]);
        for (var F = new Array(S), U = 0, Q = -1, P = new this(a); ++Q < S; ) N(C[Q], Q);
        return P;
        function N(L, B) {
          I.resolve(L).then(function(u) {
            F[B] = u, ++U !== S || $ || ($ = true, o.resolve(P, F));
          }, function(u) {
            $ || ($ = true, o.reject(P, u));
          });
        }
      }, h.race = function(C) {
        var I = this;
        if (Object.prototype.toString.call(C) !== "[object Array]") return this.reject(new TypeError("must be an array"));
        var S = C.length, $ = false;
        if (!S) return this.resolve([]);
        for (var F = -1, U = new this(a); ++F < S; ) Q = C[F], I.resolve(Q).then(function(P) {
          $ || ($ = true, o.resolve(U, P));
        }, function(P) {
          $ || ($ = true, o.reject(U, P));
        });
        var Q;
        return U;
      };
    }, { immediate: 36 }], 38: [function(n, r, s) {
      var i = {};
      (0, n("./lib/utils/common").assign)(i, n("./lib/deflate"), n("./lib/inflate"), n("./lib/zlib/constants")), r.exports = i;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(n, r, s) {
      var i = n("./zlib/deflate"), a = n("./utils/common"), o = n("./utils/strings"), f = n("./zlib/messages"), c = n("./zlib/zstream"), l = Object.prototype.toString, h = 0, m = -1, v = 0, b = 8;
      function A(C) {
        if (!(this instanceof A)) return new A(C);
        this.options = a.assign({ level: m, method: b, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: v, to: "" }, C || {});
        var I = this.options;
        I.raw && 0 < I.windowBits ? I.windowBits = -I.windowBits : I.gzip && 0 < I.windowBits && I.windowBits < 16 && (I.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new c(), this.strm.avail_out = 0;
        var S = i.deflateInit2(this.strm, I.level, I.method, I.windowBits, I.memLevel, I.strategy);
        if (S !== h) throw new Error(f[S]);
        if (I.header && i.deflateSetHeader(this.strm, I.header), I.dictionary) {
          var $;
          if ($ = typeof I.dictionary == "string" ? o.string2buf(I.dictionary) : l.call(I.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(I.dictionary) : I.dictionary, (S = i.deflateSetDictionary(this.strm, $)) !== h) throw new Error(f[S]);
          this._dict_set = true;
        }
      }
      function _(C, I) {
        var S = new A(I);
        if (S.push(C, true), S.err) throw S.msg || f[S.err];
        return S.result;
      }
      A.prototype.push = function(C, I) {
        var S, $, F = this.strm, U = this.options.chunkSize;
        if (this.ended) return false;
        $ = I === ~~I ? I : I === true ? 4 : 0, typeof C == "string" ? F.input = o.string2buf(C) : l.call(C) === "[object ArrayBuffer]" ? F.input = new Uint8Array(C) : F.input = C, F.next_in = 0, F.avail_in = F.input.length;
        do {
          if (F.avail_out === 0 && (F.output = new a.Buf8(U), F.next_out = 0, F.avail_out = U), (S = i.deflate(F, $)) !== 1 && S !== h) return this.onEnd(S), !(this.ended = true);
          F.avail_out !== 0 && (F.avail_in !== 0 || $ !== 4 && $ !== 2) || (this.options.to === "string" ? this.onData(o.buf2binstring(a.shrinkBuf(F.output, F.next_out))) : this.onData(a.shrinkBuf(F.output, F.next_out)));
        } while ((0 < F.avail_in || F.avail_out === 0) && S !== 1);
        return $ === 4 ? (S = i.deflateEnd(this.strm), this.onEnd(S), this.ended = true, S === h) : $ !== 2 || (this.onEnd(h), !(F.avail_out = 0));
      }, A.prototype.onData = function(C) {
        this.chunks.push(C);
      }, A.prototype.onEnd = function(C) {
        C === h && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = a.flattenChunks(this.chunks)), this.chunks = [], this.err = C, this.msg = this.strm.msg;
      }, s.Deflate = A, s.deflate = _, s.deflateRaw = function(C, I) {
        return (I = I || {}).raw = true, _(C, I);
      }, s.gzip = function(C, I) {
        return (I = I || {}).gzip = true, _(C, I);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(n, r, s) {
      var i = n("./zlib/inflate"), a = n("./utils/common"), o = n("./utils/strings"), f = n("./zlib/constants"), c = n("./zlib/messages"), l = n("./zlib/zstream"), h = n("./zlib/gzheader"), m = Object.prototype.toString;
      function v(A) {
        if (!(this instanceof v)) return new v(A);
        this.options = a.assign({ chunkSize: 16384, windowBits: 0, to: "" }, A || {});
        var _ = this.options;
        _.raw && 0 <= _.windowBits && _.windowBits < 16 && (_.windowBits = -_.windowBits, _.windowBits === 0 && (_.windowBits = -15)), !(0 <= _.windowBits && _.windowBits < 16) || A && A.windowBits || (_.windowBits += 32), 15 < _.windowBits && _.windowBits < 48 && !(15 & _.windowBits) && (_.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new l(), this.strm.avail_out = 0;
        var C = i.inflateInit2(this.strm, _.windowBits);
        if (C !== f.Z_OK) throw new Error(c[C]);
        this.header = new h(), i.inflateGetHeader(this.strm, this.header);
      }
      function b(A, _) {
        var C = new v(_);
        if (C.push(A, true), C.err) throw C.msg || c[C.err];
        return C.result;
      }
      v.prototype.push = function(A, _) {
        var C, I, S, $, F, U, Q = this.strm, P = this.options.chunkSize, N = this.options.dictionary, L = false;
        if (this.ended) return false;
        I = _ === ~~_ ? _ : _ === true ? f.Z_FINISH : f.Z_NO_FLUSH, typeof A == "string" ? Q.input = o.binstring2buf(A) : m.call(A) === "[object ArrayBuffer]" ? Q.input = new Uint8Array(A) : Q.input = A, Q.next_in = 0, Q.avail_in = Q.input.length;
        do {
          if (Q.avail_out === 0 && (Q.output = new a.Buf8(P), Q.next_out = 0, Q.avail_out = P), (C = i.inflate(Q, f.Z_NO_FLUSH)) === f.Z_NEED_DICT && N && (U = typeof N == "string" ? o.string2buf(N) : m.call(N) === "[object ArrayBuffer]" ? new Uint8Array(N) : N, C = i.inflateSetDictionary(this.strm, U)), C === f.Z_BUF_ERROR && L === true && (C = f.Z_OK, L = false), C !== f.Z_STREAM_END && C !== f.Z_OK) return this.onEnd(C), !(this.ended = true);
          Q.next_out && (Q.avail_out !== 0 && C !== f.Z_STREAM_END && (Q.avail_in !== 0 || I !== f.Z_FINISH && I !== f.Z_SYNC_FLUSH) || (this.options.to === "string" ? (S = o.utf8border(Q.output, Q.next_out), $ = Q.next_out - S, F = o.buf2string(Q.output, S), Q.next_out = $, Q.avail_out = P - $, $ && a.arraySet(Q.output, Q.output, S, $, 0), this.onData(F)) : this.onData(a.shrinkBuf(Q.output, Q.next_out)))), Q.avail_in === 0 && Q.avail_out === 0 && (L = true);
        } while ((0 < Q.avail_in || Q.avail_out === 0) && C !== f.Z_STREAM_END);
        return C === f.Z_STREAM_END && (I = f.Z_FINISH), I === f.Z_FINISH ? (C = i.inflateEnd(this.strm), this.onEnd(C), this.ended = true, C === f.Z_OK) : I !== f.Z_SYNC_FLUSH || (this.onEnd(f.Z_OK), !(Q.avail_out = 0));
      }, v.prototype.onData = function(A) {
        this.chunks.push(A);
      }, v.prototype.onEnd = function(A) {
        A === f.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = a.flattenChunks(this.chunks)), this.chunks = [], this.err = A, this.msg = this.strm.msg;
      }, s.Inflate = v, s.inflate = b, s.inflateRaw = function(A, _) {
        return (_ = _ || {}).raw = true, b(A, _);
      }, s.ungzip = b;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(n, r, s) {
      var i = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      s.assign = function(f) {
        for (var c = Array.prototype.slice.call(arguments, 1); c.length; ) {
          var l = c.shift();
          if (l) {
            if (typeof l != "object") throw new TypeError(l + "must be non-object");
            for (var h in l) l.hasOwnProperty(h) && (f[h] = l[h]);
          }
        }
        return f;
      }, s.shrinkBuf = function(f, c) {
        return f.length === c ? f : f.subarray ? f.subarray(0, c) : (f.length = c, f);
      };
      var a = { arraySet: function(f, c, l, h, m) {
        if (c.subarray && f.subarray) f.set(c.subarray(l, l + h), m);
        else for (var v = 0; v < h; v++) f[m + v] = c[l + v];
      }, flattenChunks: function(f) {
        var c, l, h, m, v, b;
        for (c = h = 0, l = f.length; c < l; c++) h += f[c].length;
        for (b = new Uint8Array(h), c = m = 0, l = f.length; c < l; c++) v = f[c], b.set(v, m), m += v.length;
        return b;
      } }, o = { arraySet: function(f, c, l, h, m) {
        for (var v = 0; v < h; v++) f[m + v] = c[l + v];
      }, flattenChunks: function(f) {
        return [].concat.apply([], f);
      } };
      s.setTyped = function(f) {
        f ? (s.Buf8 = Uint8Array, s.Buf16 = Uint16Array, s.Buf32 = Int32Array, s.assign(s, a)) : (s.Buf8 = Array, s.Buf16 = Array, s.Buf32 = Array, s.assign(s, o));
      }, s.setTyped(i);
    }, {}], 42: [function(n, r, s) {
      var i = n("./common"), a = true, o = true;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch {
        a = false;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch {
        o = false;
      }
      for (var f = new i.Buf8(256), c = 0; c < 256; c++) f[c] = 252 <= c ? 6 : 248 <= c ? 5 : 240 <= c ? 4 : 224 <= c ? 3 : 192 <= c ? 2 : 1;
      function l(h, m) {
        if (m < 65537 && (h.subarray && o || !h.subarray && a)) return String.fromCharCode.apply(null, i.shrinkBuf(h, m));
        for (var v = "", b = 0; b < m; b++) v += String.fromCharCode(h[b]);
        return v;
      }
      f[254] = f[254] = 1, s.string2buf = function(h) {
        var m, v, b, A, _, C = h.length, I = 0;
        for (A = 0; A < C; A++) (64512 & (v = h.charCodeAt(A))) == 55296 && A + 1 < C && (64512 & (b = h.charCodeAt(A + 1))) == 56320 && (v = 65536 + (v - 55296 << 10) + (b - 56320), A++), I += v < 128 ? 1 : v < 2048 ? 2 : v < 65536 ? 3 : 4;
        for (m = new i.Buf8(I), A = _ = 0; _ < I; A++) (64512 & (v = h.charCodeAt(A))) == 55296 && A + 1 < C && (64512 & (b = h.charCodeAt(A + 1))) == 56320 && (v = 65536 + (v - 55296 << 10) + (b - 56320), A++), v < 128 ? m[_++] = v : (v < 2048 ? m[_++] = 192 | v >>> 6 : (v < 65536 ? m[_++] = 224 | v >>> 12 : (m[_++] = 240 | v >>> 18, m[_++] = 128 | v >>> 12 & 63), m[_++] = 128 | v >>> 6 & 63), m[_++] = 128 | 63 & v);
        return m;
      }, s.buf2binstring = function(h) {
        return l(h, h.length);
      }, s.binstring2buf = function(h) {
        for (var m = new i.Buf8(h.length), v = 0, b = m.length; v < b; v++) m[v] = h.charCodeAt(v);
        return m;
      }, s.buf2string = function(h, m) {
        var v, b, A, _, C = m || h.length, I = new Array(2 * C);
        for (v = b = 0; v < C; ) if ((A = h[v++]) < 128) I[b++] = A;
        else if (4 < (_ = f[A])) I[b++] = 65533, v += _ - 1;
        else {
          for (A &= _ === 2 ? 31 : _ === 3 ? 15 : 7; 1 < _ && v < C; ) A = A << 6 | 63 & h[v++], _--;
          1 < _ ? I[b++] = 65533 : A < 65536 ? I[b++] = A : (A -= 65536, I[b++] = 55296 | A >> 10 & 1023, I[b++] = 56320 | 1023 & A);
        }
        return l(I, b);
      }, s.utf8border = function(h, m) {
        var v;
        for ((m = m || h.length) > h.length && (m = h.length), v = m - 1; 0 <= v && (192 & h[v]) == 128; ) v--;
        return v < 0 || v === 0 ? m : v + f[h[v]] > m ? v : m;
      };
    }, { "./common": 41 }], 43: [function(n, r, s) {
      r.exports = function(i, a, o, f) {
        for (var c = 65535 & i | 0, l = i >>> 16 & 65535 | 0, h = 0; o !== 0; ) {
          for (o -= h = 2e3 < o ? 2e3 : o; l = l + (c = c + a[f++] | 0) | 0, --h; ) ;
          c %= 65521, l %= 65521;
        }
        return c | l << 16 | 0;
      };
    }, {}], 44: [function(n, r, s) {
      r.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(n, r, s) {
      var i = function() {
        for (var a, o = [], f = 0; f < 256; f++) {
          a = f;
          for (var c = 0; c < 8; c++) a = 1 & a ? 3988292384 ^ a >>> 1 : a >>> 1;
          o[f] = a;
        }
        return o;
      }();
      r.exports = function(a, o, f, c) {
        var l = i, h = c + f;
        a ^= -1;
        for (var m = c; m < h; m++) a = a >>> 8 ^ l[255 & (a ^ o[m])];
        return -1 ^ a;
      };
    }, {}], 46: [function(n, r, s) {
      var i, a = n("../utils/common"), o = n("./trees"), f = n("./adler32"), c = n("./crc32"), l = n("./messages"), h = 0, m = 4, v = 0, b = -2, A = -1, _ = 4, C = 2, I = 8, S = 9, $ = 286, F = 30, U = 19, Q = 2 * $ + 1, P = 15, N = 3, L = 258, B = L + N + 1, u = 42, p = 113, d = 1, y = 2, w = 3, E = 4;
      function M(Z, ve) {
        return Z.msg = l[ve], ve;
      }
      function x(Z) {
        return (Z << 1) - (4 < Z ? 9 : 0);
      }
      function g(Z) {
        for (var ve = Z.length; 0 <= --ve; ) Z[ve] = 0;
      }
      function k(Z) {
        var ve = Z.state, he = ve.pending;
        he > Z.avail_out && (he = Z.avail_out), he !== 0 && (a.arraySet(Z.output, ve.pending_buf, ve.pending_out, he, Z.next_out), Z.next_out += he, ve.pending_out += he, Z.total_out += he, Z.avail_out -= he, ve.pending -= he, ve.pending === 0 && (ve.pending_out = 0));
      }
      function T(Z, ve) {
        o._tr_flush_block(Z, 0 <= Z.block_start ? Z.block_start : -1, Z.strstart - Z.block_start, ve), Z.block_start = Z.strstart, k(Z.strm);
      }
      function O(Z, ve) {
        Z.pending_buf[Z.pending++] = ve;
      }
      function K(Z, ve) {
        Z.pending_buf[Z.pending++] = ve >>> 8 & 255, Z.pending_buf[Z.pending++] = 255 & ve;
      }
      function Y(Z, ve) {
        var he, me, ce = Z.max_chain_length, ye = Z.strstart, Oe = Z.prev_length, Se = Z.nice_match, Ce = Z.strstart > Z.w_size - B ? Z.strstart - (Z.w_size - B) : 0, Ne = Z.window, $e = Z.w_mask, Re = Z.prev, Ge = Z.strstart + L, Fe = Ne[ye + Oe - 1], Ue = Ne[ye + Oe];
        Z.prev_length >= Z.good_match && (ce >>= 2), Se > Z.lookahead && (Se = Z.lookahead);
        do
          if (Ne[(he = ve) + Oe] === Ue && Ne[he + Oe - 1] === Fe && Ne[he] === Ne[ye] && Ne[++he] === Ne[ye + 1]) {
            ye += 2, he++;
            do
              ;
            while (Ne[++ye] === Ne[++he] && Ne[++ye] === Ne[++he] && Ne[++ye] === Ne[++he] && Ne[++ye] === Ne[++he] && Ne[++ye] === Ne[++he] && Ne[++ye] === Ne[++he] && Ne[++ye] === Ne[++he] && Ne[++ye] === Ne[++he] && ye < Ge);
            if (me = L - (Ge - ye), ye = Ge - L, Oe < me) {
              if (Z.match_start = ve, Se <= (Oe = me)) break;
              Fe = Ne[ye + Oe - 1], Ue = Ne[ye + Oe];
            }
          }
        while ((ve = Re[ve & $e]) > Ce && --ce != 0);
        return Oe <= Z.lookahead ? Oe : Z.lookahead;
      }
      function J(Z) {
        var ve, he, me, ce, ye, Oe, Se, Ce, Ne, $e, Re = Z.w_size;
        do {
          if (ce = Z.window_size - Z.lookahead - Z.strstart, Z.strstart >= Re + (Re - B)) {
            for (a.arraySet(Z.window, Z.window, Re, Re, 0), Z.match_start -= Re, Z.strstart -= Re, Z.block_start -= Re, ve = he = Z.hash_size; me = Z.head[--ve], Z.head[ve] = Re <= me ? me - Re : 0, --he; ) ;
            for (ve = he = Re; me = Z.prev[--ve], Z.prev[ve] = Re <= me ? me - Re : 0, --he; ) ;
            ce += Re;
          }
          if (Z.strm.avail_in === 0) break;
          if (Oe = Z.strm, Se = Z.window, Ce = Z.strstart + Z.lookahead, Ne = ce, $e = void 0, $e = Oe.avail_in, Ne < $e && ($e = Ne), he = $e === 0 ? 0 : (Oe.avail_in -= $e, a.arraySet(Se, Oe.input, Oe.next_in, $e, Ce), Oe.state.wrap === 1 ? Oe.adler = f(Oe.adler, Se, $e, Ce) : Oe.state.wrap === 2 && (Oe.adler = c(Oe.adler, Se, $e, Ce)), Oe.next_in += $e, Oe.total_in += $e, $e), Z.lookahead += he, Z.lookahead + Z.insert >= N) for (ye = Z.strstart - Z.insert, Z.ins_h = Z.window[ye], Z.ins_h = (Z.ins_h << Z.hash_shift ^ Z.window[ye + 1]) & Z.hash_mask; Z.insert && (Z.ins_h = (Z.ins_h << Z.hash_shift ^ Z.window[ye + N - 1]) & Z.hash_mask, Z.prev[ye & Z.w_mask] = Z.head[Z.ins_h], Z.head[Z.ins_h] = ye, ye++, Z.insert--, !(Z.lookahead + Z.insert < N)); ) ;
        } while (Z.lookahead < B && Z.strm.avail_in !== 0);
      }
      function G(Z, ve) {
        for (var he, me; ; ) {
          if (Z.lookahead < B) {
            if (J(Z), Z.lookahead < B && ve === h) return d;
            if (Z.lookahead === 0) break;
          }
          if (he = 0, Z.lookahead >= N && (Z.ins_h = (Z.ins_h << Z.hash_shift ^ Z.window[Z.strstart + N - 1]) & Z.hash_mask, he = Z.prev[Z.strstart & Z.w_mask] = Z.head[Z.ins_h], Z.head[Z.ins_h] = Z.strstart), he !== 0 && Z.strstart - he <= Z.w_size - B && (Z.match_length = Y(Z, he)), Z.match_length >= N) if (me = o._tr_tally(Z, Z.strstart - Z.match_start, Z.match_length - N), Z.lookahead -= Z.match_length, Z.match_length <= Z.max_lazy_match && Z.lookahead >= N) {
            for (Z.match_length--; Z.strstart++, Z.ins_h = (Z.ins_h << Z.hash_shift ^ Z.window[Z.strstart + N - 1]) & Z.hash_mask, he = Z.prev[Z.strstart & Z.w_mask] = Z.head[Z.ins_h], Z.head[Z.ins_h] = Z.strstart, --Z.match_length != 0; ) ;
            Z.strstart++;
          } else Z.strstart += Z.match_length, Z.match_length = 0, Z.ins_h = Z.window[Z.strstart], Z.ins_h = (Z.ins_h << Z.hash_shift ^ Z.window[Z.strstart + 1]) & Z.hash_mask;
          else me = o._tr_tally(Z, 0, Z.window[Z.strstart]), Z.lookahead--, Z.strstart++;
          if (me && (T(Z, false), Z.strm.avail_out === 0)) return d;
        }
        return Z.insert = Z.strstart < N - 1 ? Z.strstart : N - 1, ve === m ? (T(Z, true), Z.strm.avail_out === 0 ? w : E) : Z.last_lit && (T(Z, false), Z.strm.avail_out === 0) ? d : y;
      }
      function X(Z, ve) {
        for (var he, me, ce; ; ) {
          if (Z.lookahead < B) {
            if (J(Z), Z.lookahead < B && ve === h) return d;
            if (Z.lookahead === 0) break;
          }
          if (he = 0, Z.lookahead >= N && (Z.ins_h = (Z.ins_h << Z.hash_shift ^ Z.window[Z.strstart + N - 1]) & Z.hash_mask, he = Z.prev[Z.strstart & Z.w_mask] = Z.head[Z.ins_h], Z.head[Z.ins_h] = Z.strstart), Z.prev_length = Z.match_length, Z.prev_match = Z.match_start, Z.match_length = N - 1, he !== 0 && Z.prev_length < Z.max_lazy_match && Z.strstart - he <= Z.w_size - B && (Z.match_length = Y(Z, he), Z.match_length <= 5 && (Z.strategy === 1 || Z.match_length === N && 4096 < Z.strstart - Z.match_start) && (Z.match_length = N - 1)), Z.prev_length >= N && Z.match_length <= Z.prev_length) {
            for (ce = Z.strstart + Z.lookahead - N, me = o._tr_tally(Z, Z.strstart - 1 - Z.prev_match, Z.prev_length - N), Z.lookahead -= Z.prev_length - 1, Z.prev_length -= 2; ++Z.strstart <= ce && (Z.ins_h = (Z.ins_h << Z.hash_shift ^ Z.window[Z.strstart + N - 1]) & Z.hash_mask, he = Z.prev[Z.strstart & Z.w_mask] = Z.head[Z.ins_h], Z.head[Z.ins_h] = Z.strstart), --Z.prev_length != 0; ) ;
            if (Z.match_available = 0, Z.match_length = N - 1, Z.strstart++, me && (T(Z, false), Z.strm.avail_out === 0)) return d;
          } else if (Z.match_available) {
            if ((me = o._tr_tally(Z, 0, Z.window[Z.strstart - 1])) && T(Z, false), Z.strstart++, Z.lookahead--, Z.strm.avail_out === 0) return d;
          } else Z.match_available = 1, Z.strstart++, Z.lookahead--;
        }
        return Z.match_available && (me = o._tr_tally(Z, 0, Z.window[Z.strstart - 1]), Z.match_available = 0), Z.insert = Z.strstart < N - 1 ? Z.strstart : N - 1, ve === m ? (T(Z, true), Z.strm.avail_out === 0 ? w : E) : Z.last_lit && (T(Z, false), Z.strm.avail_out === 0) ? d : y;
      }
      function ie(Z, ve, he, me, ce) {
        this.good_length = Z, this.max_lazy = ve, this.nice_length = he, this.max_chain = me, this.func = ce;
      }
      function de() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = I, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new a.Buf16(2 * Q), this.dyn_dtree = new a.Buf16(2 * (2 * F + 1)), this.bl_tree = new a.Buf16(2 * (2 * U + 1)), g(this.dyn_ltree), g(this.dyn_dtree), g(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new a.Buf16(P + 1), this.heap = new a.Buf16(2 * $ + 1), g(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new a.Buf16(2 * $ + 1), g(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function se(Z) {
        var ve;
        return Z && Z.state ? (Z.total_in = Z.total_out = 0, Z.data_type = C, (ve = Z.state).pending = 0, ve.pending_out = 0, ve.wrap < 0 && (ve.wrap = -ve.wrap), ve.status = ve.wrap ? u : p, Z.adler = ve.wrap === 2 ? 0 : 1, ve.last_flush = h, o._tr_init(ve), v) : M(Z, b);
      }
      function te(Z) {
        var ve = se(Z);
        return ve === v && function(he) {
          he.window_size = 2 * he.w_size, g(he.head), he.max_lazy_match = i[he.level].max_lazy, he.good_match = i[he.level].good_length, he.nice_match = i[he.level].nice_length, he.max_chain_length = i[he.level].max_chain, he.strstart = 0, he.block_start = 0, he.lookahead = 0, he.insert = 0, he.match_length = he.prev_length = N - 1, he.match_available = 0, he.ins_h = 0;
        }(Z.state), ve;
      }
      function le(Z, ve, he, me, ce, ye) {
        if (!Z) return b;
        var Oe = 1;
        if (ve === A && (ve = 6), me < 0 ? (Oe = 0, me = -me) : 15 < me && (Oe = 2, me -= 16), ce < 1 || S < ce || he !== I || me < 8 || 15 < me || ve < 0 || 9 < ve || ye < 0 || _ < ye) return M(Z, b);
        me === 8 && (me = 9);
        var Se = new de();
        return (Z.state = Se).strm = Z, Se.wrap = Oe, Se.gzhead = null, Se.w_bits = me, Se.w_size = 1 << Se.w_bits, Se.w_mask = Se.w_size - 1, Se.hash_bits = ce + 7, Se.hash_size = 1 << Se.hash_bits, Se.hash_mask = Se.hash_size - 1, Se.hash_shift = ~~((Se.hash_bits + N - 1) / N), Se.window = new a.Buf8(2 * Se.w_size), Se.head = new a.Buf16(Se.hash_size), Se.prev = new a.Buf16(Se.w_size), Se.lit_bufsize = 1 << ce + 6, Se.pending_buf_size = 4 * Se.lit_bufsize, Se.pending_buf = new a.Buf8(Se.pending_buf_size), Se.d_buf = 1 * Se.lit_bufsize, Se.l_buf = 3 * Se.lit_bufsize, Se.level = ve, Se.strategy = ye, Se.method = he, te(Z);
      }
      i = [new ie(0, 0, 0, 0, function(Z, ve) {
        var he = 65535;
        for (he > Z.pending_buf_size - 5 && (he = Z.pending_buf_size - 5); ; ) {
          if (Z.lookahead <= 1) {
            if (J(Z), Z.lookahead === 0 && ve === h) return d;
            if (Z.lookahead === 0) break;
          }
          Z.strstart += Z.lookahead, Z.lookahead = 0;
          var me = Z.block_start + he;
          if ((Z.strstart === 0 || Z.strstart >= me) && (Z.lookahead = Z.strstart - me, Z.strstart = me, T(Z, false), Z.strm.avail_out === 0) || Z.strstart - Z.block_start >= Z.w_size - B && (T(Z, false), Z.strm.avail_out === 0)) return d;
        }
        return Z.insert = 0, ve === m ? (T(Z, true), Z.strm.avail_out === 0 ? w : E) : (Z.strstart > Z.block_start && (T(Z, false), Z.strm.avail_out), d);
      }), new ie(4, 4, 8, 4, G), new ie(4, 5, 16, 8, G), new ie(4, 6, 32, 32, G), new ie(4, 4, 16, 16, X), new ie(8, 16, 32, 32, X), new ie(8, 16, 128, 128, X), new ie(8, 32, 128, 256, X), new ie(32, 128, 258, 1024, X), new ie(32, 258, 258, 4096, X)], s.deflateInit = function(Z, ve) {
        return le(Z, ve, I, 15, 8, 0);
      }, s.deflateInit2 = le, s.deflateReset = te, s.deflateResetKeep = se, s.deflateSetHeader = function(Z, ve) {
        return Z && Z.state ? Z.state.wrap !== 2 ? b : (Z.state.gzhead = ve, v) : b;
      }, s.deflate = function(Z, ve) {
        var he, me, ce, ye;
        if (!Z || !Z.state || 5 < ve || ve < 0) return Z ? M(Z, b) : b;
        if (me = Z.state, !Z.output || !Z.input && Z.avail_in !== 0 || me.status === 666 && ve !== m) return M(Z, Z.avail_out === 0 ? -5 : b);
        if (me.strm = Z, he = me.last_flush, me.last_flush = ve, me.status === u) if (me.wrap === 2) Z.adler = 0, O(me, 31), O(me, 139), O(me, 8), me.gzhead ? (O(me, (me.gzhead.text ? 1 : 0) + (me.gzhead.hcrc ? 2 : 0) + (me.gzhead.extra ? 4 : 0) + (me.gzhead.name ? 8 : 0) + (me.gzhead.comment ? 16 : 0)), O(me, 255 & me.gzhead.time), O(me, me.gzhead.time >> 8 & 255), O(me, me.gzhead.time >> 16 & 255), O(me, me.gzhead.time >> 24 & 255), O(me, me.level === 9 ? 2 : 2 <= me.strategy || me.level < 2 ? 4 : 0), O(me, 255 & me.gzhead.os), me.gzhead.extra && me.gzhead.extra.length && (O(me, 255 & me.gzhead.extra.length), O(me, me.gzhead.extra.length >> 8 & 255)), me.gzhead.hcrc && (Z.adler = c(Z.adler, me.pending_buf, me.pending, 0)), me.gzindex = 0, me.status = 69) : (O(me, 0), O(me, 0), O(me, 0), O(me, 0), O(me, 0), O(me, me.level === 9 ? 2 : 2 <= me.strategy || me.level < 2 ? 4 : 0), O(me, 3), me.status = p);
        else {
          var Oe = I + (me.w_bits - 8 << 4) << 8;
          Oe |= (2 <= me.strategy || me.level < 2 ? 0 : me.level < 6 ? 1 : me.level === 6 ? 2 : 3) << 6, me.strstart !== 0 && (Oe |= 32), Oe += 31 - Oe % 31, me.status = p, K(me, Oe), me.strstart !== 0 && (K(me, Z.adler >>> 16), K(me, 65535 & Z.adler)), Z.adler = 1;
        }
        if (me.status === 69) if (me.gzhead.extra) {
          for (ce = me.pending; me.gzindex < (65535 & me.gzhead.extra.length) && (me.pending !== me.pending_buf_size || (me.gzhead.hcrc && me.pending > ce && (Z.adler = c(Z.adler, me.pending_buf, me.pending - ce, ce)), k(Z), ce = me.pending, me.pending !== me.pending_buf_size)); ) O(me, 255 & me.gzhead.extra[me.gzindex]), me.gzindex++;
          me.gzhead.hcrc && me.pending > ce && (Z.adler = c(Z.adler, me.pending_buf, me.pending - ce, ce)), me.gzindex === me.gzhead.extra.length && (me.gzindex = 0, me.status = 73);
        } else me.status = 73;
        if (me.status === 73) if (me.gzhead.name) {
          ce = me.pending;
          do {
            if (me.pending === me.pending_buf_size && (me.gzhead.hcrc && me.pending > ce && (Z.adler = c(Z.adler, me.pending_buf, me.pending - ce, ce)), k(Z), ce = me.pending, me.pending === me.pending_buf_size)) {
              ye = 1;
              break;
            }
            ye = me.gzindex < me.gzhead.name.length ? 255 & me.gzhead.name.charCodeAt(me.gzindex++) : 0, O(me, ye);
          } while (ye !== 0);
          me.gzhead.hcrc && me.pending > ce && (Z.adler = c(Z.adler, me.pending_buf, me.pending - ce, ce)), ye === 0 && (me.gzindex = 0, me.status = 91);
        } else me.status = 91;
        if (me.status === 91) if (me.gzhead.comment) {
          ce = me.pending;
          do {
            if (me.pending === me.pending_buf_size && (me.gzhead.hcrc && me.pending > ce && (Z.adler = c(Z.adler, me.pending_buf, me.pending - ce, ce)), k(Z), ce = me.pending, me.pending === me.pending_buf_size)) {
              ye = 1;
              break;
            }
            ye = me.gzindex < me.gzhead.comment.length ? 255 & me.gzhead.comment.charCodeAt(me.gzindex++) : 0, O(me, ye);
          } while (ye !== 0);
          me.gzhead.hcrc && me.pending > ce && (Z.adler = c(Z.adler, me.pending_buf, me.pending - ce, ce)), ye === 0 && (me.status = 103);
        } else me.status = 103;
        if (me.status === 103 && (me.gzhead.hcrc ? (me.pending + 2 > me.pending_buf_size && k(Z), me.pending + 2 <= me.pending_buf_size && (O(me, 255 & Z.adler), O(me, Z.adler >> 8 & 255), Z.adler = 0, me.status = p)) : me.status = p), me.pending !== 0) {
          if (k(Z), Z.avail_out === 0) return me.last_flush = -1, v;
        } else if (Z.avail_in === 0 && x(ve) <= x(he) && ve !== m) return M(Z, -5);
        if (me.status === 666 && Z.avail_in !== 0) return M(Z, -5);
        if (Z.avail_in !== 0 || me.lookahead !== 0 || ve !== h && me.status !== 666) {
          var Se = me.strategy === 2 ? function(Ce, Ne) {
            for (var $e; ; ) {
              if (Ce.lookahead === 0 && (J(Ce), Ce.lookahead === 0)) {
                if (Ne === h) return d;
                break;
              }
              if (Ce.match_length = 0, $e = o._tr_tally(Ce, 0, Ce.window[Ce.strstart]), Ce.lookahead--, Ce.strstart++, $e && (T(Ce, false), Ce.strm.avail_out === 0)) return d;
            }
            return Ce.insert = 0, Ne === m ? (T(Ce, true), Ce.strm.avail_out === 0 ? w : E) : Ce.last_lit && (T(Ce, false), Ce.strm.avail_out === 0) ? d : y;
          }(me, ve) : me.strategy === 3 ? function(Ce, Ne) {
            for (var $e, Re, Ge, Fe, Ue = Ce.window; ; ) {
              if (Ce.lookahead <= L) {
                if (J(Ce), Ce.lookahead <= L && Ne === h) return d;
                if (Ce.lookahead === 0) break;
              }
              if (Ce.match_length = 0, Ce.lookahead >= N && 0 < Ce.strstart && (Re = Ue[Ge = Ce.strstart - 1]) === Ue[++Ge] && Re === Ue[++Ge] && Re === Ue[++Ge]) {
                Fe = Ce.strstart + L;
                do
                  ;
                while (Re === Ue[++Ge] && Re === Ue[++Ge] && Re === Ue[++Ge] && Re === Ue[++Ge] && Re === Ue[++Ge] && Re === Ue[++Ge] && Re === Ue[++Ge] && Re === Ue[++Ge] && Ge < Fe);
                Ce.match_length = L - (Fe - Ge), Ce.match_length > Ce.lookahead && (Ce.match_length = Ce.lookahead);
              }
              if (Ce.match_length >= N ? ($e = o._tr_tally(Ce, 1, Ce.match_length - N), Ce.lookahead -= Ce.match_length, Ce.strstart += Ce.match_length, Ce.match_length = 0) : ($e = o._tr_tally(Ce, 0, Ce.window[Ce.strstart]), Ce.lookahead--, Ce.strstart++), $e && (T(Ce, false), Ce.strm.avail_out === 0)) return d;
            }
            return Ce.insert = 0, Ne === m ? (T(Ce, true), Ce.strm.avail_out === 0 ? w : E) : Ce.last_lit && (T(Ce, false), Ce.strm.avail_out === 0) ? d : y;
          }(me, ve) : i[me.level].func(me, ve);
          if (Se !== w && Se !== E || (me.status = 666), Se === d || Se === w) return Z.avail_out === 0 && (me.last_flush = -1), v;
          if (Se === y && (ve === 1 ? o._tr_align(me) : ve !== 5 && (o._tr_stored_block(me, 0, 0, false), ve === 3 && (g(me.head), me.lookahead === 0 && (me.strstart = 0, me.block_start = 0, me.insert = 0))), k(Z), Z.avail_out === 0)) return me.last_flush = -1, v;
        }
        return ve !== m ? v : me.wrap <= 0 ? 1 : (me.wrap === 2 ? (O(me, 255 & Z.adler), O(me, Z.adler >> 8 & 255), O(me, Z.adler >> 16 & 255), O(me, Z.adler >> 24 & 255), O(me, 255 & Z.total_in), O(me, Z.total_in >> 8 & 255), O(me, Z.total_in >> 16 & 255), O(me, Z.total_in >> 24 & 255)) : (K(me, Z.adler >>> 16), K(me, 65535 & Z.adler)), k(Z), 0 < me.wrap && (me.wrap = -me.wrap), me.pending !== 0 ? v : 1);
      }, s.deflateEnd = function(Z) {
        var ve;
        return Z && Z.state ? (ve = Z.state.status) !== u && ve !== 69 && ve !== 73 && ve !== 91 && ve !== 103 && ve !== p && ve !== 666 ? M(Z, b) : (Z.state = null, ve === p ? M(Z, -3) : v) : b;
      }, s.deflateSetDictionary = function(Z, ve) {
        var he, me, ce, ye, Oe, Se, Ce, Ne, $e = ve.length;
        if (!Z || !Z.state || (ye = (he = Z.state).wrap) === 2 || ye === 1 && he.status !== u || he.lookahead) return b;
        for (ye === 1 && (Z.adler = f(Z.adler, ve, $e, 0)), he.wrap = 0, $e >= he.w_size && (ye === 0 && (g(he.head), he.strstart = 0, he.block_start = 0, he.insert = 0), Ne = new a.Buf8(he.w_size), a.arraySet(Ne, ve, $e - he.w_size, he.w_size, 0), ve = Ne, $e = he.w_size), Oe = Z.avail_in, Se = Z.next_in, Ce = Z.input, Z.avail_in = $e, Z.next_in = 0, Z.input = ve, J(he); he.lookahead >= N; ) {
          for (me = he.strstart, ce = he.lookahead - (N - 1); he.ins_h = (he.ins_h << he.hash_shift ^ he.window[me + N - 1]) & he.hash_mask, he.prev[me & he.w_mask] = he.head[he.ins_h], he.head[he.ins_h] = me, me++, --ce; ) ;
          he.strstart = me, he.lookahead = N - 1, J(he);
        }
        return he.strstart += he.lookahead, he.block_start = he.strstart, he.insert = he.lookahead, he.lookahead = 0, he.match_length = he.prev_length = N - 1, he.match_available = 0, Z.next_in = Se, Z.input = Ce, Z.avail_in = Oe, he.wrap = ye, v;
      }, s.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(n, r, s) {
      r.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
      };
    }, {}], 48: [function(n, r, s) {
      r.exports = function(i, a) {
        var o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U, Q, P, N, L, B, u, p, d, y;
        o = i.state, f = i.next_in, d = i.input, c = f + (i.avail_in - 5), l = i.next_out, y = i.output, h = l - (a - i.avail_out), m = l + (i.avail_out - 257), v = o.dmax, b = o.wsize, A = o.whave, _ = o.wnext, C = o.window, I = o.hold, S = o.bits, $ = o.lencode, F = o.distcode, U = (1 << o.lenbits) - 1, Q = (1 << o.distbits) - 1;
        e: do {
          S < 15 && (I += d[f++] << S, S += 8, I += d[f++] << S, S += 8), P = $[I & U];
          t: for (; ; ) {
            if (I >>>= N = P >>> 24, S -= N, (N = P >>> 16 & 255) === 0) y[l++] = 65535 & P;
            else {
              if (!(16 & N)) {
                if (!(64 & N)) {
                  P = $[(65535 & P) + (I & (1 << N) - 1)];
                  continue t;
                }
                if (32 & N) {
                  o.mode = 12;
                  break e;
                }
                i.msg = "invalid literal/length code", o.mode = 30;
                break e;
              }
              L = 65535 & P, (N &= 15) && (S < N && (I += d[f++] << S, S += 8), L += I & (1 << N) - 1, I >>>= N, S -= N), S < 15 && (I += d[f++] << S, S += 8, I += d[f++] << S, S += 8), P = F[I & Q];
              r: for (; ; ) {
                if (I >>>= N = P >>> 24, S -= N, !(16 & (N = P >>> 16 & 255))) {
                  if (!(64 & N)) {
                    P = F[(65535 & P) + (I & (1 << N) - 1)];
                    continue r;
                  }
                  i.msg = "invalid distance code", o.mode = 30;
                  break e;
                }
                if (B = 65535 & P, S < (N &= 15) && (I += d[f++] << S, (S += 8) < N && (I += d[f++] << S, S += 8)), v < (B += I & (1 << N) - 1)) {
                  i.msg = "invalid distance too far back", o.mode = 30;
                  break e;
                }
                if (I >>>= N, S -= N, (N = l - h) < B) {
                  if (A < (N = B - N) && o.sane) {
                    i.msg = "invalid distance too far back", o.mode = 30;
                    break e;
                  }
                  if (p = C, (u = 0) === _) {
                    if (u += b - N, N < L) {
                      for (L -= N; y[l++] = C[u++], --N; ) ;
                      u = l - B, p = y;
                    }
                  } else if (_ < N) {
                    if (u += b + _ - N, (N -= _) < L) {
                      for (L -= N; y[l++] = C[u++], --N; ) ;
                      if (u = 0, _ < L) {
                        for (L -= N = _; y[l++] = C[u++], --N; ) ;
                        u = l - B, p = y;
                      }
                    }
                  } else if (u += _ - N, N < L) {
                    for (L -= N; y[l++] = C[u++], --N; ) ;
                    u = l - B, p = y;
                  }
                  for (; 2 < L; ) y[l++] = p[u++], y[l++] = p[u++], y[l++] = p[u++], L -= 3;
                  L && (y[l++] = p[u++], 1 < L && (y[l++] = p[u++]));
                } else {
                  for (u = l - B; y[l++] = y[u++], y[l++] = y[u++], y[l++] = y[u++], 2 < (L -= 3); ) ;
                  L && (y[l++] = y[u++], 1 < L && (y[l++] = y[u++]));
                }
                break;
              }
            }
            break;
          }
        } while (f < c && l < m);
        f -= L = S >> 3, I &= (1 << (S -= L << 3)) - 1, i.next_in = f, i.next_out = l, i.avail_in = f < c ? c - f + 5 : 5 - (f - c), i.avail_out = l < m ? m - l + 257 : 257 - (l - m), o.hold = I, o.bits = S;
      };
    }, {}], 49: [function(n, r, s) {
      var i = n("../utils/common"), a = n("./adler32"), o = n("./crc32"), f = n("./inffast"), c = n("./inftrees"), l = 1, h = 2, m = 0, v = -2, b = 1, A = 852, _ = 592;
      function C(u) {
        return (u >>> 24 & 255) + (u >>> 8 & 65280) + ((65280 & u) << 8) + ((255 & u) << 24);
      }
      function I() {
        this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new i.Buf16(320), this.work = new i.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function S(u) {
        var p;
        return u && u.state ? (p = u.state, u.total_in = u.total_out = p.total = 0, u.msg = "", p.wrap && (u.adler = 1 & p.wrap), p.mode = b, p.last = 0, p.havedict = 0, p.dmax = 32768, p.head = null, p.hold = 0, p.bits = 0, p.lencode = p.lendyn = new i.Buf32(A), p.distcode = p.distdyn = new i.Buf32(_), p.sane = 1, p.back = -1, m) : v;
      }
      function $(u) {
        var p;
        return u && u.state ? ((p = u.state).wsize = 0, p.whave = 0, p.wnext = 0, S(u)) : v;
      }
      function F(u, p) {
        var d, y;
        return u && u.state ? (y = u.state, p < 0 ? (d = 0, p = -p) : (d = 1 + (p >> 4), p < 48 && (p &= 15)), p && (p < 8 || 15 < p) ? v : (y.window !== null && y.wbits !== p && (y.window = null), y.wrap = d, y.wbits = p, $(u))) : v;
      }
      function U(u, p) {
        var d, y;
        return u ? (y = new I(), (u.state = y).window = null, (d = F(u, p)) !== m && (u.state = null), d) : v;
      }
      var Q, P, N = true;
      function L(u) {
        if (N) {
          var p;
          for (Q = new i.Buf32(512), P = new i.Buf32(32), p = 0; p < 144; ) u.lens[p++] = 8;
          for (; p < 256; ) u.lens[p++] = 9;
          for (; p < 280; ) u.lens[p++] = 7;
          for (; p < 288; ) u.lens[p++] = 8;
          for (c(l, u.lens, 0, 288, Q, 0, u.work, { bits: 9 }), p = 0; p < 32; ) u.lens[p++] = 5;
          c(h, u.lens, 0, 32, P, 0, u.work, { bits: 5 }), N = false;
        }
        u.lencode = Q, u.lenbits = 9, u.distcode = P, u.distbits = 5;
      }
      function B(u, p, d, y) {
        var w, E = u.state;
        return E.window === null && (E.wsize = 1 << E.wbits, E.wnext = 0, E.whave = 0, E.window = new i.Buf8(E.wsize)), y >= E.wsize ? (i.arraySet(E.window, p, d - E.wsize, E.wsize, 0), E.wnext = 0, E.whave = E.wsize) : (y < (w = E.wsize - E.wnext) && (w = y), i.arraySet(E.window, p, d - y, w, E.wnext), (y -= w) ? (i.arraySet(E.window, p, d - y, y, 0), E.wnext = y, E.whave = E.wsize) : (E.wnext += w, E.wnext === E.wsize && (E.wnext = 0), E.whave < E.wsize && (E.whave += w))), 0;
      }
      s.inflateReset = $, s.inflateReset2 = F, s.inflateResetKeep = S, s.inflateInit = function(u) {
        return U(u, 15);
      }, s.inflateInit2 = U, s.inflate = function(u, p) {
        var d, y, w, E, M, x, g, k, T, O, K, Y, J, G, X, ie, de, se, te, le, Z, ve, he, me, ce = 0, ye = new i.Buf8(4), Oe = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!u || !u.state || !u.output || !u.input && u.avail_in !== 0) return v;
        (d = u.state).mode === 12 && (d.mode = 13), M = u.next_out, w = u.output, g = u.avail_out, E = u.next_in, y = u.input, x = u.avail_in, k = d.hold, T = d.bits, O = x, K = g, ve = m;
        e: for (; ; ) switch (d.mode) {
          case b:
            if (d.wrap === 0) {
              d.mode = 13;
              break;
            }
            for (; T < 16; ) {
              if (x === 0) break e;
              x--, k += y[E++] << T, T += 8;
            }
            if (2 & d.wrap && k === 35615) {
              ye[d.check = 0] = 255 & k, ye[1] = k >>> 8 & 255, d.check = o(d.check, ye, 2, 0), T = k = 0, d.mode = 2;
              break;
            }
            if (d.flags = 0, d.head && (d.head.done = false), !(1 & d.wrap) || (((255 & k) << 8) + (k >> 8)) % 31) {
              u.msg = "incorrect header check", d.mode = 30;
              break;
            }
            if ((15 & k) != 8) {
              u.msg = "unknown compression method", d.mode = 30;
              break;
            }
            if (T -= 4, Z = 8 + (15 & (k >>>= 4)), d.wbits === 0) d.wbits = Z;
            else if (Z > d.wbits) {
              u.msg = "invalid window size", d.mode = 30;
              break;
            }
            d.dmax = 1 << Z, u.adler = d.check = 1, d.mode = 512 & k ? 10 : 12, T = k = 0;
            break;
          case 2:
            for (; T < 16; ) {
              if (x === 0) break e;
              x--, k += y[E++] << T, T += 8;
            }
            if (d.flags = k, (255 & d.flags) != 8) {
              u.msg = "unknown compression method", d.mode = 30;
              break;
            }
            if (57344 & d.flags) {
              u.msg = "unknown header flags set", d.mode = 30;
              break;
            }
            d.head && (d.head.text = k >> 8 & 1), 512 & d.flags && (ye[0] = 255 & k, ye[1] = k >>> 8 & 255, d.check = o(d.check, ye, 2, 0)), T = k = 0, d.mode = 3;
          case 3:
            for (; T < 32; ) {
              if (x === 0) break e;
              x--, k += y[E++] << T, T += 8;
            }
            d.head && (d.head.time = k), 512 & d.flags && (ye[0] = 255 & k, ye[1] = k >>> 8 & 255, ye[2] = k >>> 16 & 255, ye[3] = k >>> 24 & 255, d.check = o(d.check, ye, 4, 0)), T = k = 0, d.mode = 4;
          case 4:
            for (; T < 16; ) {
              if (x === 0) break e;
              x--, k += y[E++] << T, T += 8;
            }
            d.head && (d.head.xflags = 255 & k, d.head.os = k >> 8), 512 & d.flags && (ye[0] = 255 & k, ye[1] = k >>> 8 & 255, d.check = o(d.check, ye, 2, 0)), T = k = 0, d.mode = 5;
          case 5:
            if (1024 & d.flags) {
              for (; T < 16; ) {
                if (x === 0) break e;
                x--, k += y[E++] << T, T += 8;
              }
              d.length = k, d.head && (d.head.extra_len = k), 512 & d.flags && (ye[0] = 255 & k, ye[1] = k >>> 8 & 255, d.check = o(d.check, ye, 2, 0)), T = k = 0;
            } else d.head && (d.head.extra = null);
            d.mode = 6;
          case 6:
            if (1024 & d.flags && (x < (Y = d.length) && (Y = x), Y && (d.head && (Z = d.head.extra_len - d.length, d.head.extra || (d.head.extra = new Array(d.head.extra_len)), i.arraySet(d.head.extra, y, E, Y, Z)), 512 & d.flags && (d.check = o(d.check, y, Y, E)), x -= Y, E += Y, d.length -= Y), d.length)) break e;
            d.length = 0, d.mode = 7;
          case 7:
            if (2048 & d.flags) {
              if (x === 0) break e;
              for (Y = 0; Z = y[E + Y++], d.head && Z && d.length < 65536 && (d.head.name += String.fromCharCode(Z)), Z && Y < x; ) ;
              if (512 & d.flags && (d.check = o(d.check, y, Y, E)), x -= Y, E += Y, Z) break e;
            } else d.head && (d.head.name = null);
            d.length = 0, d.mode = 8;
          case 8:
            if (4096 & d.flags) {
              if (x === 0) break e;
              for (Y = 0; Z = y[E + Y++], d.head && Z && d.length < 65536 && (d.head.comment += String.fromCharCode(Z)), Z && Y < x; ) ;
              if (512 & d.flags && (d.check = o(d.check, y, Y, E)), x -= Y, E += Y, Z) break e;
            } else d.head && (d.head.comment = null);
            d.mode = 9;
          case 9:
            if (512 & d.flags) {
              for (; T < 16; ) {
                if (x === 0) break e;
                x--, k += y[E++] << T, T += 8;
              }
              if (k !== (65535 & d.check)) {
                u.msg = "header crc mismatch", d.mode = 30;
                break;
              }
              T = k = 0;
            }
            d.head && (d.head.hcrc = d.flags >> 9 & 1, d.head.done = true), u.adler = d.check = 0, d.mode = 12;
            break;
          case 10:
            for (; T < 32; ) {
              if (x === 0) break e;
              x--, k += y[E++] << T, T += 8;
            }
            u.adler = d.check = C(k), T = k = 0, d.mode = 11;
          case 11:
            if (d.havedict === 0) return u.next_out = M, u.avail_out = g, u.next_in = E, u.avail_in = x, d.hold = k, d.bits = T, 2;
            u.adler = d.check = 1, d.mode = 12;
          case 12:
            if (p === 5 || p === 6) break e;
          case 13:
            if (d.last) {
              k >>>= 7 & T, T -= 7 & T, d.mode = 27;
              break;
            }
            for (; T < 3; ) {
              if (x === 0) break e;
              x--, k += y[E++] << T, T += 8;
            }
            switch (d.last = 1 & k, T -= 1, 3 & (k >>>= 1)) {
              case 0:
                d.mode = 14;
                break;
              case 1:
                if (L(d), d.mode = 20, p !== 6) break;
                k >>>= 2, T -= 2;
                break e;
              case 2:
                d.mode = 17;
                break;
              case 3:
                u.msg = "invalid block type", d.mode = 30;
            }
            k >>>= 2, T -= 2;
            break;
          case 14:
            for (k >>>= 7 & T, T -= 7 & T; T < 32; ) {
              if (x === 0) break e;
              x--, k += y[E++] << T, T += 8;
            }
            if ((65535 & k) != (k >>> 16 ^ 65535)) {
              u.msg = "invalid stored block lengths", d.mode = 30;
              break;
            }
            if (d.length = 65535 & k, T = k = 0, d.mode = 15, p === 6) break e;
          case 15:
            d.mode = 16;
          case 16:
            if (Y = d.length) {
              if (x < Y && (Y = x), g < Y && (Y = g), Y === 0) break e;
              i.arraySet(w, y, E, Y, M), x -= Y, E += Y, g -= Y, M += Y, d.length -= Y;
              break;
            }
            d.mode = 12;
            break;
          case 17:
            for (; T < 14; ) {
              if (x === 0) break e;
              x--, k += y[E++] << T, T += 8;
            }
            if (d.nlen = 257 + (31 & k), k >>>= 5, T -= 5, d.ndist = 1 + (31 & k), k >>>= 5, T -= 5, d.ncode = 4 + (15 & k), k >>>= 4, T -= 4, 286 < d.nlen || 30 < d.ndist) {
              u.msg = "too many length or distance symbols", d.mode = 30;
              break;
            }
            d.have = 0, d.mode = 18;
          case 18:
            for (; d.have < d.ncode; ) {
              for (; T < 3; ) {
                if (x === 0) break e;
                x--, k += y[E++] << T, T += 8;
              }
              d.lens[Oe[d.have++]] = 7 & k, k >>>= 3, T -= 3;
            }
            for (; d.have < 19; ) d.lens[Oe[d.have++]] = 0;
            if (d.lencode = d.lendyn, d.lenbits = 7, he = { bits: d.lenbits }, ve = c(0, d.lens, 0, 19, d.lencode, 0, d.work, he), d.lenbits = he.bits, ve) {
              u.msg = "invalid code lengths set", d.mode = 30;
              break;
            }
            d.have = 0, d.mode = 19;
          case 19:
            for (; d.have < d.nlen + d.ndist; ) {
              for (; ie = (ce = d.lencode[k & (1 << d.lenbits) - 1]) >>> 16 & 255, de = 65535 & ce, !((X = ce >>> 24) <= T); ) {
                if (x === 0) break e;
                x--, k += y[E++] << T, T += 8;
              }
              if (de < 16) k >>>= X, T -= X, d.lens[d.have++] = de;
              else {
                if (de === 16) {
                  for (me = X + 2; T < me; ) {
                    if (x === 0) break e;
                    x--, k += y[E++] << T, T += 8;
                  }
                  if (k >>>= X, T -= X, d.have === 0) {
                    u.msg = "invalid bit length repeat", d.mode = 30;
                    break;
                  }
                  Z = d.lens[d.have - 1], Y = 3 + (3 & k), k >>>= 2, T -= 2;
                } else if (de === 17) {
                  for (me = X + 3; T < me; ) {
                    if (x === 0) break e;
                    x--, k += y[E++] << T, T += 8;
                  }
                  T -= X, Z = 0, Y = 3 + (7 & (k >>>= X)), k >>>= 3, T -= 3;
                } else {
                  for (me = X + 7; T < me; ) {
                    if (x === 0) break e;
                    x--, k += y[E++] << T, T += 8;
                  }
                  T -= X, Z = 0, Y = 11 + (127 & (k >>>= X)), k >>>= 7, T -= 7;
                }
                if (d.have + Y > d.nlen + d.ndist) {
                  u.msg = "invalid bit length repeat", d.mode = 30;
                  break;
                }
                for (; Y--; ) d.lens[d.have++] = Z;
              }
            }
            if (d.mode === 30) break;
            if (d.lens[256] === 0) {
              u.msg = "invalid code -- missing end-of-block", d.mode = 30;
              break;
            }
            if (d.lenbits = 9, he = { bits: d.lenbits }, ve = c(l, d.lens, 0, d.nlen, d.lencode, 0, d.work, he), d.lenbits = he.bits, ve) {
              u.msg = "invalid literal/lengths set", d.mode = 30;
              break;
            }
            if (d.distbits = 6, d.distcode = d.distdyn, he = { bits: d.distbits }, ve = c(h, d.lens, d.nlen, d.ndist, d.distcode, 0, d.work, he), d.distbits = he.bits, ve) {
              u.msg = "invalid distances set", d.mode = 30;
              break;
            }
            if (d.mode = 20, p === 6) break e;
          case 20:
            d.mode = 21;
          case 21:
            if (6 <= x && 258 <= g) {
              u.next_out = M, u.avail_out = g, u.next_in = E, u.avail_in = x, d.hold = k, d.bits = T, f(u, K), M = u.next_out, w = u.output, g = u.avail_out, E = u.next_in, y = u.input, x = u.avail_in, k = d.hold, T = d.bits, d.mode === 12 && (d.back = -1);
              break;
            }
            for (d.back = 0; ie = (ce = d.lencode[k & (1 << d.lenbits) - 1]) >>> 16 & 255, de = 65535 & ce, !((X = ce >>> 24) <= T); ) {
              if (x === 0) break e;
              x--, k += y[E++] << T, T += 8;
            }
            if (ie && !(240 & ie)) {
              for (se = X, te = ie, le = de; ie = (ce = d.lencode[le + ((k & (1 << se + te) - 1) >> se)]) >>> 16 & 255, de = 65535 & ce, !(se + (X = ce >>> 24) <= T); ) {
                if (x === 0) break e;
                x--, k += y[E++] << T, T += 8;
              }
              k >>>= se, T -= se, d.back += se;
            }
            if (k >>>= X, T -= X, d.back += X, d.length = de, ie === 0) {
              d.mode = 26;
              break;
            }
            if (32 & ie) {
              d.back = -1, d.mode = 12;
              break;
            }
            if (64 & ie) {
              u.msg = "invalid literal/length code", d.mode = 30;
              break;
            }
            d.extra = 15 & ie, d.mode = 22;
          case 22:
            if (d.extra) {
              for (me = d.extra; T < me; ) {
                if (x === 0) break e;
                x--, k += y[E++] << T, T += 8;
              }
              d.length += k & (1 << d.extra) - 1, k >>>= d.extra, T -= d.extra, d.back += d.extra;
            }
            d.was = d.length, d.mode = 23;
          case 23:
            for (; ie = (ce = d.distcode[k & (1 << d.distbits) - 1]) >>> 16 & 255, de = 65535 & ce, !((X = ce >>> 24) <= T); ) {
              if (x === 0) break e;
              x--, k += y[E++] << T, T += 8;
            }
            if (!(240 & ie)) {
              for (se = X, te = ie, le = de; ie = (ce = d.distcode[le + ((k & (1 << se + te) - 1) >> se)]) >>> 16 & 255, de = 65535 & ce, !(se + (X = ce >>> 24) <= T); ) {
                if (x === 0) break e;
                x--, k += y[E++] << T, T += 8;
              }
              k >>>= se, T -= se, d.back += se;
            }
            if (k >>>= X, T -= X, d.back += X, 64 & ie) {
              u.msg = "invalid distance code", d.mode = 30;
              break;
            }
            d.offset = de, d.extra = 15 & ie, d.mode = 24;
          case 24:
            if (d.extra) {
              for (me = d.extra; T < me; ) {
                if (x === 0) break e;
                x--, k += y[E++] << T, T += 8;
              }
              d.offset += k & (1 << d.extra) - 1, k >>>= d.extra, T -= d.extra, d.back += d.extra;
            }
            if (d.offset > d.dmax) {
              u.msg = "invalid distance too far back", d.mode = 30;
              break;
            }
            d.mode = 25;
          case 25:
            if (g === 0) break e;
            if (Y = K - g, d.offset > Y) {
              if ((Y = d.offset - Y) > d.whave && d.sane) {
                u.msg = "invalid distance too far back", d.mode = 30;
                break;
              }
              J = Y > d.wnext ? (Y -= d.wnext, d.wsize - Y) : d.wnext - Y, Y > d.length && (Y = d.length), G = d.window;
            } else G = w, J = M - d.offset, Y = d.length;
            for (g < Y && (Y = g), g -= Y, d.length -= Y; w[M++] = G[J++], --Y; ) ;
            d.length === 0 && (d.mode = 21);
            break;
          case 26:
            if (g === 0) break e;
            w[M++] = d.length, g--, d.mode = 21;
            break;
          case 27:
            if (d.wrap) {
              for (; T < 32; ) {
                if (x === 0) break e;
                x--, k |= y[E++] << T, T += 8;
              }
              if (K -= g, u.total_out += K, d.total += K, K && (u.adler = d.check = d.flags ? o(d.check, w, K, M - K) : a(d.check, w, K, M - K)), K = g, (d.flags ? k : C(k)) !== d.check) {
                u.msg = "incorrect data check", d.mode = 30;
                break;
              }
              T = k = 0;
            }
            d.mode = 28;
          case 28:
            if (d.wrap && d.flags) {
              for (; T < 32; ) {
                if (x === 0) break e;
                x--, k += y[E++] << T, T += 8;
              }
              if (k !== (4294967295 & d.total)) {
                u.msg = "incorrect length check", d.mode = 30;
                break;
              }
              T = k = 0;
            }
            d.mode = 29;
          case 29:
            ve = 1;
            break e;
          case 30:
            ve = -3;
            break e;
          case 31:
            return -4;
          case 32:
          default:
            return v;
        }
        return u.next_out = M, u.avail_out = g, u.next_in = E, u.avail_in = x, d.hold = k, d.bits = T, (d.wsize || K !== u.avail_out && d.mode < 30 && (d.mode < 27 || p !== 4)) && B(u, u.output, u.next_out, K - u.avail_out) ? (d.mode = 31, -4) : (O -= u.avail_in, K -= u.avail_out, u.total_in += O, u.total_out += K, d.total += K, d.wrap && K && (u.adler = d.check = d.flags ? o(d.check, w, K, u.next_out - K) : a(d.check, w, K, u.next_out - K)), u.data_type = d.bits + (d.last ? 64 : 0) + (d.mode === 12 ? 128 : 0) + (d.mode === 20 || d.mode === 15 ? 256 : 0), (O == 0 && K === 0 || p === 4) && ve === m && (ve = -5), ve);
      }, s.inflateEnd = function(u) {
        if (!u || !u.state) return v;
        var p = u.state;
        return p.window && (p.window = null), u.state = null, m;
      }, s.inflateGetHeader = function(u, p) {
        var d;
        return u && u.state && 2 & (d = u.state).wrap ? ((d.head = p).done = false, m) : v;
      }, s.inflateSetDictionary = function(u, p) {
        var d, y = p.length;
        return u && u.state ? (d = u.state).wrap !== 0 && d.mode !== 11 ? v : d.mode === 11 && a(1, p, y, 0) !== d.check ? -3 : B(u, p, y, y) ? (d.mode = 31, -4) : (d.havedict = 1, m) : v;
      }, s.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(n, r, s) {
      var i = n("../utils/common"), a = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], o = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], f = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], c = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      r.exports = function(l, h, m, v, b, A, _, C) {
        var I, S, $, F, U, Q, P, N, L, B = C.bits, u = 0, p = 0, d = 0, y = 0, w = 0, E = 0, M = 0, x = 0, g = 0, k = 0, T = null, O = 0, K = new i.Buf16(16), Y = new i.Buf16(16), J = null, G = 0;
        for (u = 0; u <= 15; u++) K[u] = 0;
        for (p = 0; p < v; p++) K[h[m + p]]++;
        for (w = B, y = 15; 1 <= y && K[y] === 0; y--) ;
        if (y < w && (w = y), y === 0) return b[A++] = 20971520, b[A++] = 20971520, C.bits = 1, 0;
        for (d = 1; d < y && K[d] === 0; d++) ;
        for (w < d && (w = d), u = x = 1; u <= 15; u++) if (x <<= 1, (x -= K[u]) < 0) return -1;
        if (0 < x && (l === 0 || y !== 1)) return -1;
        for (Y[1] = 0, u = 1; u < 15; u++) Y[u + 1] = Y[u] + K[u];
        for (p = 0; p < v; p++) h[m + p] !== 0 && (_[Y[h[m + p]]++] = p);
        if (Q = l === 0 ? (T = J = _, 19) : l === 1 ? (T = a, O -= 257, J = o, G -= 257, 256) : (T = f, J = c, -1), u = d, U = A, M = p = k = 0, $ = -1, F = (g = 1 << (E = w)) - 1, l === 1 && 852 < g || l === 2 && 592 < g) return 1;
        for (; ; ) {
          for (P = u - M, L = _[p] < Q ? (N = 0, _[p]) : _[p] > Q ? (N = J[G + _[p]], T[O + _[p]]) : (N = 96, 0), I = 1 << u - M, d = S = 1 << E; b[U + (k >> M) + (S -= I)] = P << 24 | N << 16 | L | 0, S !== 0; ) ;
          for (I = 1 << u - 1; k & I; ) I >>= 1;
          if (I !== 0 ? (k &= I - 1, k += I) : k = 0, p++, --K[u] == 0) {
            if (u === y) break;
            u = h[m + _[p]];
          }
          if (w < u && (k & F) !== $) {
            for (M === 0 && (M = w), U += d, x = 1 << (E = u - M); E + M < y && !((x -= K[E + M]) <= 0); ) E++, x <<= 1;
            if (g += 1 << E, l === 1 && 852 < g || l === 2 && 592 < g) return 1;
            b[$ = k & F] = w << 24 | E << 16 | U - A | 0;
          }
        }
        return k !== 0 && (b[U + k] = u - M << 24 | 64 << 16 | 0), C.bits = w, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(n, r, s) {
      r.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(n, r, s) {
      var i = n("../utils/common"), a = 0, o = 1;
      function f(ce) {
        for (var ye = ce.length; 0 <= --ye; ) ce[ye] = 0;
      }
      var c = 0, l = 29, h = 256, m = h + 1 + l, v = 30, b = 19, A = 2 * m + 1, _ = 15, C = 16, I = 7, S = 256, $ = 16, F = 17, U = 18, Q = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], P = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], N = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], L = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], B = new Array(2 * (m + 2));
      f(B);
      var u = new Array(2 * v);
      f(u);
      var p = new Array(512);
      f(p);
      var d = new Array(256);
      f(d);
      var y = new Array(l);
      f(y);
      var w, E, M, x = new Array(v);
      function g(ce, ye, Oe, Se, Ce) {
        this.static_tree = ce, this.extra_bits = ye, this.extra_base = Oe, this.elems = Se, this.max_length = Ce, this.has_stree = ce && ce.length;
      }
      function k(ce, ye) {
        this.dyn_tree = ce, this.max_code = 0, this.stat_desc = ye;
      }
      function T(ce) {
        return ce < 256 ? p[ce] : p[256 + (ce >>> 7)];
      }
      function O(ce, ye) {
        ce.pending_buf[ce.pending++] = 255 & ye, ce.pending_buf[ce.pending++] = ye >>> 8 & 255;
      }
      function K(ce, ye, Oe) {
        ce.bi_valid > C - Oe ? (ce.bi_buf |= ye << ce.bi_valid & 65535, O(ce, ce.bi_buf), ce.bi_buf = ye >> C - ce.bi_valid, ce.bi_valid += Oe - C) : (ce.bi_buf |= ye << ce.bi_valid & 65535, ce.bi_valid += Oe);
      }
      function Y(ce, ye, Oe) {
        K(ce, Oe[2 * ye], Oe[2 * ye + 1]);
      }
      function J(ce, ye) {
        for (var Oe = 0; Oe |= 1 & ce, ce >>>= 1, Oe <<= 1, 0 < --ye; ) ;
        return Oe >>> 1;
      }
      function G(ce, ye, Oe) {
        var Se, Ce, Ne = new Array(_ + 1), $e = 0;
        for (Se = 1; Se <= _; Se++) Ne[Se] = $e = $e + Oe[Se - 1] << 1;
        for (Ce = 0; Ce <= ye; Ce++) {
          var Re = ce[2 * Ce + 1];
          Re !== 0 && (ce[2 * Ce] = J(Ne[Re]++, Re));
        }
      }
      function X(ce) {
        var ye;
        for (ye = 0; ye < m; ye++) ce.dyn_ltree[2 * ye] = 0;
        for (ye = 0; ye < v; ye++) ce.dyn_dtree[2 * ye] = 0;
        for (ye = 0; ye < b; ye++) ce.bl_tree[2 * ye] = 0;
        ce.dyn_ltree[2 * S] = 1, ce.opt_len = ce.static_len = 0, ce.last_lit = ce.matches = 0;
      }
      function ie(ce) {
        8 < ce.bi_valid ? O(ce, ce.bi_buf) : 0 < ce.bi_valid && (ce.pending_buf[ce.pending++] = ce.bi_buf), ce.bi_buf = 0, ce.bi_valid = 0;
      }
      function de(ce, ye, Oe, Se) {
        var Ce = 2 * ye, Ne = 2 * Oe;
        return ce[Ce] < ce[Ne] || ce[Ce] === ce[Ne] && Se[ye] <= Se[Oe];
      }
      function se(ce, ye, Oe) {
        for (var Se = ce.heap[Oe], Ce = Oe << 1; Ce <= ce.heap_len && (Ce < ce.heap_len && de(ye, ce.heap[Ce + 1], ce.heap[Ce], ce.depth) && Ce++, !de(ye, Se, ce.heap[Ce], ce.depth)); ) ce.heap[Oe] = ce.heap[Ce], Oe = Ce, Ce <<= 1;
        ce.heap[Oe] = Se;
      }
      function te(ce, ye, Oe) {
        var Se, Ce, Ne, $e, Re = 0;
        if (ce.last_lit !== 0) for (; Se = ce.pending_buf[ce.d_buf + 2 * Re] << 8 | ce.pending_buf[ce.d_buf + 2 * Re + 1], Ce = ce.pending_buf[ce.l_buf + Re], Re++, Se === 0 ? Y(ce, Ce, ye) : (Y(ce, (Ne = d[Ce]) + h + 1, ye), ($e = Q[Ne]) !== 0 && K(ce, Ce -= y[Ne], $e), Y(ce, Ne = T(--Se), Oe), ($e = P[Ne]) !== 0 && K(ce, Se -= x[Ne], $e)), Re < ce.last_lit; ) ;
        Y(ce, S, ye);
      }
      function le(ce, ye) {
        var Oe, Se, Ce, Ne = ye.dyn_tree, $e = ye.stat_desc.static_tree, Re = ye.stat_desc.has_stree, Ge = ye.stat_desc.elems, Fe = -1;
        for (ce.heap_len = 0, ce.heap_max = A, Oe = 0; Oe < Ge; Oe++) Ne[2 * Oe] !== 0 ? (ce.heap[++ce.heap_len] = Fe = Oe, ce.depth[Oe] = 0) : Ne[2 * Oe + 1] = 0;
        for (; ce.heap_len < 2; ) Ne[2 * (Ce = ce.heap[++ce.heap_len] = Fe < 2 ? ++Fe : 0)] = 1, ce.depth[Ce] = 0, ce.opt_len--, Re && (ce.static_len -= $e[2 * Ce + 1]);
        for (ye.max_code = Fe, Oe = ce.heap_len >> 1; 1 <= Oe; Oe--) se(ce, Ne, Oe);
        for (Ce = Ge; Oe = ce.heap[1], ce.heap[1] = ce.heap[ce.heap_len--], se(ce, Ne, 1), Se = ce.heap[1], ce.heap[--ce.heap_max] = Oe, ce.heap[--ce.heap_max] = Se, Ne[2 * Ce] = Ne[2 * Oe] + Ne[2 * Se], ce.depth[Ce] = (ce.depth[Oe] >= ce.depth[Se] ? ce.depth[Oe] : ce.depth[Se]) + 1, Ne[2 * Oe + 1] = Ne[2 * Se + 1] = Ce, ce.heap[1] = Ce++, se(ce, Ne, 1), 2 <= ce.heap_len; ) ;
        ce.heap[--ce.heap_max] = ce.heap[1], function(Ue, kt) {
          var pe, re, ue, xe, Me, We, De = kt.dyn_tree, je = kt.max_code, ir = kt.stat_desc.static_tree, Xe = kt.stat_desc.has_stree, st = kt.stat_desc.extra_bits, Vt = kt.stat_desc.extra_base, at = kt.stat_desc.max_length, ht = 0;
          for (xe = 0; xe <= _; xe++) Ue.bl_count[xe] = 0;
          for (De[2 * Ue.heap[Ue.heap_max] + 1] = 0, pe = Ue.heap_max + 1; pe < A; pe++) at < (xe = De[2 * De[2 * (re = Ue.heap[pe]) + 1] + 1] + 1) && (xe = at, ht++), De[2 * re + 1] = xe, je < re || (Ue.bl_count[xe]++, Me = 0, Vt <= re && (Me = st[re - Vt]), We = De[2 * re], Ue.opt_len += We * (xe + Me), Xe && (Ue.static_len += We * (ir[2 * re + 1] + Me)));
          if (ht !== 0) {
            do {
              for (xe = at - 1; Ue.bl_count[xe] === 0; ) xe--;
              Ue.bl_count[xe]--, Ue.bl_count[xe + 1] += 2, Ue.bl_count[at]--, ht -= 2;
            } while (0 < ht);
            for (xe = at; xe !== 0; xe--) for (re = Ue.bl_count[xe]; re !== 0; ) je < (ue = Ue.heap[--pe]) || (De[2 * ue + 1] !== xe && (Ue.opt_len += (xe - De[2 * ue + 1]) * De[2 * ue], De[2 * ue + 1] = xe), re--);
          }
        }(ce, ye), G(Ne, Fe, ce.bl_count);
      }
      function Z(ce, ye, Oe) {
        var Se, Ce, Ne = -1, $e = ye[1], Re = 0, Ge = 7, Fe = 4;
        for ($e === 0 && (Ge = 138, Fe = 3), ye[2 * (Oe + 1) + 1] = 65535, Se = 0; Se <= Oe; Se++) Ce = $e, $e = ye[2 * (Se + 1) + 1], ++Re < Ge && Ce === $e || (Re < Fe ? ce.bl_tree[2 * Ce] += Re : Ce !== 0 ? (Ce !== Ne && ce.bl_tree[2 * Ce]++, ce.bl_tree[2 * $]++) : Re <= 10 ? ce.bl_tree[2 * F]++ : ce.bl_tree[2 * U]++, Ne = Ce, Fe = (Re = 0) === $e ? (Ge = 138, 3) : Ce === $e ? (Ge = 6, 3) : (Ge = 7, 4));
      }
      function ve(ce, ye, Oe) {
        var Se, Ce, Ne = -1, $e = ye[1], Re = 0, Ge = 7, Fe = 4;
        for ($e === 0 && (Ge = 138, Fe = 3), Se = 0; Se <= Oe; Se++) if (Ce = $e, $e = ye[2 * (Se + 1) + 1], !(++Re < Ge && Ce === $e)) {
          if (Re < Fe) for (; Y(ce, Ce, ce.bl_tree), --Re != 0; ) ;
          else Ce !== 0 ? (Ce !== Ne && (Y(ce, Ce, ce.bl_tree), Re--), Y(ce, $, ce.bl_tree), K(ce, Re - 3, 2)) : Re <= 10 ? (Y(ce, F, ce.bl_tree), K(ce, Re - 3, 3)) : (Y(ce, U, ce.bl_tree), K(ce, Re - 11, 7));
          Ne = Ce, Fe = (Re = 0) === $e ? (Ge = 138, 3) : Ce === $e ? (Ge = 6, 3) : (Ge = 7, 4);
        }
      }
      f(x);
      var he = false;
      function me(ce, ye, Oe, Se) {
        K(ce, (c << 1) + (Se ? 1 : 0), 3), function(Ce, Ne, $e, Re) {
          ie(Ce), O(Ce, $e), O(Ce, ~$e), i.arraySet(Ce.pending_buf, Ce.window, Ne, $e, Ce.pending), Ce.pending += $e;
        }(ce, ye, Oe);
      }
      s._tr_init = function(ce) {
        he || (function() {
          var ye, Oe, Se, Ce, Ne, $e = new Array(_ + 1);
          for (Ce = Se = 0; Ce < l - 1; Ce++) for (y[Ce] = Se, ye = 0; ye < 1 << Q[Ce]; ye++) d[Se++] = Ce;
          for (d[Se - 1] = Ce, Ce = Ne = 0; Ce < 16; Ce++) for (x[Ce] = Ne, ye = 0; ye < 1 << P[Ce]; ye++) p[Ne++] = Ce;
          for (Ne >>= 7; Ce < v; Ce++) for (x[Ce] = Ne << 7, ye = 0; ye < 1 << P[Ce] - 7; ye++) p[256 + Ne++] = Ce;
          for (Oe = 0; Oe <= _; Oe++) $e[Oe] = 0;
          for (ye = 0; ye <= 143; ) B[2 * ye + 1] = 8, ye++, $e[8]++;
          for (; ye <= 255; ) B[2 * ye + 1] = 9, ye++, $e[9]++;
          for (; ye <= 279; ) B[2 * ye + 1] = 7, ye++, $e[7]++;
          for (; ye <= 287; ) B[2 * ye + 1] = 8, ye++, $e[8]++;
          for (G(B, m + 1, $e), ye = 0; ye < v; ye++) u[2 * ye + 1] = 5, u[2 * ye] = J(ye, 5);
          w = new g(B, Q, h + 1, m, _), E = new g(u, P, 0, v, _), M = new g(new Array(0), N, 0, b, I);
        }(), he = true), ce.l_desc = new k(ce.dyn_ltree, w), ce.d_desc = new k(ce.dyn_dtree, E), ce.bl_desc = new k(ce.bl_tree, M), ce.bi_buf = 0, ce.bi_valid = 0, X(ce);
      }, s._tr_stored_block = me, s._tr_flush_block = function(ce, ye, Oe, Se) {
        var Ce, Ne, $e = 0;
        0 < ce.level ? (ce.strm.data_type === 2 && (ce.strm.data_type = function(Re) {
          var Ge, Fe = 4093624447;
          for (Ge = 0; Ge <= 31; Ge++, Fe >>>= 1) if (1 & Fe && Re.dyn_ltree[2 * Ge] !== 0) return a;
          if (Re.dyn_ltree[18] !== 0 || Re.dyn_ltree[20] !== 0 || Re.dyn_ltree[26] !== 0) return o;
          for (Ge = 32; Ge < h; Ge++) if (Re.dyn_ltree[2 * Ge] !== 0) return o;
          return a;
        }(ce)), le(ce, ce.l_desc), le(ce, ce.d_desc), $e = function(Re) {
          var Ge;
          for (Z(Re, Re.dyn_ltree, Re.l_desc.max_code), Z(Re, Re.dyn_dtree, Re.d_desc.max_code), le(Re, Re.bl_desc), Ge = b - 1; 3 <= Ge && Re.bl_tree[2 * L[Ge] + 1] === 0; Ge--) ;
          return Re.opt_len += 3 * (Ge + 1) + 5 + 5 + 4, Ge;
        }(ce), Ce = ce.opt_len + 3 + 7 >>> 3, (Ne = ce.static_len + 3 + 7 >>> 3) <= Ce && (Ce = Ne)) : Ce = Ne = Oe + 5, Oe + 4 <= Ce && ye !== -1 ? me(ce, ye, Oe, Se) : ce.strategy === 4 || Ne === Ce ? (K(ce, 2 + (Se ? 1 : 0), 3), te(ce, B, u)) : (K(ce, 4 + (Se ? 1 : 0), 3), function(Re, Ge, Fe, Ue) {
          var kt;
          for (K(Re, Ge - 257, 5), K(Re, Fe - 1, 5), K(Re, Ue - 4, 4), kt = 0; kt < Ue; kt++) K(Re, Re.bl_tree[2 * L[kt] + 1], 3);
          ve(Re, Re.dyn_ltree, Ge - 1), ve(Re, Re.dyn_dtree, Fe - 1);
        }(ce, ce.l_desc.max_code + 1, ce.d_desc.max_code + 1, $e + 1), te(ce, ce.dyn_ltree, ce.dyn_dtree)), X(ce), Se && ie(ce);
      }, s._tr_tally = function(ce, ye, Oe) {
        return ce.pending_buf[ce.d_buf + 2 * ce.last_lit] = ye >>> 8 & 255, ce.pending_buf[ce.d_buf + 2 * ce.last_lit + 1] = 255 & ye, ce.pending_buf[ce.l_buf + ce.last_lit] = 255 & Oe, ce.last_lit++, ye === 0 ? ce.dyn_ltree[2 * Oe]++ : (ce.matches++, ye--, ce.dyn_ltree[2 * (d[Oe] + h + 1)]++, ce.dyn_dtree[2 * T(ye)]++), ce.last_lit === ce.lit_bufsize - 1;
      }, s._tr_align = function(ce) {
        K(ce, 2, 3), Y(ce, S, B), function(ye) {
          ye.bi_valid === 16 ? (O(ye, ye.bi_buf), ye.bi_buf = 0, ye.bi_valid = 0) : 8 <= ye.bi_valid && (ye.pending_buf[ye.pending++] = 255 & ye.bi_buf, ye.bi_buf >>= 8, ye.bi_valid -= 8);
        }(ce);
      };
    }, { "../utils/common": 41 }], 53: [function(n, r, s) {
      r.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(n, r, s) {
      (function(i) {
        (function(a, o) {
          if (!a.setImmediate) {
            var f, c, l, h, m = 1, v = {}, b = false, A = a.document, _ = Object.getPrototypeOf && Object.getPrototypeOf(a);
            _ = _ && _.setTimeout ? _ : a, f = {}.toString.call(a.process) === "[object process]" ? function($) {
              jt.nextTick(function() {
                I($);
              });
            } : function() {
              if (a.postMessage && !a.importScripts) {
                var $ = true, F = a.onmessage;
                return a.onmessage = function() {
                  $ = false;
                }, a.postMessage("", "*"), a.onmessage = F, $;
              }
            }() ? (h = "setImmediate$" + Math.random() + "$", a.addEventListener ? a.addEventListener("message", S, false) : a.attachEvent("onmessage", S), function($) {
              a.postMessage(h + $, "*");
            }) : a.MessageChannel ? ((l = new MessageChannel()).port1.onmessage = function($) {
              I($.data);
            }, function($) {
              l.port2.postMessage($);
            }) : A && "onreadystatechange" in A.createElement("script") ? (c = A.documentElement, function($) {
              var F = A.createElement("script");
              F.onreadystatechange = function() {
                I($), F.onreadystatechange = null, c.removeChild(F), F = null;
              }, c.appendChild(F);
            }) : function($) {
              setTimeout(I, 0, $);
            }, _.setImmediate = function($) {
              typeof $ != "function" && ($ = new Function("" + $));
              for (var F = new Array(arguments.length - 1), U = 0; U < F.length; U++) F[U] = arguments[U + 1];
              var Q = { callback: $, args: F };
              return v[m] = Q, f(m), m++;
            }, _.clearImmediate = C;
          }
          function C($) {
            delete v[$];
          }
          function I($) {
            if (b) setTimeout(I, 0, $);
            else {
              var F = v[$];
              if (F) {
                b = true;
                try {
                  (function(U) {
                    var Q = U.callback, P = U.args;
                    switch (P.length) {
                      case 0:
                        Q();
                        break;
                      case 1:
                        Q(P[0]);
                        break;
                      case 2:
                        Q(P[0], P[1]);
                        break;
                      case 3:
                        Q(P[0], P[1], P[2]);
                        break;
                      default:
                        Q.apply(o, P);
                    }
                  })(F);
                } finally {
                  C($), b = false;
                }
              }
            }
          }
          function S($) {
            $.source === a && typeof $.data == "string" && $.data.indexOf(h) === 0 && I(+$.data.slice(h.length));
          }
        })(typeof self > "u" ? i === void 0 ? this : i : self);
      }).call(this, typeof mt < "u" ? mt : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(aS);
var fK = aS.exports;
const lK = Fa(fK);
function uK(t3) {
  let e, n, r, s, i, a, o;
  return { c() {
    e = Nr("svg"), n = Nr("polyline"), r = Nr("rect"), s = Nr("line"), i = z(), a = H("span"), o = we(t3[0]), V(n, "points", "21 8 21 21 3 21 3 8"), V(r, "x", "1"), V(r, "y", "3"), V(r, "width", "22"), V(r, "height", "5"), V(s, "x1", "10"), V(s, "y1", "12"), V(s, "x2", "14"), V(s, "y2", "12"), V(e, "width", "18"), V(e, "height", "18"), V(e, "viewBox", "0 0 24 24"), V(e, "fill", "none"), V(e, "stroke", "currentColor"), V(e, "stroke-width", "2"), V(e, "stroke-linecap", "round"), V(e, "stroke-linejoin", "round");
  }, m(f, c) {
    R(f, e, c), q(e, n), q(e, r), q(e, s), R(f, i, c), R(f, a, c), q(a, o);
  }, p(f, c) {
    c & 1 && Ze(o, f[0]);
  }, d(f) {
    f && (D(e), D(i), D(a));
  } };
}
function cK(t3) {
  let e, n, r, s;
  return { c() {
    e = Nr("svg"), n = Nr("polyline"), r = z(), s = H("span"), s.textContent = "Downloaded!", V(n, "points", "20 6 9 17 4 12"), V(e, "width", "18"), V(e, "height", "18"), V(e, "viewBox", "0 0 24 24"), V(e, "fill", "none"), V(e, "stroke", "currentColor"), V(e, "stroke-width", "2");
  }, m(i, a) {
    R(i, e, a), q(e, n), R(i, r, a), R(i, s, a);
  }, p: dt, d(i) {
    i && (D(e), D(r), D(s));
  } };
}
function hK(t3) {
  let e, n, r, s;
  return { c() {
    e = Nr("svg"), n = Nr("circle"), r = z(), s = H("span"), s.textContent = "Compressing...", V(n, "class", "path svelte-psbz6j"), V(n, "cx", "25"), V(n, "cy", "25"), V(n, "r", "20"), V(n, "fill", "none"), V(n, "stroke-width", "5"), V(e, "class", "spinner svelte-psbz6j"), V(e, "viewBox", "0 0 50 50");
  }, m(i, a) {
    R(i, e, a), q(e, n), R(i, r, a), R(i, s, a);
  }, p: dt, d(i) {
    i && (D(e), D(r), D(s));
  } };
}
function dK(t3) {
  let e, n, r, s;
  function i(f, c) {
    return f[2] ? hK : f[3] ? cK : uK;
  }
  let a = i(t3), o = a(t3);
  return { c() {
    e = H("button"), o.c(), V(e, "class", "zip-btn svelte-psbz6j"), e.disabled = n = t3[1] || t3[2], Zt(e, "success", t3[3]);
  }, m(f, c) {
    R(f, e, c), o.m(e, null), r || (s = Kt(e, "click", t3[4]), r = true);
  }, p(f, [c]) {
    a === (a = i(f)) && o ? o.p(f, c) : (o.d(1), o = a(f), o && (o.c(), o.m(e, null))), c & 6 && n !== (n = f[1] || f[2]) && (e.disabled = n), c & 8 && Zt(e, "success", f[3]);
  }, i: dt, o: dt, d(f) {
    f && D(e), o.d(), r = false, s();
  } };
}
function pK(t3, e, n) {
  let { data: r = [] } = e, { zipName: s = "archive.zip" } = e, { label: i = "Download ZIP" } = e, { disabled: a = false } = e, o = false, f = false;
  async function c() {
    if (!(!r || r.length === 0)) {
      n(2, o = true);
      try {
        const l = new lK();
        r.forEach((b) => {
          b.name && b.content && l.file(b.name, b.content);
        });
        const h = await l.generateAsync({ type: "blob" }), m = URL.createObjectURL(h), v = document.createElement("a");
        v.href = m, v.download = s, document.body.appendChild(v), v.click(), document.body.removeChild(v), URL.revokeObjectURL(m), n(3, f = true), setTimeout(() => n(3, f = false), 2e3);
      } catch (l) {
        console.error("Failed to zip files:", l);
      } finally {
        n(2, o = false);
      }
    }
  }
  return t3.$$set = (l) => {
    "data" in l && n(5, r = l.data), "zipName" in l && n(6, s = l.zipName), "label" in l && n(0, i = l.label), "disabled" in l && n(1, a = l.disabled);
  }, [i, a, o, f, c, r, s];
}
class sd extends xt {
  constructor(e) {
    super(), wt(this, e, pK, dK, At, { data: 5, zipName: 6, label: 0, disabled: 1 });
  }
}
var Ur = { options: { usePureJavaScript: false } }, pA = {}, gK = pA, p8 = {};
pA.encode = function(t3, e, n) {
  if (typeof e != "string") throw new TypeError('"alphabet" must be a string.');
  if (n !== void 0 && typeof n != "number") throw new TypeError('"maxline" must be a number.');
  var r = "";
  if (!(t3 instanceof Uint8Array)) r = mK(t3, e);
  else {
    var s = 0, i = e.length, a = e.charAt(0), o = [0];
    for (s = 0; s < t3.length; ++s) {
      for (var f = 0, c = t3[s]; f < o.length; ++f) c += o[f] << 8, o[f] = c % i, c = c / i | 0;
      for (; c > 0; ) o.push(c % i), c = c / i | 0;
    }
    for (s = 0; t3[s] === 0 && s < t3.length - 1; ++s) r += a;
    for (s = o.length - 1; s >= 0; --s) r += e[o[s]];
  }
  if (n) {
    var l = new RegExp(".{1," + n + "}", "g");
    r = r.match(l).join(`\r
`);
  }
  return r;
};
pA.decode = function(t3, e) {
  if (typeof t3 != "string") throw new TypeError('"input" must be a string.');
  if (typeof e != "string") throw new TypeError('"alphabet" must be a string.');
  var n = p8[e];
  if (!n) {
    n = p8[e] = [];
    for (var r = 0; r < e.length; ++r) n[e.charCodeAt(r)] = r;
  }
  t3 = t3.replace(/\s/g, "");
  for (var s = e.length, i = e.charAt(0), a = [0], r = 0; r < t3.length; r++) {
    var o = n[t3.charCodeAt(r)];
    if (o === void 0) return;
    for (var f = 0, c = o; f < a.length; ++f) c += a[f] * s, a[f] = c & 255, c >>= 8;
    for (; c > 0; ) a.push(c & 255), c >>= 8;
  }
  for (var l = 0; t3[l] === i && l < t3.length - 1; ++l) a.push(0);
  return typeof hr < "u" ? hr.from(a.reverse()) : new Uint8Array(a.reverse());
};
function mK(t3, e) {
  var n = 0, r = e.length, s = e.charAt(0), i = [0];
  for (n = 0; n < t3.length(); ++n) {
    for (var a = 0, o = t3.at(n); a < i.length; ++a) o += i[a] << 8, i[a] = o % r, o = o / r | 0;
    for (; o > 0; ) i.push(o % r), o = o / r | 0;
  }
  var f = "";
  for (n = 0; t3.at(n) === 0 && n < t3.length() - 1; ++n) f += s;
  for (n = i.length - 1; n >= 0; --n) f += e[i[n]];
  return f;
}
var g8 = Ur, m8 = gK, Je = g8.util = g8.util || {};
(function() {
  if (typeof jt < "u" && jt.nextTick && !jt.browser) {
    Je.nextTick = jt.nextTick, typeof setImmediate == "function" ? Je.setImmediate = setImmediate : Je.setImmediate = Je.nextTick;
    return;
  }
  if (typeof setImmediate == "function") {
    Je.setImmediate = function() {
      return setImmediate.apply(void 0, arguments);
    }, Je.nextTick = function(a) {
      return setImmediate(a);
    };
    return;
  }
  if (Je.setImmediate = function(a) {
    setTimeout(a, 0);
  }, typeof window < "u" && typeof window.postMessage == "function") {
    let a = function(o) {
      if (o.source === window && o.data === t3) {
        o.stopPropagation();
        var f = e.slice();
        e.length = 0, f.forEach(function(c) {
          c();
        });
      }
    };
    var t3 = "forge.setImmediate", e = [];
    Je.setImmediate = function(o) {
      e.push(o), e.length === 1 && window.postMessage(t3, "*");
    }, window.addEventListener("message", a, true);
  }
  if (typeof MutationObserver < "u") {
    var n = Date.now(), r = true, s = document.createElement("div"), e = [];
    new MutationObserver(function() {
      var o = e.slice();
      e.length = 0, o.forEach(function(f) {
        f();
      });
    }).observe(s, { attributes: true });
    var i = Je.setImmediate;
    Je.setImmediate = function(o) {
      Date.now() - n > 15 ? (n = Date.now(), i(o)) : (e.push(o), e.length === 1 && s.setAttribute("a", r = !r));
    };
  }
  Je.nextTick = Je.setImmediate;
})();
Je.isNodejs = typeof jt < "u" && jt.versions && jt.versions.node;
Je.globalScope = function() {
  return Je.isNodejs ? mt : typeof self > "u" ? window : self;
}();
Je.isArray = Array.isArray || function(t3) {
  return Object.prototype.toString.call(t3) === "[object Array]";
};
Je.isArrayBuffer = function(t3) {
  return typeof ArrayBuffer < "u" && t3 instanceof ArrayBuffer;
};
Je.isArrayBufferView = function(t3) {
  return t3 && Je.isArrayBuffer(t3.buffer) && t3.byteLength !== void 0;
};
function ad(t3) {
  if (!(t3 === 8 || t3 === 16 || t3 === 24 || t3 === 32)) throw new Error("Only 8, 16, 24, or 32 bits supported: " + t3);
}
Je.ByteBuffer = gA;
function gA(t3) {
  if (this.data = "", this.read = 0, typeof t3 == "string") this.data = t3;
  else if (Je.isArrayBuffer(t3) || Je.isArrayBufferView(t3)) if (typeof hr < "u" && t3 instanceof hr) this.data = t3.toString("binary");
  else {
    var e = new Uint8Array(t3);
    try {
      this.data = String.fromCharCode.apply(null, e);
    } catch {
      for (var n = 0; n < e.length; ++n) this.putByte(e[n]);
    }
  }
  else (t3 instanceof gA || typeof t3 == "object" && typeof t3.data == "string" && typeof t3.read == "number") && (this.data = t3.data, this.read = t3.read);
  this._constructedStringLength = 0;
}
Je.ByteStringBuffer = gA;
var vK = 4096;
Je.ByteStringBuffer.prototype._optimizeConstructedString = function(t3) {
  this._constructedStringLength += t3, this._constructedStringLength > vK && (this.data.substr(0, 1), this._constructedStringLength = 0);
};
Je.ByteStringBuffer.prototype.length = function() {
  return this.data.length - this.read;
};
Je.ByteStringBuffer.prototype.isEmpty = function() {
  return this.length() <= 0;
};
Je.ByteStringBuffer.prototype.putByte = function(t3) {
  return this.putBytes(String.fromCharCode(t3));
};
Je.ByteStringBuffer.prototype.fillWithByte = function(t3, e) {
  t3 = String.fromCharCode(t3);
  for (var n = this.data; e > 0; ) e & 1 && (n += t3), e >>>= 1, e > 0 && (t3 += t3);
  return this.data = n, this._optimizeConstructedString(e), this;
};
Je.ByteStringBuffer.prototype.putBytes = function(t3) {
  return this.data += t3, this._optimizeConstructedString(t3.length), this;
};
Je.ByteStringBuffer.prototype.putString = function(t3) {
  return this.putBytes(Je.encodeUtf8(t3));
};
Je.ByteStringBuffer.prototype.putInt16 = function(t3) {
  return this.putBytes(String.fromCharCode(t3 >> 8 & 255) + String.fromCharCode(t3 & 255));
};
Je.ByteStringBuffer.prototype.putInt24 = function(t3) {
  return this.putBytes(String.fromCharCode(t3 >> 16 & 255) + String.fromCharCode(t3 >> 8 & 255) + String.fromCharCode(t3 & 255));
};
Je.ByteStringBuffer.prototype.putInt32 = function(t3) {
  return this.putBytes(String.fromCharCode(t3 >> 24 & 255) + String.fromCharCode(t3 >> 16 & 255) + String.fromCharCode(t3 >> 8 & 255) + String.fromCharCode(t3 & 255));
};
Je.ByteStringBuffer.prototype.putInt16Le = function(t3) {
  return this.putBytes(String.fromCharCode(t3 & 255) + String.fromCharCode(t3 >> 8 & 255));
};
Je.ByteStringBuffer.prototype.putInt24Le = function(t3) {
  return this.putBytes(String.fromCharCode(t3 & 255) + String.fromCharCode(t3 >> 8 & 255) + String.fromCharCode(t3 >> 16 & 255));
};
Je.ByteStringBuffer.prototype.putInt32Le = function(t3) {
  return this.putBytes(String.fromCharCode(t3 & 255) + String.fromCharCode(t3 >> 8 & 255) + String.fromCharCode(t3 >> 16 & 255) + String.fromCharCode(t3 >> 24 & 255));
};
Je.ByteStringBuffer.prototype.putInt = function(t3, e) {
  ad(e);
  var n = "";
  do
    e -= 8, n += String.fromCharCode(t3 >> e & 255);
  while (e > 0);
  return this.putBytes(n);
};
Je.ByteStringBuffer.prototype.putSignedInt = function(t3, e) {
  return t3 < 0 && (t3 += 2 << e - 1), this.putInt(t3, e);
};
Je.ByteStringBuffer.prototype.putBuffer = function(t3) {
  return this.putBytes(t3.getBytes());
};
Je.ByteStringBuffer.prototype.getByte = function() {
  return this.data.charCodeAt(this.read++);
};
Je.ByteStringBuffer.prototype.getInt16 = function() {
  var t3 = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
  return this.read += 2, t3;
};
Je.ByteStringBuffer.prototype.getInt24 = function() {
  var t3 = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
  return this.read += 3, t3;
};
Je.ByteStringBuffer.prototype.getInt32 = function() {
  var t3 = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
  return this.read += 4, t3;
};
Je.ByteStringBuffer.prototype.getInt16Le = function() {
  var t3 = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
  return this.read += 2, t3;
};
Je.ByteStringBuffer.prototype.getInt24Le = function() {
  var t3 = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
  return this.read += 3, t3;
};
Je.ByteStringBuffer.prototype.getInt32Le = function() {
  var t3 = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
  return this.read += 4, t3;
};
Je.ByteStringBuffer.prototype.getInt = function(t3) {
  ad(t3);
  var e = 0;
  do
    e = (e << 8) + this.data.charCodeAt(this.read++), t3 -= 8;
  while (t3 > 0);
  return e;
};
Je.ByteStringBuffer.prototype.getSignedInt = function(t3) {
  var e = this.getInt(t3), n = 2 << t3 - 2;
  return e >= n && (e -= n << 1), e;
};
Je.ByteStringBuffer.prototype.getBytes = function(t3) {
  var e;
  return t3 ? (t3 = Math.min(this.length(), t3), e = this.data.slice(this.read, this.read + t3), this.read += t3) : t3 === 0 ? e = "" : (e = this.read === 0 ? this.data : this.data.slice(this.read), this.clear()), e;
};
Je.ByteStringBuffer.prototype.bytes = function(t3) {
  return typeof t3 > "u" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + t3);
};
Je.ByteStringBuffer.prototype.at = function(t3) {
  return this.data.charCodeAt(this.read + t3);
};
Je.ByteStringBuffer.prototype.setAt = function(t3, e) {
  return this.data = this.data.substr(0, this.read + t3) + String.fromCharCode(e) + this.data.substr(this.read + t3 + 1), this;
};
Je.ByteStringBuffer.prototype.last = function() {
  return this.data.charCodeAt(this.data.length - 1);
};
Je.ByteStringBuffer.prototype.copy = function() {
  var t3 = Je.createBuffer(this.data);
  return t3.read = this.read, t3;
};
Je.ByteStringBuffer.prototype.compact = function() {
  return this.read > 0 && (this.data = this.data.slice(this.read), this.read = 0), this;
};
Je.ByteStringBuffer.prototype.clear = function() {
  return this.data = "", this.read = 0, this;
};
Je.ByteStringBuffer.prototype.truncate = function(t3) {
  var e = Math.max(0, this.length() - t3);
  return this.data = this.data.substr(this.read, e), this.read = 0, this;
};
Je.ByteStringBuffer.prototype.toHex = function() {
  for (var t3 = "", e = this.read; e < this.data.length; ++e) {
    var n = this.data.charCodeAt(e);
    n < 16 && (t3 += "0"), t3 += n.toString(16);
  }
  return t3;
};
Je.ByteStringBuffer.prototype.toString = function() {
  return Je.decodeUtf8(this.bytes());
};
function yK(t3, e) {
  e = e || {}, this.read = e.readOffset || 0, this.growSize = e.growSize || 1024;
  var n = Je.isArrayBuffer(t3), r = Je.isArrayBufferView(t3);
  if (n || r) {
    n ? this.data = new DataView(t3) : this.data = new DataView(t3.buffer, t3.byteOffset, t3.byteLength), this.write = "writeOffset" in e ? e.writeOffset : this.data.byteLength;
    return;
  }
  this.data = new DataView(new ArrayBuffer(0)), this.write = 0, t3 != null && this.putBytes(t3), "writeOffset" in e && (this.write = e.writeOffset);
}
Je.DataBuffer = yK;
Je.DataBuffer.prototype.length = function() {
  return this.write - this.read;
};
Je.DataBuffer.prototype.isEmpty = function() {
  return this.length() <= 0;
};
Je.DataBuffer.prototype.accommodate = function(t3, e) {
  if (this.length() >= t3) return this;
  e = Math.max(e || this.growSize, t3);
  var n = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength), r = new Uint8Array(this.length() + e);
  return r.set(n), this.data = new DataView(r.buffer), this;
};
Je.DataBuffer.prototype.putByte = function(t3) {
  return this.accommodate(1), this.data.setUint8(this.write++, t3), this;
};
Je.DataBuffer.prototype.fillWithByte = function(t3, e) {
  this.accommodate(e);
  for (var n = 0; n < e; ++n) this.data.setUint8(t3);
  return this;
};
Je.DataBuffer.prototype.putBytes = function(t3, e) {
  if (Je.isArrayBufferView(t3)) {
    var n = new Uint8Array(t3.buffer, t3.byteOffset, t3.byteLength), r = n.byteLength - n.byteOffset;
    this.accommodate(r);
    var s = new Uint8Array(this.data.buffer, this.write);
    return s.set(n), this.write += r, this;
  }
  if (Je.isArrayBuffer(t3)) {
    var n = new Uint8Array(t3);
    this.accommodate(n.byteLength);
    var s = new Uint8Array(this.data.buffer);
    return s.set(n, this.write), this.write += n.byteLength, this;
  }
  if (t3 instanceof Je.DataBuffer || typeof t3 == "object" && typeof t3.read == "number" && typeof t3.write == "number" && Je.isArrayBufferView(t3.data)) {
    var n = new Uint8Array(t3.data.byteLength, t3.read, t3.length());
    this.accommodate(n.byteLength);
    var s = new Uint8Array(t3.data.byteLength, this.write);
    return s.set(n), this.write += n.byteLength, this;
  }
  if (t3 instanceof Je.ByteStringBuffer && (t3 = t3.data, e = "binary"), e = e || "binary", typeof t3 == "string") {
    var i;
    if (e === "hex") return this.accommodate(Math.ceil(t3.length / 2)), i = new Uint8Array(this.data.buffer, this.write), this.write += Je.binary.hex.decode(t3, i, this.write), this;
    if (e === "base64") return this.accommodate(Math.ceil(t3.length / 4) * 3), i = new Uint8Array(this.data.buffer, this.write), this.write += Je.binary.base64.decode(t3, i, this.write), this;
    if (e === "utf8" && (t3 = Je.encodeUtf8(t3), e = "binary"), e === "binary" || e === "raw") return this.accommodate(t3.length), i = new Uint8Array(this.data.buffer, this.write), this.write += Je.binary.raw.decode(i), this;
    if (e === "utf16") return this.accommodate(t3.length * 2), i = new Uint16Array(this.data.buffer, this.write), this.write += Je.text.utf16.encode(i), this;
    throw new Error("Invalid encoding: " + e);
  }
  throw Error("Invalid parameter: " + t3);
};
Je.DataBuffer.prototype.putBuffer = function(t3) {
  return this.putBytes(t3), t3.clear(), this;
};
Je.DataBuffer.prototype.putString = function(t3) {
  return this.putBytes(t3, "utf16");
};
Je.DataBuffer.prototype.putInt16 = function(t3) {
  return this.accommodate(2), this.data.setInt16(this.write, t3), this.write += 2, this;
};
Je.DataBuffer.prototype.putInt24 = function(t3) {
  return this.accommodate(3), this.data.setInt16(this.write, t3 >> 8 & 65535), this.data.setInt8(this.write, t3 >> 16 & 255), this.write += 3, this;
};
Je.DataBuffer.prototype.putInt32 = function(t3) {
  return this.accommodate(4), this.data.setInt32(this.write, t3), this.write += 4, this;
};
Je.DataBuffer.prototype.putInt16Le = function(t3) {
  return this.accommodate(2), this.data.setInt16(this.write, t3, true), this.write += 2, this;
};
Je.DataBuffer.prototype.putInt24Le = function(t3) {
  return this.accommodate(3), this.data.setInt8(this.write, t3 >> 16 & 255), this.data.setInt16(this.write, t3 >> 8 & 65535, true), this.write += 3, this;
};
Je.DataBuffer.prototype.putInt32Le = function(t3) {
  return this.accommodate(4), this.data.setInt32(this.write, t3, true), this.write += 4, this;
};
Je.DataBuffer.prototype.putInt = function(t3, e) {
  ad(e), this.accommodate(e / 8);
  do
    e -= 8, this.data.setInt8(this.write++, t3 >> e & 255);
  while (e > 0);
  return this;
};
Je.DataBuffer.prototype.putSignedInt = function(t3, e) {
  return ad(e), this.accommodate(e / 8), t3 < 0 && (t3 += 2 << e - 1), this.putInt(t3, e);
};
Je.DataBuffer.prototype.getByte = function() {
  return this.data.getInt8(this.read++);
};
Je.DataBuffer.prototype.getInt16 = function() {
  var t3 = this.data.getInt16(this.read);
  return this.read += 2, t3;
};
Je.DataBuffer.prototype.getInt24 = function() {
  var t3 = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
  return this.read += 3, t3;
};
Je.DataBuffer.prototype.getInt32 = function() {
  var t3 = this.data.getInt32(this.read);
  return this.read += 4, t3;
};
Je.DataBuffer.prototype.getInt16Le = function() {
  var t3 = this.data.getInt16(this.read, true);
  return this.read += 2, t3;
};
Je.DataBuffer.prototype.getInt24Le = function() {
  var t3 = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
  return this.read += 3, t3;
};
Je.DataBuffer.prototype.getInt32Le = function() {
  var t3 = this.data.getInt32(this.read, true);
  return this.read += 4, t3;
};
Je.DataBuffer.prototype.getInt = function(t3) {
  ad(t3);
  var e = 0;
  do
    e = (e << 8) + this.data.getInt8(this.read++), t3 -= 8;
  while (t3 > 0);
  return e;
};
Je.DataBuffer.prototype.getSignedInt = function(t3) {
  var e = this.getInt(t3), n = 2 << t3 - 2;
  return e >= n && (e -= n << 1), e;
};
Je.DataBuffer.prototype.getBytes = function(t3) {
  var e;
  return t3 ? (t3 = Math.min(this.length(), t3), e = this.data.slice(this.read, this.read + t3), this.read += t3) : t3 === 0 ? e = "" : (e = this.read === 0 ? this.data : this.data.slice(this.read), this.clear()), e;
};
Je.DataBuffer.prototype.bytes = function(t3) {
  return typeof t3 > "u" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + t3);
};
Je.DataBuffer.prototype.at = function(t3) {
  return this.data.getUint8(this.read + t3);
};
Je.DataBuffer.prototype.setAt = function(t3, e) {
  return this.data.setUint8(t3, e), this;
};
Je.DataBuffer.prototype.last = function() {
  return this.data.getUint8(this.write - 1);
};
Je.DataBuffer.prototype.copy = function() {
  return new Je.DataBuffer(this);
};
Je.DataBuffer.prototype.compact = function() {
  if (this.read > 0) {
    var t3 = new Uint8Array(this.data.buffer, this.read), e = new Uint8Array(t3.byteLength);
    e.set(t3), this.data = new DataView(e), this.write -= this.read, this.read = 0;
  }
  return this;
};
Je.DataBuffer.prototype.clear = function() {
  return this.data = new DataView(new ArrayBuffer(0)), this.read = this.write = 0, this;
};
Je.DataBuffer.prototype.truncate = function(t3) {
  return this.write = Math.max(0, this.length() - t3), this.read = Math.min(this.read, this.write), this;
};
Je.DataBuffer.prototype.toHex = function() {
  for (var t3 = "", e = this.read; e < this.data.byteLength; ++e) {
    var n = this.data.getUint8(e);
    n < 16 && (t3 += "0"), t3 += n.toString(16);
  }
  return t3;
};
Je.DataBuffer.prototype.toString = function(t3) {
  var e = new Uint8Array(this.data, this.read, this.length());
  if (t3 = t3 || "utf8", t3 === "binary" || t3 === "raw") return Je.binary.raw.encode(e);
  if (t3 === "hex") return Je.binary.hex.encode(e);
  if (t3 === "base64") return Je.binary.base64.encode(e);
  if (t3 === "utf8") return Je.text.utf8.decode(e);
  if (t3 === "utf16") return Je.text.utf16.decode(e);
  throw new Error("Invalid encoding: " + t3);
};
Je.createBuffer = function(t3, e) {
  return e = e || "raw", t3 !== void 0 && e === "utf8" && (t3 = Je.encodeUtf8(t3)), new Je.ByteBuffer(t3);
};
Je.fillString = function(t3, e) {
  for (var n = ""; e > 0; ) e & 1 && (n += t3), e >>>= 1, e > 0 && (t3 += t3);
  return n;
};
Je.xorBytes = function(t3, e, n) {
  for (var r = "", s = "", i = "", a = 0, o = 0; n > 0; --n, ++a) s = t3.charCodeAt(a) ^ e.charCodeAt(a), o >= 10 && (r += i, i = "", o = 0), i += String.fromCharCode(s), ++o;
  return r += i, r;
};
Je.hexToBytes = function(t3) {
  var e = "", n = 0;
  for (t3.length & true && (n = 1, e += String.fromCharCode(parseInt(t3[0], 16))); n < t3.length; n += 2) e += String.fromCharCode(parseInt(t3.substr(n, 2), 16));
  return e;
};
Je.bytesToHex = function(t3) {
  return Je.createBuffer(t3).toHex();
};
Je.int32ToBytes = function(t3) {
  return String.fromCharCode(t3 >> 24 & 255) + String.fromCharCode(t3 >> 16 & 255) + String.fromCharCode(t3 >> 8 & 255) + String.fromCharCode(t3 & 255);
};
var Gf = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", Vf = [62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, 64, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], oS = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
Je.encode64 = function(t3, e) {
  for (var n = "", r = "", s, i, a, o = 0; o < t3.length; ) s = t3.charCodeAt(o++), i = t3.charCodeAt(o++), a = t3.charCodeAt(o++), n += Gf.charAt(s >> 2), n += Gf.charAt((s & 3) << 4 | i >> 4), isNaN(i) ? n += "==" : (n += Gf.charAt((i & 15) << 2 | a >> 6), n += isNaN(a) ? "=" : Gf.charAt(a & 63)), e && n.length > e && (r += n.substr(0, e) + `\r
`, n = n.substr(e));
  return r += n, r;
};
Je.decode64 = function(t3) {
  t3 = t3.replace(/[^A-Za-z0-9\+\/\=]/g, "");
  for (var e = "", n, r, s, i, a = 0; a < t3.length; ) n = Vf[t3.charCodeAt(a++) - 43], r = Vf[t3.charCodeAt(a++) - 43], s = Vf[t3.charCodeAt(a++) - 43], i = Vf[t3.charCodeAt(a++) - 43], e += String.fromCharCode(n << 2 | r >> 4), s !== 64 && (e += String.fromCharCode((r & 15) << 4 | s >> 2), i !== 64 && (e += String.fromCharCode((s & 3) << 6 | i)));
  return e;
};
Je.encodeUtf8 = function(t3) {
  return unescape(encodeURIComponent(t3));
};
Je.decodeUtf8 = function(t3) {
  return decodeURIComponent(escape(t3));
};
Je.binary = { raw: {}, hex: {}, base64: {}, base58: {}, baseN: { encode: m8.encode, decode: m8.decode } };
Je.binary.raw.encode = function(t3) {
  return String.fromCharCode.apply(null, t3);
};
Je.binary.raw.decode = function(t3, e, n) {
  var r = e;
  r || (r = new Uint8Array(t3.length)), n = n || 0;
  for (var s = n, i = 0; i < t3.length; ++i) r[s++] = t3.charCodeAt(i);
  return e ? s - n : r;
};
Je.binary.hex.encode = Je.bytesToHex;
Je.binary.hex.decode = function(t3, e, n) {
  var r = e;
  r || (r = new Uint8Array(Math.ceil(t3.length / 2))), n = n || 0;
  var s = 0, i = n;
  for (t3.length & 1 && (s = 1, r[i++] = parseInt(t3[0], 16)); s < t3.length; s += 2) r[i++] = parseInt(t3.substr(s, 2), 16);
  return e ? i - n : r;
};
Je.binary.base64.encode = function(t3, e) {
  for (var n = "", r = "", s, i, a, o = 0; o < t3.byteLength; ) s = t3[o++], i = t3[o++], a = t3[o++], n += Gf.charAt(s >> 2), n += Gf.charAt((s & 3) << 4 | i >> 4), isNaN(i) ? n += "==" : (n += Gf.charAt((i & 15) << 2 | a >> 6), n += isNaN(a) ? "=" : Gf.charAt(a & 63)), e && n.length > e && (r += n.substr(0, e) + `\r
`, n = n.substr(e));
  return r += n, r;
};
Je.binary.base64.decode = function(t3, e, n) {
  var r = e;
  r || (r = new Uint8Array(Math.ceil(t3.length / 4) * 3)), t3 = t3.replace(/[^A-Za-z0-9\+\/\=]/g, ""), n = n || 0;
  for (var s, i, a, o, f = 0, c = n; f < t3.length; ) s = Vf[t3.charCodeAt(f++) - 43], i = Vf[t3.charCodeAt(f++) - 43], a = Vf[t3.charCodeAt(f++) - 43], o = Vf[t3.charCodeAt(f++) - 43], r[c++] = s << 2 | i >> 4, a !== 64 && (r[c++] = (i & 15) << 4 | a >> 2, o !== 64 && (r[c++] = (a & 3) << 6 | o));
  return e ? c - n : r.subarray(0, c);
};
Je.binary.base58.encode = function(t3, e) {
  return Je.binary.baseN.encode(t3, oS, e);
};
Je.binary.base58.decode = function(t3, e) {
  return Je.binary.baseN.decode(t3, oS, e);
};
Je.text = { utf8: {}, utf16: {} };
Je.text.utf8.encode = function(t3, e, n) {
  t3 = Je.encodeUtf8(t3);
  var r = e;
  r || (r = new Uint8Array(t3.length)), n = n || 0;
  for (var s = n, i = 0; i < t3.length; ++i) r[s++] = t3.charCodeAt(i);
  return e ? s - n : r;
};
Je.text.utf8.decode = function(t3) {
  return Je.decodeUtf8(String.fromCharCode.apply(null, t3));
};
Je.text.utf16.encode = function(t3, e, n) {
  var r = e;
  r || (r = new Uint8Array(t3.length * 2));
  var s = new Uint16Array(r.buffer);
  n = n || 0;
  for (var i = n, a = n, o = 0; o < t3.length; ++o) s[a++] = t3.charCodeAt(o), i += 2;
  return e ? i - n : r;
};
Je.text.utf16.decode = function(t3) {
  return String.fromCharCode.apply(null, new Uint16Array(t3.buffer));
};
Je.deflate = function(t3, e, n) {
  if (e = Je.decode64(t3.deflate(Je.encode64(e)).rval), n) {
    var r = 2, s = e.charCodeAt(1);
    s & 32 && (r = 6), e = e.substring(r, e.length - 4);
  }
  return e;
};
Je.inflate = function(t3, e, n) {
  var r = t3.inflate(Je.encode64(e)).rval;
  return r === null ? null : Je.decode64(r);
};
var mA = function(t3, e, n) {
  if (!t3) throw new Error("WebStorage not available.");
  var r;
  if (n === null ? r = t3.removeItem(e) : (n = Je.encode64(JSON.stringify(n)), r = t3.setItem(e, n)), typeof r < "u" && r.rval !== true) {
    var s = new Error(r.error.message);
    throw s.id = r.error.id, s.name = r.error.name, s;
  }
}, vA = function(t3, e) {
  if (!t3) throw new Error("WebStorage not available.");
  var n = t3.getItem(e);
  if (t3.init) if (n.rval === null) {
    if (n.error) {
      var r = new Error(n.error.message);
      throw r.id = n.error.id, r.name = n.error.name, r;
    }
    n = null;
  } else n = n.rval;
  return n !== null && (n = JSON.parse(Je.decode64(n))), n;
}, bK = function(t3, e, n, r) {
  var s = vA(t3, e);
  s === null && (s = {}), s[n] = r, mA(t3, e, s);
}, AK = function(t3, e, n) {
  var r = vA(t3, e);
  return r !== null && (r = n in r ? r[n] : null), r;
}, wK = function(t3, e, n) {
  var r = vA(t3, e);
  if (r !== null && n in r) {
    delete r[n];
    var s = true;
    for (var i in r) {
      s = false;
      break;
    }
    s && (r = null), mA(t3, e, r);
  }
}, xK = function(t3, e) {
  mA(t3, e, null);
}, Cg = function(t3, e, n) {
  var r = null;
  typeof n > "u" && (n = ["web", "flash"]);
  var s, i = false, a = null;
  for (var o in n) {
    s = n[o];
    try {
      if (s === "flash" || s === "both") {
        if (e[0] === null) throw new Error("Flash local storage not available.");
        r = t3.apply(this, e), i = s === "flash";
      }
      (s === "web" || s === "both") && (e[0] = localStorage, r = t3.apply(this, e), i = true);
    } catch (f) {
      a = f;
    }
    if (i) break;
  }
  if (!i) throw a;
  return r;
};
Je.setItem = function(t3, e, n, r, s) {
  Cg(bK, arguments, s);
};
Je.getItem = function(t3, e, n, r) {
  return Cg(AK, arguments, r);
};
Je.removeItem = function(t3, e, n, r) {
  Cg(wK, arguments, r);
};
Je.clearItems = function(t3, e, n) {
  Cg(xK, arguments, n);
};
Je.isEmpty = function(t3) {
  for (var e in t3) if (t3.hasOwnProperty(e)) return false;
  return true;
};
Je.format = function(t3) {
  for (var e = /%./g, n, r, s = 0, i = [], a = 0; n = e.exec(t3); ) {
    r = t3.substring(a, e.lastIndex - 2), r.length > 0 && i.push(r), a = e.lastIndex;
    var o = n[0][1];
    switch (o) {
      case "s":
      case "o":
        s < arguments.length ? i.push(arguments[s++ + 1]) : i.push("<?>");
        break;
      case "%":
        i.push("%");
        break;
      default:
        i.push("<%" + o + "?>");
    }
  }
  return i.push(t3.substring(a)), i.join("");
};
Je.formatNumber = function(t3, e, n, r) {
  var s = t3, i = isNaN(e = Math.abs(e)) ? 2 : e, a = n === void 0 ? "," : n, o = r === void 0 ? "." : r, f = s < 0 ? "-" : "", c = parseInt(s = Math.abs(+s || 0).toFixed(i), 10) + "", l = c.length > 3 ? c.length % 3 : 0;
  return f + (l ? c.substr(0, l) + o : "") + c.substr(l).replace(/(\d{3})(?=\d)/g, "$1" + o) + (i ? a + Math.abs(s - c).toFixed(i).slice(2) : "");
};
Je.formatSize = function(t3) {
  return t3 >= 1073741824 ? t3 = Je.formatNumber(t3 / 1073741824, 2, ".", "") + " GiB" : t3 >= 1048576 ? t3 = Je.formatNumber(t3 / 1048576, 2, ".", "") + " MiB" : t3 >= 1024 ? t3 = Je.formatNumber(t3 / 1024, 0) + " KiB" : t3 = Je.formatNumber(t3, 0) + " bytes", t3;
};
Je.bytesFromIP = function(t3) {
  return t3.indexOf(".") !== -1 ? Je.bytesFromIPv4(t3) : t3.indexOf(":") !== -1 ? Je.bytesFromIPv6(t3) : null;
};
Je.bytesFromIPv4 = function(t3) {
  if (t3 = t3.split("."), t3.length !== 4) return null;
  for (var e = Je.createBuffer(), n = 0; n < t3.length; ++n) {
    var r = parseInt(t3[n], 10);
    if (isNaN(r)) return null;
    e.putByte(r);
  }
  return e.getBytes();
};
Je.bytesFromIPv6 = function(t3) {
  var e = 0;
  t3 = t3.split(":").filter(function(a) {
    return a.length === 0 && ++e, true;
  });
  for (var n = (8 - t3.length + e) * 2, r = Je.createBuffer(), s = 0; s < 8; ++s) {
    if (!t3[s] || t3[s].length === 0) {
      r.fillWithByte(0, n), n = 0;
      continue;
    }
    var i = Je.hexToBytes(t3[s]);
    i.length < 2 && r.putByte(0), r.putBytes(i);
  }
  return r.getBytes();
};
Je.bytesToIP = function(t3) {
  return t3.length === 4 ? Je.bytesToIPv4(t3) : t3.length === 16 ? Je.bytesToIPv6(t3) : null;
};
Je.bytesToIPv4 = function(t3) {
  if (t3.length !== 4) return null;
  for (var e = [], n = 0; n < t3.length; ++n) e.push(t3.charCodeAt(n));
  return e.join(".");
};
Je.bytesToIPv6 = function(t3) {
  if (t3.length !== 16) return null;
  for (var e = [], n = [], r = 0, s = 0; s < t3.length; s += 2) {
    for (var i = Je.bytesToHex(t3[s] + t3[s + 1]); i[0] === "0" && i !== "0"; ) i = i.substr(1);
    if (i === "0") {
      var a = n[n.length - 1], o = e.length;
      !a || o !== a.end + 1 ? n.push({ start: o, end: o }) : (a.end = o, a.end - a.start > n[r].end - n[r].start && (r = n.length - 1));
    }
    e.push(i);
  }
  if (n.length > 0) {
    var f = n[r];
    f.end - f.start > 0 && (e.splice(f.start, f.end - f.start + 1, ""), f.start === 0 && e.unshift(""), f.end === 7 && e.push(""));
  }
  return e.join(":");
};
Je.estimateCores = function(t3, e) {
  if (typeof t3 == "function" && (e = t3, t3 = {}), t3 = t3 || {}, "cores" in Je && !t3.update) return e(null, Je.cores);
  if (typeof navigator < "u" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) return Je.cores = navigator.hardwareConcurrency, e(null, Je.cores);
  if (typeof Worker > "u") return Je.cores = 1, e(null, Je.cores);
  if (typeof Blob > "u") return Je.cores = 2, e(null, Je.cores);
  var n = URL.createObjectURL(new Blob(["(", (function() {
    self.addEventListener("message", function(a) {
      var o = Date.now(), f = o + 4;
      self.postMessage({ st: o, et: f });
    });
  }).toString(), ")()"], { type: "application/javascript" }));
  r([], 5, 16);
  function r(a, o, f) {
    if (o === 0) {
      var c = Math.floor(a.reduce(function(l, h) {
        return l + h;
      }, 0) / a.length);
      return Je.cores = Math.max(1, c), URL.revokeObjectURL(n), e(null, Je.cores);
    }
    s(f, function(l, h) {
      a.push(i(f, h)), r(a, o - 1, f);
    });
  }
  function s(a, o) {
    for (var f = [], c = [], l = 0; l < a; ++l) {
      var h = new Worker(n);
      h.addEventListener("message", function(m) {
        if (c.push(m.data), c.length === a) {
          for (var v = 0; v < a; ++v) f[v].terminate();
          o(null, c);
        }
      }), f.push(h);
    }
    for (var l = 0; l < a; ++l) f[l].postMessage(l);
  }
  function i(a, o) {
    for (var f = [], c = 0; c < a; ++c) for (var l = o[c], h = f[c] = [], m = 0; m < a; ++m) if (c !== m) {
      var v = o[m];
      (l.st > v.st && l.st < v.et || v.st > l.st && v.st < l.et) && h.push(m);
    }
    return f.reduce(function(b, A) {
      return Math.max(b, A.length);
    }, 0);
  }
};
var Ei = Ur;
Ei.cipher = Ei.cipher || {};
Ei.cipher.algorithms = Ei.cipher.algorithms || {};
Ei.cipher.createCipher = function(t3, e) {
  var n = t3;
  if (typeof n == "string" && (n = Ei.cipher.getAlgorithm(n), n && (n = n())), !n) throw new Error("Unsupported algorithm: " + t3);
  return new Ei.cipher.BlockCipher({ algorithm: n, key: e, decrypt: false });
};
Ei.cipher.createDecipher = function(t3, e) {
  var n = t3;
  if (typeof n == "string" && (n = Ei.cipher.getAlgorithm(n), n && (n = n())), !n) throw new Error("Unsupported algorithm: " + t3);
  return new Ei.cipher.BlockCipher({ algorithm: n, key: e, decrypt: true });
};
Ei.cipher.registerAlgorithm = function(t3, e) {
  t3 = t3.toUpperCase(), Ei.cipher.algorithms[t3] = e;
};
Ei.cipher.getAlgorithm = function(t3) {
  return t3 = t3.toUpperCase(), t3 in Ei.cipher.algorithms ? Ei.cipher.algorithms[t3] : null;
};
var yA = Ei.cipher.BlockCipher = function(t3) {
  this.algorithm = t3.algorithm, this.mode = this.algorithm.mode, this.blockSize = this.mode.blockSize, this._finish = false, this._input = null, this.output = null, this._op = t3.decrypt ? this.mode.decrypt : this.mode.encrypt, this._decrypt = t3.decrypt, this.algorithm.initialize(t3);
};
yA.prototype.start = function(t3) {
  t3 = t3 || {};
  var e = {};
  for (var n in t3) e[n] = t3[n];
  e.decrypt = this._decrypt, this._finish = false, this._input = Ei.util.createBuffer(), this.output = t3.output || Ei.util.createBuffer(), this.mode.start(e);
};
yA.prototype.update = function(t3) {
  for (t3 && this._input.putBuffer(t3); !this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish; ) ;
  this._input.compact();
};
yA.prototype.finish = function(t3) {
  t3 && (this.mode.name === "ECB" || this.mode.name === "CBC") && (this.mode.pad = function(n) {
    return t3(this.blockSize, n, false);
  }, this.mode.unpad = function(n) {
    return t3(this.blockSize, n, true);
  });
  var e = {};
  return e.decrypt = this._decrypt, e.overflow = this._input.length() % this.blockSize, !(!this._decrypt && this.mode.pad && !this.mode.pad(this._input, e) || (this._finish = true, this.update(), this._decrypt && this.mode.unpad && !this.mode.unpad(this.output, e)) || this.mode.afterFinish && !this.mode.afterFinish(this.output, e));
};
var xi = Ur;
xi.cipher = xi.cipher || {};
var qr = xi.cipher.modes = xi.cipher.modes || {};
qr.ecb = function(t3) {
  t3 = t3 || {}, this.name = "ECB", this.cipher = t3.cipher, this.blockSize = t3.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints);
};
qr.ecb.prototype.start = function(t3) {
};
qr.ecb.prototype.encrypt = function(t3, e, n) {
  if (t3.length() < this.blockSize && !(n && t3.length() > 0)) return true;
  for (var r = 0; r < this._ints; ++r) this._inBlock[r] = t3.getInt32();
  this.cipher.encrypt(this._inBlock, this._outBlock);
  for (var r = 0; r < this._ints; ++r) e.putInt32(this._outBlock[r]);
};
qr.ecb.prototype.decrypt = function(t3, e, n) {
  if (t3.length() < this.blockSize && !(n && t3.length() > 0)) return true;
  for (var r = 0; r < this._ints; ++r) this._inBlock[r] = t3.getInt32();
  this.cipher.decrypt(this._inBlock, this._outBlock);
  for (var r = 0; r < this._ints; ++r) e.putInt32(this._outBlock[r]);
};
qr.ecb.prototype.pad = function(t3, e) {
  var n = t3.length() === this.blockSize ? this.blockSize : this.blockSize - t3.length();
  return t3.fillWithByte(n, n), true;
};
qr.ecb.prototype.unpad = function(t3, e) {
  if (e.overflow > 0) return false;
  var n = t3.length(), r = t3.at(n - 1);
  return r > this.blockSize << 2 ? false : (t3.truncate(r), true);
};
qr.cbc = function(t3) {
  t3 = t3 || {}, this.name = "CBC", this.cipher = t3.cipher, this.blockSize = t3.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints);
};
qr.cbc.prototype.start = function(t3) {
  if (t3.iv === null) {
    if (!this._prev) throw new Error("Invalid IV parameter.");
    this._iv = this._prev.slice(0);
  } else if ("iv" in t3) this._iv = kg(t3.iv, this.blockSize), this._prev = this._iv.slice(0);
  else throw new Error("Invalid IV parameter.");
};
qr.cbc.prototype.encrypt = function(t3, e, n) {
  if (t3.length() < this.blockSize && !(n && t3.length() > 0)) return true;
  for (var r = 0; r < this._ints; ++r) this._inBlock[r] = this._prev[r] ^ t3.getInt32();
  this.cipher.encrypt(this._inBlock, this._outBlock);
  for (var r = 0; r < this._ints; ++r) e.putInt32(this._outBlock[r]);
  this._prev = this._outBlock;
};
qr.cbc.prototype.decrypt = function(t3, e, n) {
  if (t3.length() < this.blockSize && !(n && t3.length() > 0)) return true;
  for (var r = 0; r < this._ints; ++r) this._inBlock[r] = t3.getInt32();
  this.cipher.decrypt(this._inBlock, this._outBlock);
  for (var r = 0; r < this._ints; ++r) e.putInt32(this._prev[r] ^ this._outBlock[r]);
  this._prev = this._inBlock.slice(0);
};
qr.cbc.prototype.pad = function(t3, e) {
  var n = t3.length() === this.blockSize ? this.blockSize : this.blockSize - t3.length();
  return t3.fillWithByte(n, n), true;
};
qr.cbc.prototype.unpad = function(t3, e) {
  if (e.overflow > 0) return false;
  var n = t3.length(), r = t3.at(n - 1);
  return r > this.blockSize << 2 ? false : (t3.truncate(r), true);
};
qr.cfb = function(t3) {
  t3 = t3 || {}, this.name = "CFB", this.cipher = t3.cipher, this.blockSize = t3.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialBlock = new Array(this._ints), this._partialOutput = xi.util.createBuffer(), this._partialBytes = 0;
};
qr.cfb.prototype.start = function(t3) {
  if (!("iv" in t3)) throw new Error("Invalid IV parameter.");
  this._iv = kg(t3.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0;
};
qr.cfb.prototype.encrypt = function(t3, e, n) {
  var r = t3.length();
  if (r === 0) return true;
  if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && r >= this.blockSize) {
    for (var s = 0; s < this._ints; ++s) this._inBlock[s] = t3.getInt32() ^ this._outBlock[s], e.putInt32(this._inBlock[s]);
    return;
  }
  var i = (this.blockSize - r) % this.blockSize;
  i > 0 && (i = this.blockSize - i), this._partialOutput.clear();
  for (var s = 0; s < this._ints; ++s) this._partialBlock[s] = t3.getInt32() ^ this._outBlock[s], this._partialOutput.putInt32(this._partialBlock[s]);
  if (i > 0) t3.read -= this.blockSize;
  else for (var s = 0; s < this._ints; ++s) this._inBlock[s] = this._partialBlock[s];
  if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), i > 0 && !n) return e.putBytes(this._partialOutput.getBytes(i - this._partialBytes)), this._partialBytes = i, true;
  e.putBytes(this._partialOutput.getBytes(r - this._partialBytes)), this._partialBytes = 0;
};
qr.cfb.prototype.decrypt = function(t3, e, n) {
  var r = t3.length();
  if (r === 0) return true;
  if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && r >= this.blockSize) {
    for (var s = 0; s < this._ints; ++s) this._inBlock[s] = t3.getInt32(), e.putInt32(this._inBlock[s] ^ this._outBlock[s]);
    return;
  }
  var i = (this.blockSize - r) % this.blockSize;
  i > 0 && (i = this.blockSize - i), this._partialOutput.clear();
  for (var s = 0; s < this._ints; ++s) this._partialBlock[s] = t3.getInt32(), this._partialOutput.putInt32(this._partialBlock[s] ^ this._outBlock[s]);
  if (i > 0) t3.read -= this.blockSize;
  else for (var s = 0; s < this._ints; ++s) this._inBlock[s] = this._partialBlock[s];
  if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), i > 0 && !n) return e.putBytes(this._partialOutput.getBytes(i - this._partialBytes)), this._partialBytes = i, true;
  e.putBytes(this._partialOutput.getBytes(r - this._partialBytes)), this._partialBytes = 0;
};
qr.ofb = function(t3) {
  t3 = t3 || {}, this.name = "OFB", this.cipher = t3.cipher, this.blockSize = t3.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialOutput = xi.util.createBuffer(), this._partialBytes = 0;
};
qr.ofb.prototype.start = function(t3) {
  if (!("iv" in t3)) throw new Error("Invalid IV parameter.");
  this._iv = kg(t3.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0;
};
qr.ofb.prototype.encrypt = function(t3, e, n) {
  var r = t3.length();
  if (t3.length() === 0) return true;
  if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && r >= this.blockSize) {
    for (var s = 0; s < this._ints; ++s) e.putInt32(t3.getInt32() ^ this._outBlock[s]), this._inBlock[s] = this._outBlock[s];
    return;
  }
  var i = (this.blockSize - r) % this.blockSize;
  i > 0 && (i = this.blockSize - i), this._partialOutput.clear();
  for (var s = 0; s < this._ints; ++s) this._partialOutput.putInt32(t3.getInt32() ^ this._outBlock[s]);
  if (i > 0) t3.read -= this.blockSize;
  else for (var s = 0; s < this._ints; ++s) this._inBlock[s] = this._outBlock[s];
  if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), i > 0 && !n) return e.putBytes(this._partialOutput.getBytes(i - this._partialBytes)), this._partialBytes = i, true;
  e.putBytes(this._partialOutput.getBytes(r - this._partialBytes)), this._partialBytes = 0;
};
qr.ofb.prototype.decrypt = qr.ofb.prototype.encrypt;
qr.ctr = function(t3) {
  t3 = t3 || {}, this.name = "CTR", this.cipher = t3.cipher, this.blockSize = t3.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialOutput = xi.util.createBuffer(), this._partialBytes = 0;
};
qr.ctr.prototype.start = function(t3) {
  if (!("iv" in t3)) throw new Error("Invalid IV parameter.");
  this._iv = kg(t3.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0;
};
qr.ctr.prototype.encrypt = function(t3, e, n) {
  var r = t3.length();
  if (r === 0) return true;
  if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && r >= this.blockSize) for (var s = 0; s < this._ints; ++s) e.putInt32(t3.getInt32() ^ this._outBlock[s]);
  else {
    var i = (this.blockSize - r) % this.blockSize;
    i > 0 && (i = this.blockSize - i), this._partialOutput.clear();
    for (var s = 0; s < this._ints; ++s) this._partialOutput.putInt32(t3.getInt32() ^ this._outBlock[s]);
    if (i > 0 && (t3.read -= this.blockSize), this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), i > 0 && !n) return e.putBytes(this._partialOutput.getBytes(i - this._partialBytes)), this._partialBytes = i, true;
    e.putBytes(this._partialOutput.getBytes(r - this._partialBytes)), this._partialBytes = 0;
  }
  Ig(this._inBlock);
};
qr.ctr.prototype.decrypt = qr.ctr.prototype.encrypt;
qr.gcm = function(t3) {
  t3 = t3 || {}, this.name = "GCM", this.cipher = t3.cipher, this.blockSize = t3.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints), this._partialOutput = xi.util.createBuffer(), this._partialBytes = 0, this._R = 3774873600;
};
qr.gcm.prototype.start = function(t3) {
  if (!("iv" in t3)) throw new Error("Invalid IV parameter.");
  var e = xi.util.createBuffer(t3.iv);
  this._cipherLength = 0;
  var n;
  if ("additionalData" in t3 ? n = xi.util.createBuffer(t3.additionalData) : n = xi.util.createBuffer(), "tagLength" in t3 ? this._tagLength = t3.tagLength : this._tagLength = 128, this._tag = null, t3.decrypt && (this._tag = xi.util.createBuffer(t3.tag).getBytes(), this._tag.length !== this._tagLength / 8)) throw new Error("Authentication tag does not match tag length.");
  this._hashBlock = new Array(this._ints), this.tag = null, this._hashSubkey = new Array(this._ints), this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey), this.componentBits = 4, this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
  var r = e.length();
  if (r === 12) this._j0 = [e.getInt32(), e.getInt32(), e.getInt32(), 1];
  else {
    for (this._j0 = [0, 0, 0, 0]; e.length() > 0; ) this._j0 = this.ghash(this._hashSubkey, this._j0, [e.getInt32(), e.getInt32(), e.getInt32(), e.getInt32()]);
    this._j0 = this.ghash(this._hashSubkey, this._j0, [0, 0].concat(b3(r * 8)));
  }
  this._inBlock = this._j0.slice(0), Ig(this._inBlock), this._partialBytes = 0, n = xi.util.createBuffer(n), this._aDataLength = b3(n.length() * 8);
  var s = n.length() % this.blockSize;
  for (s && n.fillWithByte(0, this.blockSize - s), this._s = [0, 0, 0, 0]; n.length() > 0; ) this._s = this.ghash(this._hashSubkey, this._s, [n.getInt32(), n.getInt32(), n.getInt32(), n.getInt32()]);
};
qr.gcm.prototype.encrypt = function(t3, e, n) {
  var r = t3.length();
  if (r === 0) return true;
  if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && r >= this.blockSize) {
    for (var s = 0; s < this._ints; ++s) e.putInt32(this._outBlock[s] ^= t3.getInt32());
    this._cipherLength += this.blockSize;
  } else {
    var i = (this.blockSize - r) % this.blockSize;
    i > 0 && (i = this.blockSize - i), this._partialOutput.clear();
    for (var s = 0; s < this._ints; ++s) this._partialOutput.putInt32(t3.getInt32() ^ this._outBlock[s]);
    if (i <= 0 || n) {
      if (n) {
        var a = r % this.blockSize;
        this._cipherLength += a, this._partialOutput.truncate(this.blockSize - a);
      } else this._cipherLength += this.blockSize;
      for (var s = 0; s < this._ints; ++s) this._outBlock[s] = this._partialOutput.getInt32();
      this._partialOutput.read -= this.blockSize;
    }
    if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), i > 0 && !n) return t3.read -= this.blockSize, e.putBytes(this._partialOutput.getBytes(i - this._partialBytes)), this._partialBytes = i, true;
    e.putBytes(this._partialOutput.getBytes(r - this._partialBytes)), this._partialBytes = 0;
  }
  this._s = this.ghash(this._hashSubkey, this._s, this._outBlock), Ig(this._inBlock);
};
qr.gcm.prototype.decrypt = function(t3, e, n) {
  var r = t3.length();
  if (r < this.blockSize && !(n && r > 0)) return true;
  this.cipher.encrypt(this._inBlock, this._outBlock), Ig(this._inBlock), this._hashBlock[0] = t3.getInt32(), this._hashBlock[1] = t3.getInt32(), this._hashBlock[2] = t3.getInt32(), this._hashBlock[3] = t3.getInt32(), this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
  for (var s = 0; s < this._ints; ++s) e.putInt32(this._outBlock[s] ^ this._hashBlock[s]);
  r < this.blockSize ? this._cipherLength += r % this.blockSize : this._cipherLength += this.blockSize;
};
qr.gcm.prototype.afterFinish = function(t3, e) {
  var n = true;
  e.decrypt && e.overflow && t3.truncate(this.blockSize - e.overflow), this.tag = xi.util.createBuffer();
  var r = this._aDataLength.concat(b3(this._cipherLength * 8));
  this._s = this.ghash(this._hashSubkey, this._s, r);
  var s = [];
  this.cipher.encrypt(this._j0, s);
  for (var i = 0; i < this._ints; ++i) this.tag.putInt32(this._s[i] ^ s[i]);
  return this.tag.truncate(this.tag.length() % (this._tagLength / 8)), e.decrypt && this.tag.bytes() !== this._tag && (n = false), n;
};
qr.gcm.prototype.multiply = function(t3, e) {
  for (var n = [0, 0, 0, 0], r = e.slice(0), s = 0; s < 128; ++s) {
    var i = t3[s / 32 | 0] & 1 << 31 - s % 32;
    i && (n[0] ^= r[0], n[1] ^= r[1], n[2] ^= r[2], n[3] ^= r[3]), this.pow(r, r);
  }
  return n;
};
qr.gcm.prototype.pow = function(t3, e) {
  for (var n = t3[3] & 1, r = 3; r > 0; --r) e[r] = t3[r] >>> 1 | (t3[r - 1] & 1) << 31;
  e[0] = t3[0] >>> 1, n && (e[0] ^= this._R);
};
qr.gcm.prototype.tableMultiply = function(t3) {
  for (var e = [0, 0, 0, 0], n = 0; n < 32; ++n) {
    var r = n / 8 | 0, s = t3[r] >>> (7 - n % 8) * 4 & 15, i = this._m[n][s];
    e[0] ^= i[0], e[1] ^= i[1], e[2] ^= i[2], e[3] ^= i[3];
  }
  return e;
};
qr.gcm.prototype.ghash = function(t3, e, n) {
  return e[0] ^= n[0], e[1] ^= n[1], e[2] ^= n[2], e[3] ^= n[3], this.tableMultiply(e);
};
qr.gcm.prototype.generateHashTable = function(t3, e) {
  for (var n = 8 / e, r = 4 * n, s = 16 * n, i = new Array(s), a = 0; a < s; ++a) {
    var o = [0, 0, 0, 0], f = a / r | 0, c = (r - 1 - a % r) * e;
    o[f] = 1 << e - 1 << c, i[a] = this.generateSubHashTable(this.multiply(o, t3), e);
  }
  return i;
};
qr.gcm.prototype.generateSubHashTable = function(t3, e) {
  var n = 1 << e, r = n >>> 1, s = new Array(n);
  s[r] = t3.slice(0);
  for (var i = r >>> 1; i > 0; ) this.pow(s[2 * i], s[i] = []), i >>= 1;
  for (i = 2; i < r; ) {
    for (var a = 1; a < i; ++a) {
      var o = s[i], f = s[a];
      s[i + a] = [o[0] ^ f[0], o[1] ^ f[1], o[2] ^ f[2], o[3] ^ f[3]];
    }
    i *= 2;
  }
  for (s[0] = [0, 0, 0, 0], i = r + 1; i < n; ++i) {
    var c = s[i ^ r];
    s[i] = [t3[0] ^ c[0], t3[1] ^ c[1], t3[2] ^ c[2], t3[3] ^ c[3]];
  }
  return s;
};
function kg(t3, e) {
  if (typeof t3 == "string" && (t3 = xi.util.createBuffer(t3)), xi.util.isArray(t3) && t3.length > 4) {
    var n = t3;
    t3 = xi.util.createBuffer();
    for (var r = 0; r < n.length; ++r) t3.putByte(n[r]);
  }
  if (t3.length() < e) throw new Error("Invalid IV length; got " + t3.length() + " bytes and expected " + e + " bytes.");
  if (!xi.util.isArray(t3)) {
    for (var s = [], i = e / 4, r = 0; r < i; ++r) s.push(t3.getInt32());
    t3 = s;
  }
  return t3;
}
function Ig(t3) {
  t3[t3.length - 1] = t3[t3.length - 1] + 1 & 4294967295;
}
function b3(t3) {
  return [t3 / 4294967296 | 0, t3 & 4294967295];
}
var wn = Ur;
wn.aes = wn.aes || {};
wn.aes.startEncrypting = function(t3, e, n, r) {
  var s = Sg({ key: t3, output: n, decrypt: false, mode: r });
  return s.start(e), s;
};
wn.aes.createEncryptionCipher = function(t3, e) {
  return Sg({ key: t3, output: null, decrypt: false, mode: e });
};
wn.aes.startDecrypting = function(t3, e, n, r) {
  var s = Sg({ key: t3, output: n, decrypt: true, mode: r });
  return s.start(e), s;
};
wn.aes.createDecryptionCipher = function(t3, e) {
  return Sg({ key: t3, output: null, decrypt: true, mode: e });
};
wn.aes.Algorithm = function(t3, e) {
  bA || lS();
  var n = this;
  n.name = t3, n.mode = new e({ blockSize: 16, cipher: { encrypt: function(r, s) {
    return w3(n._w, r, s, false);
  }, decrypt: function(r, s) {
    return w3(n._w, r, s, true);
  } } }), n._init = false;
};
wn.aes.Algorithm.prototype.initialize = function(t3) {
  if (!this._init) {
    var e = t3.key, n;
    if (typeof e == "string" && (e.length === 16 || e.length === 24 || e.length === 32)) e = wn.util.createBuffer(e);
    else if (wn.util.isArray(e) && (e.length === 16 || e.length === 24 || e.length === 32)) {
      n = e, e = wn.util.createBuffer();
      for (var r = 0; r < n.length; ++r) e.putByte(n[r]);
    }
    if (!wn.util.isArray(e)) {
      n = e, e = [];
      var s = n.length();
      if (s === 16 || s === 24 || s === 32) {
        s = s >>> 2;
        for (var r = 0; r < s; ++r) e.push(n.getInt32());
      }
    }
    if (!wn.util.isArray(e) || !(e.length === 4 || e.length === 6 || e.length === 8)) throw new Error("Invalid key parameter.");
    var i = this.mode.name, a = ["CFB", "OFB", "CTR", "GCM"].indexOf(i) !== -1;
    this._w = uS(e, t3.decrypt && !a), this._init = true;
  }
};
wn.aes._expandKey = function(t3, e) {
  return bA || lS(), uS(t3, e);
};
wn.aes._updateBlock = w3;
Vu("AES-ECB", wn.cipher.modes.ecb);
Vu("AES-CBC", wn.cipher.modes.cbc);
Vu("AES-CFB", wn.cipher.modes.cfb);
Vu("AES-OFB", wn.cipher.modes.ofb);
Vu("AES-CTR", wn.cipher.modes.ctr);
Vu("AES-GCM", wn.cipher.modes.gcm);
function Vu(t3, e) {
  var n = function() {
    return new wn.aes.Algorithm(t3, e);
  };
  wn.cipher.registerAlgorithm(t3, n);
}
var bA = false, P0 = 4, as, A3, fS, Vl, Sa;
function lS() {
  bA = true, fS = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
  for (var t3 = new Array(256), e = 0; e < 128; ++e) t3[e] = e << 1, t3[e + 128] = e + 128 << 1 ^ 283;
  as = new Array(256), A3 = new Array(256), Vl = new Array(4), Sa = new Array(4);
  for (var e = 0; e < 4; ++e) Vl[e] = new Array(256), Sa[e] = new Array(256);
  for (var n = 0, r = 0, s, i, a, o, f, c, l, e = 0; e < 256; ++e) {
    o = r ^ r << 1 ^ r << 2 ^ r << 3 ^ r << 4, o = o >> 8 ^ o & 255 ^ 99, as[n] = o, A3[o] = n, f = t3[o], s = t3[n], i = t3[s], a = t3[i], c = f << 24 ^ o << 16 ^ o << 8 ^ (o ^ f), l = (s ^ i ^ a) << 24 ^ (n ^ a) << 16 ^ (n ^ i ^ a) << 8 ^ (n ^ s ^ a);
    for (var h = 0; h < 4; ++h) Vl[h][n] = c, Sa[h][o] = l, c = c << 24 | c >>> 8, l = l << 24 | l >>> 8;
    n === 0 ? n = r = 1 : (n = s ^ t3[t3[t3[s ^ a]]], r ^= t3[t3[r]]);
  }
}
function uS(t3, e) {
  for (var n = t3.slice(0), r, s = 1, i = n.length, a = i + 6 + 1, o = P0 * a, f = i; f < o; ++f) r = n[f - 1], f % i === 0 ? (r = as[r >>> 16 & 255] << 24 ^ as[r >>> 8 & 255] << 16 ^ as[r & 255] << 8 ^ as[r >>> 24] ^ fS[s] << 24, s++) : i > 6 && f % i === 4 && (r = as[r >>> 24] << 24 ^ as[r >>> 16 & 255] << 16 ^ as[r >>> 8 & 255] << 8 ^ as[r & 255]), n[f] = n[f - i] ^ r;
  if (e) {
    var c, l = Sa[0], h = Sa[1], m = Sa[2], v = Sa[3], b = n.slice(0);
    o = n.length;
    for (var f = 0, A = o - P0; f < o; f += P0, A -= P0) if (f === 0 || f === o - P0) b[f] = n[A], b[f + 1] = n[A + 3], b[f + 2] = n[A + 2], b[f + 3] = n[A + 1];
    else for (var _ = 0; _ < P0; ++_) c = n[A + _], b[f + (3 & -_)] = l[as[c >>> 24]] ^ h[as[c >>> 16 & 255]] ^ m[as[c >>> 8 & 255]] ^ v[as[c & 255]];
    n = b;
  }
  return n;
}
function w3(t3, e, n, r) {
  var s = t3.length / 4 - 1, i, a, o, f, c;
  r ? (i = Sa[0], a = Sa[1], o = Sa[2], f = Sa[3], c = A3) : (i = Vl[0], a = Vl[1], o = Vl[2], f = Vl[3], c = as);
  var l, h, m, v, b, A, _;
  l = e[0] ^ t3[0], h = e[r ? 3 : 1] ^ t3[1], m = e[2] ^ t3[2], v = e[r ? 1 : 3] ^ t3[3];
  for (var C = 3, I = 1; I < s; ++I) b = i[l >>> 24] ^ a[h >>> 16 & 255] ^ o[m >>> 8 & 255] ^ f[v & 255] ^ t3[++C], A = i[h >>> 24] ^ a[m >>> 16 & 255] ^ o[v >>> 8 & 255] ^ f[l & 255] ^ t3[++C], _ = i[m >>> 24] ^ a[v >>> 16 & 255] ^ o[l >>> 8 & 255] ^ f[h & 255] ^ t3[++C], v = i[v >>> 24] ^ a[l >>> 16 & 255] ^ o[h >>> 8 & 255] ^ f[m & 255] ^ t3[++C], l = b, h = A, m = _;
  n[0] = c[l >>> 24] << 24 ^ c[h >>> 16 & 255] << 16 ^ c[m >>> 8 & 255] << 8 ^ c[v & 255] ^ t3[++C], n[r ? 3 : 1] = c[h >>> 24] << 24 ^ c[m >>> 16 & 255] << 16 ^ c[v >>> 8 & 255] << 8 ^ c[l & 255] ^ t3[++C], n[2] = c[m >>> 24] << 24 ^ c[v >>> 16 & 255] << 16 ^ c[l >>> 8 & 255] << 8 ^ c[h & 255] ^ t3[++C], n[r ? 1 : 3] = c[v >>> 24] << 24 ^ c[l >>> 16 & 255] << 16 ^ c[h >>> 8 & 255] << 8 ^ c[m & 255] ^ t3[++C];
}
function Sg(t3) {
  t3 = t3 || {};
  var e = (t3.mode || "CBC").toUpperCase(), n = "AES-" + e, r;
  t3.decrypt ? r = wn.cipher.createDecipher(n, t3.key) : r = wn.cipher.createCipher(n, t3.key);
  var s = r.start;
  return r.start = function(i, a) {
    var o = null;
    a instanceof wn.util.ByteBuffer && (o = a, a = {}), a = a || {}, a.output = o, a.iv = i, s.call(r, a);
  }, r;
}
var oh = Ur;
oh.pki = oh.pki || {};
var x3 = oh.pki.oids = oh.oids = oh.oids || {};
function $t(t3, e) {
  x3[t3] = e, x3[e] = t3;
}
function ln(t3, e) {
  x3[t3] = e;
}
$t("1.2.840.113549.1.1.1", "rsaEncryption");
$t("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
$t("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
$t("1.2.840.113549.1.1.7", "RSAES-OAEP");
$t("1.2.840.113549.1.1.8", "mgf1");
$t("1.2.840.113549.1.1.9", "pSpecified");
$t("1.2.840.113549.1.1.10", "RSASSA-PSS");
$t("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
$t("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
$t("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
$t("1.3.101.112", "EdDSA25519");
$t("1.2.840.10040.4.3", "dsa-with-sha1");
$t("1.3.14.3.2.7", "desCBC");
$t("1.3.14.3.2.26", "sha1");
$t("1.3.14.3.2.29", "sha1WithRSASignature");
$t("2.16.840.1.101.3.4.2.1", "sha256");
$t("2.16.840.1.101.3.4.2.2", "sha384");
$t("2.16.840.1.101.3.4.2.3", "sha512");
$t("2.16.840.1.101.3.4.2.4", "sha224");
$t("2.16.840.1.101.3.4.2.5", "sha512-224");
$t("2.16.840.1.101.3.4.2.6", "sha512-256");
$t("1.2.840.113549.2.2", "md2");
$t("1.2.840.113549.2.5", "md5");
$t("1.2.840.113549.1.7.1", "data");
$t("1.2.840.113549.1.7.2", "signedData");
$t("1.2.840.113549.1.7.3", "envelopedData");
$t("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
$t("1.2.840.113549.1.7.5", "digestedData");
$t("1.2.840.113549.1.7.6", "encryptedData");
$t("1.2.840.113549.1.9.1", "emailAddress");
$t("1.2.840.113549.1.9.2", "unstructuredName");
$t("1.2.840.113549.1.9.3", "contentType");
$t("1.2.840.113549.1.9.4", "messageDigest");
$t("1.2.840.113549.1.9.5", "signingTime");
$t("1.2.840.113549.1.9.6", "counterSignature");
$t("1.2.840.113549.1.9.7", "challengePassword");
$t("1.2.840.113549.1.9.8", "unstructuredAddress");
$t("1.2.840.113549.1.9.14", "extensionRequest");
$t("1.2.840.113549.1.9.20", "friendlyName");
$t("1.2.840.113549.1.9.21", "localKeyId");
$t("1.2.840.113549.1.9.22.1", "x509Certificate");
$t("1.2.840.113549.1.12.10.1.1", "keyBag");
$t("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
$t("1.2.840.113549.1.12.10.1.3", "certBag");
$t("1.2.840.113549.1.12.10.1.4", "crlBag");
$t("1.2.840.113549.1.12.10.1.5", "secretBag");
$t("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
$t("1.2.840.113549.1.5.13", "pkcs5PBES2");
$t("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
$t("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
$t("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
$t("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
$t("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
$t("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
$t("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
$t("1.2.840.113549.2.7", "hmacWithSHA1");
$t("1.2.840.113549.2.8", "hmacWithSHA224");
$t("1.2.840.113549.2.9", "hmacWithSHA256");
$t("1.2.840.113549.2.10", "hmacWithSHA384");
$t("1.2.840.113549.2.11", "hmacWithSHA512");
$t("1.2.840.113549.3.7", "des-EDE3-CBC");
$t("2.16.840.1.101.3.4.1.2", "aes128-CBC");
$t("2.16.840.1.101.3.4.1.22", "aes192-CBC");
$t("2.16.840.1.101.3.4.1.42", "aes256-CBC");
$t("2.5.4.3", "commonName");
$t("2.5.4.4", "surname");
$t("2.5.4.5", "serialNumber");
$t("2.5.4.6", "countryName");
$t("2.5.4.7", "localityName");
$t("2.5.4.8", "stateOrProvinceName");
$t("2.5.4.9", "streetAddress");
$t("2.5.4.10", "organizationName");
$t("2.5.4.11", "organizationalUnitName");
$t("2.5.4.12", "title");
$t("2.5.4.13", "description");
$t("2.5.4.15", "businessCategory");
$t("2.5.4.17", "postalCode");
$t("2.5.4.42", "givenName");
$t("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName");
$t("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName");
$t("2.16.840.1.113730.1.1", "nsCertType");
$t("2.16.840.1.113730.1.13", "nsComment");
ln("2.5.29.1", "authorityKeyIdentifier");
ln("2.5.29.2", "keyAttributes");
ln("2.5.29.3", "certificatePolicies");
ln("2.5.29.4", "keyUsageRestriction");
ln("2.5.29.5", "policyMapping");
ln("2.5.29.6", "subtreesConstraint");
ln("2.5.29.7", "subjectAltName");
ln("2.5.29.8", "issuerAltName");
ln("2.5.29.9", "subjectDirectoryAttributes");
ln("2.5.29.10", "basicConstraints");
ln("2.5.29.11", "nameConstraints");
ln("2.5.29.12", "policyConstraints");
ln("2.5.29.13", "basicConstraints");
$t("2.5.29.14", "subjectKeyIdentifier");
$t("2.5.29.15", "keyUsage");
ln("2.5.29.16", "privateKeyUsagePeriod");
$t("2.5.29.17", "subjectAltName");
$t("2.5.29.18", "issuerAltName");
$t("2.5.29.19", "basicConstraints");
ln("2.5.29.20", "cRLNumber");
ln("2.5.29.21", "cRLReason");
ln("2.5.29.22", "expirationDate");
ln("2.5.29.23", "instructionCode");
ln("2.5.29.24", "invalidityDate");
ln("2.5.29.25", "cRLDistributionPoints");
ln("2.5.29.26", "issuingDistributionPoint");
ln("2.5.29.27", "deltaCRLIndicator");
ln("2.5.29.28", "issuingDistributionPoint");
ln("2.5.29.29", "certificateIssuer");
ln("2.5.29.30", "nameConstraints");
$t("2.5.29.31", "cRLDistributionPoints");
$t("2.5.29.32", "certificatePolicies");
ln("2.5.29.33", "policyMappings");
ln("2.5.29.34", "policyConstraints");
$t("2.5.29.35", "authorityKeyIdentifier");
ln("2.5.29.36", "policyConstraints");
$t("2.5.29.37", "extKeyUsage");
ln("2.5.29.46", "freshestCRL");
ln("2.5.29.54", "inhibitAnyPolicy");
$t("1.3.6.1.4.1.11129.2.4.2", "timestampList");
$t("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
$t("1.3.6.1.5.5.7.3.1", "serverAuth");
$t("1.3.6.1.5.5.7.3.2", "clientAuth");
$t("1.3.6.1.5.5.7.3.3", "codeSigning");
$t("1.3.6.1.5.5.7.3.4", "emailProtection");
$t("1.3.6.1.5.5.7.3.8", "timeStamping");
var En = Ur, zt = En.asn1 = En.asn1 || {};
zt.Class = { UNIVERSAL: 0, APPLICATION: 64, CONTEXT_SPECIFIC: 128, PRIVATE: 192 };
zt.Type = { NONE: 0, BOOLEAN: 1, INTEGER: 2, BITSTRING: 3, OCTETSTRING: 4, NULL: 5, OID: 6, ODESC: 7, EXTERNAL: 8, REAL: 9, ENUMERATED: 10, EMBEDDED: 11, UTF8: 12, ROID: 13, SEQUENCE: 16, SET: 17, PRINTABLESTRING: 19, IA5STRING: 22, UTCTIME: 23, GENERALIZEDTIME: 24, BMPSTRING: 30 };
zt.maxDepth = 256;
zt.create = function(t3, e, n, r, s) {
  if (En.util.isArray(r)) {
    for (var i = [], a = 0; a < r.length; ++a) r[a] !== void 0 && i.push(r[a]);
    r = i;
  }
  var o = { tagClass: t3, type: e, constructed: n, composed: n || En.util.isArray(r), value: r };
  return s && "bitStringContents" in s && (o.bitStringContents = s.bitStringContents, o.original = zt.copy(o)), o;
};
zt.copy = function(t3, e) {
  var n;
  if (En.util.isArray(t3)) {
    n = [];
    for (var r = 0; r < t3.length; ++r) n.push(zt.copy(t3[r], e));
    return n;
  }
  return typeof t3 == "string" ? t3 : (n = { tagClass: t3.tagClass, type: t3.type, constructed: t3.constructed, composed: t3.composed, value: zt.copy(t3.value, e) }, e && !e.excludeBitStringContents && (n.bitStringContents = t3.bitStringContents), n);
};
zt.equals = function(t3, e, n) {
  if (En.util.isArray(t3)) {
    if (!En.util.isArray(e) || t3.length !== e.length) return false;
    for (var r = 0; r < t3.length; ++r) if (!zt.equals(t3[r], e[r])) return false;
    return true;
  }
  if (typeof t3 != typeof e) return false;
  if (typeof t3 == "string") return t3 === e;
  var s = t3.tagClass === e.tagClass && t3.type === e.type && t3.constructed === e.constructed && t3.composed === e.composed && zt.equals(t3.value, e.value);
  return n && n.includeBitStringContents && (s = s && t3.bitStringContents === e.bitStringContents), s;
};
zt.getBerValueLength = function(t3) {
  var e = t3.getByte();
  if (e !== 128) {
    var n, r = e & 128;
    return r ? n = t3.getInt((e & 127) << 3) : n = e, n;
  }
};
function Jc(t3, e, n) {
  if (n > e) {
    var r = new Error("Too few bytes to parse DER.");
    throw r.available = t3.length(), r.remaining = e, r.requested = n, r;
  }
}
var _K = function(t3, e) {
  var n = t3.getByte();
  if (e--, n !== 128) {
    var r, s = n & 128;
    if (!s) r = n;
    else {
      var i = n & 127;
      Jc(t3, e, i), r = t3.getInt(i << 3);
    }
    if (r < 0) throw new Error("Negative length: " + r);
    return r;
  }
};
zt.fromDer = function(t3, e) {
  e === void 0 && (e = { strict: true, parseAllBytes: true, decodeBitStrings: true }), typeof e == "boolean" && (e = { strict: e, parseAllBytes: true, decodeBitStrings: true }), "strict" in e || (e.strict = true), "parseAllBytes" in e || (e.parseAllBytes = true), "decodeBitStrings" in e || (e.decodeBitStrings = true), "maxDepth" in e || (e.maxDepth = zt.maxDepth), typeof t3 == "string" && (t3 = En.util.createBuffer(t3));
  var n = t3.length(), r = Dp(t3, t3.length(), 0, e);
  if (e.parseAllBytes && t3.length() !== 0) {
    var s = new Error("Unparsed DER bytes remain after ASN.1 parsing.");
    throw s.byteCount = n, s.remaining = t3.length(), s;
  }
  return r;
};
function Dp(t3, e, n, r) {
  if (n >= r.maxDepth) throw new Error("ASN.1 parsing error: Max depth exceeded.");
  var s;
  Jc(t3, e, 2);
  var i = t3.getByte();
  e--;
  var a = i & 192, o = i & 31;
  s = t3.length();
  var f = _K(t3, e);
  if (e -= s - t3.length(), f !== void 0 && f > e) {
    if (r.strict) {
      var c = new Error("Too few bytes to read ASN.1 value.");
      throw c.available = t3.length(), c.remaining = e, c.requested = f, c;
    }
    f = e;
  }
  var l, h, m = (i & 32) === 32;
  if (m) if (l = [], f === void 0) for (; ; ) {
    if (Jc(t3, e, 2), t3.bytes(2) === "\0\0") {
      t3.getBytes(2), e -= 2;
      break;
    }
    s = t3.length(), l.push(Dp(t3, e, n + 1, r)), e -= s - t3.length();
  }
  else for (; f > 0; ) s = t3.length(), l.push(Dp(t3, f, n + 1, r)), e -= s - t3.length(), f -= s - t3.length();
  if (l === void 0 && a === zt.Class.UNIVERSAL && o === zt.Type.BITSTRING && (h = t3.bytes(f)), l === void 0 && r.decodeBitStrings && a === zt.Class.UNIVERSAL && o === zt.Type.BITSTRING && f > 1) {
    var v = t3.read, b = e, A = 0;
    if (o === zt.Type.BITSTRING && (Jc(t3, e, 1), A = t3.getByte(), e--), A === 0) try {
      s = t3.length();
      var _ = { strict: true, decodeBitStrings: true }, C = Dp(t3, e, n + 1, _), I = s - t3.length();
      e -= I, o == zt.Type.BITSTRING && I++;
      var S = C.tagClass;
      I === f && (S === zt.Class.UNIVERSAL || S === zt.Class.CONTEXT_SPECIFIC) && (l = [C]);
    } catch {
    }
    l === void 0 && (t3.read = v, e = b);
  }
  if (l === void 0) {
    if (f === void 0) {
      if (r.strict) throw new Error("Non-constructed ASN.1 object of indefinite length.");
      f = e;
    }
    if (o === zt.Type.BMPSTRING) for (l = ""; f > 0; f -= 2) Jc(t3, e, 2), l += String.fromCharCode(t3.getInt16()), e -= 2;
    else l = t3.getBytes(f), e -= f;
  }
  var $ = h === void 0 ? null : { bitStringContents: h };
  return zt.create(a, o, m, l, $);
}
zt.toDer = function(t3) {
  var e = En.util.createBuffer(), n = t3.tagClass | t3.type, r = En.util.createBuffer(), s = false;
  if ("bitStringContents" in t3 && (s = true, t3.original && (s = zt.equals(t3, t3.original))), s) r.putBytes(t3.bitStringContents);
  else if (t3.composed) {
    t3.constructed ? n |= 32 : r.putByte(0);
    for (var i = 0; i < t3.value.length; ++i) t3.value[i] !== void 0 && r.putBuffer(zt.toDer(t3.value[i]));
  } else if (t3.type === zt.Type.BMPSTRING) for (var i = 0; i < t3.value.length; ++i) r.putInt16(t3.value.charCodeAt(i));
  else t3.type === zt.Type.INTEGER && t3.value.length > 1 && (t3.value.charCodeAt(0) === 0 && !(t3.value.charCodeAt(1) & 128) || t3.value.charCodeAt(0) === 255 && (t3.value.charCodeAt(1) & 128) === 128) ? r.putBytes(t3.value.substr(1)) : r.putBytes(t3.value);
  if (e.putByte(n), r.length() <= 127) e.putByte(r.length() & 127);
  else {
    var a = r.length(), o = "";
    do
      o += String.fromCharCode(a & 255), a = a >>> 8;
    while (a > 0);
    e.putByte(o.length | 128);
    for (var i = o.length - 1; i >= 0; --i) e.putByte(o.charCodeAt(i));
  }
  return e.putBuffer(r), e;
};
zt.oidToDer = function(t3) {
  var e = t3.split("."), n = En.util.createBuffer();
  n.putByte(40 * parseInt(e[0], 10) + parseInt(e[1], 10));
  for (var r, s, i, a, o = 2; o < e.length; ++o) {
    if (r = true, s = [], i = parseInt(e[o], 10), i > 4294967295) throw new Error("OID value too large; max is 32-bits.");
    do
      a = i & 127, i = i >>> 7, r || (a |= 128), s.push(a), r = false;
    while (i > 0);
    for (var f = s.length - 1; f >= 0; --f) n.putByte(s[f]);
  }
  return n;
};
zt.derToOid = function(t3) {
  var e;
  typeof t3 == "string" && (t3 = En.util.createBuffer(t3));
  var n = t3.getByte();
  e = Math.floor(n / 40) + "." + n % 40;
  for (var r = 0; t3.length() > 0; ) {
    if (r > 70368744177663) throw new Error("OID value too large; max is 53-bits.");
    n = t3.getByte(), r = r * 128, n & 128 ? r += n & 127 : (e += "." + (r + n), r = 0);
  }
  return e;
};
zt.utcTimeToDate = function(t3) {
  var e = /* @__PURE__ */ new Date(), n = parseInt(t3.substr(0, 2), 10);
  n = n >= 50 ? 1900 + n : 2e3 + n;
  var r = parseInt(t3.substr(2, 2), 10) - 1, s = parseInt(t3.substr(4, 2), 10), i = parseInt(t3.substr(6, 2), 10), a = parseInt(t3.substr(8, 2), 10), o = 0;
  if (t3.length > 11) {
    var f = t3.charAt(10), c = 10;
    f !== "+" && f !== "-" && (o = parseInt(t3.substr(10, 2), 10), c += 2);
  }
  if (e.setUTCFullYear(n, r, s), e.setUTCHours(i, a, o, 0), c && (f = t3.charAt(c), f === "+" || f === "-")) {
    var l = parseInt(t3.substr(c + 1, 2), 10), h = parseInt(t3.substr(c + 4, 2), 10), m = l * 60 + h;
    m *= 6e4, f === "+" ? e.setTime(+e - m) : e.setTime(+e + m);
  }
  return e;
};
zt.generalizedTimeToDate = function(t3) {
  var e = /* @__PURE__ */ new Date(), n = parseInt(t3.substr(0, 4), 10), r = parseInt(t3.substr(4, 2), 10) - 1, s = parseInt(t3.substr(6, 2), 10), i = parseInt(t3.substr(8, 2), 10), a = parseInt(t3.substr(10, 2), 10), o = parseInt(t3.substr(12, 2), 10), f = 0, c = 0, l = false;
  t3.charAt(t3.length - 1) === "Z" && (l = true);
  var h = t3.length - 5, m = t3.charAt(h);
  if (m === "+" || m === "-") {
    var v = parseInt(t3.substr(h + 1, 2), 10), b = parseInt(t3.substr(h + 4, 2), 10);
    c = v * 60 + b, c *= 6e4, m === "+" && (c *= -1), l = true;
  }
  return t3.charAt(14) === "." && (f = parseFloat(t3.substr(14), 10) * 1e3), l ? (e.setUTCFullYear(n, r, s), e.setUTCHours(i, a, o, f), e.setTime(+e + c)) : (e.setFullYear(n, r, s), e.setHours(i, a, o, f)), e;
};
zt.dateToUtcTime = function(t3) {
  if (typeof t3 == "string") return t3;
  var e = "", n = [];
  n.push(("" + t3.getUTCFullYear()).substr(2)), n.push("" + (t3.getUTCMonth() + 1)), n.push("" + t3.getUTCDate()), n.push("" + t3.getUTCHours()), n.push("" + t3.getUTCMinutes()), n.push("" + t3.getUTCSeconds());
  for (var r = 0; r < n.length; ++r) n[r].length < 2 && (e += "0"), e += n[r];
  return e += "Z", e;
};
zt.dateToGeneralizedTime = function(t3) {
  if (typeof t3 == "string") return t3;
  var e = "", n = [];
  n.push("" + t3.getUTCFullYear()), n.push("" + (t3.getUTCMonth() + 1)), n.push("" + t3.getUTCDate()), n.push("" + t3.getUTCHours()), n.push("" + t3.getUTCMinutes()), n.push("" + t3.getUTCSeconds());
  for (var r = 0; r < n.length; ++r) n[r].length < 2 && (e += "0"), e += n[r];
  return e += "Z", e;
};
zt.integerToDer = function(t3) {
  var e = En.util.createBuffer();
  if (t3 >= -128 && t3 < 128) return e.putSignedInt(t3, 8);
  if (t3 >= -32768 && t3 < 32768) return e.putSignedInt(t3, 16);
  if (t3 >= -8388608 && t3 < 8388608) return e.putSignedInt(t3, 24);
  if (t3 >= -2147483648 && t3 < 2147483648) return e.putSignedInt(t3, 32);
  var n = new Error("Integer too large; max is 32-bits.");
  throw n.integer = t3, n;
};
zt.derToInteger = function(t3) {
  typeof t3 == "string" && (t3 = En.util.createBuffer(t3));
  var e = t3.length() * 8;
  if (e > 32) throw new Error("Integer too large; max is 32-bits.");
  return t3.getSignedInt(e);
};
zt.validate = function(t3, e, n, r) {
  var s = false;
  if ((t3.tagClass === e.tagClass || typeof e.tagClass > "u") && (t3.type === e.type || typeof e.type > "u")) if (t3.constructed === e.constructed || typeof e.constructed > "u") {
    if (s = true, e.value && En.util.isArray(e.value)) for (var i = 0, a = 0; s && a < e.value.length; ++a) {
      var o = e.value[a];
      s = !!o.optional;
      var f = t3.value[i];
      if (!f) {
        o.optional || (s = false, r && r.push("[" + e.name + '] Missing required element. Expected tag class "' + o.tagClass + '", type "' + o.type + '"'));
        continue;
      }
      var c = typeof o.tagClass < "u" && typeof o.type < "u";
      if (c && (f.tagClass !== o.tagClass || f.type !== o.type)) if (o.optional) {
        s = true;
        continue;
      } else {
        s = false, r && r.push("[" + e.name + "] Tag mismatch. Expected (" + o.tagClass + "," + o.type + "), got (" + f.tagClass + "," + f.type + ")");
        break;
      }
      var l = zt.validate(f, o, n, r);
      if (l) ++i, s = true;
      else if (o.optional) s = true;
      else {
        s = false;
        break;
      }
    }
    if (s && n && (e.capture && (n[e.capture] = t3.value), e.captureAsn1 && (n[e.captureAsn1] = t3), e.captureBitStringContents && "bitStringContents" in t3 && (n[e.captureBitStringContents] = t3.bitStringContents), e.captureBitStringValue && "bitStringContents" in t3)) if (t3.bitStringContents.length < 2) n[e.captureBitStringValue] = "";
    else {
      var h = t3.bitStringContents.charCodeAt(0);
      if (h !== 0) throw new Error("captureBitStringValue only supported for zero unused bits");
      n[e.captureBitStringValue] = t3.bitStringContents.slice(1);
    }
  } else r && r.push("[" + e.name + '] Expected constructed "' + e.constructed + '", got "' + t3.constructed + '"');
  else r && (t3.tagClass !== e.tagClass && r.push("[" + e.name + '] Expected tag class "' + e.tagClass + '", got "' + t3.tagClass + '"'), t3.type !== e.type && r.push("[" + e.name + '] Expected type "' + e.type + '", got "' + t3.type + '"'));
  return s;
};
var v8 = /[^\\u0000-\\u00ff]/;
zt.prettyPrint = function(t3, e, n) {
  var r = "";
  e = e || 0, n = n || 2, e > 0 && (r += `
`);
  for (var s = "", i = 0; i < e * n; ++i) s += " ";
  switch (r += s + "Tag: ", t3.tagClass) {
    case zt.Class.UNIVERSAL:
      r += "Universal:";
      break;
    case zt.Class.APPLICATION:
      r += "Application:";
      break;
    case zt.Class.CONTEXT_SPECIFIC:
      r += "Context-Specific:";
      break;
    case zt.Class.PRIVATE:
      r += "Private:";
      break;
  }
  if (t3.tagClass === zt.Class.UNIVERSAL) switch (r += t3.type, t3.type) {
    case zt.Type.NONE:
      r += " (None)";
      break;
    case zt.Type.BOOLEAN:
      r += " (Boolean)";
      break;
    case zt.Type.INTEGER:
      r += " (Integer)";
      break;
    case zt.Type.BITSTRING:
      r += " (Bit string)";
      break;
    case zt.Type.OCTETSTRING:
      r += " (Octet string)";
      break;
    case zt.Type.NULL:
      r += " (Null)";
      break;
    case zt.Type.OID:
      r += " (Object Identifier)";
      break;
    case zt.Type.ODESC:
      r += " (Object Descriptor)";
      break;
    case zt.Type.EXTERNAL:
      r += " (External or Instance of)";
      break;
    case zt.Type.REAL:
      r += " (Real)";
      break;
    case zt.Type.ENUMERATED:
      r += " (Enumerated)";
      break;
    case zt.Type.EMBEDDED:
      r += " (Embedded PDV)";
      break;
    case zt.Type.UTF8:
      r += " (UTF8)";
      break;
    case zt.Type.ROID:
      r += " (Relative Object Identifier)";
      break;
    case zt.Type.SEQUENCE:
      r += " (Sequence)";
      break;
    case zt.Type.SET:
      r += " (Set)";
      break;
    case zt.Type.PRINTABLESTRING:
      r += " (Printable String)";
      break;
    case zt.Type.IA5String:
      r += " (IA5String (ASCII))";
      break;
    case zt.Type.UTCTIME:
      r += " (UTC time)";
      break;
    case zt.Type.GENERALIZEDTIME:
      r += " (Generalized time)";
      break;
    case zt.Type.BMPSTRING:
      r += " (BMP String)";
      break;
  }
  else r += t3.type;
  if (r += `
`, r += s + "Constructed: " + t3.constructed + `
`, t3.composed) {
    for (var a = 0, o = "", i = 0; i < t3.value.length; ++i) t3.value[i] !== void 0 && (a += 1, o += zt.prettyPrint(t3.value[i], e + 1, n), i + 1 < t3.value.length && (o += ","));
    r += s + "Sub values: " + a + o;
  } else {
    if (r += s + "Value: ", t3.type === zt.Type.OID) {
      var f = zt.derToOid(t3.value);
      r += f, En.pki && En.pki.oids && f in En.pki.oids && (r += " (" + En.pki.oids[f] + ") ");
    }
    if (t3.type === zt.Type.INTEGER) try {
      r += zt.derToInteger(t3.value);
    } catch {
      r += "0x" + En.util.bytesToHex(t3.value);
    }
    else if (t3.type === zt.Type.BITSTRING) {
      if (t3.value.length > 1 ? r += "0x" + En.util.bytesToHex(t3.value.slice(1)) : r += "(none)", t3.value.length > 0) {
        var c = t3.value.charCodeAt(0);
        c == 1 ? r += " (1 unused bit shown)" : c > 1 && (r += " (" + c + " unused bits shown)");
      }
    } else if (t3.type === zt.Type.OCTETSTRING) v8.test(t3.value) || (r += "(" + t3.value + ") "), r += "0x" + En.util.bytesToHex(t3.value);
    else if (t3.type === zt.Type.UTF8) try {
      r += En.util.decodeUtf8(t3.value);
    } catch (l) {
      if (l.message === "URI malformed") r += "0x" + En.util.bytesToHex(t3.value) + " (malformed UTF8)";
      else throw l;
    }
    else t3.type === zt.Type.PRINTABLESTRING || t3.type === zt.Type.IA5String ? r += t3.value : v8.test(t3.value) ? r += "0x" + En.util.bytesToHex(t3.value) : t3.value.length === 0 ? r += "[null]" : r += t3.value;
  }
  return r;
};
var b1 = Ur;
b1.md = b1.md || {};
b1.md.algorithms = b1.md.algorithms || {};
var qo = Ur, EK = qo.hmac = qo.hmac || {};
EK.create = function() {
  var t3 = null, e = null, n = null, r = null, s = {};
  return s.start = function(i, a) {
    if (i !== null) if (typeof i == "string") if (i = i.toLowerCase(), i in qo.md.algorithms) e = qo.md.algorithms[i].create();
    else throw new Error('Unknown hash algorithm "' + i + '"');
    else e = i;
    if (a === null) a = t3;
    else {
      if (typeof a == "string") a = qo.util.createBuffer(a);
      else if (qo.util.isArray(a)) {
        var o = a;
        a = qo.util.createBuffer();
        for (var f = 0; f < o.length; ++f) a.putByte(o[f]);
      }
      var c = a.length();
      c > e.blockLength && (e.start(), e.update(a.bytes()), a = e.digest()), n = qo.util.createBuffer(), r = qo.util.createBuffer(), c = a.length();
      for (var f = 0; f < c; ++f) {
        var o = a.at(f);
        n.putByte(54 ^ o), r.putByte(92 ^ o);
      }
      if (c < e.blockLength) for (var o = e.blockLength - c, f = 0; f < o; ++f) n.putByte(54), r.putByte(92);
      t3 = a, n = n.bytes(), r = r.bytes();
    }
    e.start(), e.update(n);
  }, s.update = function(i) {
    e.update(i);
  }, s.getMac = function() {
    var i = e.digest().bytes();
    return e.start(), e.update(r), e.update(i), e.digest();
  }, s.digest = s.getMac, s;
};
var io = Ur, cS = io.md5 = io.md5 || {};
io.md.md5 = io.md.algorithms.md5 = cS;
cS.create = function() {
  hS || BK();
  var t3 = null, e = io.util.createBuffer(), n = new Array(16), r = { algorithm: "md5", blockLength: 64, digestLength: 16, messageLength: 0, fullMessageLength: null, messageLengthSize: 8 };
  return r.start = function() {
    r.messageLength = 0, r.fullMessageLength = r.messageLength64 = [];
    for (var s = r.messageLengthSize / 4, i = 0; i < s; ++i) r.fullMessageLength.push(0);
    return e = io.util.createBuffer(), t3 = { h0: 1732584193, h1: 4023233417, h2: 2562383102, h3: 271733878 }, r;
  }, r.start(), r.update = function(s, i) {
    i === "utf8" && (s = io.util.encodeUtf8(s));
    var a = s.length;
    r.messageLength += a, a = [a / 4294967296 >>> 0, a >>> 0];
    for (var o = r.fullMessageLength.length - 1; o >= 0; --o) r.fullMessageLength[o] += a[1], a[1] = a[0] + (r.fullMessageLength[o] / 4294967296 >>> 0), r.fullMessageLength[o] = r.fullMessageLength[o] >>> 0, a[0] = a[1] / 4294967296 >>> 0;
    return e.putBytes(s), y8(t3, n, e), (e.read > 2048 || e.length() === 0) && e.compact(), r;
  }, r.digest = function() {
    var s = io.util.createBuffer();
    s.putBytes(e.bytes());
    var i = r.fullMessageLength[r.fullMessageLength.length - 1] + r.messageLengthSize, a = i & r.blockLength - 1;
    s.putBytes(_3.substr(0, r.blockLength - a));
    for (var o, f = 0, c = r.fullMessageLength.length - 1; c >= 0; --c) o = r.fullMessageLength[c] * 8 + f, f = o / 4294967296 >>> 0, s.putInt32Le(o >>> 0);
    var l = { h0: t3.h0, h1: t3.h1, h2: t3.h2, h3: t3.h3 };
    y8(l, n, s);
    var h = io.util.createBuffer();
    return h.putInt32Le(l.h0), h.putInt32Le(l.h1), h.putInt32Le(l.h2), h.putInt32Le(l.h3), h;
  }, r;
};
var _3 = null, Rp = null, Zc = null, eu = null, hS = false;
function BK() {
  _3 = "\x80", _3 += io.util.fillString("\0", 64), Rp = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1, 6, 11, 0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12, 5, 8, 11, 14, 1, 4, 7, 10, 13, 0, 3, 6, 9, 12, 15, 2, 0, 7, 14, 5, 12, 3, 10, 1, 8, 15, 6, 13, 4, 11, 2, 9], Zc = [7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21], eu = new Array(64);
  for (var t3 = 0; t3 < 64; ++t3) eu[t3] = Math.floor(Math.abs(Math.sin(t3 + 1)) * 4294967296);
  hS = true;
}
function y8(t3, e, n) {
  for (var r, s, i, a, o, f, c, l, h = n.length(); h >= 64; ) {
    for (s = t3.h0, i = t3.h1, a = t3.h2, o = t3.h3, l = 0; l < 16; ++l) e[l] = n.getInt32Le(), f = o ^ i & (a ^ o), r = s + f + eu[l] + e[l], c = Zc[l], s = o, o = a, a = i, i += r << c | r >>> 32 - c;
    for (; l < 32; ++l) f = a ^ o & (i ^ a), r = s + f + eu[l] + e[Rp[l]], c = Zc[l], s = o, o = a, a = i, i += r << c | r >>> 32 - c;
    for (; l < 48; ++l) f = i ^ a ^ o, r = s + f + eu[l] + e[Rp[l]], c = Zc[l], s = o, o = a, a = i, i += r << c | r >>> 32 - c;
    for (; l < 64; ++l) f = a ^ (i | ~o), r = s + f + eu[l] + e[Rp[l]], c = Zc[l], s = o, o = a, a = i, i += r << c | r >>> 32 - c;
    t3.h0 = t3.h0 + s | 0, t3.h1 = t3.h1 + i | 0, t3.h2 = t3.h2 + a | 0, t3.h3 = t3.h3 + o | 0, h -= 64;
  }
}
var A1 = Ur, dS = A1.pem = A1.pem || {};
dS.encode = function(t3, e) {
  e = e || {};
  var n = "-----BEGIN " + t3.type + `-----\r
`, r;
  if (t3.procType && (r = { name: "Proc-Type", values: [String(t3.procType.version), t3.procType.type] }, n += Wd(r)), t3.contentDomain && (r = { name: "Content-Domain", values: [t3.contentDomain] }, n += Wd(r)), t3.dekInfo && (r = { name: "DEK-Info", values: [t3.dekInfo.algorithm] }, t3.dekInfo.parameters && r.values.push(t3.dekInfo.parameters), n += Wd(r)), t3.headers) for (var s = 0; s < t3.headers.length; ++s) n += Wd(t3.headers[s]);
  return t3.procType && (n += `\r
`), n += A1.util.encode64(t3.body, e.maxline || 64) + `\r
`, n += "-----END " + t3.type + `-----\r
`, n;
};
dS.decode = function(t3) {
  for (var e = [], n = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g, r = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/, s = /\r?\n/, i; i = n.exec(t3), !!i; ) {
    var a = i[1];
    a === "NEW CERTIFICATE REQUEST" && (a = "CERTIFICATE REQUEST");
    var o = { type: a, procType: null, contentDomain: null, dekInfo: null, headers: [], body: A1.util.decode64(i[3]) };
    if (e.push(o), !!i[2]) {
      for (var f = i[2].split(s), c = 0; i && c < f.length; ) {
        for (var l = f[c].replace(/\s+$/, ""), h = c + 1; h < f.length; ++h) {
          var m = f[h];
          if (!/\s/.test(m[0])) break;
          l += m, c = h;
        }
        if (i = l.match(r), i) {
          for (var v = { name: i[1], values: [] }, b = i[2].split(","), A = 0; A < b.length; ++A) v.values.push(CK(b[A]));
          if (o.procType) if (!o.contentDomain && v.name === "Content-Domain") o.contentDomain = b[0] || "";
          else if (!o.dekInfo && v.name === "DEK-Info") {
            if (v.values.length === 0) throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
            o.dekInfo = { algorithm: b[0], parameters: b[1] || null };
          } else o.headers.push(v);
          else {
            if (v.name !== "Proc-Type") throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
            if (v.values.length !== 2) throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
            o.procType = { version: b[0], type: b[1] };
          }
        }
        ++c;
      }
      if (o.procType === "ENCRYPTED" && !o.dekInfo) throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
    }
  }
  if (e.length === 0) throw new Error("Invalid PEM formatted message.");
  return e;
};
function Wd(t3) {
  for (var e = t3.name + ": ", n = [], r = function(f, c) {
    return " " + c;
  }, s = 0; s < t3.values.length; ++s) n.push(t3.values[s].replace(/^(\S+\r\n)/, r));
  e += n.join(",") + `\r
`;
  for (var i = 0, a = -1, s = 0; s < e.length; ++s, ++i) if (i > 65 && a !== -1) {
    var o = e[a];
    o === "," ? (++a, e = e.substr(0, a) + `\r
 ` + e.substr(a)) : e = e.substr(0, a) + `\r
` + o + e.substr(a + 1), i = s - a - 1, a = -1, ++s;
  } else (e[s] === " " || e[s] === "	" || e[s] === ",") && (a = s);
  return e;
}
function CK(t3) {
  return t3.replace(/^\s+/, "");
}
var Pn = Ur;
Pn.des = Pn.des || {};
Pn.des.startEncrypting = function(t3, e, n, r) {
  var s = Mg({ key: t3, output: n, decrypt: false, mode: r || (e === null ? "ECB" : "CBC") });
  return s.start(e), s;
};
Pn.des.createEncryptionCipher = function(t3, e) {
  return Mg({ key: t3, output: null, decrypt: false, mode: e });
};
Pn.des.startDecrypting = function(t3, e, n, r) {
  var s = Mg({ key: t3, output: n, decrypt: true, mode: r || (e === null ? "ECB" : "CBC") });
  return s.start(e), s;
};
Pn.des.createDecryptionCipher = function(t3, e) {
  return Mg({ key: t3, output: null, decrypt: true, mode: e });
};
Pn.des.Algorithm = function(t3, e) {
  var n = this;
  n.name = t3, n.mode = new e({ blockSize: 8, cipher: { encrypt: function(r, s) {
    return b8(n._keys, r, s, false);
  }, decrypt: function(r, s) {
    return b8(n._keys, r, s, true);
  } } }), n._init = false;
};
Pn.des.Algorithm.prototype.initialize = function(t3) {
  if (!this._init) {
    var e = Pn.util.createBuffer(t3.key);
    if (this.name.indexOf("3DES") === 0 && e.length() !== 24) throw new Error("Invalid Triple-DES key size: " + e.length() * 8);
    this._keys = FK(e), this._init = true;
  }
};
So("DES-ECB", Pn.cipher.modes.ecb);
So("DES-CBC", Pn.cipher.modes.cbc);
So("DES-CFB", Pn.cipher.modes.cfb);
So("DES-OFB", Pn.cipher.modes.ofb);
So("DES-CTR", Pn.cipher.modes.ctr);
So("3DES-ECB", Pn.cipher.modes.ecb);
So("3DES-CBC", Pn.cipher.modes.cbc);
So("3DES-CFB", Pn.cipher.modes.cfb);
So("3DES-OFB", Pn.cipher.modes.ofb);
So("3DES-CTR", Pn.cipher.modes.ctr);
function So(t3, e) {
  var n = function() {
    return new Pn.des.Algorithm(t3, e);
  };
  Pn.cipher.registerAlgorithm(t3, n);
}
var kK = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756], IK = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344], SK = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584], MK = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928], $K = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080], TK = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312], DK = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154], RK = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
function FK(t3) {
  for (var e = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], n = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], r = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], s = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], i = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], a = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], o = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], f = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], c = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], l = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], h = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], m = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], v = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], b = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261], A = t3.length() > 8 ? 3 : 1, _ = [], C = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0], I = 0, S, $ = 0; $ < A; $++) {
    var F = t3.getInt32(), U = t3.getInt32();
    S = (F >>> 4 ^ U) & 252645135, U ^= S, F ^= S << 4, S = (U >>> -16 ^ F) & 65535, F ^= S, U ^= S << -16, S = (F >>> 2 ^ U) & 858993459, U ^= S, F ^= S << 2, S = (U >>> -16 ^ F) & 65535, F ^= S, U ^= S << -16, S = (F >>> 1 ^ U) & 1431655765, U ^= S, F ^= S << 1, S = (U >>> 8 ^ F) & 16711935, F ^= S, U ^= S << 8, S = (F >>> 1 ^ U) & 1431655765, U ^= S, F ^= S << 1, S = F << 8 | U >>> 20 & 240, F = U << 24 | U << 8 & 16711680 | U >>> 8 & 65280 | U >>> 24 & 240, U = S;
    for (var Q = 0; Q < C.length; ++Q) {
      C[Q] ? (F = F << 2 | F >>> 26, U = U << 2 | U >>> 26) : (F = F << 1 | F >>> 27, U = U << 1 | U >>> 27), F &= -15, U &= -15;
      var P = e[F >>> 28] | n[F >>> 24 & 15] | r[F >>> 20 & 15] | s[F >>> 16 & 15] | i[F >>> 12 & 15] | a[F >>> 8 & 15] | o[F >>> 4 & 15], N = f[U >>> 28] | c[U >>> 24 & 15] | l[U >>> 20 & 15] | h[U >>> 16 & 15] | m[U >>> 12 & 15] | v[U >>> 8 & 15] | b[U >>> 4 & 15];
      S = (N >>> 16 ^ P) & 65535, _[I++] = P ^ S, _[I++] = N ^ S << 16;
    }
  }
  return _;
}
function b8(t3, e, n, r) {
  var s = t3.length === 32 ? 3 : 9, i;
  s === 3 ? i = r ? [30, -2, -2] : [0, 32, 2] : i = r ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
  var a, o = e[0], f = e[1];
  a = (o >>> 4 ^ f) & 252645135, f ^= a, o ^= a << 4, a = (o >>> 16 ^ f) & 65535, f ^= a, o ^= a << 16, a = (f >>> 2 ^ o) & 858993459, o ^= a, f ^= a << 2, a = (f >>> 8 ^ o) & 16711935, o ^= a, f ^= a << 8, a = (o >>> 1 ^ f) & 1431655765, f ^= a, o ^= a << 1, o = o << 1 | o >>> 31, f = f << 1 | f >>> 31;
  for (var c = 0; c < s; c += 3) {
    for (var l = i[c + 1], h = i[c + 2], m = i[c]; m != l; m += h) {
      var v = f ^ t3[m], b = (f >>> 4 | f << 28) ^ t3[m + 1];
      a = o, o = f, f = a ^ (IK[v >>> 24 & 63] | MK[v >>> 16 & 63] | TK[v >>> 8 & 63] | RK[v & 63] | kK[b >>> 24 & 63] | SK[b >>> 16 & 63] | $K[b >>> 8 & 63] | DK[b & 63]);
    }
    a = o, o = f, f = a;
  }
  o = o >>> 1 | o << 31, f = f >>> 1 | f << 31, a = (o >>> 1 ^ f) & 1431655765, f ^= a, o ^= a << 1, a = (f >>> 8 ^ o) & 16711935, o ^= a, f ^= a << 8, a = (f >>> 2 ^ o) & 858993459, o ^= a, f ^= a << 2, a = (o >>> 16 ^ f) & 65535, f ^= a, o ^= a << 16, a = (o >>> 4 ^ f) & 252645135, f ^= a, o ^= a << 4, n[0] = o, n[1] = f;
}
function Mg(t3) {
  t3 = t3 || {};
  var e = (t3.mode || "CBC").toUpperCase(), n = "DES-" + e, r;
  t3.decrypt ? r = Pn.cipher.createDecipher(n, t3.key) : r = Pn.cipher.createCipher(n, t3.key);
  var s = r.start;
  return r.start = function(i, a) {
    var o = null;
    a instanceof Pn.util.ByteBuffer && (o = a, a = {}), a = a || {}, a.output = o, a.iv = i, s.call(r, a);
  }, r;
}
var Tr = {}, E3 = { exports: {} }, B3 = { exports: {} };
const $n = sS(nK);
(function(t3, e) {
  var n = $n, r = n.Buffer;
  function s(a, o) {
    for (var f in a) o[f] = a[f];
  }
  r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow ? t3.exports = n : (s(n, e), e.Buffer = i);
  function i(a, o, f) {
    return r(a, o, f);
  }
  s(r, i), i.from = function(a, o, f) {
    if (typeof a == "number") throw new TypeError("Argument must not be a number");
    return r(a, o, f);
  }, i.alloc = function(a, o, f) {
    if (typeof a != "number") throw new TypeError("Argument must be a number");
    var c = r(a);
    return o !== void 0 ? typeof f == "string" ? c.fill(o, f) : c.fill(o) : c.fill(0), c;
  }, i.allocUnsafe = function(a) {
    if (typeof a != "number") throw new TypeError("Argument must be a number");
    return r(a);
  }, i.allocUnsafeSlow = function(a) {
    if (typeof a != "number") throw new TypeError("Argument must be a number");
    return n.SlowBuffer(a);
  };
})(B3, B3.exports);
var Tn = B3.exports, f2 = 65536, PK = 4294967295;
function NK() {
  throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
}
var UK = Tn.Buffer, w1 = mt.crypto || mt.msCrypto;
w1 && w1.getRandomValues ? E3.exports = LK : E3.exports = NK;
function LK(t3, e) {
  if (t3 > PK) throw new RangeError("requested too many random bytes");
  var n = UK.allocUnsafe(t3);
  if (t3 > 0) if (t3 > f2) for (var r = 0; r < t3; r += f2) w1.getRandomValues(n.slice(r, r + f2));
  else w1.getRandomValues(n);
  return typeof e == "function" ? jt.nextTick(function() {
    e(null, n);
  }) : n;
}
var Yu = E3.exports, C3 = { exports: {} };
typeof Object.create == "function" ? C3.exports = function(e, n) {
  n && (e.super_ = n, e.prototype = Object.create(n.prototype, { constructor: { value: e, enumerable: false, writable: true, configurable: true } }));
} : C3.exports = function(e, n) {
  if (n) {
    e.super_ = n;
    var r = function() {
    };
    r.prototype = n.prototype, e.prototype = new r(), e.prototype.constructor = e;
  }
};
var wr = C3.exports, k3 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(t3, e) {
  var n = $n, r = n.Buffer;
  function s(a, o) {
    for (var f in a) o[f] = a[f];
  }
  r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow ? t3.exports = n : (s(n, e), e.Buffer = i);
  function i(a, o, f) {
    return r(a, o, f);
  }
  i.prototype = Object.create(r.prototype), s(r, i), i.from = function(a, o, f) {
    if (typeof a == "number") throw new TypeError("Argument must not be a number");
    return r(a, o, f);
  }, i.alloc = function(a, o, f) {
    if (typeof a != "number") throw new TypeError("Argument must be a number");
    var c = r(a);
    return o !== void 0 ? typeof f == "string" ? c.fill(o, f) : c.fill(o) : c.fill(0), c;
  }, i.allocUnsafe = function(a) {
    if (typeof a != "number") throw new TypeError("Argument must be a number");
    return r(a);
  }, i.allocUnsafeSlow = function(a) {
    if (typeof a != "number") throw new TypeError("Argument must be a number");
    return n.SlowBuffer(a);
  };
})(k3, k3.exports);
var OK = k3.exports, AA = { exports: {} }, cu = typeof Reflect == "object" ? Reflect : null, A8 = cu && typeof cu.apply == "function" ? cu.apply : function(e, n, r) {
  return Function.prototype.apply.call(e, n, r);
}, Fp;
cu && typeof cu.ownKeys == "function" ? Fp = cu.ownKeys : Object.getOwnPropertySymbols ? Fp = function(e) {
  return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
} : Fp = function(e) {
  return Object.getOwnPropertyNames(e);
};
function QK(t3) {
  console && console.warn && console.warn(t3);
}
var pS = Number.isNaN || function(e) {
  return e !== e;
};
function dn() {
  dn.init.call(this);
}
AA.exports = dn;
AA.exports.once = zK;
dn.EventEmitter = dn;
dn.prototype._events = void 0;
dn.prototype._eventsCount = 0;
dn.prototype._maxListeners = void 0;
var w8 = 10;
function $g(t3) {
  if (typeof t3 != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t3);
}
Object.defineProperty(dn, "defaultMaxListeners", { enumerable: true, get: function() {
  return w8;
}, set: function(t3) {
  if (typeof t3 != "number" || t3 < 0 || pS(t3)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t3 + ".");
  w8 = t3;
} });
dn.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
dn.prototype.setMaxListeners = function(e) {
  if (typeof e != "number" || e < 0 || pS(e)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
  return this._maxListeners = e, this;
};
function gS(t3) {
  return t3._maxListeners === void 0 ? dn.defaultMaxListeners : t3._maxListeners;
}
dn.prototype.getMaxListeners = function() {
  return gS(this);
};
dn.prototype.emit = function(e) {
  for (var n = [], r = 1; r < arguments.length; r++) n.push(arguments[r]);
  var s = e === "error", i = this._events;
  if (i !== void 0) s = s && i.error === void 0;
  else if (!s) return false;
  if (s) {
    var a;
    if (n.length > 0 && (a = n[0]), a instanceof Error) throw a;
    var o = new Error("Unhandled error." + (a ? " (" + a.message + ")" : ""));
    throw o.context = a, o;
  }
  var f = i[e];
  if (f === void 0) return false;
  if (typeof f == "function") A8(f, this, n);
  else for (var c = f.length, l = AS(f, c), r = 0; r < c; ++r) A8(l[r], this, n);
  return true;
};
function mS(t3, e, n, r) {
  var s, i, a;
  if ($g(n), i = t3._events, i === void 0 ? (i = t3._events = /* @__PURE__ */ Object.create(null), t3._eventsCount = 0) : (i.newListener !== void 0 && (t3.emit("newListener", e, n.listener ? n.listener : n), i = t3._events), a = i[e]), a === void 0) a = i[e] = n, ++t3._eventsCount;
  else if (typeof a == "function" ? a = i[e] = r ? [n, a] : [a, n] : r ? a.unshift(n) : a.push(n), s = gS(t3), s > 0 && a.length > s && !a.warned) {
    a.warned = true;
    var o = new Error("Possible EventEmitter memory leak detected. " + a.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    o.name = "MaxListenersExceededWarning", o.emitter = t3, o.type = e, o.count = a.length, QK(o);
  }
  return t3;
}
dn.prototype.addListener = function(e, n) {
  return mS(this, e, n, false);
};
dn.prototype.on = dn.prototype.addListener;
dn.prototype.prependListener = function(e, n) {
  return mS(this, e, n, true);
};
function KK() {
  if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function vS(t3, e, n) {
  var r = { fired: false, wrapFn: void 0, target: t3, type: e, listener: n }, s = KK.bind(r);
  return s.listener = n, r.wrapFn = s, s;
}
dn.prototype.once = function(e, n) {
  return $g(n), this.on(e, vS(this, e, n)), this;
};
dn.prototype.prependOnceListener = function(e, n) {
  return $g(n), this.prependListener(e, vS(this, e, n)), this;
};
dn.prototype.removeListener = function(e, n) {
  var r, s, i, a, o;
  if ($g(n), s = this._events, s === void 0) return this;
  if (r = s[e], r === void 0) return this;
  if (r === n || r.listener === n) --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete s[e], s.removeListener && this.emit("removeListener", e, r.listener || n));
  else if (typeof r != "function") {
    for (i = -1, a = r.length - 1; a >= 0; a--) if (r[a] === n || r[a].listener === n) {
      o = r[a].listener, i = a;
      break;
    }
    if (i < 0) return this;
    i === 0 ? r.shift() : HK(r, i), r.length === 1 && (s[e] = r[0]), s.removeListener !== void 0 && this.emit("removeListener", e, o || n);
  }
  return this;
};
dn.prototype.off = dn.prototype.removeListener;
dn.prototype.removeAllListeners = function(e) {
  var n, r, s;
  if (r = this._events, r === void 0) return this;
  if (r.removeListener === void 0) return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : r[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete r[e]), this;
  if (arguments.length === 0) {
    var i = Object.keys(r), a;
    for (s = 0; s < i.length; ++s) a = i[s], a !== "removeListener" && this.removeAllListeners(a);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (n = r[e], typeof n == "function") this.removeListener(e, n);
  else if (n !== void 0) for (s = n.length - 1; s >= 0; s--) this.removeListener(e, n[s]);
  return this;
};
function yS(t3, e, n) {
  var r = t3._events;
  if (r === void 0) return [];
  var s = r[e];
  return s === void 0 ? [] : typeof s == "function" ? n ? [s.listener || s] : [s] : n ? qK(s) : AS(s, s.length);
}
dn.prototype.listeners = function(e) {
  return yS(this, e, true);
};
dn.prototype.rawListeners = function(e) {
  return yS(this, e, false);
};
dn.listenerCount = function(t3, e) {
  return typeof t3.listenerCount == "function" ? t3.listenerCount(e) : bS.call(t3, e);
};
dn.prototype.listenerCount = bS;
function bS(t3) {
  var e = this._events;
  if (e !== void 0) {
    var n = e[t3];
    if (typeof n == "function") return 1;
    if (n !== void 0) return n.length;
  }
  return 0;
}
dn.prototype.eventNames = function() {
  return this._eventsCount > 0 ? Fp(this._events) : [];
};
function AS(t3, e) {
  for (var n = new Array(e), r = 0; r < e; ++r) n[r] = t3[r];
  return n;
}
function HK(t3, e) {
  for (; e + 1 < t3.length; e++) t3[e] = t3[e + 1];
  t3.pop();
}
function qK(t3) {
  for (var e = new Array(t3.length), n = 0; n < e.length; ++n) e[n] = t3[n].listener || t3[n];
  return e;
}
function zK(t3, e) {
  return new Promise(function(n, r) {
    function s(a) {
      t3.removeListener(e, i), r(a);
    }
    function i() {
      typeof t3.removeListener == "function" && t3.removeListener("error", s), n([].slice.call(arguments));
    }
    wS(t3, e, i, { once: true }), e !== "error" && GK(t3, s, { once: true });
  });
}
function GK(t3, e, n) {
  typeof t3.on == "function" && wS(t3, "error", e, n);
}
function wS(t3, e, n, r) {
  if (typeof t3.on == "function") r.once ? t3.once(e, n) : t3.on(e, n);
  else if (typeof t3.addEventListener == "function") t3.addEventListener(e, function s(i) {
    r.once && t3.removeEventListener(e, s), n(i);
  });
  else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t3);
}
var od = AA.exports, l2, x8;
function xS() {
  return x8 || (x8 = 1, l2 = od.EventEmitter), l2;
}
var fd = {}, _S = {}, ES = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function") return false;
  if (typeof Symbol.iterator == "symbol") return true;
  var e = {}, n = Symbol("test"), r = Object(n);
  if (typeof n == "string" || Object.prototype.toString.call(n) !== "[object Symbol]" || Object.prototype.toString.call(r) !== "[object Symbol]") return false;
  var s = 42;
  e[n] = s;
  for (var i in e) return false;
  if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0) return false;
  var a = Object.getOwnPropertySymbols(e);
  if (a.length !== 1 || a[0] !== n || !Object.prototype.propertyIsEnumerable.call(e, n)) return false;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var o = Object.getOwnPropertyDescriptor(e, n);
    if (o.value !== s || o.enumerable !== true) return false;
  }
  return true;
}, VK = ES, Tg = function() {
  return VK() && !!Symbol.toStringTag;
}, BS = Object, YK = Error, WK = EvalError, JK = RangeError, ZK = ReferenceError, CS = SyntaxError, Wu = TypeError, jK = URIError, XK = Math.abs, eH = Math.floor, tH = Math.max, rH = Math.min, nH = Math.pow, iH = Math.round, sH = Number.isNaN || function(e) {
  return e !== e;
}, aH = sH, oH = function(e) {
  return aH(e) || e === 0 ? e : e < 0 ? -1 : 1;
}, fH = Object.getOwnPropertyDescriptor, Pp = fH;
if (Pp) try {
  Pp([], "length");
} catch {
  Pp = null;
}
var Ju = Pp, Np = Object.defineProperty || false;
if (Np) try {
  Np({}, "a", { value: 1 });
} catch {
  Np = false;
}
var Dg = Np, u2, _8;
function lH() {
  if (_8) return u2;
  _8 = 1;
  var t3 = typeof Symbol < "u" && Symbol, e = ES;
  return u2 = function() {
    return typeof t3 != "function" || typeof Symbol != "function" || typeof t3("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? false : e();
  }, u2;
}
var kS = typeof Reflect < "u" && Reflect.getPrototypeOf || null, uH = BS, IS = uH.getPrototypeOf || null, cH = "Function.prototype.bind called on incompatible ", hH = Object.prototype.toString, dH = Math.max, pH = "[object Function]", E8 = function(e, n) {
  for (var r = [], s = 0; s < e.length; s += 1) r[s] = e[s];
  for (var i = 0; i < n.length; i += 1) r[i + e.length] = n[i];
  return r;
}, gH = function(e, n) {
  for (var r = [], s = n, i = 0; s < e.length; s += 1, i += 1) r[i] = e[s];
  return r;
}, mH = function(t3, e) {
  for (var n = "", r = 0; r < t3.length; r += 1) n += t3[r], r + 1 < t3.length && (n += e);
  return n;
}, vH = function(e) {
  var n = this;
  if (typeof n != "function" || hH.apply(n) !== pH) throw new TypeError(cH + n);
  for (var r = gH(arguments, 1), s, i = function() {
    if (this instanceof s) {
      var l = n.apply(this, E8(r, arguments));
      return Object(l) === l ? l : this;
    }
    return n.apply(e, E8(r, arguments));
  }, a = dH(0, n.length - r.length), o = [], f = 0; f < a; f++) o[f] = "$" + f;
  if (s = Function("binder", "return function (" + mH(o, ",") + "){ return binder.apply(this,arguments); }")(i), n.prototype) {
    var c = function() {
    };
    c.prototype = n.prototype, s.prototype = new c(), c.prototype = null;
  }
  return s;
}, yH = vH, ld = Function.prototype.bind || yH, wA = Function.prototype.call, xA = Function.prototype.apply, bH = typeof Reflect < "u" && Reflect && Reflect.apply, AH = ld, wH = xA, xH = wA, _H = bH, SS = _H || AH.call(xH, wH), EH = ld, BH = Wu, CH = wA, kH = SS, _A = function(e) {
  if (e.length < 1 || typeof e[0] != "function") throw new BH("a function is required");
  return kH(EH, CH, e);
}, IH = _A, B8 = Ju, MS;
try {
  MS = [].__proto__ === Array.prototype;
} catch (t3) {
  if (!t3 || typeof t3 != "object" || !("code" in t3) || t3.code !== "ERR_PROTO_ACCESS") throw t3;
}
var c2 = !!MS && B8 && B8(Object.prototype, "__proto__"), $S = Object, C8 = $S.getPrototypeOf, SH = c2 && typeof c2.get == "function" ? IH([c2.get]) : typeof C8 == "function" ? function(e) {
  return C8(e == null ? e : $S(e));
} : false, k8 = kS, I8 = IS, S8 = SH, EA = k8 ? function(e) {
  return k8(e);
} : I8 ? function(e) {
  if (!e || typeof e != "object" && typeof e != "function") throw new TypeError("getProto: not an object");
  return I8(e);
} : S8 ? function(e) {
  return S8(e);
} : null, h2, M8;
function TS() {
  if (M8) return h2;
  M8 = 1;
  var t3 = Function.prototype.call, e = Object.prototype.hasOwnProperty, n = ld;
  return h2 = n.call(t3, e), h2;
}
var Or, MH = BS, $H = YK, TH = WK, DH = JK, RH = ZK, Cu = CS, hu = Wu, FH = jK, PH = XK, NH = eH, UH = tH, LH = rH, OH = nH, QH = iH, KH = oH, DS = Function, d2 = function(t3) {
  try {
    return DS('"use strict"; return (' + t3 + ").constructor;")();
  } catch {
  }
}, Dh = Ju, HH = Dg, p2 = function() {
  throw new hu();
}, qH = Dh ? function() {
  try {
    return arguments.callee, p2;
  } catch {
    try {
      return Dh(arguments, "callee").get;
    } catch {
      return p2;
    }
  }
}() : p2, N0 = lH()(), vi = EA, zH = IS, GH = kS, RS = xA, ud = wA, H0 = {}, VH = typeof Uint8Array > "u" || !vi ? Or : vi(Uint8Array), Xl = { __proto__: null, "%AggregateError%": typeof AggregateError > "u" ? Or : AggregateError, "%Array%": Array, "%ArrayBuffer%": typeof ArrayBuffer > "u" ? Or : ArrayBuffer, "%ArrayIteratorPrototype%": N0 && vi ? vi([][Symbol.iterator]()) : Or, "%AsyncFromSyncIteratorPrototype%": Or, "%AsyncFunction%": H0, "%AsyncGenerator%": H0, "%AsyncGeneratorFunction%": H0, "%AsyncIteratorPrototype%": H0, "%Atomics%": typeof Atomics > "u" ? Or : Atomics, "%BigInt%": typeof BigInt > "u" ? Or : BigInt, "%BigInt64Array%": typeof BigInt64Array > "u" ? Or : BigInt64Array, "%BigUint64Array%": typeof BigUint64Array > "u" ? Or : BigUint64Array, "%Boolean%": Boolean, "%DataView%": typeof DataView > "u" ? Or : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": $H, "%eval%": eval, "%EvalError%": TH, "%Float16Array%": typeof Float16Array > "u" ? Or : Float16Array, "%Float32Array%": typeof Float32Array > "u" ? Or : Float32Array, "%Float64Array%": typeof Float64Array > "u" ? Or : Float64Array, "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? Or : FinalizationRegistry, "%Function%": DS, "%GeneratorFunction%": H0, "%Int8Array%": typeof Int8Array > "u" ? Or : Int8Array, "%Int16Array%": typeof Int16Array > "u" ? Or : Int16Array, "%Int32Array%": typeof Int32Array > "u" ? Or : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": N0 && vi ? vi(vi([][Symbol.iterator]())) : Or, "%JSON%": typeof JSON == "object" ? JSON : Or, "%Map%": typeof Map > "u" ? Or : Map, "%MapIteratorPrototype%": typeof Map > "u" || !N0 || !vi ? Or : vi((/* @__PURE__ */ new Map())[Symbol.iterator]()), "%Math%": Math, "%Number%": Number, "%Object%": MH, "%Object.getOwnPropertyDescriptor%": Dh, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": typeof Promise > "u" ? Or : Promise, "%Proxy%": typeof Proxy > "u" ? Or : Proxy, "%RangeError%": DH, "%ReferenceError%": RH, "%Reflect%": typeof Reflect > "u" ? Or : Reflect, "%RegExp%": RegExp, "%Set%": typeof Set > "u" ? Or : Set, "%SetIteratorPrototype%": typeof Set > "u" || !N0 || !vi ? Or : vi((/* @__PURE__ */ new Set())[Symbol.iterator]()), "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? Or : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": N0 && vi ? vi(""[Symbol.iterator]()) : Or, "%Symbol%": N0 ? Symbol : Or, "%SyntaxError%": Cu, "%ThrowTypeError%": qH, "%TypedArray%": VH, "%TypeError%": hu, "%Uint8Array%": typeof Uint8Array > "u" ? Or : Uint8Array, "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? Or : Uint8ClampedArray, "%Uint16Array%": typeof Uint16Array > "u" ? Or : Uint16Array, "%Uint32Array%": typeof Uint32Array > "u" ? Or : Uint32Array, "%URIError%": FH, "%WeakMap%": typeof WeakMap > "u" ? Or : WeakMap, "%WeakRef%": typeof WeakRef > "u" ? Or : WeakRef, "%WeakSet%": typeof WeakSet > "u" ? Or : WeakSet, "%Function.prototype.call%": ud, "%Function.prototype.apply%": RS, "%Object.defineProperty%": HH, "%Object.getPrototypeOf%": zH, "%Math.abs%": PH, "%Math.floor%": NH, "%Math.max%": UH, "%Math.min%": LH, "%Math.pow%": OH, "%Math.round%": QH, "%Math.sign%": KH, "%Reflect.getPrototypeOf%": GH };
if (vi) try {
  null.error;
} catch (t3) {
  var YH = vi(vi(t3));
  Xl["%Error.prototype%"] = YH;
}
var WH = function t(e) {
  var n;
  if (e === "%AsyncFunction%") n = d2("async function () {}");
  else if (e === "%GeneratorFunction%") n = d2("function* () {}");
  else if (e === "%AsyncGeneratorFunction%") n = d2("async function* () {}");
  else if (e === "%AsyncGenerator%") {
    var r = t("%AsyncGeneratorFunction%");
    r && (n = r.prototype);
  } else if (e === "%AsyncIteratorPrototype%") {
    var s = t("%AsyncGenerator%");
    s && vi && (n = vi(s.prototype));
  }
  return Xl[e] = n, n;
}, $8 = { __proto__: null, "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, cd = ld, x1 = TS(), JH = cd.call(ud, Array.prototype.concat), ZH = cd.call(RS, Array.prototype.splice), T8 = cd.call(ud, String.prototype.replace), _1 = cd.call(ud, String.prototype.slice), jH = cd.call(ud, RegExp.prototype.exec), XH = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, eq = /\\(\\)?/g, tq = function(e) {
  var n = _1(e, 0, 1), r = _1(e, -1);
  if (n === "%" && r !== "%") throw new Cu("invalid intrinsic syntax, expected closing `%`");
  if (r === "%" && n !== "%") throw new Cu("invalid intrinsic syntax, expected opening `%`");
  var s = [];
  return T8(e, XH, function(i, a, o, f) {
    s[s.length] = o ? T8(f, eq, "$1") : a || i;
  }), s;
}, rq = function(e, n) {
  var r = e, s;
  if (x1($8, r) && (s = $8[r], r = "%" + s[0] + "%"), x1(Xl, r)) {
    var i = Xl[r];
    if (i === H0 && (i = WH(r)), typeof i > "u" && !n) throw new hu("intrinsic " + e + " exists, but is not available. Please file an issue!");
    return { alias: s, name: r, value: i };
  }
  throw new Cu("intrinsic " + e + " does not exist!");
}, FS = function(e, n) {
  if (typeof e != "string" || e.length === 0) throw new hu("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof n != "boolean") throw new hu('"allowMissing" argument must be a boolean');
  if (jH(/^%?[^%]*%?$/, e) === null) throw new Cu("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var r = tq(e), s = r.length > 0 ? r[0] : "", i = rq("%" + s + "%", n), a = i.name, o = i.value, f = false, c = i.alias;
  c && (s = c[0], ZH(r, JH([0, 1], c)));
  for (var l = 1, h = true; l < r.length; l += 1) {
    var m = r[l], v = _1(m, 0, 1), b = _1(m, -1);
    if ((v === '"' || v === "'" || v === "`" || b === '"' || b === "'" || b === "`") && v !== b) throw new Cu("property names with quotes must have matching quotes");
    if ((m === "constructor" || !h) && (f = true), s += "." + m, a = "%" + s + "%", x1(Xl, a)) o = Xl[a];
    else if (o != null) {
      if (!(m in o)) {
        if (!n) throw new hu("base intrinsic for " + e + " exists, but the property is not available.");
        return;
      }
      if (Dh && l + 1 >= r.length) {
        var A = Dh(o, m);
        h = !!A, h && "get" in A && !("originalValue" in A.get) ? o = A.get : o = o[m];
      } else h = x1(o, m), o = o[m];
      h && !f && (Xl[a] = o);
    }
  }
  return o;
}, PS = FS, NS = _A, nq = NS([PS("%String.prototype.indexOf%")]), Zu = function(e, n) {
  var r = PS(e, !!n);
  return typeof r == "function" && nq(e, ".prototype.") > -1 ? NS([r]) : r;
}, iq = Tg(), sq = Zu, I3 = sq("Object.prototype.toString"), Rg = function(e) {
  return iq && e && typeof e == "object" && Symbol.toStringTag in e ? false : I3(e) === "[object Arguments]";
}, US = function(e) {
  return Rg(e) ? true : e !== null && typeof e == "object" && "length" in e && typeof e.length == "number" && e.length >= 0 && I3(e) !== "[object Array]" && "callee" in e && I3(e.callee) === "[object Function]";
}, aq = function() {
  return Rg(arguments);
}();
Rg.isLegacyArguments = US;
var oq = aq ? Rg : US, D8 = Zu, fq = Tg(), lq = TS(), uq = Ju, S3;
if (fq) {
  var cq = D8("RegExp.prototype.exec"), R8 = {}, g2 = function() {
    throw R8;
  }, F8 = { toString: g2, valueOf: g2 };
  typeof Symbol.toPrimitive == "symbol" && (F8[Symbol.toPrimitive] = g2), S3 = function(e) {
    if (!e || typeof e != "object") return false;
    var n = uq(e, "lastIndex"), r = n && lq(n, "value");
    if (!r) return false;
    try {
      cq(e, F8);
    } catch (s) {
      return s === R8;
    }
  };
} else {
  var hq = D8("Object.prototype.toString"), dq = "[object RegExp]";
  S3 = function(e) {
    return !e || typeof e != "object" && typeof e != "function" ? false : hq(e) === dq;
  };
}
var pq = S3, gq = Zu, mq = pq, vq = gq("RegExp.prototype.exec"), yq = Wu, bq = function(e) {
  if (!mq(e)) throw new yq("`regex` must be a RegExp");
  return function(r) {
    return vq(e, r) !== null;
  };
}, m2, P8;
function Aq() {
  if (P8) return m2;
  P8 = 1;
  const t3 = (function* () {
  }).constructor;
  return m2 = () => t3, m2;
}
var LS = Zu, wq = bq, xq = wq(/^\s*(?:function)?\*/), _q = Tg(), N8 = EA, Eq = LS("Object.prototype.toString"), Bq = LS("Function.prototype.toString"), Cq = Aq(), kq = function(e) {
  if (typeof e != "function") return false;
  if (xq(Bq(e))) return true;
  if (!_q) {
    var n = Eq(e);
    return n === "[object GeneratorFunction]";
  }
  if (!N8) return false;
  var r = Cq();
  return r && N8(e) === r.prototype;
}, OS = Function.prototype.toString, tu = typeof Reflect == "object" && Reflect !== null && Reflect.apply, M3, Up;
if (typeof tu == "function" && typeof Object.defineProperty == "function") try {
  M3 = Object.defineProperty({}, "length", { get: function() {
    throw Up;
  } }), Up = {}, tu(function() {
    throw 42;
  }, null, M3);
} catch (t3) {
  t3 !== Up && (tu = null);
}
else tu = null;
var Iq = /^\s*class\b/, $3 = function(e) {
  try {
    var n = OS.call(e);
    return Iq.test(n);
  } catch {
    return false;
  }
}, v2 = function(e) {
  try {
    return $3(e) ? false : (OS.call(e), true);
  } catch {
    return false;
  }
}, Lp = Object.prototype.toString, Sq = "[object Object]", Mq = "[object Function]", $q = "[object GeneratorFunction]", Tq = "[object HTMLAllCollection]", Dq = "[object HTML document.all class]", Rq = "[object HTMLCollection]", Fq = typeof Symbol == "function" && !!Symbol.toStringTag, Pq = !(0 in [,]), T3 = function() {
  return false;
};
if (typeof document == "object") {
  var Nq = document.all;
  Lp.call(Nq) === Lp.call(document.all) && (T3 = function(e) {
    if ((Pq || !e) && (typeof e > "u" || typeof e == "object")) try {
      var n = Lp.call(e);
      return (n === Tq || n === Dq || n === Rq || n === Sq) && e("") == null;
    } catch {
    }
    return false;
  });
}
var Uq = tu ? function(e) {
  if (T3(e)) return true;
  if (!e || typeof e != "function" && typeof e != "object") return false;
  try {
    tu(e, null, M3);
  } catch (n) {
    if (n !== Up) return false;
  }
  return !$3(e) && v2(e);
} : function(e) {
  if (T3(e)) return true;
  if (!e || typeof e != "function" && typeof e != "object") return false;
  if (Fq) return v2(e);
  if ($3(e)) return false;
  var n = Lp.call(e);
  return n !== Mq && n !== $q && !/^\[object HTML/.test(n) ? false : v2(e);
}, Lq = Uq, Oq = Object.prototype.toString, QS = Object.prototype.hasOwnProperty, Qq = function(e, n, r) {
  for (var s = 0, i = e.length; s < i; s++) QS.call(e, s) && (r == null ? n(e[s], s, e) : n.call(r, e[s], s, e));
}, Kq = function(e, n, r) {
  for (var s = 0, i = e.length; s < i; s++) r == null ? n(e.charAt(s), s, e) : n.call(r, e.charAt(s), s, e);
}, Hq = function(e, n, r) {
  for (var s in e) QS.call(e, s) && (r == null ? n(e[s], s, e) : n.call(r, e[s], s, e));
};
function qq(t3) {
  return Oq.call(t3) === "[object Array]";
}
var zq = function(e, n, r) {
  if (!Lq(n)) throw new TypeError("iterator must be a function");
  var s;
  arguments.length >= 3 && (s = r), qq(e) ? Qq(e, n, s) : typeof e == "string" ? Kq(e, n, s) : Hq(e, n, s);
}, Gq = ["Float16Array", "Float32Array", "Float64Array", "Int8Array", "Int16Array", "Int32Array", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "BigInt64Array", "BigUint64Array"], y2 = Gq, Vq = typeof globalThis > "u" ? mt : globalThis, Yq = function() {
  for (var e = [], n = 0; n < y2.length; n++) typeof Vq[y2[n]] == "function" && (e[e.length] = y2[n]);
  return e;
}, KS = { exports: {} }, U8 = Dg, Wq = CS, U0 = Wu, L8 = Ju, Jq = function(e, n, r) {
  if (!e || typeof e != "object" && typeof e != "function") throw new U0("`obj` must be an object or a function`");
  if (typeof n != "string" && typeof n != "symbol") throw new U0("`property` must be a string or a symbol`");
  if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null) throw new U0("`nonEnumerable`, if provided, must be a boolean or null");
  if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null) throw new U0("`nonWritable`, if provided, must be a boolean or null");
  if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null) throw new U0("`nonConfigurable`, if provided, must be a boolean or null");
  if (arguments.length > 6 && typeof arguments[6] != "boolean") throw new U0("`loose`, if provided, must be a boolean");
  var s = arguments.length > 3 ? arguments[3] : null, i = arguments.length > 4 ? arguments[4] : null, a = arguments.length > 5 ? arguments[5] : null, o = arguments.length > 6 ? arguments[6] : false, f = !!L8 && L8(e, n);
  if (U8) U8(e, n, { configurable: a === null && f ? f.configurable : !a, enumerable: s === null && f ? f.enumerable : !s, value: r, writable: i === null && f ? f.writable : !i });
  else if (o || !s && !i && !a) e[n] = r;
  else throw new Wq("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
}, D3 = Dg, HS = function() {
  return !!D3;
};
HS.hasArrayLengthDefineBug = function() {
  if (!D3) return null;
  try {
    return D3([], "length", { value: 1 }).length !== 1;
  } catch {
    return true;
  }
};
var Zq = HS, jq = FS, O8 = Jq, Xq = Zq(), Q8 = Ju, K8 = Wu, ez = jq("%Math.floor%"), tz = function(e, n) {
  if (typeof e != "function") throw new K8("`fn` is not a function");
  if (typeof n != "number" || n < 0 || n > 4294967295 || ez(n) !== n) throw new K8("`length` must be a positive 32-bit integer");
  var r = arguments.length > 2 && !!arguments[2], s = true, i = true;
  if ("length" in e && Q8) {
    var a = Q8(e, "length");
    a && !a.configurable && (s = false), a && !a.writable && (i = false);
  }
  return (s || i || !r) && (Xq ? O8(e, "length", n, true, true) : O8(e, "length", n)), e;
}, rz = ld, nz = xA, iz = SS, sz = function() {
  return iz(rz, nz, arguments);
};
(function(t3) {
  var e = tz, n = Dg, r = _A, s = sz;
  t3.exports = function(a) {
    var o = r(arguments), f = a.length - (arguments.length - 1);
    return e(o, 1 + (f > 0 ? f : 0), true);
  }, n ? n(t3.exports, "apply", { value: s }) : t3.exports.apply = s;
})(KS);
var az = KS.exports, E1 = zq, oz = Yq, H8 = az, BA = Zu, Op = Ju, Jd = EA, fz = BA("Object.prototype.toString"), qS = Tg(), q8 = typeof globalThis > "u" ? mt : globalThis, R3 = oz(), CA = BA("String.prototype.slice"), lz = BA("Array.prototype.indexOf", true) || function(e, n) {
  for (var r = 0; r < e.length; r += 1) if (e[r] === n) return r;
  return -1;
}, B1 = { __proto__: null };
qS && Op && Jd ? E1(R3, function(t3) {
  var e = new q8[t3]();
  if (Symbol.toStringTag in e && Jd) {
    var n = Jd(e), r = Op(n, Symbol.toStringTag);
    if (!r && n) {
      var s = Jd(n);
      r = Op(s, Symbol.toStringTag);
    }
    if (r && r.get) {
      var i = H8(r.get);
      B1["$" + t3] = i;
    }
  }
}) : E1(R3, function(t3) {
  var e = new q8[t3](), n = e.slice || e.set;
  if (n) {
    var r = H8(n);
    B1["$" + t3] = r;
  }
});
var uz = function(e) {
  var n = false;
  return E1(B1, function(r, s) {
    if (!n) try {
      "$" + r(e) === s && (n = CA(s, 1));
    } catch {
    }
  }), n;
}, cz = function(e) {
  var n = false;
  return E1(B1, function(r, s) {
    if (!n) try {
      r(e), n = CA(s, 1);
    } catch {
    }
  }), n;
}, zS = function(e) {
  if (!e || typeof e != "object") return false;
  if (!qS) {
    var n = CA(fz(e), 8, -1);
    return lz(R3, n) > -1 ? n : n !== "Object" ? false : cz(e);
  }
  return Op ? uz(e) : null;
}, b2, z8;
function GS() {
  if (z8) return b2;
  z8 = 1;
  var t3 = zS;
  return b2 = function(n) {
    return !!t3(n);
  }, b2;
}
(function(t3) {
  var e = oq, n = kq, r = zS, s = GS();
  function i(ye) {
    return ye.call.bind(ye);
  }
  var a = typeof BigInt < "u", o = typeof Symbol < "u", f = i(Object.prototype.toString), c = i(Number.prototype.valueOf), l = i(String.prototype.valueOf), h = i(Boolean.prototype.valueOf);
  if (a) var m = i(BigInt.prototype.valueOf);
  if (o) var v = i(Symbol.prototype.valueOf);
  function b(ye, Oe) {
    if (typeof ye != "object") return false;
    try {
      return Oe(ye), true;
    } catch {
      return false;
    }
  }
  t3.isArgumentsObject = e, t3.isGeneratorFunction = n, t3.isTypedArray = s;
  function A(ye) {
    return typeof Promise < "u" && ye instanceof Promise || ye !== null && typeof ye == "object" && typeof ye.then == "function" && typeof ye.catch == "function";
  }
  t3.isPromise = A;
  function _(ye) {
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(ye) : s(ye) || O(ye);
  }
  t3.isArrayBufferView = _;
  function C(ye) {
    return r(ye) === "Uint8Array";
  }
  t3.isUint8Array = C;
  function I(ye) {
    return r(ye) === "Uint8ClampedArray";
  }
  t3.isUint8ClampedArray = I;
  function S(ye) {
    return r(ye) === "Uint16Array";
  }
  t3.isUint16Array = S;
  function $(ye) {
    return r(ye) === "Uint32Array";
  }
  t3.isUint32Array = $;
  function F(ye) {
    return r(ye) === "Int8Array";
  }
  t3.isInt8Array = F;
  function U(ye) {
    return r(ye) === "Int16Array";
  }
  t3.isInt16Array = U;
  function Q(ye) {
    return r(ye) === "Int32Array";
  }
  t3.isInt32Array = Q;
  function P(ye) {
    return r(ye) === "Float32Array";
  }
  t3.isFloat32Array = P;
  function N(ye) {
    return r(ye) === "Float64Array";
  }
  t3.isFloat64Array = N;
  function L(ye) {
    return r(ye) === "BigInt64Array";
  }
  t3.isBigInt64Array = L;
  function B(ye) {
    return r(ye) === "BigUint64Array";
  }
  t3.isBigUint64Array = B;
  function u(ye) {
    return f(ye) === "[object Map]";
  }
  u.working = typeof Map < "u" && u(/* @__PURE__ */ new Map());
  function p(ye) {
    return typeof Map > "u" ? false : u.working ? u(ye) : ye instanceof Map;
  }
  t3.isMap = p;
  function d(ye) {
    return f(ye) === "[object Set]";
  }
  d.working = typeof Set < "u" && d(/* @__PURE__ */ new Set());
  function y(ye) {
    return typeof Set > "u" ? false : d.working ? d(ye) : ye instanceof Set;
  }
  t3.isSet = y;
  function w(ye) {
    return f(ye) === "[object WeakMap]";
  }
  w.working = typeof WeakMap < "u" && w(/* @__PURE__ */ new WeakMap());
  function E(ye) {
    return typeof WeakMap > "u" ? false : w.working ? w(ye) : ye instanceof WeakMap;
  }
  t3.isWeakMap = E;
  function M(ye) {
    return f(ye) === "[object WeakSet]";
  }
  M.working = typeof WeakSet < "u" && M(/* @__PURE__ */ new WeakSet());
  function x(ye) {
    return M(ye);
  }
  t3.isWeakSet = x;
  function g(ye) {
    return f(ye) === "[object ArrayBuffer]";
  }
  g.working = typeof ArrayBuffer < "u" && g(new ArrayBuffer());
  function k(ye) {
    return typeof ArrayBuffer > "u" ? false : g.working ? g(ye) : ye instanceof ArrayBuffer;
  }
  t3.isArrayBuffer = k;
  function T(ye) {
    return f(ye) === "[object DataView]";
  }
  T.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && T(new DataView(new ArrayBuffer(1), 0, 1));
  function O(ye) {
    return typeof DataView > "u" ? false : T.working ? T(ye) : ye instanceof DataView;
  }
  t3.isDataView = O;
  var K = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
  function Y(ye) {
    return f(ye) === "[object SharedArrayBuffer]";
  }
  function J(ye) {
    return typeof K > "u" ? false : (typeof Y.working > "u" && (Y.working = Y(new K())), Y.working ? Y(ye) : ye instanceof K);
  }
  t3.isSharedArrayBuffer = J;
  function G(ye) {
    return f(ye) === "[object AsyncFunction]";
  }
  t3.isAsyncFunction = G;
  function X(ye) {
    return f(ye) === "[object Map Iterator]";
  }
  t3.isMapIterator = X;
  function ie(ye) {
    return f(ye) === "[object Set Iterator]";
  }
  t3.isSetIterator = ie;
  function de(ye) {
    return f(ye) === "[object Generator]";
  }
  t3.isGeneratorObject = de;
  function se(ye) {
    return f(ye) === "[object WebAssembly.Module]";
  }
  t3.isWebAssemblyCompiledModule = se;
  function te(ye) {
    return b(ye, c);
  }
  t3.isNumberObject = te;
  function le(ye) {
    return b(ye, l);
  }
  t3.isStringObject = le;
  function Z(ye) {
    return b(ye, h);
  }
  t3.isBooleanObject = Z;
  function ve(ye) {
    return a && b(ye, m);
  }
  t3.isBigIntObject = ve;
  function he(ye) {
    return o && b(ye, v);
  }
  t3.isSymbolObject = he;
  function me(ye) {
    return te(ye) || le(ye) || Z(ye) || ve(ye) || he(ye);
  }
  t3.isBoxedPrimitive = me;
  function ce(ye) {
    return typeof Uint8Array < "u" && (k(ye) || J(ye));
  }
  t3.isAnyArrayBuffer = ce, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(ye) {
    Object.defineProperty(t3, ye, { enumerable: false, value: function() {
      throw new Error(ye + " is not supported in userland");
    } });
  });
})(_S);
var hz = function(e) {
  return e && typeof e == "object" && typeof e.copy == "function" && typeof e.fill == "function" && typeof e.readUInt8 == "function";
};
(function(t3) {
  var e = {}, n = Object.getOwnPropertyDescriptors || function(K) {
    for (var Y = Object.keys(K), J = {}, G = 0; G < Y.length; G++) J[Y[G]] = Object.getOwnPropertyDescriptor(K, Y[G]);
    return J;
  }, r = /%[sdj%]/g;
  t3.format = function(O) {
    if (!U(O)) {
      for (var K = [], Y = 0; Y < arguments.length; Y++) K.push(o(arguments[Y]));
      return K.join(" ");
    }
    for (var Y = 1, J = arguments, G = J.length, X = String(O).replace(r, function(de) {
      if (de === "%%") return "%";
      if (Y >= G) return de;
      switch (de) {
        case "%s":
          return String(J[Y++]);
        case "%d":
          return Number(J[Y++]);
        case "%j":
          try {
            return JSON.stringify(J[Y++]);
          } catch {
            return "[Circular]";
          }
        default:
          return de;
      }
    }), ie = J[Y]; Y < G; ie = J[++Y]) S(ie) || !L(ie) ? X += " " + ie : X += " " + o(ie);
    return X;
  }, t3.deprecate = function(O, K) {
    if (typeof jt < "u" && jt.noDeprecation === true) return O;
    if (typeof jt > "u") return function() {
      return t3.deprecate(O, K).apply(this, arguments);
    };
    var Y = false;
    function J() {
      if (!Y) {
        if (jt.throwDeprecation) throw new Error(K);
        jt.traceDeprecation ? console.trace(K) : console.error(K), Y = true;
      }
      return O.apply(this, arguments);
    }
    return J;
  };
  var s = {}, i = /^$/;
  if (e.NODE_DEBUG) {
    var a = e.NODE_DEBUG;
    a = a.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), i = new RegExp("^" + a + "$", "i");
  }
  t3.debuglog = function(O) {
    if (O = O.toUpperCase(), !s[O]) if (i.test(O)) {
      var K = jt.pid;
      s[O] = function() {
        var Y = t3.format.apply(t3, arguments);
        console.error("%s %d: %s", O, K, Y);
      };
    } else s[O] = function() {
    };
    return s[O];
  };
  function o(O, K) {
    var Y = { seen: [], stylize: c };
    return arguments.length >= 3 && (Y.depth = arguments[2]), arguments.length >= 4 && (Y.colors = arguments[3]), I(K) ? Y.showHidden = K : K && t3._extend(Y, K), P(Y.showHidden) && (Y.showHidden = false), P(Y.depth) && (Y.depth = 2), P(Y.colors) && (Y.colors = false), P(Y.customInspect) && (Y.customInspect = true), Y.colors && (Y.stylize = f), h(Y, O, Y.depth);
  }
  t3.inspect = o, o.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, o.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" };
  function f(O, K) {
    var Y = o.styles[K];
    return Y ? "\x1B[" + o.colors[Y][0] + "m" + O + "\x1B[" + o.colors[Y][1] + "m" : O;
  }
  function c(O, K) {
    return O;
  }
  function l(O) {
    var K = {};
    return O.forEach(function(Y, J) {
      K[Y] = true;
    }), K;
  }
  function h(O, K, Y) {
    if (O.customInspect && K && p(K.inspect) && K.inspect !== t3.inspect && !(K.constructor && K.constructor.prototype === K)) {
      var J = K.inspect(Y, O);
      return U(J) || (J = h(O, J, Y)), J;
    }
    var G = m(O, K);
    if (G) return G;
    var X = Object.keys(K), ie = l(X);
    if (O.showHidden && (X = Object.getOwnPropertyNames(K)), u(K) && (X.indexOf("message") >= 0 || X.indexOf("description") >= 0)) return v(K);
    if (X.length === 0) {
      if (p(K)) {
        var de = K.name ? ": " + K.name : "";
        return O.stylize("[Function" + de + "]", "special");
      }
      if (N(K)) return O.stylize(RegExp.prototype.toString.call(K), "regexp");
      if (B(K)) return O.stylize(Date.prototype.toString.call(K), "date");
      if (u(K)) return v(K);
    }
    var se = "", te = false, le = ["{", "}"];
    if (C(K) && (te = true, le = ["[", "]"]), p(K)) {
      var Z = K.name ? ": " + K.name : "";
      se = " [Function" + Z + "]";
    }
    if (N(K) && (se = " " + RegExp.prototype.toString.call(K)), B(K) && (se = " " + Date.prototype.toUTCString.call(K)), u(K) && (se = " " + v(K)), X.length === 0 && (!te || K.length == 0)) return le[0] + se + le[1];
    if (Y < 0) return N(K) ? O.stylize(RegExp.prototype.toString.call(K), "regexp") : O.stylize("[Object]", "special");
    O.seen.push(K);
    var ve;
    return te ? ve = b(O, K, Y, ie, X) : ve = X.map(function(he) {
      return A(O, K, Y, ie, he, te);
    }), O.seen.pop(), _(ve, se, le);
  }
  function m(O, K) {
    if (P(K)) return O.stylize("undefined", "undefined");
    if (U(K)) {
      var Y = "'" + JSON.stringify(K).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return O.stylize(Y, "string");
    }
    if (F(K)) return O.stylize("" + K, "number");
    if (I(K)) return O.stylize("" + K, "boolean");
    if (S(K)) return O.stylize("null", "null");
  }
  function v(O) {
    return "[" + Error.prototype.toString.call(O) + "]";
  }
  function b(O, K, Y, J, G) {
    for (var X = [], ie = 0, de = K.length; ie < de; ++ie) x(K, String(ie)) ? X.push(A(O, K, Y, J, String(ie), true)) : X.push("");
    return G.forEach(function(se) {
      se.match(/^\d+$/) || X.push(A(O, K, Y, J, se, true));
    }), X;
  }
  function A(O, K, Y, J, G, X) {
    var ie, de, se;
    if (se = Object.getOwnPropertyDescriptor(K, G) || { value: K[G] }, se.get ? se.set ? de = O.stylize("[Getter/Setter]", "special") : de = O.stylize("[Getter]", "special") : se.set && (de = O.stylize("[Setter]", "special")), x(J, G) || (ie = "[" + G + "]"), de || (O.seen.indexOf(se.value) < 0 ? (S(Y) ? de = h(O, se.value, null) : de = h(O, se.value, Y - 1), de.indexOf(`
`) > -1 && (X ? de = de.split(`
`).map(function(te) {
      return "  " + te;
    }).join(`
`).slice(2) : de = `
` + de.split(`
`).map(function(te) {
      return "   " + te;
    }).join(`
`))) : de = O.stylize("[Circular]", "special")), P(ie)) {
      if (X && G.match(/^\d+$/)) return de;
      ie = JSON.stringify("" + G), ie.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (ie = ie.slice(1, -1), ie = O.stylize(ie, "name")) : (ie = ie.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), ie = O.stylize(ie, "string"));
    }
    return ie + ": " + de;
  }
  function _(O, K, Y) {
    var J = O.reduce(function(G, X) {
      return X.indexOf(`
`) >= 0, G + X.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return J > 60 ? Y[0] + (K === "" ? "" : K + `
 `) + " " + O.join(`,
  `) + " " + Y[1] : Y[0] + K + " " + O.join(", ") + " " + Y[1];
  }
  t3.types = _S;
  function C(O) {
    return Array.isArray(O);
  }
  t3.isArray = C;
  function I(O) {
    return typeof O == "boolean";
  }
  t3.isBoolean = I;
  function S(O) {
    return O === null;
  }
  t3.isNull = S;
  function $(O) {
    return O == null;
  }
  t3.isNullOrUndefined = $;
  function F(O) {
    return typeof O == "number";
  }
  t3.isNumber = F;
  function U(O) {
    return typeof O == "string";
  }
  t3.isString = U;
  function Q(O) {
    return typeof O == "symbol";
  }
  t3.isSymbol = Q;
  function P(O) {
    return O === void 0;
  }
  t3.isUndefined = P;
  function N(O) {
    return L(O) && y(O) === "[object RegExp]";
  }
  t3.isRegExp = N, t3.types.isRegExp = N;
  function L(O) {
    return typeof O == "object" && O !== null;
  }
  t3.isObject = L;
  function B(O) {
    return L(O) && y(O) === "[object Date]";
  }
  t3.isDate = B, t3.types.isDate = B;
  function u(O) {
    return L(O) && (y(O) === "[object Error]" || O instanceof Error);
  }
  t3.isError = u, t3.types.isNativeError = u;
  function p(O) {
    return typeof O == "function";
  }
  t3.isFunction = p;
  function d(O) {
    return O === null || typeof O == "boolean" || typeof O == "number" || typeof O == "string" || typeof O == "symbol" || typeof O > "u";
  }
  t3.isPrimitive = d, t3.isBuffer = hz;
  function y(O) {
    return Object.prototype.toString.call(O);
  }
  function w(O) {
    return O < 10 ? "0" + O.toString(10) : O.toString(10);
  }
  var E = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  function M() {
    var O = /* @__PURE__ */ new Date(), K = [w(O.getHours()), w(O.getMinutes()), w(O.getSeconds())].join(":");
    return [O.getDate(), E[O.getMonth()], K].join(" ");
  }
  t3.log = function() {
    console.log("%s - %s", M(), t3.format.apply(t3, arguments));
  }, t3.inherits = wr, t3._extend = function(O, K) {
    if (!K || !L(K)) return O;
    for (var Y = Object.keys(K), J = Y.length; J--; ) O[Y[J]] = K[Y[J]];
    return O;
  };
  function x(O, K) {
    return Object.prototype.hasOwnProperty.call(O, K);
  }
  var g = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
  t3.promisify = function(K) {
    if (typeof K != "function") throw new TypeError('The "original" argument must be of type Function');
    if (g && K[g]) {
      var Y = K[g];
      if (typeof Y != "function") throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(Y, g, { value: Y, enumerable: false, writable: false, configurable: true }), Y;
    }
    function Y() {
      for (var J, G, X = new Promise(function(se, te) {
        J = se, G = te;
      }), ie = [], de = 0; de < arguments.length; de++) ie.push(arguments[de]);
      ie.push(function(se, te) {
        se ? G(se) : J(te);
      });
      try {
        K.apply(this, ie);
      } catch (se) {
        G(se);
      }
      return X;
    }
    return Object.setPrototypeOf(Y, Object.getPrototypeOf(K)), g && Object.defineProperty(Y, g, { value: Y, enumerable: false, writable: false, configurable: true }), Object.defineProperties(Y, n(K));
  }, t3.promisify.custom = g;
  function k(O, K) {
    if (!O) {
      var Y = new Error("Promise was rejected with a falsy value");
      Y.reason = O, O = Y;
    }
    return K(O);
  }
  function T(O) {
    if (typeof O != "function") throw new TypeError('The "original" argument must be of type Function');
    function K() {
      for (var Y = [], J = 0; J < arguments.length; J++) Y.push(arguments[J]);
      var G = Y.pop();
      if (typeof G != "function") throw new TypeError("The last argument must be of type Function");
      var X = this, ie = function() {
        return G.apply(X, arguments);
      };
      O.apply(this, Y).then(function(de) {
        jt.nextTick(ie.bind(null, null, de));
      }, function(de) {
        jt.nextTick(k.bind(null, de, ie));
      });
    }
    return Object.setPrototypeOf(K, Object.getPrototypeOf(O)), Object.defineProperties(K, n(O)), K;
  }
  t3.callbackify = T;
})(fd);
var A2, G8;
function dz() {
  if (G8) return A2;
  G8 = 1;
  function t3(b, A) {
    var _ = Object.keys(b);
    if (Object.getOwnPropertySymbols) {
      var C = Object.getOwnPropertySymbols(b);
      A && (C = C.filter(function(I) {
        return Object.getOwnPropertyDescriptor(b, I).enumerable;
      })), _.push.apply(_, C);
    }
    return _;
  }
  function e(b) {
    for (var A = 1; A < arguments.length; A++) {
      var _ = arguments[A] != null ? arguments[A] : {};
      A % 2 ? t3(Object(_), true).forEach(function(C) {
        n(b, C, _[C]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(b, Object.getOwnPropertyDescriptors(_)) : t3(Object(_)).forEach(function(C) {
        Object.defineProperty(b, C, Object.getOwnPropertyDescriptor(_, C));
      });
    }
    return b;
  }
  function n(b, A, _) {
    return A = a(A), A in b ? Object.defineProperty(b, A, { value: _, enumerable: true, configurable: true, writable: true }) : b[A] = _, b;
  }
  function r(b, A) {
    if (!(b instanceof A)) throw new TypeError("Cannot call a class as a function");
  }
  function s(b, A) {
    for (var _ = 0; _ < A.length; _++) {
      var C = A[_];
      C.enumerable = C.enumerable || false, C.configurable = true, "value" in C && (C.writable = true), Object.defineProperty(b, a(C.key), C);
    }
  }
  function i(b, A, _) {
    return A && s(b.prototype, A), Object.defineProperty(b, "prototype", { writable: false }), b;
  }
  function a(b) {
    var A = o(b, "string");
    return typeof A == "symbol" ? A : String(A);
  }
  function o(b, A) {
    if (typeof b != "object" || b === null) return b;
    var _ = b[Symbol.toPrimitive];
    if (_ !== void 0) {
      var C = _.call(b, A);
      if (typeof C != "object") return C;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(b);
  }
  var f = $n, c = f.Buffer, l = fd, h = l.inspect, m = h && h.custom || "inspect";
  function v(b, A, _) {
    c.prototype.copy.call(b, A, _);
  }
  return A2 = function() {
    function b() {
      r(this, b), this.head = null, this.tail = null, this.length = 0;
    }
    return i(b, [{ key: "push", value: function(_) {
      var C = { data: _, next: null };
      this.length > 0 ? this.tail.next = C : this.head = C, this.tail = C, ++this.length;
    } }, { key: "unshift", value: function(_) {
      var C = { data: _, next: this.head };
      this.length === 0 && (this.tail = C), this.head = C, ++this.length;
    } }, { key: "shift", value: function() {
      if (this.length !== 0) {
        var _ = this.head.data;
        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, _;
      }
    } }, { key: "clear", value: function() {
      this.head = this.tail = null, this.length = 0;
    } }, { key: "join", value: function(_) {
      if (this.length === 0) return "";
      for (var C = this.head, I = "" + C.data; C = C.next; ) I += _ + C.data;
      return I;
    } }, { key: "concat", value: function(_) {
      if (this.length === 0) return c.alloc(0);
      for (var C = c.allocUnsafe(_ >>> 0), I = this.head, S = 0; I; ) v(I.data, C, S), S += I.data.length, I = I.next;
      return C;
    } }, { key: "consume", value: function(_, C) {
      var I;
      return _ < this.head.data.length ? (I = this.head.data.slice(0, _), this.head.data = this.head.data.slice(_)) : _ === this.head.data.length ? I = this.shift() : I = C ? this._getString(_) : this._getBuffer(_), I;
    } }, { key: "first", value: function() {
      return this.head.data;
    } }, { key: "_getString", value: function(_) {
      var C = this.head, I = 1, S = C.data;
      for (_ -= S.length; C = C.next; ) {
        var $ = C.data, F = _ > $.length ? $.length : _;
        if (F === $.length ? S += $ : S += $.slice(0, _), _ -= F, _ === 0) {
          F === $.length ? (++I, C.next ? this.head = C.next : this.head = this.tail = null) : (this.head = C, C.data = $.slice(F));
          break;
        }
        ++I;
      }
      return this.length -= I, S;
    } }, { key: "_getBuffer", value: function(_) {
      var C = c.allocUnsafe(_), I = this.head, S = 1;
      for (I.data.copy(C), _ -= I.data.length; I = I.next; ) {
        var $ = I.data, F = _ > $.length ? $.length : _;
        if ($.copy(C, C.length - _, 0, F), _ -= F, _ === 0) {
          F === $.length ? (++S, I.next ? this.head = I.next : this.head = this.tail = null) : (this.head = I, I.data = $.slice(F));
          break;
        }
        ++S;
      }
      return this.length -= S, C;
    } }, { key: m, value: function(_, C) {
      return h(this, e(e({}, C), {}, { depth: 0, customInspect: false }));
    } }]), b;
  }(), A2;
}
var w2, V8;
function VS() {
  if (V8) return w2;
  V8 = 1;
  function t3(a, o) {
    var f = this, c = this._readableState && this._readableState.destroyed, l = this._writableState && this._writableState.destroyed;
    return c || l ? (o ? o(a) : a && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, jt.nextTick(s, this, a)) : jt.nextTick(s, this, a)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(a || null, function(h) {
      !o && h ? f._writableState ? f._writableState.errorEmitted ? jt.nextTick(n, f) : (f._writableState.errorEmitted = true, jt.nextTick(e, f, h)) : jt.nextTick(e, f, h) : o ? (jt.nextTick(n, f), o(h)) : jt.nextTick(n, f);
    }), this);
  }
  function e(a, o) {
    s(a, o), n(a);
  }
  function n(a) {
    a._writableState && !a._writableState.emitClose || a._readableState && !a._readableState.emitClose || a.emit("close");
  }
  function r() {
    this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
  }
  function s(a, o) {
    a.emit("error", o);
  }
  function i(a, o) {
    var f = a._readableState, c = a._writableState;
    f && f.autoDestroy || c && c.autoDestroy ? a.destroy(o) : a.emit("error", o);
  }
  return w2 = { destroy: t3, undestroy: r, errorOrDestroy: i }, w2;
}
var x2 = {}, Y8;
function ju() {
  if (Y8) return x2;
  Y8 = 1;
  function t3(o, f) {
    o.prototype = Object.create(f.prototype), o.prototype.constructor = o, o.__proto__ = f;
  }
  var e = {};
  function n(o, f, c) {
    c || (c = Error);
    function l(m, v, b) {
      return typeof f == "string" ? f : f(m, v, b);
    }
    var h = function(m) {
      t3(v, m);
      function v(b, A, _) {
        return m.call(this, l(b, A, _)) || this;
      }
      return v;
    }(c);
    h.prototype.name = c.name, h.prototype.code = o, e[o] = h;
  }
  function r(o, f) {
    if (Array.isArray(o)) {
      var c = o.length;
      return o = o.map(function(l) {
        return String(l);
      }), c > 2 ? "one of ".concat(f, " ").concat(o.slice(0, c - 1).join(", "), ", or ") + o[c - 1] : c === 2 ? "one of ".concat(f, " ").concat(o[0], " or ").concat(o[1]) : "of ".concat(f, " ").concat(o[0]);
    } else return "of ".concat(f, " ").concat(String(o));
  }
  function s(o, f, c) {
    return o.substr(0, f.length) === f;
  }
  function i(o, f, c) {
    return (c === void 0 || c > o.length) && (c = o.length), o.substring(c - f.length, c) === f;
  }
  function a(o, f, c) {
    return typeof c != "number" && (c = 0), c + f.length > o.length ? false : o.indexOf(f, c) !== -1;
  }
  return n("ERR_INVALID_OPT_VALUE", function(o, f) {
    return 'The value "' + f + '" is invalid for option "' + o + '"';
  }, TypeError), n("ERR_INVALID_ARG_TYPE", function(o, f, c) {
    var l;
    typeof f == "string" && s(f, "not ") ? (l = "must not be", f = f.replace(/^not /, "")) : l = "must be";
    var h;
    if (i(o, " argument")) h = "The ".concat(o, " ").concat(l, " ").concat(r(f, "type"));
    else {
      var m = a(o, ".") ? "property" : "argument";
      h = 'The "'.concat(o, '" ').concat(m, " ").concat(l, " ").concat(r(f, "type"));
    }
    return h += ". Received type ".concat(typeof c), h;
  }, TypeError), n("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), n("ERR_METHOD_NOT_IMPLEMENTED", function(o) {
    return "The " + o + " method is not implemented";
  }), n("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), n("ERR_STREAM_DESTROYED", function(o) {
    return "Cannot call " + o + " after a stream was destroyed";
  }), n("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), n("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), n("ERR_STREAM_WRITE_AFTER_END", "write after end"), n("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), n("ERR_UNKNOWN_ENCODING", function(o) {
    return "Unknown encoding: " + o;
  }, TypeError), n("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), x2.codes = e, x2;
}
var _2, W8;
function YS() {
  if (W8) return _2;
  W8 = 1;
  var t3 = ju().codes.ERR_INVALID_OPT_VALUE;
  function e(r, s, i) {
    return r.highWaterMark != null ? r.highWaterMark : s ? r[i] : null;
  }
  function n(r, s, i, a) {
    var o = e(s, a, i);
    if (o != null) {
      if (!(isFinite(o) && Math.floor(o) === o) || o < 0) {
        var f = a ? i : "highWaterMark";
        throw new t3(f, o);
      }
      return Math.floor(o);
    }
    return r.objectMode ? 16 : 16 * 1024;
  }
  return _2 = { getHighWaterMark: n }, _2;
}
var WS = pz;
function pz(t3, e) {
  if (E2("noDeprecation")) return t3;
  var n = false;
  function r() {
    if (!n) {
      if (E2("throwDeprecation")) throw new Error(e);
      E2("traceDeprecation") ? console.trace(e) : console.warn(e), n = true;
    }
    return t3.apply(this, arguments);
  }
  return r;
}
function E2(t3) {
  try {
    if (!mt.localStorage) return false;
  } catch {
    return false;
  }
  var e = mt.localStorage[t3];
  return e == null ? false : String(e).toLowerCase() === "true";
}
var B2, J8;
function JS() {
  if (J8) return B2;
  J8 = 1, B2 = P;
  function t3(J) {
    var G = this;
    this.next = null, this.entry = null, this.finish = function() {
      Y(G, J);
    };
  }
  var e;
  P.WritableState = U;
  var n = { deprecate: WS }, r = xS(), s = $n.Buffer, i = (typeof mt < "u" ? mt : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function a(J) {
    return s.from(J);
  }
  function o(J) {
    return s.isBuffer(J) || J instanceof i;
  }
  var f = VS(), c = YS(), l = c.getHighWaterMark, h = ju().codes, m = h.ERR_INVALID_ARG_TYPE, v = h.ERR_METHOD_NOT_IMPLEMENTED, b = h.ERR_MULTIPLE_CALLBACK, A = h.ERR_STREAM_CANNOT_PIPE, _ = h.ERR_STREAM_DESTROYED, C = h.ERR_STREAM_NULL_VALUES, I = h.ERR_STREAM_WRITE_AFTER_END, S = h.ERR_UNKNOWN_ENCODING, $ = f.errorOrDestroy;
  wr(P, r);
  function F() {
  }
  function U(J, G, X) {
    e = e || ku(), J = J || {}, typeof X != "boolean" && (X = G instanceof e), this.objectMode = !!J.objectMode, X && (this.objectMode = this.objectMode || !!J.writableObjectMode), this.highWaterMark = l(this, J, "writableHighWaterMark", X), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
    var ie = J.decodeStrings === false;
    this.decodeStrings = !ie, this.defaultEncoding = J.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(de) {
      w(G, de);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = J.emitClose !== false, this.autoDestroy = !!J.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new t3(this);
  }
  U.prototype.getBuffer = function() {
    for (var G = this.bufferedRequest, X = []; G; ) X.push(G), G = G.next;
    return X;
  }, function() {
    try {
      Object.defineProperty(U.prototype, "buffer", { get: n.deprecate(function() {
        return this.getBuffer();
      }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
    } catch {
    }
  }();
  var Q;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Q = Function.prototype[Symbol.hasInstance], Object.defineProperty(P, Symbol.hasInstance, { value: function(G) {
    return Q.call(this, G) ? true : this !== P ? false : G && G._writableState instanceof U;
  } })) : Q = function(G) {
    return G instanceof this;
  };
  function P(J) {
    e = e || ku();
    var G = this instanceof e;
    if (!G && !Q.call(P, this)) return new P(J);
    this._writableState = new U(J, this, G), this.writable = true, J && (typeof J.write == "function" && (this._write = J.write), typeof J.writev == "function" && (this._writev = J.writev), typeof J.destroy == "function" && (this._destroy = J.destroy), typeof J.final == "function" && (this._final = J.final)), r.call(this);
  }
  P.prototype.pipe = function() {
    $(this, new A());
  };
  function N(J, G) {
    var X = new I();
    $(J, X), jt.nextTick(G, X);
  }
  function L(J, G, X, ie) {
    var de;
    return X === null ? de = new C() : typeof X != "string" && !G.objectMode && (de = new m("chunk", ["string", "Buffer"], X)), de ? ($(J, de), jt.nextTick(ie, de), false) : true;
  }
  P.prototype.write = function(J, G, X) {
    var ie = this._writableState, de = false, se = !ie.objectMode && o(J);
    return se && !s.isBuffer(J) && (J = a(J)), typeof G == "function" && (X = G, G = null), se ? G = "buffer" : G || (G = ie.defaultEncoding), typeof X != "function" && (X = F), ie.ending ? N(this, X) : (se || L(this, ie, J, X)) && (ie.pendingcb++, de = u(this, ie, se, J, G, X)), de;
  }, P.prototype.cork = function() {
    this._writableState.corked++;
  }, P.prototype.uncork = function() {
    var J = this._writableState;
    J.corked && (J.corked--, !J.writing && !J.corked && !J.bufferProcessing && J.bufferedRequest && x(this, J));
  }, P.prototype.setDefaultEncoding = function(G) {
    if (typeof G == "string" && (G = G.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((G + "").toLowerCase()) > -1)) throw new S(G);
    return this._writableState.defaultEncoding = G, this;
  }, Object.defineProperty(P.prototype, "writableBuffer", { enumerable: false, get: function() {
    return this._writableState && this._writableState.getBuffer();
  } });
  function B(J, G, X) {
    return !J.objectMode && J.decodeStrings !== false && typeof G == "string" && (G = s.from(G, X)), G;
  }
  Object.defineProperty(P.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
    return this._writableState.highWaterMark;
  } });
  function u(J, G, X, ie, de, se) {
    if (!X) {
      var te = B(G, ie, de);
      ie !== te && (X = true, de = "buffer", ie = te);
    }
    var le = G.objectMode ? 1 : ie.length;
    G.length += le;
    var Z = G.length < G.highWaterMark;
    if (Z || (G.needDrain = true), G.writing || G.corked) {
      var ve = G.lastBufferedRequest;
      G.lastBufferedRequest = { chunk: ie, encoding: de, isBuf: X, callback: se, next: null }, ve ? ve.next = G.lastBufferedRequest : G.bufferedRequest = G.lastBufferedRequest, G.bufferedRequestCount += 1;
    } else p(J, G, false, le, ie, de, se);
    return Z;
  }
  function p(J, G, X, ie, de, se, te) {
    G.writelen = ie, G.writecb = te, G.writing = true, G.sync = true, G.destroyed ? G.onwrite(new _("write")) : X ? J._writev(de, G.onwrite) : J._write(de, se, G.onwrite), G.sync = false;
  }
  function d(J, G, X, ie, de) {
    --G.pendingcb, X ? (jt.nextTick(de, ie), jt.nextTick(O, J, G), J._writableState.errorEmitted = true, $(J, ie)) : (de(ie), J._writableState.errorEmitted = true, $(J, ie), O(J, G));
  }
  function y(J) {
    J.writing = false, J.writecb = null, J.length -= J.writelen, J.writelen = 0;
  }
  function w(J, G) {
    var X = J._writableState, ie = X.sync, de = X.writecb;
    if (typeof de != "function") throw new b();
    if (y(X), G) d(J, X, ie, G, de);
    else {
      var se = g(X) || J.destroyed;
      !se && !X.corked && !X.bufferProcessing && X.bufferedRequest && x(J, X), ie ? jt.nextTick(E, J, X, se, de) : E(J, X, se, de);
    }
  }
  function E(J, G, X, ie) {
    X || M(J, G), G.pendingcb--, ie(), O(J, G);
  }
  function M(J, G) {
    G.length === 0 && G.needDrain && (G.needDrain = false, J.emit("drain"));
  }
  function x(J, G) {
    G.bufferProcessing = true;
    var X = G.bufferedRequest;
    if (J._writev && X && X.next) {
      var ie = G.bufferedRequestCount, de = new Array(ie), se = G.corkedRequestsFree;
      se.entry = X;
      for (var te = 0, le = true; X; ) de[te] = X, X.isBuf || (le = false), X = X.next, te += 1;
      de.allBuffers = le, p(J, G, true, G.length, de, "", se.finish), G.pendingcb++, G.lastBufferedRequest = null, se.next ? (G.corkedRequestsFree = se.next, se.next = null) : G.corkedRequestsFree = new t3(G), G.bufferedRequestCount = 0;
    } else {
      for (; X; ) {
        var Z = X.chunk, ve = X.encoding, he = X.callback, me = G.objectMode ? 1 : Z.length;
        if (p(J, G, false, me, Z, ve, he), X = X.next, G.bufferedRequestCount--, G.writing) break;
      }
      X === null && (G.lastBufferedRequest = null);
    }
    G.bufferedRequest = X, G.bufferProcessing = false;
  }
  P.prototype._write = function(J, G, X) {
    X(new v("_write()"));
  }, P.prototype._writev = null, P.prototype.end = function(J, G, X) {
    var ie = this._writableState;
    return typeof J == "function" ? (X = J, J = null, G = null) : typeof G == "function" && (X = G, G = null), J != null && this.write(J, G), ie.corked && (ie.corked = 1, this.uncork()), ie.ending || K(this, ie, X), this;
  }, Object.defineProperty(P.prototype, "writableLength", { enumerable: false, get: function() {
    return this._writableState.length;
  } });
  function g(J) {
    return J.ending && J.length === 0 && J.bufferedRequest === null && !J.finished && !J.writing;
  }
  function k(J, G) {
    J._final(function(X) {
      G.pendingcb--, X && $(J, X), G.prefinished = true, J.emit("prefinish"), O(J, G);
    });
  }
  function T(J, G) {
    !G.prefinished && !G.finalCalled && (typeof J._final == "function" && !G.destroyed ? (G.pendingcb++, G.finalCalled = true, jt.nextTick(k, J, G)) : (G.prefinished = true, J.emit("prefinish")));
  }
  function O(J, G) {
    var X = g(G);
    if (X && (T(J, G), G.pendingcb === 0 && (G.finished = true, J.emit("finish"), G.autoDestroy))) {
      var ie = J._readableState;
      (!ie || ie.autoDestroy && ie.endEmitted) && J.destroy();
    }
    return X;
  }
  function K(J, G, X) {
    G.ending = true, O(J, G), X && (G.finished ? jt.nextTick(X) : J.once("finish", X)), G.ended = true, J.writable = false;
  }
  function Y(J, G, X) {
    var ie = J.entry;
    for (J.entry = null; ie; ) {
      var de = ie.callback;
      G.pendingcb--, de(X), ie = ie.next;
    }
    G.corkedRequestsFree.next = J;
  }
  return Object.defineProperty(P.prototype, "destroyed", { enumerable: false, get: function() {
    return this._writableState === void 0 ? false : this._writableState.destroyed;
  }, set: function(G) {
    this._writableState && (this._writableState.destroyed = G);
  } }), P.prototype.destroy = f.destroy, P.prototype._undestroy = f.undestroy, P.prototype._destroy = function(J, G) {
    G(J);
  }, B2;
}
var C2, Z8;
function ku() {
  if (Z8) return C2;
  Z8 = 1;
  var t3 = Object.keys || function(c) {
    var l = [];
    for (var h in c) l.push(h);
    return l;
  };
  C2 = a;
  var e = ZS(), n = JS();
  wr(a, e);
  for (var r = t3(n.prototype), s = 0; s < r.length; s++) {
    var i = r[s];
    a.prototype[i] || (a.prototype[i] = n.prototype[i]);
  }
  function a(c) {
    if (!(this instanceof a)) return new a(c);
    e.call(this, c), n.call(this, c), this.allowHalfOpen = true, c && (c.readable === false && (this.readable = false), c.writable === false && (this.writable = false), c.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", o)));
  }
  Object.defineProperty(a.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
    return this._writableState.highWaterMark;
  } }), Object.defineProperty(a.prototype, "writableBuffer", { enumerable: false, get: function() {
    return this._writableState && this._writableState.getBuffer();
  } }), Object.defineProperty(a.prototype, "writableLength", { enumerable: false, get: function() {
    return this._writableState.length;
  } });
  function o() {
    this._writableState.ended || jt.nextTick(f, this);
  }
  function f(c) {
    c.end();
  }
  return Object.defineProperty(a.prototype, "destroyed", { enumerable: false, get: function() {
    return this._readableState === void 0 || this._writableState === void 0 ? false : this._readableState.destroyed && this._writableState.destroyed;
  }, set: function(l) {
    this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = l, this._writableState.destroyed = l);
  } }), C2;
}
var Iu = {}, kA = Tn.Buffer, j8 = kA.isEncoding || function(t3) {
  switch (t3 = "" + t3, t3 && t3.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return true;
    default:
      return false;
  }
};
function gz(t3) {
  if (!t3) return "utf8";
  for (var e; ; ) switch (t3) {
    case "utf8":
    case "utf-8":
      return "utf8";
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return "utf16le";
    case "latin1":
    case "binary":
      return "latin1";
    case "base64":
    case "ascii":
    case "hex":
      return t3;
    default:
      if (e) return;
      t3 = ("" + t3).toLowerCase(), e = true;
  }
}
function mz(t3) {
  var e = gz(t3);
  if (typeof e != "string" && (kA.isEncoding === j8 || !j8(t3))) throw new Error("Unknown encoding: " + t3);
  return e || t3;
}
Iu.StringDecoder = hd;
function hd(t3) {
  this.encoding = mz(t3);
  var e;
  switch (this.encoding) {
    case "utf16le":
      this.text = xz, this.end = _z, e = 4;
      break;
    case "utf8":
      this.fillLast = bz, e = 4;
      break;
    case "base64":
      this.text = Ez, this.end = Bz, e = 3;
      break;
    default:
      this.write = Cz, this.end = kz;
      return;
  }
  this.lastNeed = 0, this.lastTotal = 0, this.lastChar = kA.allocUnsafe(e);
}
hd.prototype.write = function(t3) {
  if (t3.length === 0) return "";
  var e, n;
  if (this.lastNeed) {
    if (e = this.fillLast(t3), e === void 0) return "";
    n = this.lastNeed, this.lastNeed = 0;
  } else n = 0;
  return n < t3.length ? e ? e + this.text(t3, n) : this.text(t3, n) : e || "";
};
hd.prototype.end = wz;
hd.prototype.text = Az;
hd.prototype.fillLast = function(t3) {
  if (this.lastNeed <= t3.length) return t3.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  t3.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t3.length), this.lastNeed -= t3.length;
};
function k2(t3) {
  return t3 <= 127 ? 0 : t3 >> 5 === 6 ? 2 : t3 >> 4 === 14 ? 3 : t3 >> 3 === 30 ? 4 : t3 >> 6 === 2 ? -1 : -2;
}
function vz(t3, e, n) {
  var r = e.length - 1;
  if (r < n) return 0;
  var s = k2(e[r]);
  return s >= 0 ? (s > 0 && (t3.lastNeed = s - 1), s) : --r < n || s === -2 ? 0 : (s = k2(e[r]), s >= 0 ? (s > 0 && (t3.lastNeed = s - 2), s) : --r < n || s === -2 ? 0 : (s = k2(e[r]), s >= 0 ? (s > 0 && (s === 2 ? s = 0 : t3.lastNeed = s - 3), s) : 0));
}
function yz(t3, e, n) {
  if ((e[0] & 192) !== 128) return t3.lastNeed = 0, "\uFFFD";
  if (t3.lastNeed > 1 && e.length > 1) {
    if ((e[1] & 192) !== 128) return t3.lastNeed = 1, "\uFFFD";
    if (t3.lastNeed > 2 && e.length > 2 && (e[2] & 192) !== 128) return t3.lastNeed = 2, "\uFFFD";
  }
}
function bz(t3) {
  var e = this.lastTotal - this.lastNeed, n = yz(this, t3);
  if (n !== void 0) return n;
  if (this.lastNeed <= t3.length) return t3.copy(this.lastChar, e, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  t3.copy(this.lastChar, e, 0, t3.length), this.lastNeed -= t3.length;
}
function Az(t3, e) {
  var n = vz(this, t3, e);
  if (!this.lastNeed) return t3.toString("utf8", e);
  this.lastTotal = n;
  var r = t3.length - (n - this.lastNeed);
  return t3.copy(this.lastChar, 0, r), t3.toString("utf8", e, r);
}
function wz(t3) {
  var e = t3 && t3.length ? this.write(t3) : "";
  return this.lastNeed ? e + "\uFFFD" : e;
}
function xz(t3, e) {
  if ((t3.length - e) % 2 === 0) {
    var n = t3.toString("utf16le", e);
    if (n) {
      var r = n.charCodeAt(n.length - 1);
      if (r >= 55296 && r <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t3[t3.length - 2], this.lastChar[1] = t3[t3.length - 1], n.slice(0, -1);
    }
    return n;
  }
  return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t3[t3.length - 1], t3.toString("utf16le", e, t3.length - 1);
}
function _z(t3) {
  var e = t3 && t3.length ? this.write(t3) : "";
  if (this.lastNeed) {
    var n = this.lastTotal - this.lastNeed;
    return e + this.lastChar.toString("utf16le", 0, n);
  }
  return e;
}
function Ez(t3, e) {
  var n = (t3.length - e) % 3;
  return n === 0 ? t3.toString("base64", e) : (this.lastNeed = 3 - n, this.lastTotal = 3, n === 1 ? this.lastChar[0] = t3[t3.length - 1] : (this.lastChar[0] = t3[t3.length - 2], this.lastChar[1] = t3[t3.length - 1]), t3.toString("base64", e, t3.length - n));
}
function Bz(t3) {
  var e = t3 && t3.length ? this.write(t3) : "";
  return this.lastNeed ? e + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e;
}
function Cz(t3) {
  return t3.toString(this.encoding);
}
function kz(t3) {
  return t3 && t3.length ? this.write(t3) : "";
}
var I2, X8;
function IA() {
  if (X8) return I2;
  X8 = 1;
  var t3 = ju().codes.ERR_STREAM_PREMATURE_CLOSE;
  function e(i) {
    var a = false;
    return function() {
      if (!a) {
        a = true;
        for (var o = arguments.length, f = new Array(o), c = 0; c < o; c++) f[c] = arguments[c];
        i.apply(this, f);
      }
    };
  }
  function n() {
  }
  function r(i) {
    return i.setHeader && typeof i.abort == "function";
  }
  function s(i, a, o) {
    if (typeof a == "function") return s(i, null, a);
    a || (a = {}), o = e(o || n);
    var f = a.readable || a.readable !== false && i.readable, c = a.writable || a.writable !== false && i.writable, l = function() {
      i.writable || m();
    }, h = i._writableState && i._writableState.finished, m = function() {
      c = false, h = true, f || o.call(i);
    }, v = i._readableState && i._readableState.endEmitted, b = function() {
      f = false, v = true, c || o.call(i);
    }, A = function(S) {
      o.call(i, S);
    }, _ = function() {
      var S;
      if (f && !v) return (!i._readableState || !i._readableState.ended) && (S = new t3()), o.call(i, S);
      if (c && !h) return (!i._writableState || !i._writableState.ended) && (S = new t3()), o.call(i, S);
    }, C = function() {
      i.req.on("finish", m);
    };
    return r(i) ? (i.on("complete", m), i.on("abort", _), i.req ? C() : i.on("request", C)) : c && !i._writableState && (i.on("end", l), i.on("close", l)), i.on("end", b), i.on("finish", m), a.error !== false && i.on("error", A), i.on("close", _), function() {
      i.removeListener("complete", m), i.removeListener("abort", _), i.removeListener("request", C), i.req && i.req.removeListener("finish", m), i.removeListener("end", l), i.removeListener("close", l), i.removeListener("finish", m), i.removeListener("end", b), i.removeListener("error", A), i.removeListener("close", _);
    };
  }
  return I2 = s, I2;
}
var S2, ew;
function Iz() {
  if (ew) return S2;
  ew = 1;
  var t3;
  function e(S, $, F) {
    return $ = n($), $ in S ? Object.defineProperty(S, $, { value: F, enumerable: true, configurable: true, writable: true }) : S[$] = F, S;
  }
  function n(S) {
    var $ = r(S, "string");
    return typeof $ == "symbol" ? $ : String($);
  }
  function r(S, $) {
    if (typeof S != "object" || S === null) return S;
    var F = S[Symbol.toPrimitive];
    if (F !== void 0) {
      var U = F.call(S, $);
      if (typeof U != "object") return U;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ($ === "string" ? String : Number)(S);
  }
  var s = IA(), i = Symbol("lastResolve"), a = Symbol("lastReject"), o = Symbol("error"), f = Symbol("ended"), c = Symbol("lastPromise"), l = Symbol("handlePromise"), h = Symbol("stream");
  function m(S, $) {
    return { value: S, done: $ };
  }
  function v(S) {
    var $ = S[i];
    if ($ !== null) {
      var F = S[h].read();
      F !== null && (S[c] = null, S[i] = null, S[a] = null, $(m(F, false)));
    }
  }
  function b(S) {
    jt.nextTick(v, S);
  }
  function A(S, $) {
    return function(F, U) {
      S.then(function() {
        if ($[f]) {
          F(m(void 0, true));
          return;
        }
        $[l](F, U);
      }, U);
    };
  }
  var _ = Object.getPrototypeOf(function() {
  }), C = Object.setPrototypeOf((t3 = { get stream() {
    return this[h];
  }, next: function() {
    var $ = this, F = this[o];
    if (F !== null) return Promise.reject(F);
    if (this[f]) return Promise.resolve(m(void 0, true));
    if (this[h].destroyed) return new Promise(function(N, L) {
      jt.nextTick(function() {
        $[o] ? L($[o]) : N(m(void 0, true));
      });
    });
    var U = this[c], Q;
    if (U) Q = new Promise(A(U, this));
    else {
      var P = this[h].read();
      if (P !== null) return Promise.resolve(m(P, false));
      Q = new Promise(this[l]);
    }
    return this[c] = Q, Q;
  } }, e(t3, Symbol.asyncIterator, function() {
    return this;
  }), e(t3, "return", function() {
    var $ = this;
    return new Promise(function(F, U) {
      $[h].destroy(null, function(Q) {
        if (Q) {
          U(Q);
          return;
        }
        F(m(void 0, true));
      });
    });
  }), t3), _), I = function($) {
    var F, U = Object.create(C, (F = {}, e(F, h, { value: $, writable: true }), e(F, i, { value: null, writable: true }), e(F, a, { value: null, writable: true }), e(F, o, { value: null, writable: true }), e(F, f, { value: $._readableState.endEmitted, writable: true }), e(F, l, { value: function(P, N) {
      var L = U[h].read();
      L ? (U[c] = null, U[i] = null, U[a] = null, P(m(L, false))) : (U[i] = P, U[a] = N);
    }, writable: true }), F));
    return U[c] = null, s($, function(Q) {
      if (Q && Q.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var P = U[a];
        P !== null && (U[c] = null, U[i] = null, U[a] = null, P(Q)), U[o] = Q;
        return;
      }
      var N = U[i];
      N !== null && (U[c] = null, U[i] = null, U[a] = null, N(m(void 0, true))), U[f] = true;
    }), $.on("readable", b.bind(null, U)), U;
  };
  return S2 = I, S2;
}
var M2, tw;
function Sz() {
  return tw || (tw = 1, M2 = function() {
    throw new Error("Readable.from is not available in the browser");
  }), M2;
}
var $2, rw;
function ZS() {
  if (rw) return $2;
  rw = 1, $2 = N;
  var t3;
  N.ReadableState = P, od.EventEmitter;
  var e = function(te, le) {
    return te.listeners(le).length;
  }, n = xS(), r = $n.Buffer, s = (typeof mt < "u" ? mt : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function i(se) {
    return r.from(se);
  }
  function a(se) {
    return r.isBuffer(se) || se instanceof s;
  }
  var o = fd, f;
  o && o.debuglog ? f = o.debuglog("stream") : f = function() {
  };
  var c = dz(), l = VS(), h = YS(), m = h.getHighWaterMark, v = ju().codes, b = v.ERR_INVALID_ARG_TYPE, A = v.ERR_STREAM_PUSH_AFTER_EOF, _ = v.ERR_METHOD_NOT_IMPLEMENTED, C = v.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, I, S, $;
  wr(N, n);
  var F = l.errorOrDestroy, U = ["error", "close", "destroy", "pause", "resume"];
  function Q(se, te, le) {
    if (typeof se.prependListener == "function") return se.prependListener(te, le);
    !se._events || !se._events[te] ? se.on(te, le) : Array.isArray(se._events[te]) ? se._events[te].unshift(le) : se._events[te] = [le, se._events[te]];
  }
  function P(se, te, le) {
    t3 = t3 || ku(), se = se || {}, typeof le != "boolean" && (le = te instanceof t3), this.objectMode = !!se.objectMode, le && (this.objectMode = this.objectMode || !!se.readableObjectMode), this.highWaterMark = m(this, se, "readableHighWaterMark", le), this.buffer = new c(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = se.emitClose !== false, this.autoDestroy = !!se.autoDestroy, this.destroyed = false, this.defaultEncoding = se.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, se.encoding && (I || (I = Iu.StringDecoder), this.decoder = new I(se.encoding), this.encoding = se.encoding);
  }
  function N(se) {
    if (t3 = t3 || ku(), !(this instanceof N)) return new N(se);
    var te = this instanceof t3;
    this._readableState = new P(se, this, te), this.readable = true, se && (typeof se.read == "function" && (this._read = se.read), typeof se.destroy == "function" && (this._destroy = se.destroy)), n.call(this);
  }
  Object.defineProperty(N.prototype, "destroyed", { enumerable: false, get: function() {
    return this._readableState === void 0 ? false : this._readableState.destroyed;
  }, set: function(te) {
    this._readableState && (this._readableState.destroyed = te);
  } }), N.prototype.destroy = l.destroy, N.prototype._undestroy = l.undestroy, N.prototype._destroy = function(se, te) {
    te(se);
  }, N.prototype.push = function(se, te) {
    var le = this._readableState, Z;
    return le.objectMode ? Z = true : typeof se == "string" && (te = te || le.defaultEncoding, te !== le.encoding && (se = r.from(se, te), te = ""), Z = true), L(this, se, te, false, Z);
  }, N.prototype.unshift = function(se) {
    return L(this, se, null, true, false);
  };
  function L(se, te, le, Z, ve) {
    f("readableAddChunk", te);
    var he = se._readableState;
    if (te === null) he.reading = false, w(se, he);
    else {
      var me;
      if (ve || (me = u(he, te)), me) F(se, me);
      else if (he.objectMode || te && te.length > 0) if (typeof te != "string" && !he.objectMode && Object.getPrototypeOf(te) !== r.prototype && (te = i(te)), Z) he.endEmitted ? F(se, new C()) : B(se, he, te, true);
      else if (he.ended) F(se, new A());
      else {
        if (he.destroyed) return false;
        he.reading = false, he.decoder && !le ? (te = he.decoder.write(te), he.objectMode || te.length !== 0 ? B(se, he, te, false) : x(se, he)) : B(se, he, te, false);
      }
      else Z || (he.reading = false, x(se, he));
    }
    return !he.ended && (he.length < he.highWaterMark || he.length === 0);
  }
  function B(se, te, le, Z) {
    te.flowing && te.length === 0 && !te.sync ? (te.awaitDrain = 0, se.emit("data", le)) : (te.length += te.objectMode ? 1 : le.length, Z ? te.buffer.unshift(le) : te.buffer.push(le), te.needReadable && E(se)), x(se, te);
  }
  function u(se, te) {
    var le;
    return !a(te) && typeof te != "string" && te !== void 0 && !se.objectMode && (le = new b("chunk", ["string", "Buffer", "Uint8Array"], te)), le;
  }
  N.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  }, N.prototype.setEncoding = function(se) {
    I || (I = Iu.StringDecoder);
    var te = new I(se);
    this._readableState.decoder = te, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var le = this._readableState.buffer.head, Z = ""; le !== null; ) Z += te.write(le.data), le = le.next;
    return this._readableState.buffer.clear(), Z !== "" && this._readableState.buffer.push(Z), this._readableState.length = Z.length, this;
  };
  var p = 1073741824;
  function d(se) {
    return se >= p ? se = p : (se--, se |= se >>> 1, se |= se >>> 2, se |= se >>> 4, se |= se >>> 8, se |= se >>> 16, se++), se;
  }
  function y(se, te) {
    return se <= 0 || te.length === 0 && te.ended ? 0 : te.objectMode ? 1 : se !== se ? te.flowing && te.length ? te.buffer.head.data.length : te.length : (se > te.highWaterMark && (te.highWaterMark = d(se)), se <= te.length ? se : te.ended ? te.length : (te.needReadable = true, 0));
  }
  N.prototype.read = function(se) {
    f("read", se), se = parseInt(se, 10);
    var te = this._readableState, le = se;
    if (se !== 0 && (te.emittedReadable = false), se === 0 && te.needReadable && ((te.highWaterMark !== 0 ? te.length >= te.highWaterMark : te.length > 0) || te.ended)) return f("read: emitReadable", te.length, te.ended), te.length === 0 && te.ended ? X(this) : E(this), null;
    if (se = y(se, te), se === 0 && te.ended) return te.length === 0 && X(this), null;
    var Z = te.needReadable;
    f("need readable", Z), (te.length === 0 || te.length - se < te.highWaterMark) && (Z = true, f("length less than watermark", Z)), te.ended || te.reading ? (Z = false, f("reading or ended", Z)) : Z && (f("do read"), te.reading = true, te.sync = true, te.length === 0 && (te.needReadable = true), this._read(te.highWaterMark), te.sync = false, te.reading || (se = y(le, te)));
    var ve;
    return se > 0 ? ve = G(se, te) : ve = null, ve === null ? (te.needReadable = te.length <= te.highWaterMark, se = 0) : (te.length -= se, te.awaitDrain = 0), te.length === 0 && (te.ended || (te.needReadable = true), le !== se && te.ended && X(this)), ve !== null && this.emit("data", ve), ve;
  };
  function w(se, te) {
    if (f("onEofChunk"), !te.ended) {
      if (te.decoder) {
        var le = te.decoder.end();
        le && le.length && (te.buffer.push(le), te.length += te.objectMode ? 1 : le.length);
      }
      te.ended = true, te.sync ? E(se) : (te.needReadable = false, te.emittedReadable || (te.emittedReadable = true, M(se)));
    }
  }
  function E(se) {
    var te = se._readableState;
    f("emitReadable", te.needReadable, te.emittedReadable), te.needReadable = false, te.emittedReadable || (f("emitReadable", te.flowing), te.emittedReadable = true, jt.nextTick(M, se));
  }
  function M(se) {
    var te = se._readableState;
    f("emitReadable_", te.destroyed, te.length, te.ended), !te.destroyed && (te.length || te.ended) && (se.emit("readable"), te.emittedReadable = false), te.needReadable = !te.flowing && !te.ended && te.length <= te.highWaterMark, J(se);
  }
  function x(se, te) {
    te.readingMore || (te.readingMore = true, jt.nextTick(g, se, te));
  }
  function g(se, te) {
    for (; !te.reading && !te.ended && (te.length < te.highWaterMark || te.flowing && te.length === 0); ) {
      var le = te.length;
      if (f("maybeReadMore read 0"), se.read(0), le === te.length) break;
    }
    te.readingMore = false;
  }
  N.prototype._read = function(se) {
    F(this, new _("_read()"));
  }, N.prototype.pipe = function(se, te) {
    var le = this, Z = this._readableState;
    switch (Z.pipesCount) {
      case 0:
        Z.pipes = se;
        break;
      case 1:
        Z.pipes = [Z.pipes, se];
        break;
      default:
        Z.pipes.push(se);
        break;
    }
    Z.pipesCount += 1, f("pipe count=%d opts=%j", Z.pipesCount, te);
    var ve = (!te || te.end !== false) && se !== jt.stdout && se !== jt.stderr, he = ve ? ce : Ge;
    Z.endEmitted ? jt.nextTick(he) : le.once("end", he), se.on("unpipe", me);
    function me(Fe, Ue) {
      f("onunpipe"), Fe === le && Ue && Ue.hasUnpiped === false && (Ue.hasUnpiped = true, Se());
    }
    function ce() {
      f("onend"), se.end();
    }
    var ye = k(le);
    se.on("drain", ye);
    var Oe = false;
    function Se() {
      f("cleanup"), se.removeListener("close", $e), se.removeListener("finish", Re), se.removeListener("drain", ye), se.removeListener("error", Ne), se.removeListener("unpipe", me), le.removeListener("end", ce), le.removeListener("end", Ge), le.removeListener("data", Ce), Oe = true, Z.awaitDrain && (!se._writableState || se._writableState.needDrain) && ye();
    }
    le.on("data", Ce);
    function Ce(Fe) {
      f("ondata");
      var Ue = se.write(Fe);
      f("dest.write", Ue), Ue === false && ((Z.pipesCount === 1 && Z.pipes === se || Z.pipesCount > 1 && de(Z.pipes, se) !== -1) && !Oe && (f("false write response, pause", Z.awaitDrain), Z.awaitDrain++), le.pause());
    }
    function Ne(Fe) {
      f("onerror", Fe), Ge(), se.removeListener("error", Ne), e(se, "error") === 0 && F(se, Fe);
    }
    Q(se, "error", Ne);
    function $e() {
      se.removeListener("finish", Re), Ge();
    }
    se.once("close", $e);
    function Re() {
      f("onfinish"), se.removeListener("close", $e), Ge();
    }
    se.once("finish", Re);
    function Ge() {
      f("unpipe"), le.unpipe(se);
    }
    return se.emit("pipe", le), Z.flowing || (f("pipe resume"), le.resume()), se;
  };
  function k(se) {
    return function() {
      var le = se._readableState;
      f("pipeOnDrain", le.awaitDrain), le.awaitDrain && le.awaitDrain--, le.awaitDrain === 0 && e(se, "data") && (le.flowing = true, J(se));
    };
  }
  N.prototype.unpipe = function(se) {
    var te = this._readableState, le = { hasUnpiped: false };
    if (te.pipesCount === 0) return this;
    if (te.pipesCount === 1) return se && se !== te.pipes ? this : (se || (se = te.pipes), te.pipes = null, te.pipesCount = 0, te.flowing = false, se && se.emit("unpipe", this, le), this);
    if (!se) {
      var Z = te.pipes, ve = te.pipesCount;
      te.pipes = null, te.pipesCount = 0, te.flowing = false;
      for (var he = 0; he < ve; he++) Z[he].emit("unpipe", this, { hasUnpiped: false });
      return this;
    }
    var me = de(te.pipes, se);
    return me === -1 ? this : (te.pipes.splice(me, 1), te.pipesCount -= 1, te.pipesCount === 1 && (te.pipes = te.pipes[0]), se.emit("unpipe", this, le), this);
  }, N.prototype.on = function(se, te) {
    var le = n.prototype.on.call(this, se, te), Z = this._readableState;
    return se === "data" ? (Z.readableListening = this.listenerCount("readable") > 0, Z.flowing !== false && this.resume()) : se === "readable" && !Z.endEmitted && !Z.readableListening && (Z.readableListening = Z.needReadable = true, Z.flowing = false, Z.emittedReadable = false, f("on readable", Z.length, Z.reading), Z.length ? E(this) : Z.reading || jt.nextTick(O, this)), le;
  }, N.prototype.addListener = N.prototype.on, N.prototype.removeListener = function(se, te) {
    var le = n.prototype.removeListener.call(this, se, te);
    return se === "readable" && jt.nextTick(T, this), le;
  }, N.prototype.removeAllListeners = function(se) {
    var te = n.prototype.removeAllListeners.apply(this, arguments);
    return (se === "readable" || se === void 0) && jt.nextTick(T, this), te;
  };
  function T(se) {
    var te = se._readableState;
    te.readableListening = se.listenerCount("readable") > 0, te.resumeScheduled && !te.paused ? te.flowing = true : se.listenerCount("data") > 0 && se.resume();
  }
  function O(se) {
    f("readable nexttick read 0"), se.read(0);
  }
  N.prototype.resume = function() {
    var se = this._readableState;
    return se.flowing || (f("resume"), se.flowing = !se.readableListening, K(this, se)), se.paused = false, this;
  };
  function K(se, te) {
    te.resumeScheduled || (te.resumeScheduled = true, jt.nextTick(Y, se, te));
  }
  function Y(se, te) {
    f("resume", te.reading), te.reading || se.read(0), te.resumeScheduled = false, se.emit("resume"), J(se), te.flowing && !te.reading && se.read(0);
  }
  N.prototype.pause = function() {
    return f("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (f("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
  };
  function J(se) {
    var te = se._readableState;
    for (f("flow", te.flowing); te.flowing && se.read() !== null; ) ;
  }
  N.prototype.wrap = function(se) {
    var te = this, le = this._readableState, Z = false;
    se.on("end", function() {
      if (f("wrapped end"), le.decoder && !le.ended) {
        var me = le.decoder.end();
        me && me.length && te.push(me);
      }
      te.push(null);
    }), se.on("data", function(me) {
      if (f("wrapped data"), le.decoder && (me = le.decoder.write(me)), !(le.objectMode && me == null) && !(!le.objectMode && (!me || !me.length))) {
        var ce = te.push(me);
        ce || (Z = true, se.pause());
      }
    });
    for (var ve in se) this[ve] === void 0 && typeof se[ve] == "function" && (this[ve] = /* @__PURE__ */ function(ce) {
      return function() {
        return se[ce].apply(se, arguments);
      };
    }(ve));
    for (var he = 0; he < U.length; he++) se.on(U[he], this.emit.bind(this, U[he]));
    return this._read = function(me) {
      f("wrapped _read", me), Z && (Z = false, se.resume());
    }, this;
  }, typeof Symbol == "function" && (N.prototype[Symbol.asyncIterator] = function() {
    return S === void 0 && (S = Iz()), S(this);
  }), Object.defineProperty(N.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
    return this._readableState.highWaterMark;
  } }), Object.defineProperty(N.prototype, "readableBuffer", { enumerable: false, get: function() {
    return this._readableState && this._readableState.buffer;
  } }), Object.defineProperty(N.prototype, "readableFlowing", { enumerable: false, get: function() {
    return this._readableState.flowing;
  }, set: function(te) {
    this._readableState && (this._readableState.flowing = te);
  } }), N._fromList = G, Object.defineProperty(N.prototype, "readableLength", { enumerable: false, get: function() {
    return this._readableState.length;
  } });
  function G(se, te) {
    if (te.length === 0) return null;
    var le;
    return te.objectMode ? le = te.buffer.shift() : !se || se >= te.length ? (te.decoder ? le = te.buffer.join("") : te.buffer.length === 1 ? le = te.buffer.first() : le = te.buffer.concat(te.length), te.buffer.clear()) : le = te.buffer.consume(se, te.decoder), le;
  }
  function X(se) {
    var te = se._readableState;
    f("endReadable", te.endEmitted), te.endEmitted || (te.ended = true, jt.nextTick(ie, te, se));
  }
  function ie(se, te) {
    if (f("endReadableNT", se.endEmitted, se.length), !se.endEmitted && se.length === 0 && (se.endEmitted = true, te.readable = false, te.emit("end"), se.autoDestroy)) {
      var le = te._writableState;
      (!le || le.autoDestroy && le.finished) && te.destroy();
    }
  }
  typeof Symbol == "function" && (N.from = function(se, te) {
    return $ === void 0 && ($ = Sz()), $(N, se, te);
  });
  function de(se, te) {
    for (var le = 0, Z = se.length; le < Z; le++) if (se[le] === te) return le;
    return -1;
  }
  return $2;
}
var T2, nw;
function jS() {
  if (nw) return T2;
  nw = 1, T2 = o;
  var t3 = ju().codes, e = t3.ERR_METHOD_NOT_IMPLEMENTED, n = t3.ERR_MULTIPLE_CALLBACK, r = t3.ERR_TRANSFORM_ALREADY_TRANSFORMING, s = t3.ERR_TRANSFORM_WITH_LENGTH_0, i = ku();
  wr(o, i);
  function a(l, h) {
    var m = this._transformState;
    m.transforming = false;
    var v = m.writecb;
    if (v === null) return this.emit("error", new n());
    m.writechunk = null, m.writecb = null, h != null && this.push(h), v(l);
    var b = this._readableState;
    b.reading = false, (b.needReadable || b.length < b.highWaterMark) && this._read(b.highWaterMark);
  }
  function o(l) {
    if (!(this instanceof o)) return new o(l);
    i.call(this, l), this._transformState = { afterTransform: a.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, l && (typeof l.transform == "function" && (this._transform = l.transform), typeof l.flush == "function" && (this._flush = l.flush)), this.on("prefinish", f);
  }
  function f() {
    var l = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(h, m) {
      c(l, h, m);
    }) : c(this, null, null);
  }
  o.prototype.push = function(l, h) {
    return this._transformState.needTransform = false, i.prototype.push.call(this, l, h);
  }, o.prototype._transform = function(l, h, m) {
    m(new e("_transform()"));
  }, o.prototype._write = function(l, h, m) {
    var v = this._transformState;
    if (v.writecb = m, v.writechunk = l, v.writeencoding = h, !v.transforming) {
      var b = this._readableState;
      (v.needTransform || b.needReadable || b.length < b.highWaterMark) && this._read(b.highWaterMark);
    }
  }, o.prototype._read = function(l) {
    var h = this._transformState;
    h.writechunk !== null && !h.transforming ? (h.transforming = true, this._transform(h.writechunk, h.writeencoding, h.afterTransform)) : h.needTransform = true;
  }, o.prototype._destroy = function(l, h) {
    i.prototype._destroy.call(this, l, function(m) {
      h(m);
    });
  };
  function c(l, h, m) {
    if (h) return l.emit("error", h);
    if (m != null && l.push(m), l._writableState.length) throw new s();
    if (l._transformState.transforming) throw new r();
    return l.push(null);
  }
  return T2;
}
var D2, iw;
function Mz() {
  if (iw) return D2;
  iw = 1, D2 = e;
  var t3 = jS();
  wr(e, t3);
  function e(n) {
    if (!(this instanceof e)) return new e(n);
    t3.call(this, n);
  }
  return e.prototype._transform = function(n, r, s) {
    s(null, n);
  }, D2;
}
var R2, sw;
function $z() {
  if (sw) return R2;
  sw = 1;
  var t3;
  function e(m) {
    var v = false;
    return function() {
      v || (v = true, m.apply(void 0, arguments));
    };
  }
  var n = ju().codes, r = n.ERR_MISSING_ARGS, s = n.ERR_STREAM_DESTROYED;
  function i(m) {
    if (m) throw m;
  }
  function a(m) {
    return m.setHeader && typeof m.abort == "function";
  }
  function o(m, v, b, A) {
    A = e(A);
    var _ = false;
    m.on("close", function() {
      _ = true;
    }), t3 === void 0 && (t3 = IA()), t3(m, { readable: v, writable: b }, function(I) {
      if (I) return A(I);
      _ = true, A();
    });
    var C = false;
    return function(I) {
      if (!_ && !C) {
        if (C = true, a(m)) return m.abort();
        if (typeof m.destroy == "function") return m.destroy();
        A(I || new s("pipe"));
      }
    };
  }
  function f(m) {
    m();
  }
  function c(m, v) {
    return m.pipe(v);
  }
  function l(m) {
    return !m.length || typeof m[m.length - 1] != "function" ? i : m.pop();
  }
  function h() {
    for (var m = arguments.length, v = new Array(m), b = 0; b < m; b++) v[b] = arguments[b];
    var A = l(v);
    if (Array.isArray(v[0]) && (v = v[0]), v.length < 2) throw new r("streams");
    var _, C = v.map(function(I, S) {
      var $ = S < v.length - 1, F = S > 0;
      return o(I, $, F, function(U) {
        _ || (_ = U), U && C.forEach(f), !$ && (C.forEach(f), A(_));
      });
    });
    return v.reduce(c);
  }
  return R2 = h, R2;
}
var XS = ua, SA = od.EventEmitter, Tz = wr;
Tz(ua, SA);
ua.Readable = ZS();
ua.Writable = JS();
ua.Duplex = ku();
ua.Transform = jS();
ua.PassThrough = Mz();
ua.finished = IA();
ua.pipeline = $z();
ua.Stream = ua;
function ua() {
  SA.call(this);
}
ua.prototype.pipe = function(t3, e) {
  var n = this;
  function r(l) {
    t3.writable && t3.write(l) === false && n.pause && n.pause();
  }
  n.on("data", r);
  function s() {
    n.readable && n.resume && n.resume();
  }
  t3.on("drain", s), !t3._isStdio && (!e || e.end !== false) && (n.on("end", a), n.on("close", o));
  var i = false;
  function a() {
    i || (i = true, t3.end());
  }
  function o() {
    i || (i = true, typeof t3.destroy == "function" && t3.destroy());
  }
  function f(l) {
    if (c(), SA.listenerCount(this, "error") === 0) throw l;
  }
  n.on("error", f), t3.on("error", f);
  function c() {
    n.removeListener("data", r), t3.removeListener("drain", s), n.removeListener("end", a), n.removeListener("close", o), n.removeListener("error", f), t3.removeListener("error", f), n.removeListener("end", c), n.removeListener("close", c), t3.removeListener("close", c);
  }
  return n.on("end", c), n.on("close", c), t3.on("close", c), t3.emit("pipe", n), t3;
};
var ja = OK.Buffer, eM = XS.Transform, Dz = wr;
function dl(t3) {
  eM.call(this), this._block = ja.allocUnsafe(t3), this._blockSize = t3, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = false;
}
Dz(dl, eM);
dl.prototype._transform = function(t3, e, n) {
  var r = null;
  try {
    this.update(t3, e);
  } catch (s) {
    r = s;
  }
  n(r);
};
dl.prototype._flush = function(t3) {
  var e = null;
  try {
    this.push(this.digest());
  } catch (n) {
    e = n;
  }
  t3(e);
};
var Rz = typeof Uint8Array < "u", Fz = typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && ArrayBuffer.isView && (ja.prototype instanceof Uint8Array || ja.TYPED_ARRAY_SUPPORT);
function Pz(t3, e) {
  if (t3 instanceof ja) return t3;
  if (typeof t3 == "string") return ja.from(t3, e);
  if (Fz && ArrayBuffer.isView(t3)) {
    if (t3.byteLength === 0) return ja.alloc(0);
    var n = ja.from(t3.buffer, t3.byteOffset, t3.byteLength);
    if (n.byteLength === t3.byteLength) return n;
  }
  if (Rz && t3 instanceof Uint8Array || ja.isBuffer(t3) && t3.constructor && typeof t3.constructor.isBuffer == "function" && t3.constructor.isBuffer(t3)) return ja.from(t3);
  throw new TypeError('The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.');
}
dl.prototype.update = function(t3, e) {
  if (this._finalized) throw new Error("Digest already called");
  t3 = Pz(t3, e);
  for (var n = this._block, r = 0; this._blockOffset + t3.length - r >= this._blockSize; ) {
    for (var s = this._blockOffset; s < this._blockSize; ) n[s++] = t3[r++];
    this._update(), this._blockOffset = 0;
  }
  for (; r < t3.length; ) n[this._blockOffset++] = t3[r++];
  for (var i = 0, a = t3.length * 8; a > 0; ++i) this._length[i] += a, a = this._length[i] / 4294967296 | 0, a > 0 && (this._length[i] -= 4294967296 * a);
  return this;
};
dl.prototype._update = function() {
  throw new Error("_update is not implemented");
};
dl.prototype.digest = function(t3) {
  if (this._finalized) throw new Error("Digest already called");
  this._finalized = true;
  var e = this._digest();
  t3 !== void 0 && (e = e.toString(t3)), this._block.fill(0), this._blockOffset = 0;
  for (var n = 0; n < 4; ++n) this._length[n] = 0;
  return e;
};
dl.prototype._digest = function() {
  throw new Error("_digest is not implemented");
};
var Nz = dl, Uz = wr, tM = Nz, Lz = Tn.Buffer, Oz = new Array(16);
function Fg() {
  tM.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
}
Uz(Fg, tM);
Fg.prototype._update = function() {
  for (var t3 = Oz, e = 0; e < 16; ++e) t3[e] = this._block.readInt32LE(e * 4);
  var n = this._a, r = this._b, s = this._c, i = this._d;
  n = Yi(n, r, s, i, t3[0], 3614090360, 7), i = Yi(i, n, r, s, t3[1], 3905402710, 12), s = Yi(s, i, n, r, t3[2], 606105819, 17), r = Yi(r, s, i, n, t3[3], 3250441966, 22), n = Yi(n, r, s, i, t3[4], 4118548399, 7), i = Yi(i, n, r, s, t3[5], 1200080426, 12), s = Yi(s, i, n, r, t3[6], 2821735955, 17), r = Yi(r, s, i, n, t3[7], 4249261313, 22), n = Yi(n, r, s, i, t3[8], 1770035416, 7), i = Yi(i, n, r, s, t3[9], 2336552879, 12), s = Yi(s, i, n, r, t3[10], 4294925233, 17), r = Yi(r, s, i, n, t3[11], 2304563134, 22), n = Yi(n, r, s, i, t3[12], 1804603682, 7), i = Yi(i, n, r, s, t3[13], 4254626195, 12), s = Yi(s, i, n, r, t3[14], 2792965006, 17), r = Yi(r, s, i, n, t3[15], 1236535329, 22), n = Wi(n, r, s, i, t3[1], 4129170786, 5), i = Wi(i, n, r, s, t3[6], 3225465664, 9), s = Wi(s, i, n, r, t3[11], 643717713, 14), r = Wi(r, s, i, n, t3[0], 3921069994, 20), n = Wi(n, r, s, i, t3[5], 3593408605, 5), i = Wi(i, n, r, s, t3[10], 38016083, 9), s = Wi(s, i, n, r, t3[15], 3634488961, 14), r = Wi(r, s, i, n, t3[4], 3889429448, 20), n = Wi(n, r, s, i, t3[9], 568446438, 5), i = Wi(i, n, r, s, t3[14], 3275163606, 9), s = Wi(s, i, n, r, t3[3], 4107603335, 14), r = Wi(r, s, i, n, t3[8], 1163531501, 20), n = Wi(n, r, s, i, t3[13], 2850285829, 5), i = Wi(i, n, r, s, t3[2], 4243563512, 9), s = Wi(s, i, n, r, t3[7], 1735328473, 14), r = Wi(r, s, i, n, t3[12], 2368359562, 20), n = Ji(n, r, s, i, t3[5], 4294588738, 4), i = Ji(i, n, r, s, t3[8], 2272392833, 11), s = Ji(s, i, n, r, t3[11], 1839030562, 16), r = Ji(r, s, i, n, t3[14], 4259657740, 23), n = Ji(n, r, s, i, t3[1], 2763975236, 4), i = Ji(i, n, r, s, t3[4], 1272893353, 11), s = Ji(s, i, n, r, t3[7], 4139469664, 16), r = Ji(r, s, i, n, t3[10], 3200236656, 23), n = Ji(n, r, s, i, t3[13], 681279174, 4), i = Ji(i, n, r, s, t3[0], 3936430074, 11), s = Ji(s, i, n, r, t3[3], 3572445317, 16), r = Ji(r, s, i, n, t3[6], 76029189, 23), n = Ji(n, r, s, i, t3[9], 3654602809, 4), i = Ji(i, n, r, s, t3[12], 3873151461, 11), s = Ji(s, i, n, r, t3[15], 530742520, 16), r = Ji(r, s, i, n, t3[2], 3299628645, 23), n = Zi(n, r, s, i, t3[0], 4096336452, 6), i = Zi(i, n, r, s, t3[7], 1126891415, 10), s = Zi(s, i, n, r, t3[14], 2878612391, 15), r = Zi(r, s, i, n, t3[5], 4237533241, 21), n = Zi(n, r, s, i, t3[12], 1700485571, 6), i = Zi(i, n, r, s, t3[3], 2399980690, 10), s = Zi(s, i, n, r, t3[10], 4293915773, 15), r = Zi(r, s, i, n, t3[1], 2240044497, 21), n = Zi(n, r, s, i, t3[8], 1873313359, 6), i = Zi(i, n, r, s, t3[15], 4264355552, 10), s = Zi(s, i, n, r, t3[6], 2734768916, 15), r = Zi(r, s, i, n, t3[13], 1309151649, 21), n = Zi(n, r, s, i, t3[4], 4149444226, 6), i = Zi(i, n, r, s, t3[11], 3174756917, 10), s = Zi(s, i, n, r, t3[2], 718787259, 15), r = Zi(r, s, i, n, t3[9], 3951481745, 21), this._a = this._a + n | 0, this._b = this._b + r | 0, this._c = this._c + s | 0, this._d = this._d + i | 0;
};
Fg.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var t3 = Lz.allocUnsafe(16);
  return t3.writeInt32LE(this._a, 0), t3.writeInt32LE(this._b, 4), t3.writeInt32LE(this._c, 8), t3.writeInt32LE(this._d, 12), t3;
};
function Pg(t3, e) {
  return t3 << e | t3 >>> 32 - e;
}
function Yi(t3, e, n, r, s, i, a) {
  return Pg(t3 + (e & n | ~e & r) + s + i | 0, a) + e | 0;
}
function Wi(t3, e, n, r, s, i, a) {
  return Pg(t3 + (e & r | n & ~r) + s + i | 0, a) + e | 0;
}
function Ji(t3, e, n, r, s, i, a) {
  return Pg(t3 + (e ^ n ^ r) + s + i | 0, a) + e | 0;
}
function Zi(t3, e, n, r, s, i, a) {
  return Pg(t3 + (n ^ (e | ~r)) + s + i | 0, a) + e | 0;
}
var MA = Fg, F3 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(t3, e) {
  var n = $n, r = n.Buffer;
  function s(a, o) {
    for (var f in a) o[f] = a[f];
  }
  r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow ? t3.exports = n : (s(n, e), e.Buffer = i);
  function i(a, o, f) {
    return r(a, o, f);
  }
  i.prototype = Object.create(r.prototype), s(r, i), i.from = function(a, o, f) {
    if (typeof a == "number") throw new TypeError("Argument must not be a number");
    return r(a, o, f);
  }, i.alloc = function(a, o, f) {
    if (typeof a != "number") throw new TypeError("Argument must be a number");
    var c = r(a);
    return o !== void 0 ? typeof f == "string" ? c.fill(o, f) : c.fill(o) : c.fill(0), c;
  }, i.allocUnsafe = function(a) {
    if (typeof a != "number") throw new TypeError("Argument must be a number");
    return r(a);
  }, i.allocUnsafeSlow = function(a) {
    if (typeof a != "number") throw new TypeError("Argument must be a number");
    return n.SlowBuffer(a);
  };
})(F3, F3.exports);
var rM = F3.exports, P3 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(t3, e) {
  var n = $n, r = n.Buffer;
  function s(a, o) {
    for (var f in a) o[f] = a[f];
  }
  r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow ? t3.exports = n : (s(n, e), e.Buffer = i);
  function i(a, o, f) {
    return r(a, o, f);
  }
  i.prototype = Object.create(r.prototype), s(r, i), i.from = function(a, o, f) {
    if (typeof a == "number") throw new TypeError("Argument must not be a number");
    return r(a, o, f);
  }, i.alloc = function(a, o, f) {
    if (typeof a != "number") throw new TypeError("Argument must be a number");
    var c = r(a);
    return o !== void 0 ? typeof f == "string" ? c.fill(o, f) : c.fill(o) : c.fill(0), c;
  }, i.allocUnsafe = function(a) {
    if (typeof a != "number") throw new TypeError("Argument must be a number");
    return r(a);
  }, i.allocUnsafeSlow = function(a) {
    if (typeof a != "number") throw new TypeError("Argument must be a number");
    return n.SlowBuffer(a);
  };
})(P3, P3.exports);
var Qz = P3.exports, Kz = {}.toString, Hz = Array.isArray || function(t3) {
  return Kz.call(t3) == "[object Array]";
}, qz = Wu, zz = Zu, Gz = zz("TypedArray.prototype.buffer", true), Vz = GS(), Yz = Gz || function(e) {
  if (!Vz(e)) throw new qz("Not a Typed Array");
  return e.buffer;
}, wa = Qz.Buffer, Wz = Hz, Jz = Yz, Zz = ArrayBuffer.isView || function(e) {
  try {
    return Jz(e), true;
  } catch {
    return false;
  }
}, jz = typeof Uint8Array < "u", nM = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", Xz = nM && (wa.prototype instanceof Uint8Array || wa.TYPED_ARRAY_SUPPORT), Ng = function(e, n) {
  if (wa.isBuffer(e)) return e.constructor && !("isBuffer" in e) ? wa.from(e) : e;
  if (typeof e == "string") return wa.from(e, n);
  if (nM && Zz(e)) {
    if (e.byteLength === 0) return wa.alloc(0);
    if (Xz) {
      var r = wa.from(e.buffer, e.byteOffset, e.byteLength);
      if (r.byteLength === e.byteLength) return r;
    }
    var s = e instanceof Uint8Array ? e : new Uint8Array(e.buffer, e.byteOffset, e.byteLength), i = wa.from(s);
    if (i.length === e.byteLength) return i;
  }
  if (jz && e instanceof Uint8Array) return wa.from(e);
  var a = Wz(e);
  if (a) for (var o = 0; o < e.length; o += 1) {
    var f = e[o];
    if (typeof f != "number" || f < 0 || f > 255 || ~~f !== f) throw new RangeError("Array items must be numbers in the range 0-255.");
  }
  if (a || wa.isBuffer(e) && e.constructor && typeof e.constructor.isBuffer == "function" && e.constructor.isBuffer(e)) return wa.from(e);
  throw new TypeError('The "data" argument must be a string, an Array, a Buffer, a Uint8Array, or a DataView.');
}, eG = rM.Buffer, tG = Ng, iM = typeof Uint8Array < "u", rG = iM && typeof ArrayBuffer < "u", aw = rG && ArrayBuffer.isView, nG = function(t3, e) {
  if (typeof t3 == "string" || eG.isBuffer(t3) || iM && t3 instanceof Uint8Array || aw && aw(t3)) return tG(t3, e);
  throw new TypeError('The "data" argument must be a string, a Buffer, a Uint8Array, or a DataView');
}, N3 = { exports: {} }, U3 = { exports: {} };
typeof jt > "u" || !jt.version || jt.version.indexOf("v0.") === 0 || jt.version.indexOf("v1.") === 0 && jt.version.indexOf("v1.8.") !== 0 ? U3.exports = { nextTick: iG } : U3.exports = jt;
function iG(t3, e, n, r) {
  if (typeof t3 != "function") throw new TypeError('"callback" argument must be a function');
  var s = arguments.length, i, a;
  switch (s) {
    case 0:
    case 1:
      return jt.nextTick(t3);
    case 2:
      return jt.nextTick(function() {
        t3.call(null, e);
      });
    case 3:
      return jt.nextTick(function() {
        t3.call(null, e, n);
      });
    case 4:
      return jt.nextTick(function() {
        t3.call(null, e, n, r);
      });
    default:
      for (i = new Array(s - 1), a = 0; a < i.length; ) i[a++] = arguments[a];
      return jt.nextTick(function() {
        t3.apply(null, i);
      });
  }
}
var Ug = U3.exports, sG = {}.toString, aG = Array.isArray || function(t3) {
  return sG.call(t3) == "[object Array]";
}, sM = od.EventEmitter, ai = {};
function oG(t3) {
  return Array.isArray ? Array.isArray(t3) : Lg(t3) === "[object Array]";
}
ai.isArray = oG;
function fG(t3) {
  return typeof t3 == "boolean";
}
ai.isBoolean = fG;
function lG(t3) {
  return t3 === null;
}
ai.isNull = lG;
function uG(t3) {
  return t3 == null;
}
ai.isNullOrUndefined = uG;
function cG(t3) {
  return typeof t3 == "number";
}
ai.isNumber = cG;
function hG(t3) {
  return typeof t3 == "string";
}
ai.isString = hG;
function dG(t3) {
  return typeof t3 == "symbol";
}
ai.isSymbol = dG;
function pG(t3) {
  return t3 === void 0;
}
ai.isUndefined = pG;
function gG(t3) {
  return Lg(t3) === "[object RegExp]";
}
ai.isRegExp = gG;
function mG(t3) {
  return typeof t3 == "object" && t3 !== null;
}
ai.isObject = mG;
function vG(t3) {
  return Lg(t3) === "[object Date]";
}
ai.isDate = vG;
function yG(t3) {
  return Lg(t3) === "[object Error]" || t3 instanceof Error;
}
ai.isError = yG;
function bG(t3) {
  return typeof t3 == "function";
}
ai.isFunction = bG;
function AG(t3) {
  return t3 === null || typeof t3 == "boolean" || typeof t3 == "number" || typeof t3 == "string" || typeof t3 == "symbol" || typeof t3 > "u";
}
ai.isPrimitive = AG;
ai.isBuffer = $n.Buffer.isBuffer;
function Lg(t3) {
  return Object.prototype.toString.call(t3);
}
var F2 = { exports: {} }, ow;
function wG() {
  return ow || (ow = 1, function(t3) {
    function e(i, a) {
      if (!(i instanceof a)) throw new TypeError("Cannot call a class as a function");
    }
    var n = Tn.Buffer, r = fd;
    function s(i, a, o) {
      i.copy(a, o);
    }
    t3.exports = function() {
      function i() {
        e(this, i), this.head = null, this.tail = null, this.length = 0;
      }
      return i.prototype.push = function(o) {
        var f = { data: o, next: null };
        this.length > 0 ? this.tail.next = f : this.head = f, this.tail = f, ++this.length;
      }, i.prototype.unshift = function(o) {
        var f = { data: o, next: this.head };
        this.length === 0 && (this.tail = f), this.head = f, ++this.length;
      }, i.prototype.shift = function() {
        if (this.length !== 0) {
          var o = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, o;
        }
      }, i.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, i.prototype.join = function(o) {
        if (this.length === 0) return "";
        for (var f = this.head, c = "" + f.data; f = f.next; ) c += o + f.data;
        return c;
      }, i.prototype.concat = function(o) {
        if (this.length === 0) return n.alloc(0);
        for (var f = n.allocUnsafe(o >>> 0), c = this.head, l = 0; c; ) s(c.data, f, l), l += c.data.length, c = c.next;
        return f;
      }, i;
    }(), r && r.inspect && r.inspect.custom && (t3.exports.prototype[r.inspect.custom] = function() {
      var i = r.inspect({ length: this.length });
      return this.constructor.name + " " + i;
    });
  }(F2)), F2.exports;
}
var Zd = Ug;
function xG(t3, e) {
  var n = this, r = this._readableState && this._readableState.destroyed, s = this._writableState && this._writableState.destroyed;
  return r || s ? (e ? e(t3) : t3 && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, Zd.nextTick(jd, this, t3)) : Zd.nextTick(jd, this, t3)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t3 || null, function(i) {
    !e && i ? n._writableState ? n._writableState.errorEmitted || (n._writableState.errorEmitted = true, Zd.nextTick(jd, n, i)) : Zd.nextTick(jd, n, i) : e && e(i);
  }), this);
}
function _G() {
  this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
}
function jd(t3, e) {
  t3.emit("error", e);
}
var aM = { destroy: xG, undestroy: _G }, P2, fw;
function oM() {
  if (fw) return P2;
  fw = 1;
  var t3 = Ug;
  P2 = A;
  function e(E) {
    var M = this;
    this.next = null, this.entry = null, this.finish = function() {
      w(M, E);
    };
  }
  var n = !jt.browser && ["v0.10", "v0.9."].indexOf(jt.version.slice(0, 5)) > -1 ? setImmediate : t3.nextTick, r;
  A.WritableState = v;
  var s = Object.create(ai);
  s.inherits = wr;
  var i = { deprecate: WS }, a = sM, o = Tn.Buffer, f = (typeof mt < "u" ? mt : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function c(E) {
    return o.from(E);
  }
  function l(E) {
    return o.isBuffer(E) || E instanceof f;
  }
  var h = aM;
  s.inherits(A, a);
  function m() {
  }
  function v(E, M) {
    r = r || Su(), E = E || {};
    var x = M instanceof r;
    this.objectMode = !!E.objectMode, x && (this.objectMode = this.objectMode || !!E.writableObjectMode);
    var g = E.highWaterMark, k = E.writableHighWaterMark, T = this.objectMode ? 16 : 16 * 1024;
    g || g === 0 ? this.highWaterMark = g : x && (k || k === 0) ? this.highWaterMark = k : this.highWaterMark = T, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
    var O = E.decodeStrings === false;
    this.decodeStrings = !O, this.defaultEncoding = E.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(K) {
      Q(M, K);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e(this);
  }
  v.prototype.getBuffer = function() {
    for (var M = this.bufferedRequest, x = []; M; ) x.push(M), M = M.next;
    return x;
  }, function() {
    try {
      Object.defineProperty(v.prototype, "buffer", { get: i.deprecate(function() {
        return this.getBuffer();
      }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
    } catch {
    }
  }();
  var b;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (b = Function.prototype[Symbol.hasInstance], Object.defineProperty(A, Symbol.hasInstance, { value: function(E) {
    return b.call(this, E) ? true : this !== A ? false : E && E._writableState instanceof v;
  } })) : b = function(E) {
    return E instanceof this;
  };
  function A(E) {
    if (r = r || Su(), !b.call(A, this) && !(this instanceof r)) return new A(E);
    this._writableState = new v(E, this), this.writable = true, E && (typeof E.write == "function" && (this._write = E.write), typeof E.writev == "function" && (this._writev = E.writev), typeof E.destroy == "function" && (this._destroy = E.destroy), typeof E.final == "function" && (this._final = E.final)), a.call(this);
  }
  A.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function _(E, M) {
    var x = new Error("write after end");
    E.emit("error", x), t3.nextTick(M, x);
  }
  function C(E, M, x, g) {
    var k = true, T = false;
    return x === null ? T = new TypeError("May not write null values to stream") : typeof x != "string" && x !== void 0 && !M.objectMode && (T = new TypeError("Invalid non-string/buffer chunk")), T && (E.emit("error", T), t3.nextTick(g, T), k = false), k;
  }
  A.prototype.write = function(E, M, x) {
    var g = this._writableState, k = false, T = !g.objectMode && l(E);
    return T && !o.isBuffer(E) && (E = c(E)), typeof M == "function" && (x = M, M = null), T ? M = "buffer" : M || (M = g.defaultEncoding), typeof x != "function" && (x = m), g.ended ? _(this, x) : (T || C(this, g, E, x)) && (g.pendingcb++, k = S(this, g, T, E, M, x)), k;
  }, A.prototype.cork = function() {
    var E = this._writableState;
    E.corked++;
  }, A.prototype.uncork = function() {
    var E = this._writableState;
    E.corked && (E.corked--, !E.writing && !E.corked && !E.bufferProcessing && E.bufferedRequest && L(this, E));
  }, A.prototype.setDefaultEncoding = function(M) {
    if (typeof M == "string" && (M = M.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((M + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + M);
    return this._writableState.defaultEncoding = M, this;
  };
  function I(E, M, x) {
    return !E.objectMode && E.decodeStrings !== false && typeof M == "string" && (M = o.from(M, x)), M;
  }
  Object.defineProperty(A.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
    return this._writableState.highWaterMark;
  } });
  function S(E, M, x, g, k, T) {
    if (!x) {
      var O = I(M, g, k);
      g !== O && (x = true, k = "buffer", g = O);
    }
    var K = M.objectMode ? 1 : g.length;
    M.length += K;
    var Y = M.length < M.highWaterMark;
    if (Y || (M.needDrain = true), M.writing || M.corked) {
      var J = M.lastBufferedRequest;
      M.lastBufferedRequest = { chunk: g, encoding: k, isBuf: x, callback: T, next: null }, J ? J.next = M.lastBufferedRequest : M.bufferedRequest = M.lastBufferedRequest, M.bufferedRequestCount += 1;
    } else $(E, M, false, K, g, k, T);
    return Y;
  }
  function $(E, M, x, g, k, T, O) {
    M.writelen = g, M.writecb = O, M.writing = true, M.sync = true, x ? E._writev(k, M.onwrite) : E._write(k, T, M.onwrite), M.sync = false;
  }
  function F(E, M, x, g, k) {
    --M.pendingcb, x ? (t3.nextTick(k, g), t3.nextTick(d, E, M), E._writableState.errorEmitted = true, E.emit("error", g)) : (k(g), E._writableState.errorEmitted = true, E.emit("error", g), d(E, M));
  }
  function U(E) {
    E.writing = false, E.writecb = null, E.length -= E.writelen, E.writelen = 0;
  }
  function Q(E, M) {
    var x = E._writableState, g = x.sync, k = x.writecb;
    if (U(x), M) F(E, x, g, M, k);
    else {
      var T = B(x);
      !T && !x.corked && !x.bufferProcessing && x.bufferedRequest && L(E, x), g ? n(P, E, x, T, k) : P(E, x, T, k);
    }
  }
  function P(E, M, x, g) {
    x || N(E, M), M.pendingcb--, g(), d(E, M);
  }
  function N(E, M) {
    M.length === 0 && M.needDrain && (M.needDrain = false, E.emit("drain"));
  }
  function L(E, M) {
    M.bufferProcessing = true;
    var x = M.bufferedRequest;
    if (E._writev && x && x.next) {
      var g = M.bufferedRequestCount, k = new Array(g), T = M.corkedRequestsFree;
      T.entry = x;
      for (var O = 0, K = true; x; ) k[O] = x, x.isBuf || (K = false), x = x.next, O += 1;
      k.allBuffers = K, $(E, M, true, M.length, k, "", T.finish), M.pendingcb++, M.lastBufferedRequest = null, T.next ? (M.corkedRequestsFree = T.next, T.next = null) : M.corkedRequestsFree = new e(M), M.bufferedRequestCount = 0;
    } else {
      for (; x; ) {
        var Y = x.chunk, J = x.encoding, G = x.callback, X = M.objectMode ? 1 : Y.length;
        if ($(E, M, false, X, Y, J, G), x = x.next, M.bufferedRequestCount--, M.writing) break;
      }
      x === null && (M.lastBufferedRequest = null);
    }
    M.bufferedRequest = x, M.bufferProcessing = false;
  }
  A.prototype._write = function(E, M, x) {
    x(new Error("_write() is not implemented"));
  }, A.prototype._writev = null, A.prototype.end = function(E, M, x) {
    var g = this._writableState;
    typeof E == "function" ? (x = E, E = null, M = null) : typeof M == "function" && (x = M, M = null), E != null && this.write(E, M), g.corked && (g.corked = 1, this.uncork()), g.ending || y(this, g, x);
  };
  function B(E) {
    return E.ending && E.length === 0 && E.bufferedRequest === null && !E.finished && !E.writing;
  }
  function u(E, M) {
    E._final(function(x) {
      M.pendingcb--, x && E.emit("error", x), M.prefinished = true, E.emit("prefinish"), d(E, M);
    });
  }
  function p(E, M) {
    !M.prefinished && !M.finalCalled && (typeof E._final == "function" ? (M.pendingcb++, M.finalCalled = true, t3.nextTick(u, E, M)) : (M.prefinished = true, E.emit("prefinish")));
  }
  function d(E, M) {
    var x = B(M);
    return x && (p(E, M), M.pendingcb === 0 && (M.finished = true, E.emit("finish"))), x;
  }
  function y(E, M, x) {
    M.ending = true, d(E, M), x && (M.finished ? t3.nextTick(x) : E.once("finish", x)), M.ended = true, E.writable = false;
  }
  function w(E, M, x) {
    var g = E.entry;
    for (E.entry = null; g; ) {
      var k = g.callback;
      M.pendingcb--, k(x), g = g.next;
    }
    M.corkedRequestsFree.next = E;
  }
  return Object.defineProperty(A.prototype, "destroyed", { get: function() {
    return this._writableState === void 0 ? false : this._writableState.destroyed;
  }, set: function(E) {
    this._writableState && (this._writableState.destroyed = E);
  } }), A.prototype.destroy = h.destroy, A.prototype._undestroy = h.undestroy, A.prototype._destroy = function(E, M) {
    this.end(), M(E);
  }, P2;
}
var N2, lw;
function Su() {
  if (lw) return N2;
  lw = 1;
  var t3 = Ug, e = Object.keys || function(h) {
    var m = [];
    for (var v in h) m.push(v);
    return m;
  };
  N2 = f;
  var n = Object.create(ai);
  n.inherits = wr;
  var r = fM(), s = oM();
  n.inherits(f, r);
  for (var i = e(s.prototype), a = 0; a < i.length; a++) {
    var o = i[a];
    f.prototype[o] || (f.prototype[o] = s.prototype[o]);
  }
  function f(h) {
    if (!(this instanceof f)) return new f(h);
    r.call(this, h), s.call(this, h), h && h.readable === false && (this.readable = false), h && h.writable === false && (this.writable = false), this.allowHalfOpen = true, h && h.allowHalfOpen === false && (this.allowHalfOpen = false), this.once("end", c);
  }
  Object.defineProperty(f.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
    return this._writableState.highWaterMark;
  } });
  function c() {
    this.allowHalfOpen || this._writableState.ended || t3.nextTick(l, this);
  }
  function l(h) {
    h.end();
  }
  return Object.defineProperty(f.prototype, "destroyed", { get: function() {
    return this._readableState === void 0 || this._writableState === void 0 ? false : this._readableState.destroyed && this._writableState.destroyed;
  }, set: function(h) {
    this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = h, this._writableState.destroyed = h);
  } }), f.prototype._destroy = function(h, m) {
    this.push(null), this.end(), t3.nextTick(m, h);
  }, N2;
}
var U2, uw;
function fM() {
  if (uw) return U2;
  uw = 1;
  var t3 = Ug;
  U2 = I;
  var e = aG, n;
  I.ReadableState = C, od.EventEmitter;
  var r = function(G, X) {
    return G.listeners(X).length;
  }, s = sM, i = Tn.Buffer, a = (typeof mt < "u" ? mt : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function o(G) {
    return i.from(G);
  }
  function f(G) {
    return i.isBuffer(G) || G instanceof a;
  }
  var c = Object.create(ai);
  c.inherits = wr;
  var l = fd, h = void 0;
  l && l.debuglog ? h = l.debuglog("stream") : h = function() {
  };
  var m = wG(), v = aM, b;
  c.inherits(I, s);
  var A = ["error", "close", "destroy", "pause", "resume"];
  function _(G, X, ie) {
    if (typeof G.prependListener == "function") return G.prependListener(X, ie);
    !G._events || !G._events[X] ? G.on(X, ie) : e(G._events[X]) ? G._events[X].unshift(ie) : G._events[X] = [ie, G._events[X]];
  }
  function C(G, X) {
    n = n || Su(), G = G || {};
    var ie = X instanceof n;
    this.objectMode = !!G.objectMode, ie && (this.objectMode = this.objectMode || !!G.readableObjectMode);
    var de = G.highWaterMark, se = G.readableHighWaterMark, te = this.objectMode ? 16 : 16 * 1024;
    de || de === 0 ? this.highWaterMark = de : ie && (se || se === 0) ? this.highWaterMark = se : this.highWaterMark = te, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new m(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.destroyed = false, this.defaultEncoding = G.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, G.encoding && (b || (b = Iu.StringDecoder), this.decoder = new b(G.encoding), this.encoding = G.encoding);
  }
  function I(G) {
    if (n = n || Su(), !(this instanceof I)) return new I(G);
    this._readableState = new C(G, this), this.readable = true, G && (typeof G.read == "function" && (this._read = G.read), typeof G.destroy == "function" && (this._destroy = G.destroy)), s.call(this);
  }
  Object.defineProperty(I.prototype, "destroyed", { get: function() {
    return this._readableState === void 0 ? false : this._readableState.destroyed;
  }, set: function(G) {
    this._readableState && (this._readableState.destroyed = G);
  } }), I.prototype.destroy = v.destroy, I.prototype._undestroy = v.undestroy, I.prototype._destroy = function(G, X) {
    this.push(null), X(G);
  }, I.prototype.push = function(G, X) {
    var ie = this._readableState, de;
    return ie.objectMode ? de = true : typeof G == "string" && (X = X || ie.defaultEncoding, X !== ie.encoding && (G = i.from(G, X), X = ""), de = true), S(this, G, X, false, de);
  }, I.prototype.unshift = function(G) {
    return S(this, G, null, true, false);
  };
  function S(G, X, ie, de, se) {
    var te = G._readableState;
    if (X === null) te.reading = false, L(G, te);
    else {
      var le;
      se || (le = F(te, X)), le ? G.emit("error", le) : te.objectMode || X && X.length > 0 ? (typeof X != "string" && !te.objectMode && Object.getPrototypeOf(X) !== i.prototype && (X = o(X)), de ? te.endEmitted ? G.emit("error", new Error("stream.unshift() after end event")) : $(G, te, X, true) : te.ended ? G.emit("error", new Error("stream.push() after EOF")) : (te.reading = false, te.decoder && !ie ? (X = te.decoder.write(X), te.objectMode || X.length !== 0 ? $(G, te, X, false) : p(G, te)) : $(G, te, X, false))) : de || (te.reading = false);
    }
    return U(te);
  }
  function $(G, X, ie, de) {
    X.flowing && X.length === 0 && !X.sync ? (G.emit("data", ie), G.read(0)) : (X.length += X.objectMode ? 1 : ie.length, de ? X.buffer.unshift(ie) : X.buffer.push(ie), X.needReadable && B(G)), p(G, X);
  }
  function F(G, X) {
    var ie;
    return !f(X) && typeof X != "string" && X !== void 0 && !G.objectMode && (ie = new TypeError("Invalid non-string/buffer chunk")), ie;
  }
  function U(G) {
    return !G.ended && (G.needReadable || G.length < G.highWaterMark || G.length === 0);
  }
  I.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  }, I.prototype.setEncoding = function(G) {
    return b || (b = Iu.StringDecoder), this._readableState.decoder = new b(G), this._readableState.encoding = G, this;
  };
  var Q = 8388608;
  function P(G) {
    return G >= Q ? G = Q : (G--, G |= G >>> 1, G |= G >>> 2, G |= G >>> 4, G |= G >>> 8, G |= G >>> 16, G++), G;
  }
  function N(G, X) {
    return G <= 0 || X.length === 0 && X.ended ? 0 : X.objectMode ? 1 : G !== G ? X.flowing && X.length ? X.buffer.head.data.length : X.length : (G > X.highWaterMark && (X.highWaterMark = P(G)), G <= X.length ? G : X.ended ? X.length : (X.needReadable = true, 0));
  }
  I.prototype.read = function(G) {
    h("read", G), G = parseInt(G, 10);
    var X = this._readableState, ie = G;
    if (G !== 0 && (X.emittedReadable = false), G === 0 && X.needReadable && (X.length >= X.highWaterMark || X.ended)) return h("read: emitReadable", X.length, X.ended), X.length === 0 && X.ended ? K(this) : B(this), null;
    if (G = N(G, X), G === 0 && X.ended) return X.length === 0 && K(this), null;
    var de = X.needReadable;
    h("need readable", de), (X.length === 0 || X.length - G < X.highWaterMark) && (de = true, h("length less than watermark", de)), X.ended || X.reading ? (de = false, h("reading or ended", de)) : de && (h("do read"), X.reading = true, X.sync = true, X.length === 0 && (X.needReadable = true), this._read(X.highWaterMark), X.sync = false, X.reading || (G = N(ie, X)));
    var se;
    return G > 0 ? se = g(G, X) : se = null, se === null ? (X.needReadable = true, G = 0) : X.length -= G, X.length === 0 && (X.ended || (X.needReadable = true), ie !== G && X.ended && K(this)), se !== null && this.emit("data", se), se;
  };
  function L(G, X) {
    if (!X.ended) {
      if (X.decoder) {
        var ie = X.decoder.end();
        ie && ie.length && (X.buffer.push(ie), X.length += X.objectMode ? 1 : ie.length);
      }
      X.ended = true, B(G);
    }
  }
  function B(G) {
    var X = G._readableState;
    X.needReadable = false, X.emittedReadable || (h("emitReadable", X.flowing), X.emittedReadable = true, X.sync ? t3.nextTick(u, G) : u(G));
  }
  function u(G) {
    h("emit readable"), G.emit("readable"), x(G);
  }
  function p(G, X) {
    X.readingMore || (X.readingMore = true, t3.nextTick(d, G, X));
  }
  function d(G, X) {
    for (var ie = X.length; !X.reading && !X.flowing && !X.ended && X.length < X.highWaterMark && (h("maybeReadMore read 0"), G.read(0), ie !== X.length); ) ie = X.length;
    X.readingMore = false;
  }
  I.prototype._read = function(G) {
    this.emit("error", new Error("_read() is not implemented"));
  }, I.prototype.pipe = function(G, X) {
    var ie = this, de = this._readableState;
    switch (de.pipesCount) {
      case 0:
        de.pipes = G;
        break;
      case 1:
        de.pipes = [de.pipes, G];
        break;
      default:
        de.pipes.push(G);
        break;
    }
    de.pipesCount += 1, h("pipe count=%d opts=%j", de.pipesCount, X);
    var se = (!X || X.end !== false) && G !== jt.stdout && G !== jt.stderr, te = se ? Z : Ne;
    de.endEmitted ? t3.nextTick(te) : ie.once("end", te), G.on("unpipe", le);
    function le($e, Re) {
      h("onunpipe"), $e === ie && Re && Re.hasUnpiped === false && (Re.hasUnpiped = true, me());
    }
    function Z() {
      h("onend"), G.end();
    }
    var ve = y(ie);
    G.on("drain", ve);
    var he = false;
    function me() {
      h("cleanup"), G.removeListener("close", Se), G.removeListener("finish", Ce), G.removeListener("drain", ve), G.removeListener("error", Oe), G.removeListener("unpipe", le), ie.removeListener("end", Z), ie.removeListener("end", Ne), ie.removeListener("data", ye), he = true, de.awaitDrain && (!G._writableState || G._writableState.needDrain) && ve();
    }
    var ce = false;
    ie.on("data", ye);
    function ye($e) {
      h("ondata"), ce = false;
      var Re = G.write($e);
      Re === false && !ce && ((de.pipesCount === 1 && de.pipes === G || de.pipesCount > 1 && J(de.pipes, G) !== -1) && !he && (h("false write response, pause", de.awaitDrain), de.awaitDrain++, ce = true), ie.pause());
    }
    function Oe($e) {
      h("onerror", $e), Ne(), G.removeListener("error", Oe), r(G, "error") === 0 && G.emit("error", $e);
    }
    _(G, "error", Oe);
    function Se() {
      G.removeListener("finish", Ce), Ne();
    }
    G.once("close", Se);
    function Ce() {
      h("onfinish"), G.removeListener("close", Se), Ne();
    }
    G.once("finish", Ce);
    function Ne() {
      h("unpipe"), ie.unpipe(G);
    }
    return G.emit("pipe", ie), de.flowing || (h("pipe resume"), ie.resume()), G;
  };
  function y(G) {
    return function() {
      var X = G._readableState;
      h("pipeOnDrain", X.awaitDrain), X.awaitDrain && X.awaitDrain--, X.awaitDrain === 0 && r(G, "data") && (X.flowing = true, x(G));
    };
  }
  I.prototype.unpipe = function(G) {
    var X = this._readableState, ie = { hasUnpiped: false };
    if (X.pipesCount === 0) return this;
    if (X.pipesCount === 1) return G && G !== X.pipes ? this : (G || (G = X.pipes), X.pipes = null, X.pipesCount = 0, X.flowing = false, G && G.emit("unpipe", this, ie), this);
    if (!G) {
      var de = X.pipes, se = X.pipesCount;
      X.pipes = null, X.pipesCount = 0, X.flowing = false;
      for (var te = 0; te < se; te++) de[te].emit("unpipe", this, { hasUnpiped: false });
      return this;
    }
    var le = J(X.pipes, G);
    return le === -1 ? this : (X.pipes.splice(le, 1), X.pipesCount -= 1, X.pipesCount === 1 && (X.pipes = X.pipes[0]), G.emit("unpipe", this, ie), this);
  }, I.prototype.on = function(G, X) {
    var ie = s.prototype.on.call(this, G, X);
    if (G === "data") this._readableState.flowing !== false && this.resume();
    else if (G === "readable") {
      var de = this._readableState;
      !de.endEmitted && !de.readableListening && (de.readableListening = de.needReadable = true, de.emittedReadable = false, de.reading ? de.length && B(this) : t3.nextTick(w, this));
    }
    return ie;
  }, I.prototype.addListener = I.prototype.on;
  function w(G) {
    h("readable nexttick read 0"), G.read(0);
  }
  I.prototype.resume = function() {
    var G = this._readableState;
    return G.flowing || (h("resume"), G.flowing = true, E(this, G)), this;
  };
  function E(G, X) {
    X.resumeScheduled || (X.resumeScheduled = true, t3.nextTick(M, G, X));
  }
  function M(G, X) {
    X.reading || (h("resume read 0"), G.read(0)), X.resumeScheduled = false, X.awaitDrain = 0, G.emit("resume"), x(G), X.flowing && !X.reading && G.read(0);
  }
  I.prototype.pause = function() {
    return h("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (h("pause"), this._readableState.flowing = false, this.emit("pause")), this;
  };
  function x(G) {
    var X = G._readableState;
    for (h("flow", X.flowing); X.flowing && G.read() !== null; ) ;
  }
  I.prototype.wrap = function(G) {
    var X = this, ie = this._readableState, de = false;
    G.on("end", function() {
      if (h("wrapped end"), ie.decoder && !ie.ended) {
        var le = ie.decoder.end();
        le && le.length && X.push(le);
      }
      X.push(null);
    }), G.on("data", function(le) {
      if (h("wrapped data"), ie.decoder && (le = ie.decoder.write(le)), !(ie.objectMode && le == null) && !(!ie.objectMode && (!le || !le.length))) {
        var Z = X.push(le);
        Z || (de = true, G.pause());
      }
    });
    for (var se in G) this[se] === void 0 && typeof G[se] == "function" && (this[se] = /* @__PURE__ */ function(le) {
      return function() {
        return G[le].apply(G, arguments);
      };
    }(se));
    for (var te = 0; te < A.length; te++) G.on(A[te], this.emit.bind(this, A[te]));
    return this._read = function(le) {
      h("wrapped _read", le), de && (de = false, G.resume());
    }, this;
  }, Object.defineProperty(I.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
    return this._readableState.highWaterMark;
  } }), I._fromList = g;
  function g(G, X) {
    if (X.length === 0) return null;
    var ie;
    return X.objectMode ? ie = X.buffer.shift() : !G || G >= X.length ? (X.decoder ? ie = X.buffer.join("") : X.buffer.length === 1 ? ie = X.buffer.head.data : ie = X.buffer.concat(X.length), X.buffer.clear()) : ie = k(G, X.buffer, X.decoder), ie;
  }
  function k(G, X, ie) {
    var de;
    return G < X.head.data.length ? (de = X.head.data.slice(0, G), X.head.data = X.head.data.slice(G)) : G === X.head.data.length ? de = X.shift() : de = ie ? T(G, X) : O(G, X), de;
  }
  function T(G, X) {
    var ie = X.head, de = 1, se = ie.data;
    for (G -= se.length; ie = ie.next; ) {
      var te = ie.data, le = G > te.length ? te.length : G;
      if (le === te.length ? se += te : se += te.slice(0, G), G -= le, G === 0) {
        le === te.length ? (++de, ie.next ? X.head = ie.next : X.head = X.tail = null) : (X.head = ie, ie.data = te.slice(le));
        break;
      }
      ++de;
    }
    return X.length -= de, se;
  }
  function O(G, X) {
    var ie = i.allocUnsafe(G), de = X.head, se = 1;
    for (de.data.copy(ie), G -= de.data.length; de = de.next; ) {
      var te = de.data, le = G > te.length ? te.length : G;
      if (te.copy(ie, ie.length - G, 0, le), G -= le, G === 0) {
        le === te.length ? (++se, de.next ? X.head = de.next : X.head = X.tail = null) : (X.head = de, de.data = te.slice(le));
        break;
      }
      ++se;
    }
    return X.length -= se, ie;
  }
  function K(G) {
    var X = G._readableState;
    if (X.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    X.endEmitted || (X.ended = true, t3.nextTick(Y, X, G));
  }
  function Y(G, X) {
    !G.endEmitted && G.length === 0 && (G.endEmitted = true, X.readable = false, X.emit("end"));
  }
  function J(G, X) {
    for (var ie = 0, de = G.length; ie < de; ie++) if (G[ie] === X) return ie;
    return -1;
  }
  return U2;
}
var lM = sf, Og = Su(), uM = Object.create(ai);
uM.inherits = wr;
uM.inherits(sf, Og);
function EG(t3, e) {
  var n = this._transformState;
  n.transforming = false;
  var r = n.writecb;
  if (!r) return this.emit("error", new Error("write callback called multiple times"));
  n.writechunk = null, n.writecb = null, e != null && this.push(e), r(t3);
  var s = this._readableState;
  s.reading = false, (s.needReadable || s.length < s.highWaterMark) && this._read(s.highWaterMark);
}
function sf(t3) {
  if (!(this instanceof sf)) return new sf(t3);
  Og.call(this, t3), this._transformState = { afterTransform: EG.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, t3 && (typeof t3.transform == "function" && (this._transform = t3.transform), typeof t3.flush == "function" && (this._flush = t3.flush)), this.on("prefinish", BG);
}
function BG() {
  var t3 = this;
  typeof this._flush == "function" ? this._flush(function(e, n) {
    cw(t3, e, n);
  }) : cw(this, null, null);
}
sf.prototype.push = function(t3, e) {
  return this._transformState.needTransform = false, Og.prototype.push.call(this, t3, e);
};
sf.prototype._transform = function(t3, e, n) {
  throw new Error("_transform() is not implemented");
};
sf.prototype._write = function(t3, e, n) {
  var r = this._transformState;
  if (r.writecb = n, r.writechunk = t3, r.writeencoding = e, !r.transforming) {
    var s = this._readableState;
    (r.needTransform || s.needReadable || s.length < s.highWaterMark) && this._read(s.highWaterMark);
  }
};
sf.prototype._read = function(t3) {
  var e = this._transformState;
  e.writechunk !== null && e.writecb && !e.transforming ? (e.transforming = true, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = true;
};
sf.prototype._destroy = function(t3, e) {
  var n = this;
  Og.prototype._destroy.call(this, t3, function(r) {
    e(r), n.emit("close");
  });
};
function cw(t3, e, n) {
  if (e) return t3.emit("error", e);
  if (n != null && t3.push(n), t3._writableState.length) throw new Error("Calling transform done when ws.length != 0");
  if (t3._transformState.transforming) throw new Error("Calling transform done when still transforming");
  return t3.push(null);
}
var CG = Rh, cM = lM, hM = Object.create(ai);
hM.inherits = wr;
hM.inherits(Rh, cM);
function Rh(t3) {
  if (!(this instanceof Rh)) return new Rh(t3);
  cM.call(this, t3);
}
Rh.prototype._transform = function(t3, e, n) {
  n(null, t3);
};
(function(t3, e) {
  e = t3.exports = fM(), e.Stream = e, e.Readable = e, e.Writable = oM(), e.Duplex = Su(), e.Transform = lM, e.PassThrough = CG;
})(N3, N3.exports);
var dM = N3.exports, kG = rM.Buffer, IG = nG, pM = dM.Transform, SG = wr;
function pl(t3) {
  pM.call(this), this._block = kG.allocUnsafe(t3), this._blockSize = t3, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = false;
}
SG(pl, pM);
pl.prototype._transform = function(t3, e, n) {
  var r = null;
  try {
    this.update(t3, e);
  } catch (s) {
    r = s;
  }
  n(r);
};
pl.prototype._flush = function(t3) {
  var e = null;
  try {
    this.push(this.digest());
  } catch (n) {
    e = n;
  }
  t3(e);
};
pl.prototype.update = function(t3, e) {
  if (this._finalized) throw new Error("Digest already called");
  for (var n = IG(t3, e), r = this._block, s = 0; this._blockOffset + n.length - s >= this._blockSize; ) {
    for (var i = this._blockOffset; i < this._blockSize; ) r[i] = n[s], i += 1, s += 1;
    this._update(), this._blockOffset = 0;
  }
  for (; s < n.length; ) r[this._blockOffset] = n[s], this._blockOffset += 1, s += 1;
  for (var a = 0, o = n.length * 8; o > 0; ++a) this._length[a] += o, o = this._length[a] / 4294967296 | 0, o > 0 && (this._length[a] -= 4294967296 * o);
  return this;
};
pl.prototype._update = function() {
  throw new Error("_update is not implemented");
};
pl.prototype.digest = function(t3) {
  if (this._finalized) throw new Error("Digest already called");
  this._finalized = true;
  var e = this._digest();
  t3 !== void 0 && (e = e.toString(t3)), this._block.fill(0), this._blockOffset = 0;
  for (var n = 0; n < 4; ++n) this._length[n] = 0;
  return e;
};
pl.prototype._digest = function() {
  throw new Error("_digest is not implemented");
};
var MG = pl, L2 = $n.Buffer, $G = wr, gM = MG, TG = new Array(16), Bc = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], Cc = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], kc = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], Ic = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11], Sc = [0, 1518500249, 1859775393, 2400959708, 2840853838], Mc = [1352829926, 1548603684, 1836072691, 2053994217, 0];
function l0(t3, e) {
  return t3 << e | t3 >>> 32 - e;
}
function hw(t3, e, n, r, s, i, a, o) {
  return l0(t3 + (e ^ n ^ r) + i + a | 0, o) + s | 0;
}
function dw(t3, e, n, r, s, i, a, o) {
  return l0(t3 + (e & n | ~e & r) + i + a | 0, o) + s | 0;
}
function pw(t3, e, n, r, s, i, a, o) {
  return l0(t3 + ((e | ~n) ^ r) + i + a | 0, o) + s | 0;
}
function gw(t3, e, n, r, s, i, a, o) {
  return l0(t3 + (e & r | n & ~r) + i + a | 0, o) + s | 0;
}
function mw(t3, e, n, r, s, i, a, o) {
  return l0(t3 + (e ^ (n | ~r)) + i + a | 0, o) + s | 0;
}
function Qg() {
  gM.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
}
$G(Qg, gM);
Qg.prototype._update = function() {
  for (var t3 = TG, e = 0; e < 16; ++e) t3[e] = this._block.readInt32LE(e * 4);
  for (var n = this._a | 0, r = this._b | 0, s = this._c | 0, i = this._d | 0, a = this._e | 0, o = this._a | 0, f = this._b | 0, c = this._c | 0, l = this._d | 0, h = this._e | 0, m = 0; m < 80; m += 1) {
    var v, b;
    m < 16 ? (v = hw(n, r, s, i, a, t3[Bc[m]], Sc[0], kc[m]), b = mw(o, f, c, l, h, t3[Cc[m]], Mc[0], Ic[m])) : m < 32 ? (v = dw(n, r, s, i, a, t3[Bc[m]], Sc[1], kc[m]), b = gw(o, f, c, l, h, t3[Cc[m]], Mc[1], Ic[m])) : m < 48 ? (v = pw(n, r, s, i, a, t3[Bc[m]], Sc[2], kc[m]), b = pw(o, f, c, l, h, t3[Cc[m]], Mc[2], Ic[m])) : m < 64 ? (v = gw(n, r, s, i, a, t3[Bc[m]], Sc[3], kc[m]), b = dw(o, f, c, l, h, t3[Cc[m]], Mc[3], Ic[m])) : (v = mw(n, r, s, i, a, t3[Bc[m]], Sc[4], kc[m]), b = hw(o, f, c, l, h, t3[Cc[m]], Mc[4], Ic[m])), n = a, a = i, i = l0(s, 10), s = r, r = v, o = h, h = l, l = l0(c, 10), c = f, f = b;
  }
  var A = this._b + s + l | 0;
  this._b = this._c + i + h | 0, this._c = this._d + a + o | 0, this._d = this._e + n + f | 0, this._e = this._a + r + c | 0, this._a = A;
};
Qg.prototype._digest = function() {
  this._block[this._blockOffset] = 128, this._blockOffset += 1, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var t3 = L2.alloc ? L2.alloc(20) : new L2(20);
  return t3.writeInt32LE(this._a, 0), t3.writeInt32LE(this._b, 4), t3.writeInt32LE(this._c, 8), t3.writeInt32LE(this._d, 12), t3.writeInt32LE(this._e, 16), t3;
};
var $A = Qg, mM = { exports: {} }, L3 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(t3, e) {
  var n = $n, r = n.Buffer;
  function s(a, o) {
    for (var f in a) o[f] = a[f];
  }
  r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow ? t3.exports = n : (s(n, e), e.Buffer = i);
  function i(a, o, f) {
    return r(a, o, f);
  }
  i.prototype = Object.create(r.prototype), s(r, i), i.from = function(a, o, f) {
    if (typeof a == "number") throw new TypeError("Argument must not be a number");
    return r(a, o, f);
  }, i.alloc = function(a, o, f) {
    if (typeof a != "number") throw new TypeError("Argument must be a number");
    var c = r(a);
    return o !== void 0 ? typeof f == "string" ? c.fill(o, f) : c.fill(o) : c.fill(0), c;
  }, i.allocUnsafe = function(a) {
    if (typeof a != "number") throw new TypeError("Argument must be a number");
    return r(a);
  }, i.allocUnsafeSlow = function(a) {
    if (typeof a != "number") throw new TypeError("Argument must be a number");
    return n.SlowBuffer(a);
  };
})(L3, L3.exports);
var y0 = L3.exports, DG = y0.Buffer, RG = Ng;
function Kg(t3, e) {
  this._block = DG.alloc(t3), this._finalSize = e, this._blockSize = t3, this._len = 0;
}
Kg.prototype.update = function(t3, e) {
  t3 = RG(t3, e || "utf8");
  for (var n = this._block, r = this._blockSize, s = t3.length, i = this._len, a = 0; a < s; ) {
    for (var o = i % r, f = Math.min(s - a, r - o), c = 0; c < f; c++) n[o + c] = t3[a + c];
    i += f, a += f, i % r === 0 && this._update(n);
  }
  return this._len += s, this;
};
Kg.prototype.digest = function(t3) {
  var e = this._len % this._blockSize;
  this._block[e] = 128, this._block.fill(0, e + 1), e >= this._finalSize && (this._update(this._block), this._block.fill(0));
  var n = this._len * 8;
  if (n <= 4294967295) this._block.writeUInt32BE(n, this._blockSize - 4);
  else {
    var r = (n & 4294967295) >>> 0, s = (n - r) / 4294967296;
    this._block.writeUInt32BE(s, this._blockSize - 8), this._block.writeUInt32BE(r, this._blockSize - 4);
  }
  this._update(this._block);
  var i = this._hash();
  return t3 ? i.toString(t3) : i;
};
Kg.prototype._update = function() {
  throw new Error("_update must be implemented by subclass");
};
var Xu = Kg, FG = wr, vM = Xu, PG = y0.Buffer, NG = [1518500249, 1859775393, -1894007588, -899497514], UG = new Array(80);
function dd() {
  this.init(), this._w = UG, vM.call(this, 64, 56);
}
FG(dd, vM);
dd.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function LG(t3) {
  return t3 << 5 | t3 >>> 27;
}
function OG(t3) {
  return t3 << 30 | t3 >>> 2;
}
function QG(t3, e, n, r) {
  return t3 === 0 ? e & n | ~e & r : t3 === 2 ? e & n | e & r | n & r : e ^ n ^ r;
}
dd.prototype._update = function(t3) {
  for (var e = this._w, n = this._a | 0, r = this._b | 0, s = this._c | 0, i = this._d | 0, a = this._e | 0, o = 0; o < 16; ++o) e[o] = t3.readInt32BE(o * 4);
  for (; o < 80; ++o) e[o] = e[o - 3] ^ e[o - 8] ^ e[o - 14] ^ e[o - 16];
  for (var f = 0; f < 80; ++f) {
    var c = ~~(f / 20), l = LG(n) + QG(c, r, s, i) + a + e[f] + NG[c] | 0;
    a = i, i = s, s = OG(r), r = n, n = l;
  }
  this._a = n + this._a | 0, this._b = r + this._b | 0, this._c = s + this._c | 0, this._d = i + this._d | 0, this._e = a + this._e | 0;
};
dd.prototype._hash = function() {
  var t3 = PG.allocUnsafe(20);
  return t3.writeInt32BE(this._a | 0, 0), t3.writeInt32BE(this._b | 0, 4), t3.writeInt32BE(this._c | 0, 8), t3.writeInt32BE(this._d | 0, 12), t3.writeInt32BE(this._e | 0, 16), t3;
};
var KG = dd, HG = wr, yM = Xu, qG = y0.Buffer, zG = [1518500249, 1859775393, -1894007588, -899497514], GG = new Array(80);
function pd() {
  this.init(), this._w = GG, yM.call(this, 64, 56);
}
HG(pd, yM);
pd.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function VG(t3) {
  return t3 << 1 | t3 >>> 31;
}
function YG(t3) {
  return t3 << 5 | t3 >>> 27;
}
function WG(t3) {
  return t3 << 30 | t3 >>> 2;
}
function JG(t3, e, n, r) {
  return t3 === 0 ? e & n | ~e & r : t3 === 2 ? e & n | e & r | n & r : e ^ n ^ r;
}
pd.prototype._update = function(t3) {
  for (var e = this._w, n = this._a | 0, r = this._b | 0, s = this._c | 0, i = this._d | 0, a = this._e | 0, o = 0; o < 16; ++o) e[o] = t3.readInt32BE(o * 4);
  for (; o < 80; ++o) e[o] = VG(e[o - 3] ^ e[o - 8] ^ e[o - 14] ^ e[o - 16]);
  for (var f = 0; f < 80; ++f) {
    var c = ~~(f / 20), l = YG(n) + JG(c, r, s, i) + a + e[f] + zG[c] | 0;
    a = i, i = s, s = WG(r), r = n, n = l;
  }
  this._a = n + this._a | 0, this._b = r + this._b | 0, this._c = s + this._c | 0, this._d = i + this._d | 0, this._e = a + this._e | 0;
};
pd.prototype._hash = function() {
  var t3 = qG.allocUnsafe(20);
  return t3.writeInt32BE(this._a | 0, 0), t3.writeInt32BE(this._b | 0, 4), t3.writeInt32BE(this._c | 0, 8), t3.writeInt32BE(this._d | 0, 12), t3.writeInt32BE(this._e | 0, 16), t3;
};
var ZG = pd, jG = wr, bM = Xu, XG = y0.Buffer, eV = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], tV = new Array(64);
function gd() {
  this.init(), this._w = tV, bM.call(this, 64, 56);
}
jG(gd, bM);
gd.prototype.init = function() {
  return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
};
function rV(t3, e, n) {
  return n ^ t3 & (e ^ n);
}
function nV(t3, e, n) {
  return t3 & e | n & (t3 | e);
}
function iV(t3) {
  return (t3 >>> 2 | t3 << 30) ^ (t3 >>> 13 | t3 << 19) ^ (t3 >>> 22 | t3 << 10);
}
function sV(t3) {
  return (t3 >>> 6 | t3 << 26) ^ (t3 >>> 11 | t3 << 21) ^ (t3 >>> 25 | t3 << 7);
}
function aV(t3) {
  return (t3 >>> 7 | t3 << 25) ^ (t3 >>> 18 | t3 << 14) ^ t3 >>> 3;
}
function oV(t3) {
  return (t3 >>> 17 | t3 << 15) ^ (t3 >>> 19 | t3 << 13) ^ t3 >>> 10;
}
gd.prototype._update = function(t3) {
  for (var e = this._w, n = this._a | 0, r = this._b | 0, s = this._c | 0, i = this._d | 0, a = this._e | 0, o = this._f | 0, f = this._g | 0, c = this._h | 0, l = 0; l < 16; ++l) e[l] = t3.readInt32BE(l * 4);
  for (; l < 64; ++l) e[l] = oV(e[l - 2]) + e[l - 7] + aV(e[l - 15]) + e[l - 16] | 0;
  for (var h = 0; h < 64; ++h) {
    var m = c + sV(a) + rV(a, o, f) + eV[h] + e[h] | 0, v = iV(n) + nV(n, r, s) | 0;
    c = f, f = o, o = a, a = i + m | 0, i = s, s = r, r = n, n = m + v | 0;
  }
  this._a = n + this._a | 0, this._b = r + this._b | 0, this._c = s + this._c | 0, this._d = i + this._d | 0, this._e = a + this._e | 0, this._f = o + this._f | 0, this._g = f + this._g | 0, this._h = c + this._h | 0;
};
gd.prototype._hash = function() {
  var t3 = XG.allocUnsafe(32);
  return t3.writeInt32BE(this._a, 0), t3.writeInt32BE(this._b, 4), t3.writeInt32BE(this._c, 8), t3.writeInt32BE(this._d, 12), t3.writeInt32BE(this._e, 16), t3.writeInt32BE(this._f, 20), t3.writeInt32BE(this._g, 24), t3.writeInt32BE(this._h, 28), t3;
};
var AM = gd, fV = wr, lV = AM, uV = Xu, cV = y0.Buffer, hV = new Array(64);
function Hg() {
  this.init(), this._w = hV, uV.call(this, 64, 56);
}
fV(Hg, lV);
Hg.prototype.init = function() {
  return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
};
Hg.prototype._hash = function() {
  var t3 = cV.allocUnsafe(28);
  return t3.writeInt32BE(this._a, 0), t3.writeInt32BE(this._b, 4), t3.writeInt32BE(this._c, 8), t3.writeInt32BE(this._d, 12), t3.writeInt32BE(this._e, 16), t3.writeInt32BE(this._f, 20), t3.writeInt32BE(this._g, 24), t3;
};
var dV = Hg, pV = wr, wM = Xu, gV = y0.Buffer, vw = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591], mV = new Array(160);
function md() {
  this.init(), this._w = mV, wM.call(this, 128, 112);
}
pV(md, wM);
md.prototype.init = function() {
  return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
};
function yw(t3, e, n) {
  return n ^ t3 & (e ^ n);
}
function bw(t3, e, n) {
  return t3 & e | n & (t3 | e);
}
function Aw(t3, e) {
  return (t3 >>> 28 | e << 4) ^ (e >>> 2 | t3 << 30) ^ (e >>> 7 | t3 << 25);
}
function ww(t3, e) {
  return (t3 >>> 14 | e << 18) ^ (t3 >>> 18 | e << 14) ^ (e >>> 9 | t3 << 23);
}
function vV(t3, e) {
  return (t3 >>> 1 | e << 31) ^ (t3 >>> 8 | e << 24) ^ t3 >>> 7;
}
function yV(t3, e) {
  return (t3 >>> 1 | e << 31) ^ (t3 >>> 8 | e << 24) ^ (t3 >>> 7 | e << 25);
}
function bV(t3, e) {
  return (t3 >>> 19 | e << 13) ^ (e >>> 29 | t3 << 3) ^ t3 >>> 6;
}
function AV(t3, e) {
  return (t3 >>> 19 | e << 13) ^ (e >>> 29 | t3 << 3) ^ (t3 >>> 6 | e << 26);
}
function pi(t3, e) {
  return t3 >>> 0 < e >>> 0 ? 1 : 0;
}
md.prototype._update = function(t3) {
  for (var e = this._w, n = this._ah | 0, r = this._bh | 0, s = this._ch | 0, i = this._dh | 0, a = this._eh | 0, o = this._fh | 0, f = this._gh | 0, c = this._hh | 0, l = this._al | 0, h = this._bl | 0, m = this._cl | 0, v = this._dl | 0, b = this._el | 0, A = this._fl | 0, _ = this._gl | 0, C = this._hl | 0, I = 0; I < 32; I += 2) e[I] = t3.readInt32BE(I * 4), e[I + 1] = t3.readInt32BE(I * 4 + 4);
  for (; I < 160; I += 2) {
    var S = e[I - 30], $ = e[I - 15 * 2 + 1], F = vV(S, $), U = yV($, S);
    S = e[I - 2 * 2], $ = e[I - 2 * 2 + 1];
    var Q = bV(S, $), P = AV($, S), N = e[I - 7 * 2], L = e[I - 7 * 2 + 1], B = e[I - 16 * 2], u = e[I - 16 * 2 + 1], p = U + L | 0, d = F + N + pi(p, U) | 0;
    p = p + P | 0, d = d + Q + pi(p, P) | 0, p = p + u | 0, d = d + B + pi(p, u) | 0, e[I] = d, e[I + 1] = p;
  }
  for (var y = 0; y < 160; y += 2) {
    d = e[y], p = e[y + 1];
    var w = bw(n, r, s), E = bw(l, h, m), M = Aw(n, l), x = Aw(l, n), g = ww(a, b), k = ww(b, a), T = vw[y], O = vw[y + 1], K = yw(a, o, f), Y = yw(b, A, _), J = C + k | 0, G = c + g + pi(J, C) | 0;
    J = J + Y | 0, G = G + K + pi(J, Y) | 0, J = J + O | 0, G = G + T + pi(J, O) | 0, J = J + p | 0, G = G + d + pi(J, p) | 0;
    var X = x + E | 0, ie = M + w + pi(X, x) | 0;
    c = f, C = _, f = o, _ = A, o = a, A = b, b = v + J | 0, a = i + G + pi(b, v) | 0, i = s, v = m, s = r, m = h, r = n, h = l, l = J + X | 0, n = G + ie + pi(l, J) | 0;
  }
  this._al = this._al + l | 0, this._bl = this._bl + h | 0, this._cl = this._cl + m | 0, this._dl = this._dl + v | 0, this._el = this._el + b | 0, this._fl = this._fl + A | 0, this._gl = this._gl + _ | 0, this._hl = this._hl + C | 0, this._ah = this._ah + n + pi(this._al, l) | 0, this._bh = this._bh + r + pi(this._bl, h) | 0, this._ch = this._ch + s + pi(this._cl, m) | 0, this._dh = this._dh + i + pi(this._dl, v) | 0, this._eh = this._eh + a + pi(this._el, b) | 0, this._fh = this._fh + o + pi(this._fl, A) | 0, this._gh = this._gh + f + pi(this._gl, _) | 0, this._hh = this._hh + c + pi(this._hl, C) | 0;
};
md.prototype._hash = function() {
  var t3 = gV.allocUnsafe(64);
  function e(n, r, s) {
    t3.writeInt32BE(n, s), t3.writeInt32BE(r, s + 4);
  }
  return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), e(this._gh, this._gl, 48), e(this._hh, this._hl, 56), t3;
};
var xM = md, wV = wr, xV = xM, _V = Xu, EV = y0.Buffer, BV = new Array(160);
function qg() {
  this.init(), this._w = BV, _V.call(this, 128, 112);
}
wV(qg, xV);
qg.prototype.init = function() {
  return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
};
qg.prototype._hash = function() {
  var t3 = EV.allocUnsafe(48);
  function e(n, r, s) {
    t3.writeInt32BE(n, s), t3.writeInt32BE(r, s + 4);
  }
  return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), t3;
};
var CV = qg;
(function(t3) {
  t3.exports = function(n) {
    var r = n.toLowerCase(), s = t3.exports[r];
    if (!s) throw new Error(r + " is not supported (we accept pull requests)");
    return new s();
  }, t3.exports.sha = KG, t3.exports.sha1 = ZG, t3.exports.sha224 = dV, t3.exports.sha256 = AM, t3.exports.sha384 = CV, t3.exports.sha512 = xM;
})(mM);
var TA = mM.exports, O3 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(t3, e) {
  var n = $n, r = n.Buffer;
  function s(a, o) {
    for (var f in a) o[f] = a[f];
  }
  r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow ? t3.exports = n : (s(n, e), e.Buffer = i);
  function i(a, o, f) {
    return r(a, o, f);
  }
  i.prototype = Object.create(r.prototype), s(r, i), i.from = function(a, o, f) {
    if (typeof a == "number") throw new TypeError("Argument must not be a number");
    return r(a, o, f);
  }, i.alloc = function(a, o, f) {
    if (typeof a != "number") throw new TypeError("Argument must be a number");
    var c = r(a);
    return o !== void 0 ? typeof f == "string" ? c.fill(o, f) : c.fill(o) : c.fill(0), c;
  }, i.allocUnsafe = function(a) {
    if (typeof a != "number") throw new TypeError("Argument must be a number");
    return r(a);
  }, i.allocUnsafeSlow = function(a) {
    if (typeof a != "number") throw new TypeError("Argument must be a number");
    return n.SlowBuffer(a);
  };
})(O3, O3.exports);
var kV = O3.exports, IV = kV.Buffer, _M = XS.Transform, SV = Iu.StringDecoder, MV = wr, $V = Ng;
function Pa(t3) {
  _M.call(this), this.hashMode = typeof t3 == "string", this.hashMode ? this[t3] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
}
MV(Pa, _M);
Pa.prototype.update = function(t3, e, n) {
  var r = $V(t3, e), s = this._update(r);
  return this.hashMode ? this : (n && (s = this._toString(s, n)), s);
};
Pa.prototype.setAutoPadding = function() {
};
Pa.prototype.getAuthTag = function() {
  throw new Error("trying to get auth tag in unsupported state");
};
Pa.prototype.setAuthTag = function() {
  throw new Error("trying to set auth tag in unsupported state");
};
Pa.prototype.setAAD = function() {
  throw new Error("trying to set aad in unsupported state");
};
Pa.prototype._transform = function(t3, e, n) {
  var r;
  try {
    this.hashMode ? this._update(t3) : this.push(this._update(t3));
  } catch (s) {
    r = s;
  } finally {
    n(r);
  }
};
Pa.prototype._flush = function(t3) {
  var e;
  try {
    this.push(this.__final());
  } catch (n) {
    e = n;
  }
  t3(e);
};
Pa.prototype._finalOrDigest = function(t3) {
  var e = this.__final() || IV.alloc(0);
  return t3 && (e = this._toString(e, t3, true)), e;
};
Pa.prototype._toString = function(t3, e, n) {
  if (this._decoder || (this._decoder = new SV(e), this._encoding = e), this._encoding !== e) throw new Error("can\u2019t switch encodings");
  var r = this._decoder.write(t3);
  return n && (r += this._decoder.end()), r;
};
var gl = Pa, TV = wr, DV = MA, RV = $A, FV = TA, EM = gl;
function zg(t3) {
  EM.call(this, "digest"), this._hash = t3;
}
TV(zg, EM);
zg.prototype._update = function(t3) {
  this._hash.update(t3);
};
zg.prototype._final = function() {
  return this._hash.digest();
};
var vd = function(e) {
  return e = e.toLowerCase(), e === "md5" ? new DV() : e === "rmd160" || e === "ripemd160" ? new RV() : new zg(FV(e));
}, PV = wr, Yl = Tn.Buffer, BM = gl, NV = Yl.alloc(128), L0 = 64;
function Gg(t3, e) {
  BM.call(this, "digest"), typeof e == "string" && (e = Yl.from(e)), this._alg = t3, this._key = e, e.length > L0 ? e = t3(e) : e.length < L0 && (e = Yl.concat([e, NV], L0));
  for (var n = this._ipad = Yl.allocUnsafe(L0), r = this._opad = Yl.allocUnsafe(L0), s = 0; s < L0; s++) n[s] = e[s] ^ 54, r[s] = e[s] ^ 92;
  this._hash = [n];
}
PV(Gg, BM);
Gg.prototype._update = function(t3) {
  this._hash.push(t3);
};
Gg.prototype._final = function() {
  var t3 = this._alg(Yl.concat(this._hash));
  return this._alg(Yl.concat([this._opad, t3]));
};
var UV = Gg, LV = MA, CM = function(t3) {
  return new LV().update(t3).digest();
}, OV = wr, QV = UV, kM = gl, jc = Tn.Buffer, KV = CM, Q3 = $A, K3 = TA, HV = jc.alloc(128);
function Fh(t3, e) {
  kM.call(this, "digest"), typeof e == "string" && (e = jc.from(e));
  var n = t3 === "sha512" || t3 === "sha384" ? 128 : 64;
  if (this._alg = t3, this._key = e, e.length > n) {
    var r = t3 === "rmd160" ? new Q3() : K3(t3);
    e = r.update(e).digest();
  } else e.length < n && (e = jc.concat([e, HV], n));
  for (var s = this._ipad = jc.allocUnsafe(n), i = this._opad = jc.allocUnsafe(n), a = 0; a < n; a++) s[a] = e[a] ^ 54, i[a] = e[a] ^ 92;
  this._hash = t3 === "rmd160" ? new Q3() : K3(t3), this._hash.update(s);
}
OV(Fh, kM);
Fh.prototype._update = function(t3) {
  this._hash.update(t3);
};
Fh.prototype._final = function() {
  var t3 = this._hash.digest(), e = this._alg === "rmd160" ? new Q3() : K3(this._alg);
  return e.update(this._opad).update(t3).digest();
};
var IM = function(e, n) {
  return e = e.toLowerCase(), e === "rmd160" || e === "ripemd160" ? new Fh("rmd160", n) : e === "md5" ? new QV(KV, n) : new Fh(e, n);
};
const qV = { sign: "rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, zV = { sign: "rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, GV = { sign: "rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, VV = { sign: "rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, YV = { sign: "ecdsa", hash: "sha256", id: "" }, WV = { sign: "ecdsa", hash: "sha224", id: "" }, JV = { sign: "ecdsa", hash: "sha384", id: "" }, ZV = { sign: "ecdsa", hash: "sha512", id: "" }, jV = { sign: "dsa", hash: "sha1", id: "" }, XV = { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, eY = { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" }, SM = { sha224WithRSAEncryption: qV, "RSA-SHA224": { sign: "ecdsa/rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, sha256WithRSAEncryption: zV, "RSA-SHA256": { sign: "ecdsa/rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, sha384WithRSAEncryption: GV, "RSA-SHA384": { sign: "ecdsa/rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, sha512WithRSAEncryption: VV, "RSA-SHA512": { sign: "ecdsa/rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA1": { sign: "rsa", hash: "sha1", id: "3021300906052b0e03021a05000414" }, "ecdsa-with-SHA1": { sign: "ecdsa", hash: "sha1", id: "" }, sha256: YV, sha224: WV, sha384: JV, sha512: ZV, "DSA-SHA": { sign: "dsa", hash: "sha1", id: "" }, "DSA-SHA1": { sign: "dsa", hash: "sha1", id: "" }, DSA: jV, "DSA-WITH-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-WITH-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-WITH-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-WITH-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-RIPEMD160": { sign: "dsa", hash: "rmd160", id: "" }, ripemd160WithRSA: XV, "RSA-RIPEMD160": { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, md5WithRSAEncryption: eY, "RSA-MD5": { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" } };
var tY = SM, Vg = {}, H3 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(t3, e) {
  var n = $n, r = n.Buffer;
  function s(a, o) {
    for (var f in a) o[f] = a[f];
  }
  r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow ? t3.exports = n : (s(n, e), e.Buffer = i);
  function i(a, o, f) {
    return r(a, o, f);
  }
  i.prototype = Object.create(r.prototype), s(r, i), i.from = function(a, o, f) {
    if (typeof a == "number") throw new TypeError("Argument must not be a number");
    return r(a, o, f);
  }, i.alloc = function(a, o, f) {
    if (typeof a != "number") throw new TypeError("Argument must be a number");
    var c = r(a);
    return o !== void 0 ? typeof f == "string" ? c.fill(o, f) : c.fill(o) : c.fill(0), c;
  }, i.allocUnsafe = function(a) {
    if (typeof a != "number") throw new TypeError("Argument must be a number");
    return r(a);
  }, i.allocUnsafeSlow = function(a) {
    if (typeof a != "number") throw new TypeError("Argument must be a number");
    return n.SlowBuffer(a);
  };
})(H3, H3.exports);
var DA = H3.exports, rY = isFinite, nY = Math.pow(2, 30) - 1, MM = function(t3, e) {
  if (typeof t3 != "number") throw new TypeError("Iterations not a number");
  if (t3 < 0 || !rY(t3)) throw new TypeError("Bad iterations");
  if (typeof e != "number") throw new TypeError("Key length not a number");
  if (e < 0 || e > nY || e !== e) throw new TypeError("Bad key length");
}, Qp;
if (mt.process && mt.process.browser) Qp = "utf-8";
else if (mt.process && mt.process.version) {
  var iY = parseInt(jt.version.split(".")[0].slice(1), 10);
  Qp = iY >= 6 ? "utf-8" : "binary";
} else Qp = "utf-8";
var $M = Qp, sY = DA.Buffer, aY = Ng, TM = typeof Uint8Array < "u", oY = TM && typeof ArrayBuffer < "u", xw = oY && ArrayBuffer.isView, DM = function(t3, e, n) {
  if (typeof t3 == "string" || sY.isBuffer(t3) || TM && t3 instanceof Uint8Array || xw && xw(t3)) return aY(t3, e);
  throw new TypeError(n + " must be a string, a Buffer, a Uint8Array, or a DataView");
}, fY = CM, lY = $A, uY = TA, Wl = DA.Buffer, cY = MM, _w = $M, Ew = DM, hY = Wl.alloc(128), Kp = { __proto__: null, md5: 16, sha1: 20, sha224: 28, sha256: 32, sha384: 48, sha512: 64, "sha512-256": 32, ripemd160: 20, rmd160: 20 }, dY = { __proto__: null, "sha-1": "sha1", "sha-224": "sha224", "sha-256": "sha256", "sha-384": "sha384", "sha-512": "sha512", "ripemd-160": "ripemd160" };
function pY(t3) {
  return new lY().update(t3).digest();
}
function gY(t3) {
  function e(n) {
    return uY(t3).update(n).digest();
  }
  return t3 === "rmd160" || t3 === "ripemd160" ? pY : t3 === "md5" ? fY : e;
}
function RM(t3, e, n) {
  var r = gY(t3), s = t3 === "sha512" || t3 === "sha384" ? 128 : 64;
  e.length > s ? e = r(e) : e.length < s && (e = Wl.concat([e, hY], s));
  for (var i = Wl.allocUnsafe(s + Kp[t3]), a = Wl.allocUnsafe(s + Kp[t3]), o = 0; o < s; o++) i[o] = e[o] ^ 54, a[o] = e[o] ^ 92;
  var f = Wl.allocUnsafe(s + n + 4);
  i.copy(f, 0, 0, s), this.ipad1 = f, this.ipad2 = i, this.opad = a, this.alg = t3, this.blocksize = s, this.hash = r, this.size = Kp[t3];
}
RM.prototype.run = function(t3, e) {
  t3.copy(e, this.blocksize);
  var n = this.hash(e);
  return n.copy(this.opad, this.blocksize), this.hash(this.opad);
};
function mY(t3, e, n, r, s) {
  cY(n, r), t3 = Ew(t3, _w, "Password"), e = Ew(e, _w, "Salt");
  var i = (s || "sha1").toLowerCase(), a = dY[i] || i, o = Kp[a];
  if (typeof o != "number" || !o) throw new TypeError("Digest algorithm not supported: " + s);
  var f = new RM(a, t3, e.length), c = Wl.allocUnsafe(r), l = Wl.allocUnsafe(e.length + 4);
  e.copy(l, 0, 0, e.length);
  for (var h = 0, m = o, v = Math.ceil(r / m), b = 1; b <= v; b++) {
    l.writeUInt32BE(b, e.length);
    for (var A = f.run(l, f.ipad1), _ = A, C = 1; C < n; C++) {
      _ = f.run(_, f.ipad2);
      for (var I = 0; I < m; I++) A[I] ^= _[I];
    }
    A.copy(c, h), h += m;
  }
  return c;
}
var FM = mY, PM = DA.Buffer, vY = MM, Bw = $M, Cw = FM, kw = DM, Xd, fh = mt.crypto && mt.crypto.subtle, yY = { sha: "SHA-1", "sha-1": "SHA-1", sha1: "SHA-1", sha256: "SHA-256", "sha-256": "SHA-256", sha384: "SHA-384", "sha-384": "SHA-384", "sha-512": "SHA-512", sha512: "SHA-512" }, O2 = [], Sl;
function q3() {
  return Sl || (mt.process && mt.process.nextTick ? Sl = mt.process.nextTick : mt.queueMicrotask ? Sl = mt.queueMicrotask : mt.setImmediate ? Sl = mt.setImmediate : Sl = mt.setTimeout, Sl);
}
function NM(t3, e, n, r, s) {
  return fh.importKey("raw", t3, { name: "PBKDF2" }, false, ["deriveBits"]).then(function(i) {
    return fh.deriveBits({ name: "PBKDF2", salt: e, iterations: n, hash: { name: s } }, i, r << 3);
  }).then(function(i) {
    return PM.from(i);
  });
}
function bY(t3) {
  if (mt.process && !mt.process.browser || !fh || !fh.importKey || !fh.deriveBits) return Promise.resolve(false);
  if (O2[t3] !== void 0) return O2[t3];
  Xd = Xd || PM.alloc(8);
  var e = NM(Xd, Xd, 10, 128, t3).then(function() {
    return true;
  }, function() {
    return false;
  });
  return O2[t3] = e, e;
}
function AY(t3, e) {
  t3.then(function(n) {
    q3()(function() {
      e(null, n);
    });
  }, function(n) {
    q3()(function() {
      e(n);
    });
  });
}
var wY = function(t3, e, n, r, s, i) {
  if (typeof s == "function" && (i = s, s = void 0), vY(n, r), t3 = kw(t3, Bw, "Password"), e = kw(e, Bw, "Salt"), typeof i != "function") throw new Error("No callback provided to pbkdf2");
  s = s || "sha1";
  var a = yY[s.toLowerCase()];
  if (!a || typeof mt.Promise != "function") {
    q3()(function() {
      var o;
      try {
        o = Cw(t3, e, n, r, s);
      } catch (f) {
        i(f);
        return;
      }
      i(null, o);
    });
    return;
  }
  AY(bY(a).then(function(o) {
    return o ? NM(t3, e, n, r, a) : Cw(t3, e, n, r, s);
  }), i);
};
Vg.pbkdf2 = wY;
Vg.pbkdf2Sync = FM;
var Ta = {}, ec = {}, zs = {};
zs.readUInt32BE = function(e, n) {
  var r = e[0 + n] << 24 | e[1 + n] << 16 | e[2 + n] << 8 | e[3 + n];
  return r >>> 0;
};
zs.writeUInt32BE = function(e, n, r) {
  e[0 + r] = n >>> 24, e[1 + r] = n >>> 16 & 255, e[2 + r] = n >>> 8 & 255, e[3 + r] = n & 255;
};
zs.ip = function(e, n, r, s) {
  for (var i = 0, a = 0, o = 6; o >= 0; o -= 2) {
    for (var f = 0; f <= 24; f += 8) i <<= 1, i |= n >>> f + o & 1;
    for (var f = 0; f <= 24; f += 8) i <<= 1, i |= e >>> f + o & 1;
  }
  for (var o = 6; o >= 0; o -= 2) {
    for (var f = 1; f <= 25; f += 8) a <<= 1, a |= n >>> f + o & 1;
    for (var f = 1; f <= 25; f += 8) a <<= 1, a |= e >>> f + o & 1;
  }
  r[s + 0] = i >>> 0, r[s + 1] = a >>> 0;
};
zs.rip = function(e, n, r, s) {
  for (var i = 0, a = 0, o = 0; o < 4; o++) for (var f = 24; f >= 0; f -= 8) i <<= 1, i |= n >>> f + o & 1, i <<= 1, i |= e >>> f + o & 1;
  for (var o = 4; o < 8; o++) for (var f = 24; f >= 0; f -= 8) a <<= 1, a |= n >>> f + o & 1, a <<= 1, a |= e >>> f + o & 1;
  r[s + 0] = i >>> 0, r[s + 1] = a >>> 0;
};
zs.pc1 = function(e, n, r, s) {
  for (var i = 0, a = 0, o = 7; o >= 5; o--) {
    for (var f = 0; f <= 24; f += 8) i <<= 1, i |= n >> f + o & 1;
    for (var f = 0; f <= 24; f += 8) i <<= 1, i |= e >> f + o & 1;
  }
  for (var f = 0; f <= 24; f += 8) i <<= 1, i |= n >> f + o & 1;
  for (var o = 1; o <= 3; o++) {
    for (var f = 0; f <= 24; f += 8) a <<= 1, a |= n >> f + o & 1;
    for (var f = 0; f <= 24; f += 8) a <<= 1, a |= e >> f + o & 1;
  }
  for (var f = 0; f <= 24; f += 8) a <<= 1, a |= e >> f + o & 1;
  r[s + 0] = i >>> 0, r[s + 1] = a >>> 0;
};
zs.r28shl = function(e, n) {
  return e << n & 268435455 | e >>> 28 - n;
};
var ep = [14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, 15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24];
zs.pc2 = function(e, n, r, s) {
  for (var i = 0, a = 0, o = ep.length >>> 1, f = 0; f < o; f++) i <<= 1, i |= e >>> ep[f] & 1;
  for (var f = o; f < ep.length; f++) a <<= 1, a |= n >>> ep[f] & 1;
  r[s + 0] = i >>> 0, r[s + 1] = a >>> 0;
};
zs.expand = function(e, n, r) {
  var s = 0, i = 0;
  s = (e & 1) << 5 | e >>> 27;
  for (var a = 23; a >= 15; a -= 4) s <<= 6, s |= e >>> a & 63;
  for (var a = 11; a >= 3; a -= 4) i |= e >>> a & 63, i <<= 6;
  i |= (e & 31) << 1 | e >>> 31, n[r + 0] = s >>> 0, n[r + 1] = i >>> 0;
};
var Iw = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];
zs.substitute = function(e, n) {
  for (var r = 0, s = 0; s < 4; s++) {
    var i = e >>> 18 - s * 6 & 63, a = Iw[s * 64 + i];
    r <<= 4, r |= a;
  }
  for (var s = 0; s < 4; s++) {
    var i = n >>> 18 - s * 6 & 63, a = Iw[4 * 64 + s * 64 + i];
    r <<= 4, r |= a;
  }
  return r >>> 0;
};
var Sw = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];
zs.permute = function(e) {
  for (var n = 0, r = 0; r < Sw.length; r++) n <<= 1, n |= e >>> Sw[r] & 1;
  return n >>> 0;
};
zs.padSplit = function(e, n, r) {
  for (var s = e.toString(2); s.length < n; ) s = "0" + s;
  for (var i = [], a = 0; a < n; a += r) i.push(s.slice(a, a + r));
  return i.join(" ");
};
var ha = UM;
function UM(t3, e) {
  if (!t3) throw new Error(e || "Assertion failed");
}
UM.equal = function(e, n, r) {
  if (e != n) throw new Error(r || "Assertion failed: " + e + " != " + n);
};
var xY = ha;
function da(t3) {
  this.options = t3, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = t3.padding !== false;
}
var RA = da;
da.prototype._init = function() {
};
da.prototype.update = function(e) {
  return e.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(e) : this._updateEncrypt(e);
};
da.prototype._buffer = function(e, n) {
  for (var r = Math.min(this.buffer.length - this.bufferOff, e.length - n), s = 0; s < r; s++) this.buffer[this.bufferOff + s] = e[n + s];
  return this.bufferOff += r, r;
};
da.prototype._flushBuffer = function(e, n) {
  return this._update(this.buffer, 0, e, n), this.bufferOff = 0, this.blockSize;
};
da.prototype._updateEncrypt = function(e) {
  var n = 0, r = 0, s = (this.bufferOff + e.length) / this.blockSize | 0, i = new Array(s * this.blockSize);
  this.bufferOff !== 0 && (n += this._buffer(e, n), this.bufferOff === this.buffer.length && (r += this._flushBuffer(i, r)));
  for (var a = e.length - (e.length - n) % this.blockSize; n < a; n += this.blockSize) this._update(e, n, i, r), r += this.blockSize;
  for (; n < e.length; n++, this.bufferOff++) this.buffer[this.bufferOff] = e[n];
  return i;
};
da.prototype._updateDecrypt = function(e) {
  for (var n = 0, r = 0, s = Math.ceil((this.bufferOff + e.length) / this.blockSize) - 1, i = new Array(s * this.blockSize); s > 0; s--) n += this._buffer(e, n), r += this._flushBuffer(i, r);
  return n += this._buffer(e, n), i;
};
da.prototype.final = function(e) {
  var n;
  e && (n = this.update(e));
  var r;
  return this.type === "encrypt" ? r = this._finalEncrypt() : r = this._finalDecrypt(), n ? n.concat(r) : r;
};
da.prototype._pad = function(e, n) {
  if (n === 0) return false;
  for (; n < e.length; ) e[n++] = 0;
  return true;
};
da.prototype._finalEncrypt = function() {
  if (!this._pad(this.buffer, this.bufferOff)) return [];
  var e = new Array(this.blockSize);
  return this._update(this.buffer, 0, e, 0), e;
};
da.prototype._unpad = function(e) {
  return e;
};
da.prototype._finalDecrypt = function() {
  xY.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
  var e = new Array(this.blockSize);
  return this._flushBuffer(e, 0), this._unpad(e);
};
var LM = ha, _Y = wr, hi = zs, OM = RA;
function EY() {
  this.tmp = new Array(2), this.keys = null;
}
function Bo(t3) {
  OM.call(this, t3);
  var e = new EY();
  this._desState = e, this.deriveKeys(e, t3.key);
}
_Y(Bo, OM);
var QM = Bo;
Bo.create = function(e) {
  return new Bo(e);
};
var BY = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
Bo.prototype.deriveKeys = function(e, n) {
  e.keys = new Array(16 * 2), LM.equal(n.length, this.blockSize, "Invalid key length");
  var r = hi.readUInt32BE(n, 0), s = hi.readUInt32BE(n, 4);
  hi.pc1(r, s, e.tmp, 0), r = e.tmp[0], s = e.tmp[1];
  for (var i = 0; i < e.keys.length; i += 2) {
    var a = BY[i >>> 1];
    r = hi.r28shl(r, a), s = hi.r28shl(s, a), hi.pc2(r, s, e.keys, i);
  }
};
Bo.prototype._update = function(e, n, r, s) {
  var i = this._desState, a = hi.readUInt32BE(e, n), o = hi.readUInt32BE(e, n + 4);
  hi.ip(a, o, i.tmp, 0), a = i.tmp[0], o = i.tmp[1], this.type === "encrypt" ? this._encrypt(i, a, o, i.tmp, 0) : this._decrypt(i, a, o, i.tmp, 0), a = i.tmp[0], o = i.tmp[1], hi.writeUInt32BE(r, a, s), hi.writeUInt32BE(r, o, s + 4);
};
Bo.prototype._pad = function(e, n) {
  if (this.padding === false) return false;
  for (var r = e.length - n, s = n; s < e.length; s++) e[s] = r;
  return true;
};
Bo.prototype._unpad = function(e) {
  if (this.padding === false) return e;
  for (var n = e[e.length - 1], r = e.length - n; r < e.length; r++) LM.equal(e[r], n);
  return e.slice(0, e.length - n);
};
Bo.prototype._encrypt = function(e, n, r, s, i) {
  for (var a = n, o = r, f = 0; f < e.keys.length; f += 2) {
    var c = e.keys[f], l = e.keys[f + 1];
    hi.expand(o, e.tmp, 0), c ^= e.tmp[0], l ^= e.tmp[1];
    var h = hi.substitute(c, l), m = hi.permute(h), v = o;
    o = (a ^ m) >>> 0, a = v;
  }
  hi.rip(o, a, s, i);
};
Bo.prototype._decrypt = function(e, n, r, s, i) {
  for (var a = r, o = n, f = e.keys.length - 2; f >= 0; f -= 2) {
    var c = e.keys[f], l = e.keys[f + 1];
    hi.expand(a, e.tmp, 0), c ^= e.tmp[0], l ^= e.tmp[1];
    var h = hi.substitute(c, l), m = hi.permute(h), v = a;
    a = (o ^ m) >>> 0, o = v;
  }
  hi.rip(a, o, s, i);
};
var KM = {}, CY = ha, kY = wr, C1 = {};
function IY(t3) {
  CY.equal(t3.length, 8, "Invalid IV length"), this.iv = new Array(8);
  for (var e = 0; e < this.iv.length; e++) this.iv[e] = t3[e];
}
function SY(t3) {
  function e(i) {
    t3.call(this, i), this._cbcInit();
  }
  kY(e, t3);
  for (var n = Object.keys(C1), r = 0; r < n.length; r++) {
    var s = n[r];
    e.prototype[s] = C1[s];
  }
  return e.create = function(a) {
    return new e(a);
  }, e;
}
KM.instantiate = SY;
C1._cbcInit = function() {
  var e = new IY(this.options.iv);
  this._cbcState = e;
};
C1._update = function(e, n, r, s) {
  var i = this._cbcState, a = this.constructor.super_.prototype, o = i.iv;
  if (this.type === "encrypt") {
    for (var f = 0; f < this.blockSize; f++) o[f] ^= e[n + f];
    a._update.call(this, o, 0, r, s);
    for (var f = 0; f < this.blockSize; f++) o[f] = r[s + f];
  } else {
    a._update.call(this, e, n, r, s);
    for (var f = 0; f < this.blockSize; f++) r[s + f] ^= o[f];
    for (var f = 0; f < this.blockSize; f++) o[f] = e[n + f];
  }
};
var MY = ha, $Y = wr, HM = RA, Of = QM;
function TY(t3, e) {
  MY.equal(e.length, 24, "Invalid key length");
  var n = e.slice(0, 8), r = e.slice(8, 16), s = e.slice(16, 24);
  t3 === "encrypt" ? this.ciphers = [Of.create({ type: "encrypt", key: n }), Of.create({ type: "decrypt", key: r }), Of.create({ type: "encrypt", key: s })] : this.ciphers = [Of.create({ type: "decrypt", key: s }), Of.create({ type: "encrypt", key: r }), Of.create({ type: "decrypt", key: n })];
}
function u0(t3) {
  HM.call(this, t3);
  var e = new TY(this.type, this.options.key);
  this._edeState = e;
}
$Y(u0, HM);
var DY = u0;
u0.create = function(e) {
  return new u0(e);
};
u0.prototype._update = function(e, n, r, s) {
  var i = this._edeState;
  i.ciphers[0]._update(e, n, r, s), i.ciphers[1]._update(r, s, r, s), i.ciphers[2]._update(r, s, r, s);
};
u0.prototype._pad = Of.prototype._pad;
u0.prototype._unpad = Of.prototype._unpad;
ec.utils = zs;
ec.Cipher = RA;
ec.DES = QM;
ec.CBC = KM;
ec.EDE = DY;
var qM = gl, Lo = ec, RY = wr, Pl = Tn.Buffer, Ph = { "des-ede3-cbc": Lo.CBC.instantiate(Lo.EDE), "des-ede3": Lo.EDE, "des-ede-cbc": Lo.CBC.instantiate(Lo.EDE), "des-ede": Lo.EDE, "des-cbc": Lo.CBC.instantiate(Lo.DES), "des-ecb": Lo.DES };
Ph.des = Ph["des-cbc"];
Ph.des3 = Ph["des-ede3-cbc"];
var FY = Yg;
RY(Yg, qM);
function Yg(t3) {
  qM.call(this);
  var e = t3.mode.toLowerCase(), n = Ph[e], r;
  t3.decrypt ? r = "decrypt" : r = "encrypt";
  var s = t3.key;
  Pl.isBuffer(s) || (s = Pl.from(s)), (e === "des-ede" || e === "des-ede-cbc") && (s = Pl.concat([s, s.slice(0, 8)]));
  var i = t3.iv;
  Pl.isBuffer(i) || (i = Pl.from(i)), this._des = n.create({ key: s, iv: i, type: r });
}
Yg.prototype._update = function(t3) {
  return Pl.from(this._des.update(t3));
};
Yg.prototype._final = function() {
  return Pl.from(this._des.final());
};
var qs = {}, FA = {}, PA = {};
PA.encrypt = function(t3, e) {
  return t3._cipher.encryptBlock(e);
};
PA.decrypt = function(t3, e) {
  return t3._cipher.decryptBlock(e);
};
var NA = {}, yd = function(e, n) {
  for (var r = Math.min(e.length, n.length), s = new hr(r), i = 0; i < r; ++i) s[i] = e[i] ^ n[i];
  return s;
}, zM = yd;
NA.encrypt = function(t3, e) {
  var n = zM(e, t3._prev);
  return t3._prev = t3._cipher.encryptBlock(n), t3._prev;
};
NA.decrypt = function(t3, e) {
  var n = t3._prev;
  t3._prev = e;
  var r = t3._cipher.decryptBlock(e);
  return zM(r, n);
};
var GM = {}, Xc = Tn.Buffer, PY = yd;
function Mw(t3, e, n) {
  var r = e.length, s = PY(e, t3._cache);
  return t3._cache = t3._cache.slice(r), t3._prev = Xc.concat([t3._prev, n ? e : s]), s;
}
GM.encrypt = function(t3, e, n) {
  for (var r = Xc.allocUnsafe(0), s; e.length; ) if (t3._cache.length === 0 && (t3._cache = t3._cipher.encryptBlock(t3._prev), t3._prev = Xc.allocUnsafe(0)), t3._cache.length <= e.length) s = t3._cache.length, r = Xc.concat([r, Mw(t3, e.slice(0, s), n)]), e = e.slice(s);
  else {
    r = Xc.concat([r, Mw(t3, e, n)]);
    break;
  }
  return r;
};
var VM = {}, z3 = Tn.Buffer;
function NY(t3, e, n) {
  var r = t3._cipher.encryptBlock(t3._prev), s = r[0] ^ e;
  return t3._prev = z3.concat([t3._prev.slice(1), z3.from([n ? e : s])]), s;
}
VM.encrypt = function(t3, e, n) {
  for (var r = e.length, s = z3.allocUnsafe(r), i = -1; ++i < r; ) s[i] = NY(t3, e[i], n);
  return s;
};
var YM = {}, Hp = Tn.Buffer;
function UY(t3, e, n) {
  for (var r, s = -1, i = 8, a = 0, o, f; ++s < i; ) r = t3._cipher.encryptBlock(t3._prev), o = e & 1 << 7 - s ? 128 : 0, f = r[0] ^ o, a += (f & 128) >> s % 8, t3._prev = LY(t3._prev, n ? o : f);
  return a;
}
function LY(t3, e) {
  var n = t3.length, r = -1, s = Hp.allocUnsafe(t3.length);
  for (t3 = Hp.concat([t3, Hp.from([e])]); ++r < n; ) s[r] = t3[r] << 1 | t3[r + 1] >> 7;
  return s;
}
YM.encrypt = function(t3, e, n) {
  for (var r = e.length, s = Hp.allocUnsafe(r), i = -1; ++i < r; ) s[i] = UY(t3, e[i], n);
  return s;
};
var WM = {}, OY = yd;
function QY(t3) {
  return t3._prev = t3._cipher.encryptBlock(t3._prev), t3._prev;
}
WM.encrypt = function(t3, e) {
  for (; t3._cache.length < e.length; ) t3._cache = hr.concat([t3._cache, QY(t3)]);
  var n = t3._cache.slice(0, e.length);
  return t3._cache = t3._cache.slice(e.length), OY(e, n);
};
var G3 = {};
function KY(t3) {
  for (var e = t3.length, n; e--; ) if (n = t3.readUInt8(e), n === 255) t3.writeUInt8(0, e);
  else {
    n++, t3.writeUInt8(n, e);
    break;
  }
}
var JM = KY, HY = yd, $w = Tn.Buffer, qY = JM;
function zY(t3) {
  var e = t3._cipher.encryptBlockRaw(t3._prev);
  return qY(t3._prev), e;
}
var Q2 = 16;
G3.encrypt = function(t3, e) {
  var n = Math.ceil(e.length / Q2), r = t3._cache.length;
  t3._cache = $w.concat([t3._cache, $w.allocUnsafe(n * Q2)]);
  for (var s = 0; s < n; s++) {
    var i = zY(t3), a = r + s * Q2;
    t3._cache.writeUInt32BE(i[0], a + 0), t3._cache.writeUInt32BE(i[1], a + 4), t3._cache.writeUInt32BE(i[2], a + 8), t3._cache.writeUInt32BE(i[3], a + 12);
  }
  var o = t3._cache.slice(0, e.length);
  return t3._cache = t3._cache.slice(e.length), HY(e, o);
};
const GY = { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, VY = { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, YY = { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, ZM = { "aes-128-ecb": { cipher: "AES", key: 128, iv: 0, mode: "ECB", type: "block" }, "aes-192-ecb": { cipher: "AES", key: 192, iv: 0, mode: "ECB", type: "block" }, "aes-256-ecb": { cipher: "AES", key: 256, iv: 0, mode: "ECB", type: "block" }, "aes-128-cbc": { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, "aes-192-cbc": { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, "aes-256-cbc": { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, aes128: GY, aes192: VY, aes256: YY, "aes-128-cfb": { cipher: "AES", key: 128, iv: 16, mode: "CFB", type: "stream" }, "aes-192-cfb": { cipher: "AES", key: 192, iv: 16, mode: "CFB", type: "stream" }, "aes-256-cfb": { cipher: "AES", key: 256, iv: 16, mode: "CFB", type: "stream" }, "aes-128-cfb8": { cipher: "AES", key: 128, iv: 16, mode: "CFB8", type: "stream" }, "aes-192-cfb8": { cipher: "AES", key: 192, iv: 16, mode: "CFB8", type: "stream" }, "aes-256-cfb8": { cipher: "AES", key: 256, iv: 16, mode: "CFB8", type: "stream" }, "aes-128-cfb1": { cipher: "AES", key: 128, iv: 16, mode: "CFB1", type: "stream" }, "aes-192-cfb1": { cipher: "AES", key: 192, iv: 16, mode: "CFB1", type: "stream" }, "aes-256-cfb1": { cipher: "AES", key: 256, iv: 16, mode: "CFB1", type: "stream" }, "aes-128-ofb": { cipher: "AES", key: 128, iv: 16, mode: "OFB", type: "stream" }, "aes-192-ofb": { cipher: "AES", key: 192, iv: 16, mode: "OFB", type: "stream" }, "aes-256-ofb": { cipher: "AES", key: 256, iv: 16, mode: "OFB", type: "stream" }, "aes-128-ctr": { cipher: "AES", key: 128, iv: 16, mode: "CTR", type: "stream" }, "aes-192-ctr": { cipher: "AES", key: 192, iv: 16, mode: "CTR", type: "stream" }, "aes-256-ctr": { cipher: "AES", key: 256, iv: 16, mode: "CTR", type: "stream" }, "aes-128-gcm": { cipher: "AES", key: 128, iv: 12, mode: "GCM", type: "auth" }, "aes-192-gcm": { cipher: "AES", key: 192, iv: 12, mode: "GCM", type: "auth" }, "aes-256-gcm": { cipher: "AES", key: 256, iv: 12, mode: "GCM", type: "auth" } };
var WY = { ECB: PA, CBC: NA, CFB: GM, CFB8: VM, CFB1: YM, OFB: WM, CTR: G3, GCM: G3 }, qp = ZM;
for (var Tw in qp) qp[Tw].module = WY[qp[Tw].mode];
var UA = qp, bd = {}, k1 = Tn.Buffer;
function LA(t3) {
  k1.isBuffer(t3) || (t3 = k1.from(t3));
  for (var e = t3.length / 4 | 0, n = new Array(e), r = 0; r < e; r++) n[r] = t3.readUInt32BE(r * 4);
  return n;
}
function K2(t3) {
  for (var e = 0; e < t3.length; t3++) t3[e] = 0;
}
function jM(t3, e, n, r, s) {
  for (var i = n[0], a = n[1], o = n[2], f = n[3], c = t3[0] ^ e[0], l = t3[1] ^ e[1], h = t3[2] ^ e[2], m = t3[3] ^ e[3], v, b, A, _, C = 4, I = 1; I < s; I++) v = i[c >>> 24] ^ a[l >>> 16 & 255] ^ o[h >>> 8 & 255] ^ f[m & 255] ^ e[C++], b = i[l >>> 24] ^ a[h >>> 16 & 255] ^ o[m >>> 8 & 255] ^ f[c & 255] ^ e[C++], A = i[h >>> 24] ^ a[m >>> 16 & 255] ^ o[c >>> 8 & 255] ^ f[l & 255] ^ e[C++], _ = i[m >>> 24] ^ a[c >>> 16 & 255] ^ o[l >>> 8 & 255] ^ f[h & 255] ^ e[C++], c = v, l = b, h = A, m = _;
  return v = (r[c >>> 24] << 24 | r[l >>> 16 & 255] << 16 | r[h >>> 8 & 255] << 8 | r[m & 255]) ^ e[C++], b = (r[l >>> 24] << 24 | r[h >>> 16 & 255] << 16 | r[m >>> 8 & 255] << 8 | r[c & 255]) ^ e[C++], A = (r[h >>> 24] << 24 | r[m >>> 16 & 255] << 16 | r[c >>> 8 & 255] << 8 | r[l & 255]) ^ e[C++], _ = (r[m >>> 24] << 24 | r[c >>> 16 & 255] << 16 | r[l >>> 8 & 255] << 8 | r[h & 255]) ^ e[C++], v = v >>> 0, b = b >>> 0, A = A >>> 0, _ = _ >>> 0, [v, b, A, _];
}
var JY = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], ei = function() {
  for (var t3 = new Array(256), e = 0; e < 256; e++) e < 128 ? t3[e] = e << 1 : t3[e] = e << 1 ^ 283;
  for (var n = [], r = [], s = [[], [], [], []], i = [[], [], [], []], a = 0, o = 0, f = 0; f < 256; ++f) {
    var c = o ^ o << 1 ^ o << 2 ^ o << 3 ^ o << 4;
    c = c >>> 8 ^ c & 255 ^ 99, n[a] = c, r[c] = a;
    var l = t3[a], h = t3[l], m = t3[h], v = t3[c] * 257 ^ c * 16843008;
    s[0][a] = v << 24 | v >>> 8, s[1][a] = v << 16 | v >>> 16, s[2][a] = v << 8 | v >>> 24, s[3][a] = v, v = m * 16843009 ^ h * 65537 ^ l * 257 ^ a * 16843008, i[0][c] = v << 24 | v >>> 8, i[1][c] = v << 16 | v >>> 16, i[2][c] = v << 8 | v >>> 24, i[3][c] = v, a === 0 ? a = o = 1 : (a = l ^ t3[t3[t3[m ^ l]]], o ^= t3[t3[o]]);
  }
  return { SBOX: n, INV_SBOX: r, SUB_MIX: s, INV_SUB_MIX: i };
}();
function ca(t3) {
  this._key = LA(t3), this._reset();
}
ca.blockSize = 4 * 4;
ca.keySize = 256 / 8;
ca.prototype.blockSize = ca.blockSize;
ca.prototype.keySize = ca.keySize;
ca.prototype._reset = function() {
  for (var t3 = this._key, e = t3.length, n = e + 6, r = (n + 1) * 4, s = [], i = 0; i < e; i++) s[i] = t3[i];
  for (i = e; i < r; i++) {
    var a = s[i - 1];
    i % e === 0 ? (a = a << 8 | a >>> 24, a = ei.SBOX[a >>> 24] << 24 | ei.SBOX[a >>> 16 & 255] << 16 | ei.SBOX[a >>> 8 & 255] << 8 | ei.SBOX[a & 255], a ^= JY[i / e | 0] << 24) : e > 6 && i % e === 4 && (a = ei.SBOX[a >>> 24] << 24 | ei.SBOX[a >>> 16 & 255] << 16 | ei.SBOX[a >>> 8 & 255] << 8 | ei.SBOX[a & 255]), s[i] = s[i - e] ^ a;
  }
  for (var o = [], f = 0; f < r; f++) {
    var c = r - f, l = s[c - (f % 4 ? 0 : 4)];
    f < 4 || c <= 4 ? o[f] = l : o[f] = ei.INV_SUB_MIX[0][ei.SBOX[l >>> 24]] ^ ei.INV_SUB_MIX[1][ei.SBOX[l >>> 16 & 255]] ^ ei.INV_SUB_MIX[2][ei.SBOX[l >>> 8 & 255]] ^ ei.INV_SUB_MIX[3][ei.SBOX[l & 255]];
  }
  this._nRounds = n, this._keySchedule = s, this._invKeySchedule = o;
};
ca.prototype.encryptBlockRaw = function(t3) {
  return t3 = LA(t3), jM(t3, this._keySchedule, ei.SUB_MIX, ei.SBOX, this._nRounds);
};
ca.prototype.encryptBlock = function(t3) {
  var e = this.encryptBlockRaw(t3), n = k1.allocUnsafe(16);
  return n.writeUInt32BE(e[0], 0), n.writeUInt32BE(e[1], 4), n.writeUInt32BE(e[2], 8), n.writeUInt32BE(e[3], 12), n;
};
ca.prototype.decryptBlock = function(t3) {
  t3 = LA(t3);
  var e = t3[1];
  t3[1] = t3[3], t3[3] = e;
  var n = jM(t3, this._invKeySchedule, ei.INV_SUB_MIX, ei.INV_SBOX, this._nRounds), r = k1.allocUnsafe(16);
  return r.writeUInt32BE(n[0], 0), r.writeUInt32BE(n[3], 4), r.writeUInt32BE(n[2], 8), r.writeUInt32BE(n[1], 12), r;
};
ca.prototype.scrub = function() {
  K2(this._keySchedule), K2(this._invKeySchedule), K2(this._key);
};
bd.AES = ca;
var Mu = Tn.Buffer, ZY = Mu.alloc(16, 0);
function jY(t3) {
  return [t3.readUInt32BE(0), t3.readUInt32BE(4), t3.readUInt32BE(8), t3.readUInt32BE(12)];
}
function XM(t3) {
  var e = Mu.allocUnsafe(16);
  return e.writeUInt32BE(t3[0] >>> 0, 0), e.writeUInt32BE(t3[1] >>> 0, 4), e.writeUInt32BE(t3[2] >>> 0, 8), e.writeUInt32BE(t3[3] >>> 0, 12), e;
}
function Ad(t3) {
  this.h = t3, this.state = Mu.alloc(16, 0), this.cache = Mu.allocUnsafe(0);
}
Ad.prototype.ghash = function(t3) {
  for (var e = -1; ++e < t3.length; ) this.state[e] ^= t3[e];
  this._multiply();
};
Ad.prototype._multiply = function() {
  for (var t3 = jY(this.h), e = [0, 0, 0, 0], n, r, s, i = -1; ++i < 128; ) {
    for (r = (this.state[~~(i / 8)] & 1 << 7 - i % 8) !== 0, r && (e[0] ^= t3[0], e[1] ^= t3[1], e[2] ^= t3[2], e[3] ^= t3[3]), s = (t3[3] & 1) !== 0, n = 3; n > 0; n--) t3[n] = t3[n] >>> 1 | (t3[n - 1] & 1) << 31;
    t3[0] = t3[0] >>> 1, s && (t3[0] = t3[0] ^ 225 << 24);
  }
  this.state = XM(e);
};
Ad.prototype.update = function(t3) {
  this.cache = Mu.concat([this.cache, t3]);
  for (var e; this.cache.length >= 16; ) e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(e);
};
Ad.prototype.final = function(t3, e) {
  return this.cache.length && this.ghash(Mu.concat([this.cache, ZY], 16)), this.ghash(XM([0, t3, 0, e])), this.state;
};
var XY = Ad, eW = bd, ws = Tn.Buffer, e$ = gl, tW = wr, t$ = XY, rW = yd, nW = JM;
function iW(t3, e) {
  var n = 0;
  t3.length !== e.length && n++;
  for (var r = Math.min(t3.length, e.length), s = 0; s < r; ++s) n += t3[s] ^ e[s];
  return n;
}
function sW(t3, e, n) {
  if (e.length === 12) return t3._finID = ws.concat([e, ws.from([0, 0, 0, 1])]), ws.concat([e, ws.from([0, 0, 0, 2])]);
  var r = new t$(n), s = e.length, i = s % 16;
  r.update(e), i && (i = 16 - i, r.update(ws.alloc(i, 0))), r.update(ws.alloc(8, 0));
  var a = s * 8, o = ws.alloc(8);
  o.writeUIntBE(a, 0, 8), r.update(o), t3._finID = r.state;
  var f = ws.from(t3._finID);
  return nW(f), f;
}
function b0(t3, e, n, r) {
  e$.call(this);
  var s = ws.alloc(4, 0);
  this._cipher = new eW.AES(e);
  var i = this._cipher.encryptBlock(s);
  this._ghash = new t$(i), n = sW(this, n, i), this._prev = ws.from(n), this._cache = ws.allocUnsafe(0), this._secCache = ws.allocUnsafe(0), this._decrypt = r, this._alen = 0, this._len = 0, this._mode = t3, this._authTag = null, this._called = false;
}
tW(b0, e$);
b0.prototype._update = function(t3) {
  if (!this._called && this._alen) {
    var e = 16 - this._alen % 16;
    e < 16 && (e = ws.alloc(e, 0), this._ghash.update(e));
  }
  this._called = true;
  var n = this._mode.encrypt(this, t3);
  return this._decrypt ? this._ghash.update(t3) : this._ghash.update(n), this._len += t3.length, n;
};
b0.prototype._final = function() {
  if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
  var t3 = rW(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
  if (this._decrypt && iW(t3, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
  this._authTag = t3, this._cipher.scrub();
};
b0.prototype.getAuthTag = function() {
  if (this._decrypt || !ws.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
  return this._authTag;
};
b0.prototype.setAuthTag = function(e) {
  if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
  this._authTag = e;
};
b0.prototype.setAAD = function(e) {
  if (this._called) throw new Error("Attempting to set AAD in unsupported state");
  this._ghash.update(e), this._alen += e.length;
};
var r$ = b0, aW = bd, H2 = Tn.Buffer, n$ = gl, oW = wr;
function Wg(t3, e, n, r) {
  n$.call(this), this._cipher = new aW.AES(e), this._prev = H2.from(n), this._cache = H2.allocUnsafe(0), this._secCache = H2.allocUnsafe(0), this._decrypt = r, this._mode = t3;
}
oW(Wg, n$);
Wg.prototype._update = function(t3) {
  return this._mode.encrypt(this, t3, this._decrypt);
};
Wg.prototype._final = function() {
  this._cipher.scrub();
};
var i$ = Wg, Ml = Tn.Buffer, fW = MA;
function lW(t3, e, n, r) {
  if (Ml.isBuffer(t3) || (t3 = Ml.from(t3, "binary")), e && (Ml.isBuffer(e) || (e = Ml.from(e, "binary")), e.length !== 8)) throw new RangeError("salt should be Buffer with 8 byte length");
  for (var s = n / 8, i = Ml.alloc(s), a = Ml.alloc(r || 0), o = Ml.alloc(0); s > 0 || r > 0; ) {
    var f = new fW();
    f.update(o), f.update(t3), e && f.update(e), o = f.digest();
    var c = 0;
    if (s > 0) {
      var l = i.length - s;
      c = Math.min(s, o.length), o.copy(i, l, 0, c), s -= c;
    }
    if (c < o.length && r > 0) {
      var h = a.length - r, m = Math.min(r, o.length - c);
      o.copy(a, h, c, c + m), r -= m;
    }
  }
  return o.fill(0), { key: i, iv: a };
}
var Jg = lW, s$ = UA, uW = r$, af = Tn.Buffer, cW = i$, a$ = gl, hW = bd, dW = Jg, pW = wr;
function wd(t3, e, n) {
  a$.call(this), this._cache = new Zg(), this._cipher = new hW.AES(e), this._prev = af.from(n), this._mode = t3, this._autopadding = true;
}
pW(wd, a$);
wd.prototype._update = function(t3) {
  this._cache.add(t3);
  for (var e, n, r = []; e = this._cache.get(); ) n = this._mode.encrypt(this, e), r.push(n);
  return af.concat(r);
};
var gW = af.alloc(16, 16);
wd.prototype._final = function() {
  var t3 = this._cache.flush();
  if (this._autopadding) return t3 = this._mode.encrypt(this, t3), this._cipher.scrub(), t3;
  if (!t3.equals(gW)) throw this._cipher.scrub(), new Error("data not multiple of block length");
};
wd.prototype.setAutoPadding = function(t3) {
  return this._autopadding = !!t3, this;
};
function Zg() {
  this.cache = af.allocUnsafe(0);
}
Zg.prototype.add = function(t3) {
  this.cache = af.concat([this.cache, t3]);
};
Zg.prototype.get = function() {
  if (this.cache.length > 15) {
    var t3 = this.cache.slice(0, 16);
    return this.cache = this.cache.slice(16), t3;
  }
  return null;
};
Zg.prototype.flush = function() {
  for (var t3 = 16 - this.cache.length, e = af.allocUnsafe(t3), n = -1; ++n < t3; ) e.writeUInt8(t3, n);
  return af.concat([this.cache, e]);
};
function o$(t3, e, n) {
  var r = s$[t3.toLowerCase()];
  if (!r) throw new TypeError("invalid suite type");
  if (typeof e == "string" && (e = af.from(e)), e.length !== r.key / 8) throw new TypeError("invalid key length " + e.length);
  if (typeof n == "string" && (n = af.from(n)), r.mode !== "GCM" && n.length !== r.iv) throw new TypeError("invalid iv length " + n.length);
  return r.type === "stream" ? new cW(r.module, e, n) : r.type === "auth" ? new uW(r.module, e, n) : new wd(r.module, e, n);
}
function mW(t3, e) {
  var n = s$[t3.toLowerCase()];
  if (!n) throw new TypeError("invalid suite type");
  var r = dW(e, false, n.key, n.iv);
  return o$(t3, r.key, r.iv);
}
FA.createCipheriv = o$;
FA.createCipher = mW;
var OA = {}, vW = r$, $u = Tn.Buffer, f$ = UA, yW = i$, l$ = gl, bW = bd, AW = Jg, wW = wr;
function xd(t3, e, n) {
  l$.call(this), this._cache = new jg(), this._last = void 0, this._cipher = new bW.AES(e), this._prev = $u.from(n), this._mode = t3, this._autopadding = true;
}
wW(xd, l$);
xd.prototype._update = function(t3) {
  this._cache.add(t3);
  for (var e, n, r = []; e = this._cache.get(this._autopadding); ) n = this._mode.decrypt(this, e), r.push(n);
  return $u.concat(r);
};
xd.prototype._final = function() {
  var t3 = this._cache.flush();
  if (this._autopadding) return xW(this._mode.decrypt(this, t3));
  if (t3) throw new Error("data not multiple of block length");
};
xd.prototype.setAutoPadding = function(t3) {
  return this._autopadding = !!t3, this;
};
function jg() {
  this.cache = $u.allocUnsafe(0);
}
jg.prototype.add = function(t3) {
  this.cache = $u.concat([this.cache, t3]);
};
jg.prototype.get = function(t3) {
  var e;
  if (t3) {
    if (this.cache.length > 16) return e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e;
  } else if (this.cache.length >= 16) return e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e;
  return null;
};
jg.prototype.flush = function() {
  if (this.cache.length) return this.cache;
};
function xW(t3) {
  var e = t3[15];
  if (e < 1 || e > 16) throw new Error("unable to decrypt data");
  for (var n = -1; ++n < e; ) if (t3[n + (16 - e)] !== e) throw new Error("unable to decrypt data");
  if (e !== 16) return t3.slice(0, 16 - e);
}
function u$(t3, e, n) {
  var r = f$[t3.toLowerCase()];
  if (!r) throw new TypeError("invalid suite type");
  if (typeof n == "string" && (n = $u.from(n)), r.mode !== "GCM" && n.length !== r.iv) throw new TypeError("invalid iv length " + n.length);
  if (typeof e == "string" && (e = $u.from(e)), e.length !== r.key / 8) throw new TypeError("invalid key length " + e.length);
  return r.type === "stream" ? new yW(r.module, e, n, true) : r.type === "auth" ? new vW(r.module, e, n, true) : new xd(r.module, e, n);
}
function _W(t3, e) {
  var n = f$[t3.toLowerCase()];
  if (!n) throw new TypeError("invalid suite type");
  var r = AW(e, false, n.key, n.iv);
  return u$(t3, r.key, r.iv);
}
OA.createDecipher = _W;
OA.createDecipheriv = u$;
var c$ = FA, h$ = OA, EW = ZM;
function BW() {
  return Object.keys(EW);
}
qs.createCipher = qs.Cipher = c$.createCipher;
qs.createCipheriv = qs.Cipheriv = c$.createCipheriv;
qs.createDecipher = qs.Decipher = h$.createDecipher;
qs.createDecipheriv = qs.Decipheriv = h$.createDecipheriv;
qs.listCiphers = qs.getCiphers = BW;
var d$ = {};
(function(t3) {
  t3["des-ecb"] = { key: 8, iv: 0 }, t3["des-cbc"] = t3.des = { key: 8, iv: 8 }, t3["des-ede3-cbc"] = t3.des3 = { key: 24, iv: 8 }, t3["des-ede3"] = { key: 24, iv: 0 }, t3["des-ede-cbc"] = { key: 16, iv: 8 }, t3["des-ede"] = { key: 16, iv: 0 };
})(d$);
var p$ = FY, QA = qs, el = UA, rf = d$, g$ = Jg;
function CW(t3, e) {
  t3 = t3.toLowerCase();
  var n, r;
  if (el[t3]) n = el[t3].key, r = el[t3].iv;
  else if (rf[t3]) n = rf[t3].key * 8, r = rf[t3].iv;
  else throw new TypeError("invalid suite type");
  var s = g$(e, false, n, r);
  return m$(t3, s.key, s.iv);
}
function kW(t3, e) {
  t3 = t3.toLowerCase();
  var n, r;
  if (el[t3]) n = el[t3].key, r = el[t3].iv;
  else if (rf[t3]) n = rf[t3].key * 8, r = rf[t3].iv;
  else throw new TypeError("invalid suite type");
  var s = g$(e, false, n, r);
  return v$(t3, s.key, s.iv);
}
function m$(t3, e, n) {
  if (t3 = t3.toLowerCase(), el[t3]) return QA.createCipheriv(t3, e, n);
  if (rf[t3]) return new p$({ key: e, iv: n, mode: t3 });
  throw new TypeError("invalid suite type");
}
function v$(t3, e, n) {
  if (t3 = t3.toLowerCase(), el[t3]) return QA.createDecipheriv(t3, e, n);
  if (rf[t3]) return new p$({ key: e, iv: n, mode: t3, decrypt: true });
  throw new TypeError("invalid suite type");
}
function IW() {
  return Object.keys(rf).concat(QA.getCiphers());
}
Ta.createCipher = Ta.Cipher = CW;
Ta.createCipheriv = Ta.Cipheriv = m$;
Ta.createDecipher = Ta.Decipher = kW;
Ta.createDecipheriv = Ta.Decipheriv = v$;
Ta.listCiphers = Ta.getCiphers = IW;
var $l = {}, KA = { exports: {} };
KA.exports;
(function(t3) {
  (function(e, n) {
    function r(B, u) {
      if (!B) throw new Error(u || "Assertion failed");
    }
    function s(B, u) {
      B.super_ = u;
      var p = function() {
      };
      p.prototype = u.prototype, B.prototype = new p(), B.prototype.constructor = B;
    }
    function i(B, u, p) {
      if (i.isBN(B)) return B;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, B !== null && ((u === "le" || u === "be") && (p = u, u = 10), this._init(B || 0, u || 10, p || "be"));
    }
    typeof e == "object" ? e.exports = i : n.BN = i, i.BN = i, i.wordSize = 26;
    var a;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? a = window.Buffer : a = $n.Buffer;
    } catch {
    }
    i.isBN = function(u) {
      return u instanceof i ? true : u !== null && typeof u == "object" && u.constructor.wordSize === i.wordSize && Array.isArray(u.words);
    }, i.max = function(u, p) {
      return u.cmp(p) > 0 ? u : p;
    }, i.min = function(u, p) {
      return u.cmp(p) < 0 ? u : p;
    }, i.prototype._init = function(u, p, d) {
      if (typeof u == "number") return this._initNumber(u, p, d);
      if (typeof u == "object") return this._initArray(u, p, d);
      p === "hex" && (p = 16), r(p === (p | 0) && p >= 2 && p <= 36), u = u.toString().replace(/\s+/g, "");
      var y = 0;
      u[0] === "-" && (y++, this.negative = 1), y < u.length && (p === 16 ? this._parseHex(u, y, d) : (this._parseBase(u, p, y), d === "le" && this._initArray(this.toArray(), p, d)));
    }, i.prototype._initNumber = function(u, p, d) {
      u < 0 && (this.negative = 1, u = -u), u < 67108864 ? (this.words = [u & 67108863], this.length = 1) : u < 4503599627370496 ? (this.words = [u & 67108863, u / 67108864 & 67108863], this.length = 2) : (r(u < 9007199254740992), this.words = [u & 67108863, u / 67108864 & 67108863, 1], this.length = 3), d === "le" && this._initArray(this.toArray(), p, d);
    }, i.prototype._initArray = function(u, p, d) {
      if (r(typeof u.length == "number"), u.length <= 0) return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(u.length / 3), this.words = new Array(this.length);
      for (var y = 0; y < this.length; y++) this.words[y] = 0;
      var w, E, M = 0;
      if (d === "be") for (y = u.length - 1, w = 0; y >= 0; y -= 3) E = u[y] | u[y - 1] << 8 | u[y - 2] << 16, this.words[w] |= E << M & 67108863, this.words[w + 1] = E >>> 26 - M & 67108863, M += 24, M >= 26 && (M -= 26, w++);
      else if (d === "le") for (y = 0, w = 0; y < u.length; y += 3) E = u[y] | u[y + 1] << 8 | u[y + 2] << 16, this.words[w] |= E << M & 67108863, this.words[w + 1] = E >>> 26 - M & 67108863, M += 24, M >= 26 && (M -= 26, w++);
      return this.strip();
    };
    function o(B, u) {
      var p = B.charCodeAt(u);
      return p >= 65 && p <= 70 ? p - 55 : p >= 97 && p <= 102 ? p - 87 : p - 48 & 15;
    }
    function f(B, u, p) {
      var d = o(B, p);
      return p - 1 >= u && (d |= o(B, p - 1) << 4), d;
    }
    i.prototype._parseHex = function(u, p, d) {
      this.length = Math.ceil((u.length - p) / 6), this.words = new Array(this.length);
      for (var y = 0; y < this.length; y++) this.words[y] = 0;
      var w = 0, E = 0, M;
      if (d === "be") for (y = u.length - 1; y >= p; y -= 2) M = f(u, p, y) << w, this.words[E] |= M & 67108863, w >= 18 ? (w -= 18, E += 1, this.words[E] |= M >>> 26) : w += 8;
      else {
        var x = u.length - p;
        for (y = x % 2 === 0 ? p + 1 : p; y < u.length; y += 2) M = f(u, p, y) << w, this.words[E] |= M & 67108863, w >= 18 ? (w -= 18, E += 1, this.words[E] |= M >>> 26) : w += 8;
      }
      this.strip();
    };
    function c(B, u, p, d) {
      for (var y = 0, w = Math.min(B.length, p), E = u; E < w; E++) {
        var M = B.charCodeAt(E) - 48;
        y *= d, M >= 49 ? y += M - 49 + 10 : M >= 17 ? y += M - 17 + 10 : y += M;
      }
      return y;
    }
    i.prototype._parseBase = function(u, p, d) {
      this.words = [0], this.length = 1;
      for (var y = 0, w = 1; w <= 67108863; w *= p) y++;
      y--, w = w / p | 0;
      for (var E = u.length - d, M = E % y, x = Math.min(E, E - M) + d, g = 0, k = d; k < x; k += y) g = c(u, k, k + y, p), this.imuln(w), this.words[0] + g < 67108864 ? this.words[0] += g : this._iaddn(g);
      if (M !== 0) {
        var T = 1;
        for (g = c(u, k, u.length, p), k = 0; k < M; k++) T *= p;
        this.imuln(T), this.words[0] + g < 67108864 ? this.words[0] += g : this._iaddn(g);
      }
      this.strip();
    }, i.prototype.copy = function(u) {
      u.words = new Array(this.length);
      for (var p = 0; p < this.length; p++) u.words[p] = this.words[p];
      u.length = this.length, u.negative = this.negative, u.red = this.red;
    }, i.prototype.clone = function() {
      var u = new i(null);
      return this.copy(u), u;
    }, i.prototype._expand = function(u) {
      for (; this.length < u; ) this.words[this.length++] = 0;
      return this;
    }, i.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; ) this.length--;
      return this._normSign();
    }, i.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, i.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var l = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], h = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], m = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    i.prototype.toString = function(u, p) {
      u = u || 10, p = p | 0 || 1;
      var d;
      if (u === 16 || u === "hex") {
        d = "";
        for (var y = 0, w = 0, E = 0; E < this.length; E++) {
          var M = this.words[E], x = ((M << y | w) & 16777215).toString(16);
          w = M >>> 24 - y & 16777215, y += 2, y >= 26 && (y -= 26, E--), w !== 0 || E !== this.length - 1 ? d = l[6 - x.length] + x + d : d = x + d;
        }
        for (w !== 0 && (d = w.toString(16) + d); d.length % p !== 0; ) d = "0" + d;
        return this.negative !== 0 && (d = "-" + d), d;
      }
      if (u === (u | 0) && u >= 2 && u <= 36) {
        var g = h[u], k = m[u];
        d = "";
        var T = this.clone();
        for (T.negative = 0; !T.isZero(); ) {
          var O = T.modn(k).toString(u);
          T = T.idivn(k), T.isZero() ? d = O + d : d = l[g - O.length] + O + d;
        }
        for (this.isZero() && (d = "0" + d); d.length % p !== 0; ) d = "0" + d;
        return this.negative !== 0 && (d = "-" + d), d;
      }
      r(false, "Base should be between 2 and 36");
    }, i.prototype.toNumber = function() {
      var u = this.words[0];
      return this.length === 2 ? u += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? u += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -u : u;
    }, i.prototype.toJSON = function() {
      return this.toString(16);
    }, i.prototype.toBuffer = function(u, p) {
      return r(typeof a < "u"), this.toArrayLike(a, u, p);
    }, i.prototype.toArray = function(u, p) {
      return this.toArrayLike(Array, u, p);
    }, i.prototype.toArrayLike = function(u, p, d) {
      var y = this.byteLength(), w = d || Math.max(1, y);
      r(y <= w, "byte array longer than desired length"), r(w > 0, "Requested array length <= 0"), this.strip();
      var E = p === "le", M = new u(w), x, g, k = this.clone();
      if (E) {
        for (g = 0; !k.isZero(); g++) x = k.andln(255), k.iushrn(8), M[g] = x;
        for (; g < w; g++) M[g] = 0;
      } else {
        for (g = 0; g < w - y; g++) M[g] = 0;
        for (g = 0; !k.isZero(); g++) x = k.andln(255), k.iushrn(8), M[w - g - 1] = x;
      }
      return M;
    }, Math.clz32 ? i.prototype._countBits = function(u) {
      return 32 - Math.clz32(u);
    } : i.prototype._countBits = function(u) {
      var p = u, d = 0;
      return p >= 4096 && (d += 13, p >>>= 13), p >= 64 && (d += 7, p >>>= 7), p >= 8 && (d += 4, p >>>= 4), p >= 2 && (d += 2, p >>>= 2), d + p;
    }, i.prototype._zeroBits = function(u) {
      if (u === 0) return 26;
      var p = u, d = 0;
      return p & 8191 || (d += 13, p >>>= 13), p & 127 || (d += 7, p >>>= 7), p & 15 || (d += 4, p >>>= 4), p & 3 || (d += 2, p >>>= 2), p & 1 || d++, d;
    }, i.prototype.bitLength = function() {
      var u = this.words[this.length - 1], p = this._countBits(u);
      return (this.length - 1) * 26 + p;
    };
    function v(B) {
      for (var u = new Array(B.bitLength()), p = 0; p < u.length; p++) {
        var d = p / 26 | 0, y = p % 26;
        u[p] = (B.words[d] & 1 << y) >>> y;
      }
      return u;
    }
    i.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var u = 0, p = 0; p < this.length; p++) {
        var d = this._zeroBits(this.words[p]);
        if (u += d, d !== 26) break;
      }
      return u;
    }, i.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, i.prototype.toTwos = function(u) {
      return this.negative !== 0 ? this.abs().inotn(u).iaddn(1) : this.clone();
    }, i.prototype.fromTwos = function(u) {
      return this.testn(u - 1) ? this.notn(u).iaddn(1).ineg() : this.clone();
    }, i.prototype.isNeg = function() {
      return this.negative !== 0;
    }, i.prototype.neg = function() {
      return this.clone().ineg();
    }, i.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, i.prototype.iuor = function(u) {
      for (; this.length < u.length; ) this.words[this.length++] = 0;
      for (var p = 0; p < u.length; p++) this.words[p] = this.words[p] | u.words[p];
      return this.strip();
    }, i.prototype.ior = function(u) {
      return r((this.negative | u.negative) === 0), this.iuor(u);
    }, i.prototype.or = function(u) {
      return this.length > u.length ? this.clone().ior(u) : u.clone().ior(this);
    }, i.prototype.uor = function(u) {
      return this.length > u.length ? this.clone().iuor(u) : u.clone().iuor(this);
    }, i.prototype.iuand = function(u) {
      var p;
      this.length > u.length ? p = u : p = this;
      for (var d = 0; d < p.length; d++) this.words[d] = this.words[d] & u.words[d];
      return this.length = p.length, this.strip();
    }, i.prototype.iand = function(u) {
      return r((this.negative | u.negative) === 0), this.iuand(u);
    }, i.prototype.and = function(u) {
      return this.length > u.length ? this.clone().iand(u) : u.clone().iand(this);
    }, i.prototype.uand = function(u) {
      return this.length > u.length ? this.clone().iuand(u) : u.clone().iuand(this);
    }, i.prototype.iuxor = function(u) {
      var p, d;
      this.length > u.length ? (p = this, d = u) : (p = u, d = this);
      for (var y = 0; y < d.length; y++) this.words[y] = p.words[y] ^ d.words[y];
      if (this !== p) for (; y < p.length; y++) this.words[y] = p.words[y];
      return this.length = p.length, this.strip();
    }, i.prototype.ixor = function(u) {
      return r((this.negative | u.negative) === 0), this.iuxor(u);
    }, i.prototype.xor = function(u) {
      return this.length > u.length ? this.clone().ixor(u) : u.clone().ixor(this);
    }, i.prototype.uxor = function(u) {
      return this.length > u.length ? this.clone().iuxor(u) : u.clone().iuxor(this);
    }, i.prototype.inotn = function(u) {
      r(typeof u == "number" && u >= 0);
      var p = Math.ceil(u / 26) | 0, d = u % 26;
      this._expand(p), d > 0 && p--;
      for (var y = 0; y < p; y++) this.words[y] = ~this.words[y] & 67108863;
      return d > 0 && (this.words[y] = ~this.words[y] & 67108863 >> 26 - d), this.strip();
    }, i.prototype.notn = function(u) {
      return this.clone().inotn(u);
    }, i.prototype.setn = function(u, p) {
      r(typeof u == "number" && u >= 0);
      var d = u / 26 | 0, y = u % 26;
      return this._expand(d + 1), p ? this.words[d] = this.words[d] | 1 << y : this.words[d] = this.words[d] & ~(1 << y), this.strip();
    }, i.prototype.iadd = function(u) {
      var p;
      if (this.negative !== 0 && u.negative === 0) return this.negative = 0, p = this.isub(u), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && u.negative !== 0) return u.negative = 0, p = this.isub(u), u.negative = 1, p._normSign();
      var d, y;
      this.length > u.length ? (d = this, y = u) : (d = u, y = this);
      for (var w = 0, E = 0; E < y.length; E++) p = (d.words[E] | 0) + (y.words[E] | 0) + w, this.words[E] = p & 67108863, w = p >>> 26;
      for (; w !== 0 && E < d.length; E++) p = (d.words[E] | 0) + w, this.words[E] = p & 67108863, w = p >>> 26;
      if (this.length = d.length, w !== 0) this.words[this.length] = w, this.length++;
      else if (d !== this) for (; E < d.length; E++) this.words[E] = d.words[E];
      return this;
    }, i.prototype.add = function(u) {
      var p;
      return u.negative !== 0 && this.negative === 0 ? (u.negative = 0, p = this.sub(u), u.negative ^= 1, p) : u.negative === 0 && this.negative !== 0 ? (this.negative = 0, p = u.sub(this), this.negative = 1, p) : this.length > u.length ? this.clone().iadd(u) : u.clone().iadd(this);
    }, i.prototype.isub = function(u) {
      if (u.negative !== 0) {
        u.negative = 0;
        var p = this.iadd(u);
        return u.negative = 1, p._normSign();
      } else if (this.negative !== 0) return this.negative = 0, this.iadd(u), this.negative = 1, this._normSign();
      var d = this.cmp(u);
      if (d === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var y, w;
      d > 0 ? (y = this, w = u) : (y = u, w = this);
      for (var E = 0, M = 0; M < w.length; M++) p = (y.words[M] | 0) - (w.words[M] | 0) + E, E = p >> 26, this.words[M] = p & 67108863;
      for (; E !== 0 && M < y.length; M++) p = (y.words[M] | 0) + E, E = p >> 26, this.words[M] = p & 67108863;
      if (E === 0 && M < y.length && y !== this) for (; M < y.length; M++) this.words[M] = y.words[M];
      return this.length = Math.max(this.length, M), y !== this && (this.negative = 1), this.strip();
    }, i.prototype.sub = function(u) {
      return this.clone().isub(u);
    };
    function b(B, u, p) {
      p.negative = u.negative ^ B.negative;
      var d = B.length + u.length | 0;
      p.length = d, d = d - 1 | 0;
      var y = B.words[0] | 0, w = u.words[0] | 0, E = y * w, M = E & 67108863, x = E / 67108864 | 0;
      p.words[0] = M;
      for (var g = 1; g < d; g++) {
        for (var k = x >>> 26, T = x & 67108863, O = Math.min(g, u.length - 1), K = Math.max(0, g - B.length + 1); K <= O; K++) {
          var Y = g - K | 0;
          y = B.words[Y] | 0, w = u.words[K] | 0, E = y * w + T, k += E / 67108864 | 0, T = E & 67108863;
        }
        p.words[g] = T | 0, x = k | 0;
      }
      return x !== 0 ? p.words[g] = x | 0 : p.length--, p.strip();
    }
    var A = function(u, p, d) {
      var y = u.words, w = p.words, E = d.words, M = 0, x, g, k, T = y[0] | 0, O = T & 8191, K = T >>> 13, Y = y[1] | 0, J = Y & 8191, G = Y >>> 13, X = y[2] | 0, ie = X & 8191, de = X >>> 13, se = y[3] | 0, te = se & 8191, le = se >>> 13, Z = y[4] | 0, ve = Z & 8191, he = Z >>> 13, me = y[5] | 0, ce = me & 8191, ye = me >>> 13, Oe = y[6] | 0, Se = Oe & 8191, Ce = Oe >>> 13, Ne = y[7] | 0, $e = Ne & 8191, Re = Ne >>> 13, Ge = y[8] | 0, Fe = Ge & 8191, Ue = Ge >>> 13, kt = y[9] | 0, pe = kt & 8191, re = kt >>> 13, ue = w[0] | 0, xe = ue & 8191, Me = ue >>> 13, We = w[1] | 0, De = We & 8191, je = We >>> 13, ir = w[2] | 0, Xe = ir & 8191, st = ir >>> 13, Vt = w[3] | 0, at = Vt & 8191, ht = Vt >>> 13, br = w[4] | 0, ot = br & 8191, ct = br >>> 13, _r = w[5] | 0, ft = _r & 8191, pt = _r >>> 13, Cr = w[6] | 0, nt = Cr & 8191, lt = Cr >>> 13, ge = w[7] | 0, be = ge & 8191, Ae = ge >>> 13, ne = w[8] | 0, _e = ne & 8191, Te = ne >>> 13, Ye = w[9] | 0, Pe = Ye & 8191, He = Ye >>> 13;
      d.negative = u.negative ^ p.negative, d.length = 19, x = Math.imul(O, xe), g = Math.imul(O, Me), g = g + Math.imul(K, xe) | 0, k = Math.imul(K, Me);
      var _t = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, x = Math.imul(J, xe), g = Math.imul(J, Me), g = g + Math.imul(G, xe) | 0, k = Math.imul(G, Me), x = x + Math.imul(O, De) | 0, g = g + Math.imul(O, je) | 0, g = g + Math.imul(K, De) | 0, k = k + Math.imul(K, je) | 0;
      var vt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, x = Math.imul(ie, xe), g = Math.imul(ie, Me), g = g + Math.imul(de, xe) | 0, k = Math.imul(de, Me), x = x + Math.imul(J, De) | 0, g = g + Math.imul(J, je) | 0, g = g + Math.imul(G, De) | 0, k = k + Math.imul(G, je) | 0, x = x + Math.imul(O, Xe) | 0, g = g + Math.imul(O, st) | 0, g = g + Math.imul(K, Xe) | 0, k = k + Math.imul(K, st) | 0;
      var cr = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (cr >>> 26) | 0, cr &= 67108863, x = Math.imul(te, xe), g = Math.imul(te, Me), g = g + Math.imul(le, xe) | 0, k = Math.imul(le, Me), x = x + Math.imul(ie, De) | 0, g = g + Math.imul(ie, je) | 0, g = g + Math.imul(de, De) | 0, k = k + Math.imul(de, je) | 0, x = x + Math.imul(J, Xe) | 0, g = g + Math.imul(J, st) | 0, g = g + Math.imul(G, Xe) | 0, k = k + Math.imul(G, st) | 0, x = x + Math.imul(O, at) | 0, g = g + Math.imul(O, ht) | 0, g = g + Math.imul(K, at) | 0, k = k + Math.imul(K, ht) | 0;
      var Tt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, x = Math.imul(ve, xe), g = Math.imul(ve, Me), g = g + Math.imul(he, xe) | 0, k = Math.imul(he, Me), x = x + Math.imul(te, De) | 0, g = g + Math.imul(te, je) | 0, g = g + Math.imul(le, De) | 0, k = k + Math.imul(le, je) | 0, x = x + Math.imul(ie, Xe) | 0, g = g + Math.imul(ie, st) | 0, g = g + Math.imul(de, Xe) | 0, k = k + Math.imul(de, st) | 0, x = x + Math.imul(J, at) | 0, g = g + Math.imul(J, ht) | 0, g = g + Math.imul(G, at) | 0, k = k + Math.imul(G, ht) | 0, x = x + Math.imul(O, ot) | 0, g = g + Math.imul(O, ct) | 0, g = g + Math.imul(K, ot) | 0, k = k + Math.imul(K, ct) | 0;
      var Gt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Gt >>> 26) | 0, Gt &= 67108863, x = Math.imul(ce, xe), g = Math.imul(ce, Me), g = g + Math.imul(ye, xe) | 0, k = Math.imul(ye, Me), x = x + Math.imul(ve, De) | 0, g = g + Math.imul(ve, je) | 0, g = g + Math.imul(he, De) | 0, k = k + Math.imul(he, je) | 0, x = x + Math.imul(te, Xe) | 0, g = g + Math.imul(te, st) | 0, g = g + Math.imul(le, Xe) | 0, k = k + Math.imul(le, st) | 0, x = x + Math.imul(ie, at) | 0, g = g + Math.imul(ie, ht) | 0, g = g + Math.imul(de, at) | 0, k = k + Math.imul(de, ht) | 0, x = x + Math.imul(J, ot) | 0, g = g + Math.imul(J, ct) | 0, g = g + Math.imul(G, ot) | 0, k = k + Math.imul(G, ct) | 0, x = x + Math.imul(O, ft) | 0, g = g + Math.imul(O, pt) | 0, g = g + Math.imul(K, ft) | 0, k = k + Math.imul(K, pt) | 0;
      var Yt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Yt >>> 26) | 0, Yt &= 67108863, x = Math.imul(Se, xe), g = Math.imul(Se, Me), g = g + Math.imul(Ce, xe) | 0, k = Math.imul(Ce, Me), x = x + Math.imul(ce, De) | 0, g = g + Math.imul(ce, je) | 0, g = g + Math.imul(ye, De) | 0, k = k + Math.imul(ye, je) | 0, x = x + Math.imul(ve, Xe) | 0, g = g + Math.imul(ve, st) | 0, g = g + Math.imul(he, Xe) | 0, k = k + Math.imul(he, st) | 0, x = x + Math.imul(te, at) | 0, g = g + Math.imul(te, ht) | 0, g = g + Math.imul(le, at) | 0, k = k + Math.imul(le, ht) | 0, x = x + Math.imul(ie, ot) | 0, g = g + Math.imul(ie, ct) | 0, g = g + Math.imul(de, ot) | 0, k = k + Math.imul(de, ct) | 0, x = x + Math.imul(J, ft) | 0, g = g + Math.imul(J, pt) | 0, g = g + Math.imul(G, ft) | 0, k = k + Math.imul(G, pt) | 0, x = x + Math.imul(O, nt) | 0, g = g + Math.imul(O, lt) | 0, g = g + Math.imul(K, nt) | 0, k = k + Math.imul(K, lt) | 0;
      var or = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (or >>> 26) | 0, or &= 67108863, x = Math.imul($e, xe), g = Math.imul($e, Me), g = g + Math.imul(Re, xe) | 0, k = Math.imul(Re, Me), x = x + Math.imul(Se, De) | 0, g = g + Math.imul(Se, je) | 0, g = g + Math.imul(Ce, De) | 0, k = k + Math.imul(Ce, je) | 0, x = x + Math.imul(ce, Xe) | 0, g = g + Math.imul(ce, st) | 0, g = g + Math.imul(ye, Xe) | 0, k = k + Math.imul(ye, st) | 0, x = x + Math.imul(ve, at) | 0, g = g + Math.imul(ve, ht) | 0, g = g + Math.imul(he, at) | 0, k = k + Math.imul(he, ht) | 0, x = x + Math.imul(te, ot) | 0, g = g + Math.imul(te, ct) | 0, g = g + Math.imul(le, ot) | 0, k = k + Math.imul(le, ct) | 0, x = x + Math.imul(ie, ft) | 0, g = g + Math.imul(ie, pt) | 0, g = g + Math.imul(de, ft) | 0, k = k + Math.imul(de, pt) | 0, x = x + Math.imul(J, nt) | 0, g = g + Math.imul(J, lt) | 0, g = g + Math.imul(G, nt) | 0, k = k + Math.imul(G, lt) | 0, x = x + Math.imul(O, be) | 0, g = g + Math.imul(O, Ae) | 0, g = g + Math.imul(K, be) | 0, k = k + Math.imul(K, Ae) | 0;
      var sr = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (sr >>> 26) | 0, sr &= 67108863, x = Math.imul(Fe, xe), g = Math.imul(Fe, Me), g = g + Math.imul(Ue, xe) | 0, k = Math.imul(Ue, Me), x = x + Math.imul($e, De) | 0, g = g + Math.imul($e, je) | 0, g = g + Math.imul(Re, De) | 0, k = k + Math.imul(Re, je) | 0, x = x + Math.imul(Se, Xe) | 0, g = g + Math.imul(Se, st) | 0, g = g + Math.imul(Ce, Xe) | 0, k = k + Math.imul(Ce, st) | 0, x = x + Math.imul(ce, at) | 0, g = g + Math.imul(ce, ht) | 0, g = g + Math.imul(ye, at) | 0, k = k + Math.imul(ye, ht) | 0, x = x + Math.imul(ve, ot) | 0, g = g + Math.imul(ve, ct) | 0, g = g + Math.imul(he, ot) | 0, k = k + Math.imul(he, ct) | 0, x = x + Math.imul(te, ft) | 0, g = g + Math.imul(te, pt) | 0, g = g + Math.imul(le, ft) | 0, k = k + Math.imul(le, pt) | 0, x = x + Math.imul(ie, nt) | 0, g = g + Math.imul(ie, lt) | 0, g = g + Math.imul(de, nt) | 0, k = k + Math.imul(de, lt) | 0, x = x + Math.imul(J, be) | 0, g = g + Math.imul(J, Ae) | 0, g = g + Math.imul(G, be) | 0, k = k + Math.imul(G, Ae) | 0, x = x + Math.imul(O, _e) | 0, g = g + Math.imul(O, Te) | 0, g = g + Math.imul(K, _e) | 0, k = k + Math.imul(K, Te) | 0;
      var Wt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Wt >>> 26) | 0, Wt &= 67108863, x = Math.imul(pe, xe), g = Math.imul(pe, Me), g = g + Math.imul(re, xe) | 0, k = Math.imul(re, Me), x = x + Math.imul(Fe, De) | 0, g = g + Math.imul(Fe, je) | 0, g = g + Math.imul(Ue, De) | 0, k = k + Math.imul(Ue, je) | 0, x = x + Math.imul($e, Xe) | 0, g = g + Math.imul($e, st) | 0, g = g + Math.imul(Re, Xe) | 0, k = k + Math.imul(Re, st) | 0, x = x + Math.imul(Se, at) | 0, g = g + Math.imul(Se, ht) | 0, g = g + Math.imul(Ce, at) | 0, k = k + Math.imul(Ce, ht) | 0, x = x + Math.imul(ce, ot) | 0, g = g + Math.imul(ce, ct) | 0, g = g + Math.imul(ye, ot) | 0, k = k + Math.imul(ye, ct) | 0, x = x + Math.imul(ve, ft) | 0, g = g + Math.imul(ve, pt) | 0, g = g + Math.imul(he, ft) | 0, k = k + Math.imul(he, pt) | 0, x = x + Math.imul(te, nt) | 0, g = g + Math.imul(te, lt) | 0, g = g + Math.imul(le, nt) | 0, k = k + Math.imul(le, lt) | 0, x = x + Math.imul(ie, be) | 0, g = g + Math.imul(ie, Ae) | 0, g = g + Math.imul(de, be) | 0, k = k + Math.imul(de, Ae) | 0, x = x + Math.imul(J, _e) | 0, g = g + Math.imul(J, Te) | 0, g = g + Math.imul(G, _e) | 0, k = k + Math.imul(G, Te) | 0, x = x + Math.imul(O, Pe) | 0, g = g + Math.imul(O, He) | 0, g = g + Math.imul(K, Pe) | 0, k = k + Math.imul(K, He) | 0;
      var tr = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (tr >>> 26) | 0, tr &= 67108863, x = Math.imul(pe, De), g = Math.imul(pe, je), g = g + Math.imul(re, De) | 0, k = Math.imul(re, je), x = x + Math.imul(Fe, Xe) | 0, g = g + Math.imul(Fe, st) | 0, g = g + Math.imul(Ue, Xe) | 0, k = k + Math.imul(Ue, st) | 0, x = x + Math.imul($e, at) | 0, g = g + Math.imul($e, ht) | 0, g = g + Math.imul(Re, at) | 0, k = k + Math.imul(Re, ht) | 0, x = x + Math.imul(Se, ot) | 0, g = g + Math.imul(Se, ct) | 0, g = g + Math.imul(Ce, ot) | 0, k = k + Math.imul(Ce, ct) | 0, x = x + Math.imul(ce, ft) | 0, g = g + Math.imul(ce, pt) | 0, g = g + Math.imul(ye, ft) | 0, k = k + Math.imul(ye, pt) | 0, x = x + Math.imul(ve, nt) | 0, g = g + Math.imul(ve, lt) | 0, g = g + Math.imul(he, nt) | 0, k = k + Math.imul(he, lt) | 0, x = x + Math.imul(te, be) | 0, g = g + Math.imul(te, Ae) | 0, g = g + Math.imul(le, be) | 0, k = k + Math.imul(le, Ae) | 0, x = x + Math.imul(ie, _e) | 0, g = g + Math.imul(ie, Te) | 0, g = g + Math.imul(de, _e) | 0, k = k + Math.imul(de, Te) | 0, x = x + Math.imul(J, Pe) | 0, g = g + Math.imul(J, He) | 0, g = g + Math.imul(G, Pe) | 0, k = k + Math.imul(G, He) | 0;
      var Jt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Jt >>> 26) | 0, Jt &= 67108863, x = Math.imul(pe, Xe), g = Math.imul(pe, st), g = g + Math.imul(re, Xe) | 0, k = Math.imul(re, st), x = x + Math.imul(Fe, at) | 0, g = g + Math.imul(Fe, ht) | 0, g = g + Math.imul(Ue, at) | 0, k = k + Math.imul(Ue, ht) | 0, x = x + Math.imul($e, ot) | 0, g = g + Math.imul($e, ct) | 0, g = g + Math.imul(Re, ot) | 0, k = k + Math.imul(Re, ct) | 0, x = x + Math.imul(Se, ft) | 0, g = g + Math.imul(Se, pt) | 0, g = g + Math.imul(Ce, ft) | 0, k = k + Math.imul(Ce, pt) | 0, x = x + Math.imul(ce, nt) | 0, g = g + Math.imul(ce, lt) | 0, g = g + Math.imul(ye, nt) | 0, k = k + Math.imul(ye, lt) | 0, x = x + Math.imul(ve, be) | 0, g = g + Math.imul(ve, Ae) | 0, g = g + Math.imul(he, be) | 0, k = k + Math.imul(he, Ae) | 0, x = x + Math.imul(te, _e) | 0, g = g + Math.imul(te, Te) | 0, g = g + Math.imul(le, _e) | 0, k = k + Math.imul(le, Te) | 0, x = x + Math.imul(ie, Pe) | 0, g = g + Math.imul(ie, He) | 0, g = g + Math.imul(de, Pe) | 0, k = k + Math.imul(de, He) | 0;
      var Ft = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Ft >>> 26) | 0, Ft &= 67108863, x = Math.imul(pe, at), g = Math.imul(pe, ht), g = g + Math.imul(re, at) | 0, k = Math.imul(re, ht), x = x + Math.imul(Fe, ot) | 0, g = g + Math.imul(Fe, ct) | 0, g = g + Math.imul(Ue, ot) | 0, k = k + Math.imul(Ue, ct) | 0, x = x + Math.imul($e, ft) | 0, g = g + Math.imul($e, pt) | 0, g = g + Math.imul(Re, ft) | 0, k = k + Math.imul(Re, pt) | 0, x = x + Math.imul(Se, nt) | 0, g = g + Math.imul(Se, lt) | 0, g = g + Math.imul(Ce, nt) | 0, k = k + Math.imul(Ce, lt) | 0, x = x + Math.imul(ce, be) | 0, g = g + Math.imul(ce, Ae) | 0, g = g + Math.imul(ye, be) | 0, k = k + Math.imul(ye, Ae) | 0, x = x + Math.imul(ve, _e) | 0, g = g + Math.imul(ve, Te) | 0, g = g + Math.imul(he, _e) | 0, k = k + Math.imul(he, Te) | 0, x = x + Math.imul(te, Pe) | 0, g = g + Math.imul(te, He) | 0, g = g + Math.imul(le, Pe) | 0, k = k + Math.imul(le, He) | 0;
      var Ut = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, x = Math.imul(pe, ot), g = Math.imul(pe, ct), g = g + Math.imul(re, ot) | 0, k = Math.imul(re, ct), x = x + Math.imul(Fe, ft) | 0, g = g + Math.imul(Fe, pt) | 0, g = g + Math.imul(Ue, ft) | 0, k = k + Math.imul(Ue, pt) | 0, x = x + Math.imul($e, nt) | 0, g = g + Math.imul($e, lt) | 0, g = g + Math.imul(Re, nt) | 0, k = k + Math.imul(Re, lt) | 0, x = x + Math.imul(Se, be) | 0, g = g + Math.imul(Se, Ae) | 0, g = g + Math.imul(Ce, be) | 0, k = k + Math.imul(Ce, Ae) | 0, x = x + Math.imul(ce, _e) | 0, g = g + Math.imul(ce, Te) | 0, g = g + Math.imul(ye, _e) | 0, k = k + Math.imul(ye, Te) | 0, x = x + Math.imul(ve, Pe) | 0, g = g + Math.imul(ve, He) | 0, g = g + Math.imul(he, Pe) | 0, k = k + Math.imul(he, He) | 0;
      var Mt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, x = Math.imul(pe, ft), g = Math.imul(pe, pt), g = g + Math.imul(re, ft) | 0, k = Math.imul(re, pt), x = x + Math.imul(Fe, nt) | 0, g = g + Math.imul(Fe, lt) | 0, g = g + Math.imul(Ue, nt) | 0, k = k + Math.imul(Ue, lt) | 0, x = x + Math.imul($e, be) | 0, g = g + Math.imul($e, Ae) | 0, g = g + Math.imul(Re, be) | 0, k = k + Math.imul(Re, Ae) | 0, x = x + Math.imul(Se, _e) | 0, g = g + Math.imul(Se, Te) | 0, g = g + Math.imul(Ce, _e) | 0, k = k + Math.imul(Ce, Te) | 0, x = x + Math.imul(ce, Pe) | 0, g = g + Math.imul(ce, He) | 0, g = g + Math.imul(ye, Pe) | 0, k = k + Math.imul(ye, He) | 0;
      var Pt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, x = Math.imul(pe, nt), g = Math.imul(pe, lt), g = g + Math.imul(re, nt) | 0, k = Math.imul(re, lt), x = x + Math.imul(Fe, be) | 0, g = g + Math.imul(Fe, Ae) | 0, g = g + Math.imul(Ue, be) | 0, k = k + Math.imul(Ue, Ae) | 0, x = x + Math.imul($e, _e) | 0, g = g + Math.imul($e, Te) | 0, g = g + Math.imul(Re, _e) | 0, k = k + Math.imul(Re, Te) | 0, x = x + Math.imul(Se, Pe) | 0, g = g + Math.imul(Se, He) | 0, g = g + Math.imul(Ce, Pe) | 0, k = k + Math.imul(Ce, He) | 0;
      var Nt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, x = Math.imul(pe, be), g = Math.imul(pe, Ae), g = g + Math.imul(re, be) | 0, k = Math.imul(re, Ae), x = x + Math.imul(Fe, _e) | 0, g = g + Math.imul(Fe, Te) | 0, g = g + Math.imul(Ue, _e) | 0, k = k + Math.imul(Ue, Te) | 0, x = x + Math.imul($e, Pe) | 0, g = g + Math.imul($e, He) | 0, g = g + Math.imul(Re, Pe) | 0, k = k + Math.imul(Re, He) | 0;
      var It = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, x = Math.imul(pe, _e), g = Math.imul(pe, Te), g = g + Math.imul(re, _e) | 0, k = Math.imul(re, Te), x = x + Math.imul(Fe, Pe) | 0, g = g + Math.imul(Fe, He) | 0, g = g + Math.imul(Ue, Pe) | 0, k = k + Math.imul(Ue, He) | 0;
      var tt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, x = Math.imul(pe, Pe), g = Math.imul(pe, He), g = g + Math.imul(re, Pe) | 0, k = Math.imul(re, He);
      var rt = (M + x | 0) + ((g & 8191) << 13) | 0;
      return M = (k + (g >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, E[0] = _t, E[1] = vt, E[2] = cr, E[3] = Tt, E[4] = Gt, E[5] = Yt, E[6] = or, E[7] = sr, E[8] = Wt, E[9] = tr, E[10] = Jt, E[11] = Ft, E[12] = Ut, E[13] = Mt, E[14] = Pt, E[15] = Nt, E[16] = It, E[17] = tt, E[18] = rt, M !== 0 && (E[19] = M, d.length++), d;
    };
    Math.imul || (A = b);
    function _(B, u, p) {
      p.negative = u.negative ^ B.negative, p.length = B.length + u.length;
      for (var d = 0, y = 0, w = 0; w < p.length - 1; w++) {
        var E = y;
        y = 0;
        for (var M = d & 67108863, x = Math.min(w, u.length - 1), g = Math.max(0, w - B.length + 1); g <= x; g++) {
          var k = w - g, T = B.words[k] | 0, O = u.words[g] | 0, K = T * O, Y = K & 67108863;
          E = E + (K / 67108864 | 0) | 0, Y = Y + M | 0, M = Y & 67108863, E = E + (Y >>> 26) | 0, y += E >>> 26, E &= 67108863;
        }
        p.words[w] = M, d = E, E = y;
      }
      return d !== 0 ? p.words[w] = d : p.length--, p.strip();
    }
    function C(B, u, p) {
      var d = new I();
      return d.mulp(B, u, p);
    }
    i.prototype.mulTo = function(u, p) {
      var d, y = this.length + u.length;
      return this.length === 10 && u.length === 10 ? d = A(this, u, p) : y < 63 ? d = b(this, u, p) : y < 1024 ? d = _(this, u, p) : d = C(this, u, p), d;
    };
    function I(B, u) {
      this.x = B, this.y = u;
    }
    I.prototype.makeRBT = function(u) {
      for (var p = new Array(u), d = i.prototype._countBits(u) - 1, y = 0; y < u; y++) p[y] = this.revBin(y, d, u);
      return p;
    }, I.prototype.revBin = function(u, p, d) {
      if (u === 0 || u === d - 1) return u;
      for (var y = 0, w = 0; w < p; w++) y |= (u & 1) << p - w - 1, u >>= 1;
      return y;
    }, I.prototype.permute = function(u, p, d, y, w, E) {
      for (var M = 0; M < E; M++) y[M] = p[u[M]], w[M] = d[u[M]];
    }, I.prototype.transform = function(u, p, d, y, w, E) {
      this.permute(E, u, p, d, y, w);
      for (var M = 1; M < w; M <<= 1) for (var x = M << 1, g = Math.cos(2 * Math.PI / x), k = Math.sin(2 * Math.PI / x), T = 0; T < w; T += x) for (var O = g, K = k, Y = 0; Y < M; Y++) {
        var J = d[T + Y], G = y[T + Y], X = d[T + Y + M], ie = y[T + Y + M], de = O * X - K * ie;
        ie = O * ie + K * X, X = de, d[T + Y] = J + X, y[T + Y] = G + ie, d[T + Y + M] = J - X, y[T + Y + M] = G - ie, Y !== x && (de = g * O - k * K, K = g * K + k * O, O = de);
      }
    }, I.prototype.guessLen13b = function(u, p) {
      var d = Math.max(p, u) | 1, y = d & 1, w = 0;
      for (d = d / 2 | 0; d; d = d >>> 1) w++;
      return 1 << w + 1 + y;
    }, I.prototype.conjugate = function(u, p, d) {
      if (!(d <= 1)) for (var y = 0; y < d / 2; y++) {
        var w = u[y];
        u[y] = u[d - y - 1], u[d - y - 1] = w, w = p[y], p[y] = -p[d - y - 1], p[d - y - 1] = -w;
      }
    }, I.prototype.normalize13b = function(u, p) {
      for (var d = 0, y = 0; y < p / 2; y++) {
        var w = Math.round(u[2 * y + 1] / p) * 8192 + Math.round(u[2 * y] / p) + d;
        u[y] = w & 67108863, w < 67108864 ? d = 0 : d = w / 67108864 | 0;
      }
      return u;
    }, I.prototype.convert13b = function(u, p, d, y) {
      for (var w = 0, E = 0; E < p; E++) w = w + (u[E] | 0), d[2 * E] = w & 8191, w = w >>> 13, d[2 * E + 1] = w & 8191, w = w >>> 13;
      for (E = 2 * p; E < y; ++E) d[E] = 0;
      r(w === 0), r((w & -8192) === 0);
    }, I.prototype.stub = function(u) {
      for (var p = new Array(u), d = 0; d < u; d++) p[d] = 0;
      return p;
    }, I.prototype.mulp = function(u, p, d) {
      var y = 2 * this.guessLen13b(u.length, p.length), w = this.makeRBT(y), E = this.stub(y), M = new Array(y), x = new Array(y), g = new Array(y), k = new Array(y), T = new Array(y), O = new Array(y), K = d.words;
      K.length = y, this.convert13b(u.words, u.length, M, y), this.convert13b(p.words, p.length, k, y), this.transform(M, E, x, g, y, w), this.transform(k, E, T, O, y, w);
      for (var Y = 0; Y < y; Y++) {
        var J = x[Y] * T[Y] - g[Y] * O[Y];
        g[Y] = x[Y] * O[Y] + g[Y] * T[Y], x[Y] = J;
      }
      return this.conjugate(x, g, y), this.transform(x, g, K, E, y, w), this.conjugate(K, E, y), this.normalize13b(K, y), d.negative = u.negative ^ p.negative, d.length = u.length + p.length, d.strip();
    }, i.prototype.mul = function(u) {
      var p = new i(null);
      return p.words = new Array(this.length + u.length), this.mulTo(u, p);
    }, i.prototype.mulf = function(u) {
      var p = new i(null);
      return p.words = new Array(this.length + u.length), C(this, u, p);
    }, i.prototype.imul = function(u) {
      return this.clone().mulTo(u, this);
    }, i.prototype.imuln = function(u) {
      r(typeof u == "number"), r(u < 67108864);
      for (var p = 0, d = 0; d < this.length; d++) {
        var y = (this.words[d] | 0) * u, w = (y & 67108863) + (p & 67108863);
        p >>= 26, p += y / 67108864 | 0, p += w >>> 26, this.words[d] = w & 67108863;
      }
      return p !== 0 && (this.words[d] = p, this.length++), this.length = u === 0 ? 1 : this.length, this;
    }, i.prototype.muln = function(u) {
      return this.clone().imuln(u);
    }, i.prototype.sqr = function() {
      return this.mul(this);
    }, i.prototype.isqr = function() {
      return this.imul(this.clone());
    }, i.prototype.pow = function(u) {
      var p = v(u);
      if (p.length === 0) return new i(1);
      for (var d = this, y = 0; y < p.length && p[y] === 0; y++, d = d.sqr()) ;
      if (++y < p.length) for (var w = d.sqr(); y < p.length; y++, w = w.sqr()) p[y] !== 0 && (d = d.mul(w));
      return d;
    }, i.prototype.iushln = function(u) {
      r(typeof u == "number" && u >= 0);
      var p = u % 26, d = (u - p) / 26, y = 67108863 >>> 26 - p << 26 - p, w;
      if (p !== 0) {
        var E = 0;
        for (w = 0; w < this.length; w++) {
          var M = this.words[w] & y, x = (this.words[w] | 0) - M << p;
          this.words[w] = x | E, E = M >>> 26 - p;
        }
        E && (this.words[w] = E, this.length++);
      }
      if (d !== 0) {
        for (w = this.length - 1; w >= 0; w--) this.words[w + d] = this.words[w];
        for (w = 0; w < d; w++) this.words[w] = 0;
        this.length += d;
      }
      return this.strip();
    }, i.prototype.ishln = function(u) {
      return r(this.negative === 0), this.iushln(u);
    }, i.prototype.iushrn = function(u, p, d) {
      r(typeof u == "number" && u >= 0);
      var y;
      p ? y = (p - p % 26) / 26 : y = 0;
      var w = u % 26, E = Math.min((u - w) / 26, this.length), M = 67108863 ^ 67108863 >>> w << w, x = d;
      if (y -= E, y = Math.max(0, y), x) {
        for (var g = 0; g < E; g++) x.words[g] = this.words[g];
        x.length = E;
      }
      if (E !== 0) if (this.length > E) for (this.length -= E, g = 0; g < this.length; g++) this.words[g] = this.words[g + E];
      else this.words[0] = 0, this.length = 1;
      var k = 0;
      for (g = this.length - 1; g >= 0 && (k !== 0 || g >= y); g--) {
        var T = this.words[g] | 0;
        this.words[g] = k << 26 - w | T >>> w, k = T & M;
      }
      return x && k !== 0 && (x.words[x.length++] = k), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, i.prototype.ishrn = function(u, p, d) {
      return r(this.negative === 0), this.iushrn(u, p, d);
    }, i.prototype.shln = function(u) {
      return this.clone().ishln(u);
    }, i.prototype.ushln = function(u) {
      return this.clone().iushln(u);
    }, i.prototype.shrn = function(u) {
      return this.clone().ishrn(u);
    }, i.prototype.ushrn = function(u) {
      return this.clone().iushrn(u);
    }, i.prototype.testn = function(u) {
      r(typeof u == "number" && u >= 0);
      var p = u % 26, d = (u - p) / 26, y = 1 << p;
      if (this.length <= d) return false;
      var w = this.words[d];
      return !!(w & y);
    }, i.prototype.imaskn = function(u) {
      r(typeof u == "number" && u >= 0);
      var p = u % 26, d = (u - p) / 26;
      if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= d) return this;
      if (p !== 0 && d++, this.length = Math.min(d, this.length), p !== 0) {
        var y = 67108863 ^ 67108863 >>> p << p;
        this.words[this.length - 1] &= y;
      }
      return this.strip();
    }, i.prototype.maskn = function(u) {
      return this.clone().imaskn(u);
    }, i.prototype.iaddn = function(u) {
      return r(typeof u == "number"), r(u < 67108864), u < 0 ? this.isubn(-u) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < u ? (this.words[0] = u - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(u), this.negative = 1, this) : this._iaddn(u);
    }, i.prototype._iaddn = function(u) {
      this.words[0] += u;
      for (var p = 0; p < this.length && this.words[p] >= 67108864; p++) this.words[p] -= 67108864, p === this.length - 1 ? this.words[p + 1] = 1 : this.words[p + 1]++;
      return this.length = Math.max(this.length, p + 1), this;
    }, i.prototype.isubn = function(u) {
      if (r(typeof u == "number"), r(u < 67108864), u < 0) return this.iaddn(-u);
      if (this.negative !== 0) return this.negative = 0, this.iaddn(u), this.negative = 1, this;
      if (this.words[0] -= u, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
      else for (var p = 0; p < this.length && this.words[p] < 0; p++) this.words[p] += 67108864, this.words[p + 1] -= 1;
      return this.strip();
    }, i.prototype.addn = function(u) {
      return this.clone().iaddn(u);
    }, i.prototype.subn = function(u) {
      return this.clone().isubn(u);
    }, i.prototype.iabs = function() {
      return this.negative = 0, this;
    }, i.prototype.abs = function() {
      return this.clone().iabs();
    }, i.prototype._ishlnsubmul = function(u, p, d) {
      var y = u.length + d, w;
      this._expand(y);
      var E, M = 0;
      for (w = 0; w < u.length; w++) {
        E = (this.words[w + d] | 0) + M;
        var x = (u.words[w] | 0) * p;
        E -= x & 67108863, M = (E >> 26) - (x / 67108864 | 0), this.words[w + d] = E & 67108863;
      }
      for (; w < this.length - d; w++) E = (this.words[w + d] | 0) + M, M = E >> 26, this.words[w + d] = E & 67108863;
      if (M === 0) return this.strip();
      for (r(M === -1), M = 0, w = 0; w < this.length; w++) E = -(this.words[w] | 0) + M, M = E >> 26, this.words[w] = E & 67108863;
      return this.negative = 1, this.strip();
    }, i.prototype._wordDiv = function(u, p) {
      var d = this.length - u.length, y = this.clone(), w = u, E = w.words[w.length - 1] | 0, M = this._countBits(E);
      d = 26 - M, d !== 0 && (w = w.ushln(d), y.iushln(d), E = w.words[w.length - 1] | 0);
      var x = y.length - w.length, g;
      if (p !== "mod") {
        g = new i(null), g.length = x + 1, g.words = new Array(g.length);
        for (var k = 0; k < g.length; k++) g.words[k] = 0;
      }
      var T = y.clone()._ishlnsubmul(w, 1, x);
      T.negative === 0 && (y = T, g && (g.words[x] = 1));
      for (var O = x - 1; O >= 0; O--) {
        var K = (y.words[w.length + O] | 0) * 67108864 + (y.words[w.length + O - 1] | 0);
        for (K = Math.min(K / E | 0, 67108863), y._ishlnsubmul(w, K, O); y.negative !== 0; ) K--, y.negative = 0, y._ishlnsubmul(w, 1, O), y.isZero() || (y.negative ^= 1);
        g && (g.words[O] = K);
      }
      return g && g.strip(), y.strip(), p !== "div" && d !== 0 && y.iushrn(d), { div: g || null, mod: y };
    }, i.prototype.divmod = function(u, p, d) {
      if (r(!u.isZero()), this.isZero()) return { div: new i(0), mod: new i(0) };
      var y, w, E;
      return this.negative !== 0 && u.negative === 0 ? (E = this.neg().divmod(u, p), p !== "mod" && (y = E.div.neg()), p !== "div" && (w = E.mod.neg(), d && w.negative !== 0 && w.iadd(u)), { div: y, mod: w }) : this.negative === 0 && u.negative !== 0 ? (E = this.divmod(u.neg(), p), p !== "mod" && (y = E.div.neg()), { div: y, mod: E.mod }) : this.negative & u.negative ? (E = this.neg().divmod(u.neg(), p), p !== "div" && (w = E.mod.neg(), d && w.negative !== 0 && w.isub(u)), { div: E.div, mod: w }) : u.length > this.length || this.cmp(u) < 0 ? { div: new i(0), mod: this } : u.length === 1 ? p === "div" ? { div: this.divn(u.words[0]), mod: null } : p === "mod" ? { div: null, mod: new i(this.modn(u.words[0])) } : { div: this.divn(u.words[0]), mod: new i(this.modn(u.words[0])) } : this._wordDiv(u, p);
    }, i.prototype.div = function(u) {
      return this.divmod(u, "div", false).div;
    }, i.prototype.mod = function(u) {
      return this.divmod(u, "mod", false).mod;
    }, i.prototype.umod = function(u) {
      return this.divmod(u, "mod", true).mod;
    }, i.prototype.divRound = function(u) {
      var p = this.divmod(u);
      if (p.mod.isZero()) return p.div;
      var d = p.div.negative !== 0 ? p.mod.isub(u) : p.mod, y = u.ushrn(1), w = u.andln(1), E = d.cmp(y);
      return E < 0 || w === 1 && E === 0 ? p.div : p.div.negative !== 0 ? p.div.isubn(1) : p.div.iaddn(1);
    }, i.prototype.modn = function(u) {
      r(u <= 67108863);
      for (var p = (1 << 26) % u, d = 0, y = this.length - 1; y >= 0; y--) d = (p * d + (this.words[y] | 0)) % u;
      return d;
    }, i.prototype.idivn = function(u) {
      r(u <= 67108863);
      for (var p = 0, d = this.length - 1; d >= 0; d--) {
        var y = (this.words[d] | 0) + p * 67108864;
        this.words[d] = y / u | 0, p = y % u;
      }
      return this.strip();
    }, i.prototype.divn = function(u) {
      return this.clone().idivn(u);
    }, i.prototype.egcd = function(u) {
      r(u.negative === 0), r(!u.isZero());
      var p = this, d = u.clone();
      p.negative !== 0 ? p = p.umod(u) : p = p.clone();
      for (var y = new i(1), w = new i(0), E = new i(0), M = new i(1), x = 0; p.isEven() && d.isEven(); ) p.iushrn(1), d.iushrn(1), ++x;
      for (var g = d.clone(), k = p.clone(); !p.isZero(); ) {
        for (var T = 0, O = 1; !(p.words[0] & O) && T < 26; ++T, O <<= 1) ;
        if (T > 0) for (p.iushrn(T); T-- > 0; ) (y.isOdd() || w.isOdd()) && (y.iadd(g), w.isub(k)), y.iushrn(1), w.iushrn(1);
        for (var K = 0, Y = 1; !(d.words[0] & Y) && K < 26; ++K, Y <<= 1) ;
        if (K > 0) for (d.iushrn(K); K-- > 0; ) (E.isOdd() || M.isOdd()) && (E.iadd(g), M.isub(k)), E.iushrn(1), M.iushrn(1);
        p.cmp(d) >= 0 ? (p.isub(d), y.isub(E), w.isub(M)) : (d.isub(p), E.isub(y), M.isub(w));
      }
      return { a: E, b: M, gcd: d.iushln(x) };
    }, i.prototype._invmp = function(u) {
      r(u.negative === 0), r(!u.isZero());
      var p = this, d = u.clone();
      p.negative !== 0 ? p = p.umod(u) : p = p.clone();
      for (var y = new i(1), w = new i(0), E = d.clone(); p.cmpn(1) > 0 && d.cmpn(1) > 0; ) {
        for (var M = 0, x = 1; !(p.words[0] & x) && M < 26; ++M, x <<= 1) ;
        if (M > 0) for (p.iushrn(M); M-- > 0; ) y.isOdd() && y.iadd(E), y.iushrn(1);
        for (var g = 0, k = 1; !(d.words[0] & k) && g < 26; ++g, k <<= 1) ;
        if (g > 0) for (d.iushrn(g); g-- > 0; ) w.isOdd() && w.iadd(E), w.iushrn(1);
        p.cmp(d) >= 0 ? (p.isub(d), y.isub(w)) : (d.isub(p), w.isub(y));
      }
      var T;
      return p.cmpn(1) === 0 ? T = y : T = w, T.cmpn(0) < 0 && T.iadd(u), T;
    }, i.prototype.gcd = function(u) {
      if (this.isZero()) return u.abs();
      if (u.isZero()) return this.abs();
      var p = this.clone(), d = u.clone();
      p.negative = 0, d.negative = 0;
      for (var y = 0; p.isEven() && d.isEven(); y++) p.iushrn(1), d.iushrn(1);
      do {
        for (; p.isEven(); ) p.iushrn(1);
        for (; d.isEven(); ) d.iushrn(1);
        var w = p.cmp(d);
        if (w < 0) {
          var E = p;
          p = d, d = E;
        } else if (w === 0 || d.cmpn(1) === 0) break;
        p.isub(d);
      } while (true);
      return d.iushln(y);
    }, i.prototype.invm = function(u) {
      return this.egcd(u).a.umod(u);
    }, i.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, i.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, i.prototype.andln = function(u) {
      return this.words[0] & u;
    }, i.prototype.bincn = function(u) {
      r(typeof u == "number");
      var p = u % 26, d = (u - p) / 26, y = 1 << p;
      if (this.length <= d) return this._expand(d + 1), this.words[d] |= y, this;
      for (var w = y, E = d; w !== 0 && E < this.length; E++) {
        var M = this.words[E] | 0;
        M += w, w = M >>> 26, M &= 67108863, this.words[E] = M;
      }
      return w !== 0 && (this.words[E] = w, this.length++), this;
    }, i.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, i.prototype.cmpn = function(u) {
      var p = u < 0;
      if (this.negative !== 0 && !p) return -1;
      if (this.negative === 0 && p) return 1;
      this.strip();
      var d;
      if (this.length > 1) d = 1;
      else {
        p && (u = -u), r(u <= 67108863, "Number is too big");
        var y = this.words[0] | 0;
        d = y === u ? 0 : y < u ? -1 : 1;
      }
      return this.negative !== 0 ? -d | 0 : d;
    }, i.prototype.cmp = function(u) {
      if (this.negative !== 0 && u.negative === 0) return -1;
      if (this.negative === 0 && u.negative !== 0) return 1;
      var p = this.ucmp(u);
      return this.negative !== 0 ? -p | 0 : p;
    }, i.prototype.ucmp = function(u) {
      if (this.length > u.length) return 1;
      if (this.length < u.length) return -1;
      for (var p = 0, d = this.length - 1; d >= 0; d--) {
        var y = this.words[d] | 0, w = u.words[d] | 0;
        if (y !== w) {
          y < w ? p = -1 : y > w && (p = 1);
          break;
        }
      }
      return p;
    }, i.prototype.gtn = function(u) {
      return this.cmpn(u) === 1;
    }, i.prototype.gt = function(u) {
      return this.cmp(u) === 1;
    }, i.prototype.gten = function(u) {
      return this.cmpn(u) >= 0;
    }, i.prototype.gte = function(u) {
      return this.cmp(u) >= 0;
    }, i.prototype.ltn = function(u) {
      return this.cmpn(u) === -1;
    }, i.prototype.lt = function(u) {
      return this.cmp(u) === -1;
    }, i.prototype.lten = function(u) {
      return this.cmpn(u) <= 0;
    }, i.prototype.lte = function(u) {
      return this.cmp(u) <= 0;
    }, i.prototype.eqn = function(u) {
      return this.cmpn(u) === 0;
    }, i.prototype.eq = function(u) {
      return this.cmp(u) === 0;
    }, i.red = function(u) {
      return new N(u);
    }, i.prototype.toRed = function(u) {
      return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), u.convertTo(this)._forceRed(u);
    }, i.prototype.fromRed = function() {
      return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, i.prototype._forceRed = function(u) {
      return this.red = u, this;
    }, i.prototype.forceRed = function(u) {
      return r(!this.red, "Already a number in reduction context"), this._forceRed(u);
    }, i.prototype.redAdd = function(u) {
      return r(this.red, "redAdd works only with red numbers"), this.red.add(this, u);
    }, i.prototype.redIAdd = function(u) {
      return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, u);
    }, i.prototype.redSub = function(u) {
      return r(this.red, "redSub works only with red numbers"), this.red.sub(this, u);
    }, i.prototype.redISub = function(u) {
      return r(this.red, "redISub works only with red numbers"), this.red.isub(this, u);
    }, i.prototype.redShl = function(u) {
      return r(this.red, "redShl works only with red numbers"), this.red.shl(this, u);
    }, i.prototype.redMul = function(u) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, u), this.red.mul(this, u);
    }, i.prototype.redIMul = function(u) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, u), this.red.imul(this, u);
    }, i.prototype.redSqr = function() {
      return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, i.prototype.redISqr = function() {
      return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, i.prototype.redSqrt = function() {
      return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, i.prototype.redInvm = function() {
      return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, i.prototype.redNeg = function() {
      return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, i.prototype.redPow = function(u) {
      return r(this.red && !u.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, u);
    };
    var S = { k256: null, p224: null, p192: null, p25519: null };
    function $(B, u) {
      this.name = B, this.p = new i(u, 16), this.n = this.p.bitLength(), this.k = new i(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    $.prototype._tmp = function() {
      var u = new i(null);
      return u.words = new Array(Math.ceil(this.n / 13)), u;
    }, $.prototype.ireduce = function(u) {
      var p = u, d;
      do
        this.split(p, this.tmp), p = this.imulK(p), p = p.iadd(this.tmp), d = p.bitLength();
      while (d > this.n);
      var y = d < this.n ? -1 : p.ucmp(this.p);
      return y === 0 ? (p.words[0] = 0, p.length = 1) : y > 0 ? p.isub(this.p) : p.strip !== void 0 ? p.strip() : p._strip(), p;
    }, $.prototype.split = function(u, p) {
      u.iushrn(this.n, 0, p);
    }, $.prototype.imulK = function(u) {
      return u.imul(this.k);
    };
    function F() {
      $.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    s(F, $), F.prototype.split = function(u, p) {
      for (var d = 4194303, y = Math.min(u.length, 9), w = 0; w < y; w++) p.words[w] = u.words[w];
      if (p.length = y, u.length <= 9) {
        u.words[0] = 0, u.length = 1;
        return;
      }
      var E = u.words[9];
      for (p.words[p.length++] = E & d, w = 10; w < u.length; w++) {
        var M = u.words[w] | 0;
        u.words[w - 10] = (M & d) << 4 | E >>> 22, E = M;
      }
      E >>>= 22, u.words[w - 10] = E, E === 0 && u.length > 10 ? u.length -= 10 : u.length -= 9;
    }, F.prototype.imulK = function(u) {
      u.words[u.length] = 0, u.words[u.length + 1] = 0, u.length += 2;
      for (var p = 0, d = 0; d < u.length; d++) {
        var y = u.words[d] | 0;
        p += y * 977, u.words[d] = p & 67108863, p = y * 64 + (p / 67108864 | 0);
      }
      return u.words[u.length - 1] === 0 && (u.length--, u.words[u.length - 1] === 0 && u.length--), u;
    };
    function U() {
      $.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    s(U, $);
    function Q() {
      $.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    s(Q, $);
    function P() {
      $.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    s(P, $), P.prototype.imulK = function(u) {
      for (var p = 0, d = 0; d < u.length; d++) {
        var y = (u.words[d] | 0) * 19 + p, w = y & 67108863;
        y >>>= 26, u.words[d] = w, p = y;
      }
      return p !== 0 && (u.words[u.length++] = p), u;
    }, i._prime = function(u) {
      if (S[u]) return S[u];
      var p;
      if (u === "k256") p = new F();
      else if (u === "p224") p = new U();
      else if (u === "p192") p = new Q();
      else if (u === "p25519") p = new P();
      else throw new Error("Unknown prime " + u);
      return S[u] = p, p;
    };
    function N(B) {
      if (typeof B == "string") {
        var u = i._prime(B);
        this.m = u.p, this.prime = u;
      } else r(B.gtn(1), "modulus must be greater than 1"), this.m = B, this.prime = null;
    }
    N.prototype._verify1 = function(u) {
      r(u.negative === 0, "red works only with positives"), r(u.red, "red works only with red numbers");
    }, N.prototype._verify2 = function(u, p) {
      r((u.negative | p.negative) === 0, "red works only with positives"), r(u.red && u.red === p.red, "red works only with red numbers");
    }, N.prototype.imod = function(u) {
      return this.prime ? this.prime.ireduce(u)._forceRed(this) : u.umod(this.m)._forceRed(this);
    }, N.prototype.neg = function(u) {
      return u.isZero() ? u.clone() : this.m.sub(u)._forceRed(this);
    }, N.prototype.add = function(u, p) {
      this._verify2(u, p);
      var d = u.add(p);
      return d.cmp(this.m) >= 0 && d.isub(this.m), d._forceRed(this);
    }, N.prototype.iadd = function(u, p) {
      this._verify2(u, p);
      var d = u.iadd(p);
      return d.cmp(this.m) >= 0 && d.isub(this.m), d;
    }, N.prototype.sub = function(u, p) {
      this._verify2(u, p);
      var d = u.sub(p);
      return d.cmpn(0) < 0 && d.iadd(this.m), d._forceRed(this);
    }, N.prototype.isub = function(u, p) {
      this._verify2(u, p);
      var d = u.isub(p);
      return d.cmpn(0) < 0 && d.iadd(this.m), d;
    }, N.prototype.shl = function(u, p) {
      return this._verify1(u), this.imod(u.ushln(p));
    }, N.prototype.imul = function(u, p) {
      return this._verify2(u, p), this.imod(u.imul(p));
    }, N.prototype.mul = function(u, p) {
      return this._verify2(u, p), this.imod(u.mul(p));
    }, N.prototype.isqr = function(u) {
      return this.imul(u, u.clone());
    }, N.prototype.sqr = function(u) {
      return this.mul(u, u);
    }, N.prototype.sqrt = function(u) {
      if (u.isZero()) return u.clone();
      var p = this.m.andln(3);
      if (r(p % 2 === 1), p === 3) {
        var d = this.m.add(new i(1)).iushrn(2);
        return this.pow(u, d);
      }
      for (var y = this.m.subn(1), w = 0; !y.isZero() && y.andln(1) === 0; ) w++, y.iushrn(1);
      r(!y.isZero());
      var E = new i(1).toRed(this), M = E.redNeg(), x = this.m.subn(1).iushrn(1), g = this.m.bitLength();
      for (g = new i(2 * g * g).toRed(this); this.pow(g, x).cmp(M) !== 0; ) g.redIAdd(M);
      for (var k = this.pow(g, y), T = this.pow(u, y.addn(1).iushrn(1)), O = this.pow(u, y), K = w; O.cmp(E) !== 0; ) {
        for (var Y = O, J = 0; Y.cmp(E) !== 0; J++) Y = Y.redSqr();
        r(J < K);
        var G = this.pow(k, new i(1).iushln(K - J - 1));
        T = T.redMul(G), k = G.redSqr(), O = O.redMul(k), K = J;
      }
      return T;
    }, N.prototype.invm = function(u) {
      var p = u._invmp(this.m);
      return p.negative !== 0 ? (p.negative = 0, this.imod(p).redNeg()) : this.imod(p);
    }, N.prototype.pow = function(u, p) {
      if (p.isZero()) return new i(1).toRed(this);
      if (p.cmpn(1) === 0) return u.clone();
      var d = 4, y = new Array(1 << d);
      y[0] = new i(1).toRed(this), y[1] = u;
      for (var w = 2; w < y.length; w++) y[w] = this.mul(y[w - 1], u);
      var E = y[0], M = 0, x = 0, g = p.bitLength() % 26;
      for (g === 0 && (g = 26), w = p.length - 1; w >= 0; w--) {
        for (var k = p.words[w], T = g - 1; T >= 0; T--) {
          var O = k >> T & 1;
          if (E !== y[0] && (E = this.sqr(E)), O === 0 && M === 0) {
            x = 0;
            continue;
          }
          M <<= 1, M |= O, x++, !(x !== d && (w !== 0 || T !== 0)) && (E = this.mul(E, y[M]), x = 0, M = 0);
        }
        g = 26;
      }
      return E;
    }, N.prototype.convertTo = function(u) {
      var p = u.umod(this.m);
      return p === u ? p.clone() : p;
    }, N.prototype.convertFrom = function(u) {
      var p = u.clone();
      return p.red = null, p;
    }, i.mont = function(u) {
      return new L(u);
    };
    function L(B) {
      N.call(this, B), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new i(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    s(L, N), L.prototype.convertTo = function(u) {
      return this.imod(u.ushln(this.shift));
    }, L.prototype.convertFrom = function(u) {
      var p = this.imod(u.mul(this.rinv));
      return p.red = null, p;
    }, L.prototype.imul = function(u, p) {
      if (u.isZero() || p.isZero()) return u.words[0] = 0, u.length = 1, u;
      var d = u.imul(p), y = d.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = d.isub(y).iushrn(this.shift), E = w;
      return w.cmp(this.m) >= 0 ? E = w.isub(this.m) : w.cmpn(0) < 0 && (E = w.iadd(this.m)), E._forceRed(this);
    }, L.prototype.mul = function(u, p) {
      if (u.isZero() || p.isZero()) return new i(0)._forceRed(this);
      var d = u.mul(p), y = d.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = d.isub(y).iushrn(this.shift), E = w;
      return w.cmp(this.m) >= 0 ? E = w.isub(this.m) : w.cmpn(0) < 0 && (E = w.iadd(this.m)), E._forceRed(this);
    }, L.prototype.invm = function(u) {
      var p = this.imod(u._invmp(this.m).mul(this.r2));
      return p._forceRed(this);
    };
  })(t3, mt);
})(KA);
var y$ = KA.exports, HA = { exports: {} };
HA.exports;
(function(t3) {
  (function(e, n) {
    function r(B, u) {
      if (!B) throw new Error(u || "Assertion failed");
    }
    function s(B, u) {
      B.super_ = u;
      var p = function() {
      };
      p.prototype = u.prototype, B.prototype = new p(), B.prototype.constructor = B;
    }
    function i(B, u, p) {
      if (i.isBN(B)) return B;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, B !== null && ((u === "le" || u === "be") && (p = u, u = 10), this._init(B || 0, u || 10, p || "be"));
    }
    typeof e == "object" ? e.exports = i : n.BN = i, i.BN = i, i.wordSize = 26;
    var a;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? a = window.Buffer : a = $n.Buffer;
    } catch {
    }
    i.isBN = function(u) {
      return u instanceof i ? true : u !== null && typeof u == "object" && u.constructor.wordSize === i.wordSize && Array.isArray(u.words);
    }, i.max = function(u, p) {
      return u.cmp(p) > 0 ? u : p;
    }, i.min = function(u, p) {
      return u.cmp(p) < 0 ? u : p;
    }, i.prototype._init = function(u, p, d) {
      if (typeof u == "number") return this._initNumber(u, p, d);
      if (typeof u == "object") return this._initArray(u, p, d);
      p === "hex" && (p = 16), r(p === (p | 0) && p >= 2 && p <= 36), u = u.toString().replace(/\s+/g, "");
      var y = 0;
      u[0] === "-" && (y++, this.negative = 1), y < u.length && (p === 16 ? this._parseHex(u, y, d) : (this._parseBase(u, p, y), d === "le" && this._initArray(this.toArray(), p, d)));
    }, i.prototype._initNumber = function(u, p, d) {
      u < 0 && (this.negative = 1, u = -u), u < 67108864 ? (this.words = [u & 67108863], this.length = 1) : u < 4503599627370496 ? (this.words = [u & 67108863, u / 67108864 & 67108863], this.length = 2) : (r(u < 9007199254740992), this.words = [u & 67108863, u / 67108864 & 67108863, 1], this.length = 3), d === "le" && this._initArray(this.toArray(), p, d);
    }, i.prototype._initArray = function(u, p, d) {
      if (r(typeof u.length == "number"), u.length <= 0) return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(u.length / 3), this.words = new Array(this.length);
      for (var y = 0; y < this.length; y++) this.words[y] = 0;
      var w, E, M = 0;
      if (d === "be") for (y = u.length - 1, w = 0; y >= 0; y -= 3) E = u[y] | u[y - 1] << 8 | u[y - 2] << 16, this.words[w] |= E << M & 67108863, this.words[w + 1] = E >>> 26 - M & 67108863, M += 24, M >= 26 && (M -= 26, w++);
      else if (d === "le") for (y = 0, w = 0; y < u.length; y += 3) E = u[y] | u[y + 1] << 8 | u[y + 2] << 16, this.words[w] |= E << M & 67108863, this.words[w + 1] = E >>> 26 - M & 67108863, M += 24, M >= 26 && (M -= 26, w++);
      return this.strip();
    };
    function o(B, u) {
      var p = B.charCodeAt(u);
      return p >= 65 && p <= 70 ? p - 55 : p >= 97 && p <= 102 ? p - 87 : p - 48 & 15;
    }
    function f(B, u, p) {
      var d = o(B, p);
      return p - 1 >= u && (d |= o(B, p - 1) << 4), d;
    }
    i.prototype._parseHex = function(u, p, d) {
      this.length = Math.ceil((u.length - p) / 6), this.words = new Array(this.length);
      for (var y = 0; y < this.length; y++) this.words[y] = 0;
      var w = 0, E = 0, M;
      if (d === "be") for (y = u.length - 1; y >= p; y -= 2) M = f(u, p, y) << w, this.words[E] |= M & 67108863, w >= 18 ? (w -= 18, E += 1, this.words[E] |= M >>> 26) : w += 8;
      else {
        var x = u.length - p;
        for (y = x % 2 === 0 ? p + 1 : p; y < u.length; y += 2) M = f(u, p, y) << w, this.words[E] |= M & 67108863, w >= 18 ? (w -= 18, E += 1, this.words[E] |= M >>> 26) : w += 8;
      }
      this.strip();
    };
    function c(B, u, p, d) {
      for (var y = 0, w = Math.min(B.length, p), E = u; E < w; E++) {
        var M = B.charCodeAt(E) - 48;
        y *= d, M >= 49 ? y += M - 49 + 10 : M >= 17 ? y += M - 17 + 10 : y += M;
      }
      return y;
    }
    i.prototype._parseBase = function(u, p, d) {
      this.words = [0], this.length = 1;
      for (var y = 0, w = 1; w <= 67108863; w *= p) y++;
      y--, w = w / p | 0;
      for (var E = u.length - d, M = E % y, x = Math.min(E, E - M) + d, g = 0, k = d; k < x; k += y) g = c(u, k, k + y, p), this.imuln(w), this.words[0] + g < 67108864 ? this.words[0] += g : this._iaddn(g);
      if (M !== 0) {
        var T = 1;
        for (g = c(u, k, u.length, p), k = 0; k < M; k++) T *= p;
        this.imuln(T), this.words[0] + g < 67108864 ? this.words[0] += g : this._iaddn(g);
      }
      this.strip();
    }, i.prototype.copy = function(u) {
      u.words = new Array(this.length);
      for (var p = 0; p < this.length; p++) u.words[p] = this.words[p];
      u.length = this.length, u.negative = this.negative, u.red = this.red;
    }, i.prototype.clone = function() {
      var u = new i(null);
      return this.copy(u), u;
    }, i.prototype._expand = function(u) {
      for (; this.length < u; ) this.words[this.length++] = 0;
      return this;
    }, i.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; ) this.length--;
      return this._normSign();
    }, i.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, i.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var l = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], h = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], m = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    i.prototype.toString = function(u, p) {
      u = u || 10, p = p | 0 || 1;
      var d;
      if (u === 16 || u === "hex") {
        d = "";
        for (var y = 0, w = 0, E = 0; E < this.length; E++) {
          var M = this.words[E], x = ((M << y | w) & 16777215).toString(16);
          w = M >>> 24 - y & 16777215, y += 2, y >= 26 && (y -= 26, E--), w !== 0 || E !== this.length - 1 ? d = l[6 - x.length] + x + d : d = x + d;
        }
        for (w !== 0 && (d = w.toString(16) + d); d.length % p !== 0; ) d = "0" + d;
        return this.negative !== 0 && (d = "-" + d), d;
      }
      if (u === (u | 0) && u >= 2 && u <= 36) {
        var g = h[u], k = m[u];
        d = "";
        var T = this.clone();
        for (T.negative = 0; !T.isZero(); ) {
          var O = T.modn(k).toString(u);
          T = T.idivn(k), T.isZero() ? d = O + d : d = l[g - O.length] + O + d;
        }
        for (this.isZero() && (d = "0" + d); d.length % p !== 0; ) d = "0" + d;
        return this.negative !== 0 && (d = "-" + d), d;
      }
      r(false, "Base should be between 2 and 36");
    }, i.prototype.toNumber = function() {
      var u = this.words[0];
      return this.length === 2 ? u += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? u += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -u : u;
    }, i.prototype.toJSON = function() {
      return this.toString(16);
    }, i.prototype.toBuffer = function(u, p) {
      return r(typeof a < "u"), this.toArrayLike(a, u, p);
    }, i.prototype.toArray = function(u, p) {
      return this.toArrayLike(Array, u, p);
    }, i.prototype.toArrayLike = function(u, p, d) {
      var y = this.byteLength(), w = d || Math.max(1, y);
      r(y <= w, "byte array longer than desired length"), r(w > 0, "Requested array length <= 0"), this.strip();
      var E = p === "le", M = new u(w), x, g, k = this.clone();
      if (E) {
        for (g = 0; !k.isZero(); g++) x = k.andln(255), k.iushrn(8), M[g] = x;
        for (; g < w; g++) M[g] = 0;
      } else {
        for (g = 0; g < w - y; g++) M[g] = 0;
        for (g = 0; !k.isZero(); g++) x = k.andln(255), k.iushrn(8), M[w - g - 1] = x;
      }
      return M;
    }, Math.clz32 ? i.prototype._countBits = function(u) {
      return 32 - Math.clz32(u);
    } : i.prototype._countBits = function(u) {
      var p = u, d = 0;
      return p >= 4096 && (d += 13, p >>>= 13), p >= 64 && (d += 7, p >>>= 7), p >= 8 && (d += 4, p >>>= 4), p >= 2 && (d += 2, p >>>= 2), d + p;
    }, i.prototype._zeroBits = function(u) {
      if (u === 0) return 26;
      var p = u, d = 0;
      return p & 8191 || (d += 13, p >>>= 13), p & 127 || (d += 7, p >>>= 7), p & 15 || (d += 4, p >>>= 4), p & 3 || (d += 2, p >>>= 2), p & 1 || d++, d;
    }, i.prototype.bitLength = function() {
      var u = this.words[this.length - 1], p = this._countBits(u);
      return (this.length - 1) * 26 + p;
    };
    function v(B) {
      for (var u = new Array(B.bitLength()), p = 0; p < u.length; p++) {
        var d = p / 26 | 0, y = p % 26;
        u[p] = (B.words[d] & 1 << y) >>> y;
      }
      return u;
    }
    i.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var u = 0, p = 0; p < this.length; p++) {
        var d = this._zeroBits(this.words[p]);
        if (u += d, d !== 26) break;
      }
      return u;
    }, i.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, i.prototype.toTwos = function(u) {
      return this.negative !== 0 ? this.abs().inotn(u).iaddn(1) : this.clone();
    }, i.prototype.fromTwos = function(u) {
      return this.testn(u - 1) ? this.notn(u).iaddn(1).ineg() : this.clone();
    }, i.prototype.isNeg = function() {
      return this.negative !== 0;
    }, i.prototype.neg = function() {
      return this.clone().ineg();
    }, i.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, i.prototype.iuor = function(u) {
      for (; this.length < u.length; ) this.words[this.length++] = 0;
      for (var p = 0; p < u.length; p++) this.words[p] = this.words[p] | u.words[p];
      return this.strip();
    }, i.prototype.ior = function(u) {
      return r((this.negative | u.negative) === 0), this.iuor(u);
    }, i.prototype.or = function(u) {
      return this.length > u.length ? this.clone().ior(u) : u.clone().ior(this);
    }, i.prototype.uor = function(u) {
      return this.length > u.length ? this.clone().iuor(u) : u.clone().iuor(this);
    }, i.prototype.iuand = function(u) {
      var p;
      this.length > u.length ? p = u : p = this;
      for (var d = 0; d < p.length; d++) this.words[d] = this.words[d] & u.words[d];
      return this.length = p.length, this.strip();
    }, i.prototype.iand = function(u) {
      return r((this.negative | u.negative) === 0), this.iuand(u);
    }, i.prototype.and = function(u) {
      return this.length > u.length ? this.clone().iand(u) : u.clone().iand(this);
    }, i.prototype.uand = function(u) {
      return this.length > u.length ? this.clone().iuand(u) : u.clone().iuand(this);
    }, i.prototype.iuxor = function(u) {
      var p, d;
      this.length > u.length ? (p = this, d = u) : (p = u, d = this);
      for (var y = 0; y < d.length; y++) this.words[y] = p.words[y] ^ d.words[y];
      if (this !== p) for (; y < p.length; y++) this.words[y] = p.words[y];
      return this.length = p.length, this.strip();
    }, i.prototype.ixor = function(u) {
      return r((this.negative | u.negative) === 0), this.iuxor(u);
    }, i.prototype.xor = function(u) {
      return this.length > u.length ? this.clone().ixor(u) : u.clone().ixor(this);
    }, i.prototype.uxor = function(u) {
      return this.length > u.length ? this.clone().iuxor(u) : u.clone().iuxor(this);
    }, i.prototype.inotn = function(u) {
      r(typeof u == "number" && u >= 0);
      var p = Math.ceil(u / 26) | 0, d = u % 26;
      this._expand(p), d > 0 && p--;
      for (var y = 0; y < p; y++) this.words[y] = ~this.words[y] & 67108863;
      return d > 0 && (this.words[y] = ~this.words[y] & 67108863 >> 26 - d), this.strip();
    }, i.prototype.notn = function(u) {
      return this.clone().inotn(u);
    }, i.prototype.setn = function(u, p) {
      r(typeof u == "number" && u >= 0);
      var d = u / 26 | 0, y = u % 26;
      return this._expand(d + 1), p ? this.words[d] = this.words[d] | 1 << y : this.words[d] = this.words[d] & ~(1 << y), this.strip();
    }, i.prototype.iadd = function(u) {
      var p;
      if (this.negative !== 0 && u.negative === 0) return this.negative = 0, p = this.isub(u), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && u.negative !== 0) return u.negative = 0, p = this.isub(u), u.negative = 1, p._normSign();
      var d, y;
      this.length > u.length ? (d = this, y = u) : (d = u, y = this);
      for (var w = 0, E = 0; E < y.length; E++) p = (d.words[E] | 0) + (y.words[E] | 0) + w, this.words[E] = p & 67108863, w = p >>> 26;
      for (; w !== 0 && E < d.length; E++) p = (d.words[E] | 0) + w, this.words[E] = p & 67108863, w = p >>> 26;
      if (this.length = d.length, w !== 0) this.words[this.length] = w, this.length++;
      else if (d !== this) for (; E < d.length; E++) this.words[E] = d.words[E];
      return this;
    }, i.prototype.add = function(u) {
      var p;
      return u.negative !== 0 && this.negative === 0 ? (u.negative = 0, p = this.sub(u), u.negative ^= 1, p) : u.negative === 0 && this.negative !== 0 ? (this.negative = 0, p = u.sub(this), this.negative = 1, p) : this.length > u.length ? this.clone().iadd(u) : u.clone().iadd(this);
    }, i.prototype.isub = function(u) {
      if (u.negative !== 0) {
        u.negative = 0;
        var p = this.iadd(u);
        return u.negative = 1, p._normSign();
      } else if (this.negative !== 0) return this.negative = 0, this.iadd(u), this.negative = 1, this._normSign();
      var d = this.cmp(u);
      if (d === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var y, w;
      d > 0 ? (y = this, w = u) : (y = u, w = this);
      for (var E = 0, M = 0; M < w.length; M++) p = (y.words[M] | 0) - (w.words[M] | 0) + E, E = p >> 26, this.words[M] = p & 67108863;
      for (; E !== 0 && M < y.length; M++) p = (y.words[M] | 0) + E, E = p >> 26, this.words[M] = p & 67108863;
      if (E === 0 && M < y.length && y !== this) for (; M < y.length; M++) this.words[M] = y.words[M];
      return this.length = Math.max(this.length, M), y !== this && (this.negative = 1), this.strip();
    }, i.prototype.sub = function(u) {
      return this.clone().isub(u);
    };
    function b(B, u, p) {
      p.negative = u.negative ^ B.negative;
      var d = B.length + u.length | 0;
      p.length = d, d = d - 1 | 0;
      var y = B.words[0] | 0, w = u.words[0] | 0, E = y * w, M = E & 67108863, x = E / 67108864 | 0;
      p.words[0] = M;
      for (var g = 1; g < d; g++) {
        for (var k = x >>> 26, T = x & 67108863, O = Math.min(g, u.length - 1), K = Math.max(0, g - B.length + 1); K <= O; K++) {
          var Y = g - K | 0;
          y = B.words[Y] | 0, w = u.words[K] | 0, E = y * w + T, k += E / 67108864 | 0, T = E & 67108863;
        }
        p.words[g] = T | 0, x = k | 0;
      }
      return x !== 0 ? p.words[g] = x | 0 : p.length--, p.strip();
    }
    var A = function(u, p, d) {
      var y = u.words, w = p.words, E = d.words, M = 0, x, g, k, T = y[0] | 0, O = T & 8191, K = T >>> 13, Y = y[1] | 0, J = Y & 8191, G = Y >>> 13, X = y[2] | 0, ie = X & 8191, de = X >>> 13, se = y[3] | 0, te = se & 8191, le = se >>> 13, Z = y[4] | 0, ve = Z & 8191, he = Z >>> 13, me = y[5] | 0, ce = me & 8191, ye = me >>> 13, Oe = y[6] | 0, Se = Oe & 8191, Ce = Oe >>> 13, Ne = y[7] | 0, $e = Ne & 8191, Re = Ne >>> 13, Ge = y[8] | 0, Fe = Ge & 8191, Ue = Ge >>> 13, kt = y[9] | 0, pe = kt & 8191, re = kt >>> 13, ue = w[0] | 0, xe = ue & 8191, Me = ue >>> 13, We = w[1] | 0, De = We & 8191, je = We >>> 13, ir = w[2] | 0, Xe = ir & 8191, st = ir >>> 13, Vt = w[3] | 0, at = Vt & 8191, ht = Vt >>> 13, br = w[4] | 0, ot = br & 8191, ct = br >>> 13, _r = w[5] | 0, ft = _r & 8191, pt = _r >>> 13, Cr = w[6] | 0, nt = Cr & 8191, lt = Cr >>> 13, ge = w[7] | 0, be = ge & 8191, Ae = ge >>> 13, ne = w[8] | 0, _e = ne & 8191, Te = ne >>> 13, Ye = w[9] | 0, Pe = Ye & 8191, He = Ye >>> 13;
      d.negative = u.negative ^ p.negative, d.length = 19, x = Math.imul(O, xe), g = Math.imul(O, Me), g = g + Math.imul(K, xe) | 0, k = Math.imul(K, Me);
      var _t = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, x = Math.imul(J, xe), g = Math.imul(J, Me), g = g + Math.imul(G, xe) | 0, k = Math.imul(G, Me), x = x + Math.imul(O, De) | 0, g = g + Math.imul(O, je) | 0, g = g + Math.imul(K, De) | 0, k = k + Math.imul(K, je) | 0;
      var vt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, x = Math.imul(ie, xe), g = Math.imul(ie, Me), g = g + Math.imul(de, xe) | 0, k = Math.imul(de, Me), x = x + Math.imul(J, De) | 0, g = g + Math.imul(J, je) | 0, g = g + Math.imul(G, De) | 0, k = k + Math.imul(G, je) | 0, x = x + Math.imul(O, Xe) | 0, g = g + Math.imul(O, st) | 0, g = g + Math.imul(K, Xe) | 0, k = k + Math.imul(K, st) | 0;
      var cr = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (cr >>> 26) | 0, cr &= 67108863, x = Math.imul(te, xe), g = Math.imul(te, Me), g = g + Math.imul(le, xe) | 0, k = Math.imul(le, Me), x = x + Math.imul(ie, De) | 0, g = g + Math.imul(ie, je) | 0, g = g + Math.imul(de, De) | 0, k = k + Math.imul(de, je) | 0, x = x + Math.imul(J, Xe) | 0, g = g + Math.imul(J, st) | 0, g = g + Math.imul(G, Xe) | 0, k = k + Math.imul(G, st) | 0, x = x + Math.imul(O, at) | 0, g = g + Math.imul(O, ht) | 0, g = g + Math.imul(K, at) | 0, k = k + Math.imul(K, ht) | 0;
      var Tt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, x = Math.imul(ve, xe), g = Math.imul(ve, Me), g = g + Math.imul(he, xe) | 0, k = Math.imul(he, Me), x = x + Math.imul(te, De) | 0, g = g + Math.imul(te, je) | 0, g = g + Math.imul(le, De) | 0, k = k + Math.imul(le, je) | 0, x = x + Math.imul(ie, Xe) | 0, g = g + Math.imul(ie, st) | 0, g = g + Math.imul(de, Xe) | 0, k = k + Math.imul(de, st) | 0, x = x + Math.imul(J, at) | 0, g = g + Math.imul(J, ht) | 0, g = g + Math.imul(G, at) | 0, k = k + Math.imul(G, ht) | 0, x = x + Math.imul(O, ot) | 0, g = g + Math.imul(O, ct) | 0, g = g + Math.imul(K, ot) | 0, k = k + Math.imul(K, ct) | 0;
      var Gt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Gt >>> 26) | 0, Gt &= 67108863, x = Math.imul(ce, xe), g = Math.imul(ce, Me), g = g + Math.imul(ye, xe) | 0, k = Math.imul(ye, Me), x = x + Math.imul(ve, De) | 0, g = g + Math.imul(ve, je) | 0, g = g + Math.imul(he, De) | 0, k = k + Math.imul(he, je) | 0, x = x + Math.imul(te, Xe) | 0, g = g + Math.imul(te, st) | 0, g = g + Math.imul(le, Xe) | 0, k = k + Math.imul(le, st) | 0, x = x + Math.imul(ie, at) | 0, g = g + Math.imul(ie, ht) | 0, g = g + Math.imul(de, at) | 0, k = k + Math.imul(de, ht) | 0, x = x + Math.imul(J, ot) | 0, g = g + Math.imul(J, ct) | 0, g = g + Math.imul(G, ot) | 0, k = k + Math.imul(G, ct) | 0, x = x + Math.imul(O, ft) | 0, g = g + Math.imul(O, pt) | 0, g = g + Math.imul(K, ft) | 0, k = k + Math.imul(K, pt) | 0;
      var Yt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Yt >>> 26) | 0, Yt &= 67108863, x = Math.imul(Se, xe), g = Math.imul(Se, Me), g = g + Math.imul(Ce, xe) | 0, k = Math.imul(Ce, Me), x = x + Math.imul(ce, De) | 0, g = g + Math.imul(ce, je) | 0, g = g + Math.imul(ye, De) | 0, k = k + Math.imul(ye, je) | 0, x = x + Math.imul(ve, Xe) | 0, g = g + Math.imul(ve, st) | 0, g = g + Math.imul(he, Xe) | 0, k = k + Math.imul(he, st) | 0, x = x + Math.imul(te, at) | 0, g = g + Math.imul(te, ht) | 0, g = g + Math.imul(le, at) | 0, k = k + Math.imul(le, ht) | 0, x = x + Math.imul(ie, ot) | 0, g = g + Math.imul(ie, ct) | 0, g = g + Math.imul(de, ot) | 0, k = k + Math.imul(de, ct) | 0, x = x + Math.imul(J, ft) | 0, g = g + Math.imul(J, pt) | 0, g = g + Math.imul(G, ft) | 0, k = k + Math.imul(G, pt) | 0, x = x + Math.imul(O, nt) | 0, g = g + Math.imul(O, lt) | 0, g = g + Math.imul(K, nt) | 0, k = k + Math.imul(K, lt) | 0;
      var or = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (or >>> 26) | 0, or &= 67108863, x = Math.imul($e, xe), g = Math.imul($e, Me), g = g + Math.imul(Re, xe) | 0, k = Math.imul(Re, Me), x = x + Math.imul(Se, De) | 0, g = g + Math.imul(Se, je) | 0, g = g + Math.imul(Ce, De) | 0, k = k + Math.imul(Ce, je) | 0, x = x + Math.imul(ce, Xe) | 0, g = g + Math.imul(ce, st) | 0, g = g + Math.imul(ye, Xe) | 0, k = k + Math.imul(ye, st) | 0, x = x + Math.imul(ve, at) | 0, g = g + Math.imul(ve, ht) | 0, g = g + Math.imul(he, at) | 0, k = k + Math.imul(he, ht) | 0, x = x + Math.imul(te, ot) | 0, g = g + Math.imul(te, ct) | 0, g = g + Math.imul(le, ot) | 0, k = k + Math.imul(le, ct) | 0, x = x + Math.imul(ie, ft) | 0, g = g + Math.imul(ie, pt) | 0, g = g + Math.imul(de, ft) | 0, k = k + Math.imul(de, pt) | 0, x = x + Math.imul(J, nt) | 0, g = g + Math.imul(J, lt) | 0, g = g + Math.imul(G, nt) | 0, k = k + Math.imul(G, lt) | 0, x = x + Math.imul(O, be) | 0, g = g + Math.imul(O, Ae) | 0, g = g + Math.imul(K, be) | 0, k = k + Math.imul(K, Ae) | 0;
      var sr = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (sr >>> 26) | 0, sr &= 67108863, x = Math.imul(Fe, xe), g = Math.imul(Fe, Me), g = g + Math.imul(Ue, xe) | 0, k = Math.imul(Ue, Me), x = x + Math.imul($e, De) | 0, g = g + Math.imul($e, je) | 0, g = g + Math.imul(Re, De) | 0, k = k + Math.imul(Re, je) | 0, x = x + Math.imul(Se, Xe) | 0, g = g + Math.imul(Se, st) | 0, g = g + Math.imul(Ce, Xe) | 0, k = k + Math.imul(Ce, st) | 0, x = x + Math.imul(ce, at) | 0, g = g + Math.imul(ce, ht) | 0, g = g + Math.imul(ye, at) | 0, k = k + Math.imul(ye, ht) | 0, x = x + Math.imul(ve, ot) | 0, g = g + Math.imul(ve, ct) | 0, g = g + Math.imul(he, ot) | 0, k = k + Math.imul(he, ct) | 0, x = x + Math.imul(te, ft) | 0, g = g + Math.imul(te, pt) | 0, g = g + Math.imul(le, ft) | 0, k = k + Math.imul(le, pt) | 0, x = x + Math.imul(ie, nt) | 0, g = g + Math.imul(ie, lt) | 0, g = g + Math.imul(de, nt) | 0, k = k + Math.imul(de, lt) | 0, x = x + Math.imul(J, be) | 0, g = g + Math.imul(J, Ae) | 0, g = g + Math.imul(G, be) | 0, k = k + Math.imul(G, Ae) | 0, x = x + Math.imul(O, _e) | 0, g = g + Math.imul(O, Te) | 0, g = g + Math.imul(K, _e) | 0, k = k + Math.imul(K, Te) | 0;
      var Wt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Wt >>> 26) | 0, Wt &= 67108863, x = Math.imul(pe, xe), g = Math.imul(pe, Me), g = g + Math.imul(re, xe) | 0, k = Math.imul(re, Me), x = x + Math.imul(Fe, De) | 0, g = g + Math.imul(Fe, je) | 0, g = g + Math.imul(Ue, De) | 0, k = k + Math.imul(Ue, je) | 0, x = x + Math.imul($e, Xe) | 0, g = g + Math.imul($e, st) | 0, g = g + Math.imul(Re, Xe) | 0, k = k + Math.imul(Re, st) | 0, x = x + Math.imul(Se, at) | 0, g = g + Math.imul(Se, ht) | 0, g = g + Math.imul(Ce, at) | 0, k = k + Math.imul(Ce, ht) | 0, x = x + Math.imul(ce, ot) | 0, g = g + Math.imul(ce, ct) | 0, g = g + Math.imul(ye, ot) | 0, k = k + Math.imul(ye, ct) | 0, x = x + Math.imul(ve, ft) | 0, g = g + Math.imul(ve, pt) | 0, g = g + Math.imul(he, ft) | 0, k = k + Math.imul(he, pt) | 0, x = x + Math.imul(te, nt) | 0, g = g + Math.imul(te, lt) | 0, g = g + Math.imul(le, nt) | 0, k = k + Math.imul(le, lt) | 0, x = x + Math.imul(ie, be) | 0, g = g + Math.imul(ie, Ae) | 0, g = g + Math.imul(de, be) | 0, k = k + Math.imul(de, Ae) | 0, x = x + Math.imul(J, _e) | 0, g = g + Math.imul(J, Te) | 0, g = g + Math.imul(G, _e) | 0, k = k + Math.imul(G, Te) | 0, x = x + Math.imul(O, Pe) | 0, g = g + Math.imul(O, He) | 0, g = g + Math.imul(K, Pe) | 0, k = k + Math.imul(K, He) | 0;
      var tr = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (tr >>> 26) | 0, tr &= 67108863, x = Math.imul(pe, De), g = Math.imul(pe, je), g = g + Math.imul(re, De) | 0, k = Math.imul(re, je), x = x + Math.imul(Fe, Xe) | 0, g = g + Math.imul(Fe, st) | 0, g = g + Math.imul(Ue, Xe) | 0, k = k + Math.imul(Ue, st) | 0, x = x + Math.imul($e, at) | 0, g = g + Math.imul($e, ht) | 0, g = g + Math.imul(Re, at) | 0, k = k + Math.imul(Re, ht) | 0, x = x + Math.imul(Se, ot) | 0, g = g + Math.imul(Se, ct) | 0, g = g + Math.imul(Ce, ot) | 0, k = k + Math.imul(Ce, ct) | 0, x = x + Math.imul(ce, ft) | 0, g = g + Math.imul(ce, pt) | 0, g = g + Math.imul(ye, ft) | 0, k = k + Math.imul(ye, pt) | 0, x = x + Math.imul(ve, nt) | 0, g = g + Math.imul(ve, lt) | 0, g = g + Math.imul(he, nt) | 0, k = k + Math.imul(he, lt) | 0, x = x + Math.imul(te, be) | 0, g = g + Math.imul(te, Ae) | 0, g = g + Math.imul(le, be) | 0, k = k + Math.imul(le, Ae) | 0, x = x + Math.imul(ie, _e) | 0, g = g + Math.imul(ie, Te) | 0, g = g + Math.imul(de, _e) | 0, k = k + Math.imul(de, Te) | 0, x = x + Math.imul(J, Pe) | 0, g = g + Math.imul(J, He) | 0, g = g + Math.imul(G, Pe) | 0, k = k + Math.imul(G, He) | 0;
      var Jt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Jt >>> 26) | 0, Jt &= 67108863, x = Math.imul(pe, Xe), g = Math.imul(pe, st), g = g + Math.imul(re, Xe) | 0, k = Math.imul(re, st), x = x + Math.imul(Fe, at) | 0, g = g + Math.imul(Fe, ht) | 0, g = g + Math.imul(Ue, at) | 0, k = k + Math.imul(Ue, ht) | 0, x = x + Math.imul($e, ot) | 0, g = g + Math.imul($e, ct) | 0, g = g + Math.imul(Re, ot) | 0, k = k + Math.imul(Re, ct) | 0, x = x + Math.imul(Se, ft) | 0, g = g + Math.imul(Se, pt) | 0, g = g + Math.imul(Ce, ft) | 0, k = k + Math.imul(Ce, pt) | 0, x = x + Math.imul(ce, nt) | 0, g = g + Math.imul(ce, lt) | 0, g = g + Math.imul(ye, nt) | 0, k = k + Math.imul(ye, lt) | 0, x = x + Math.imul(ve, be) | 0, g = g + Math.imul(ve, Ae) | 0, g = g + Math.imul(he, be) | 0, k = k + Math.imul(he, Ae) | 0, x = x + Math.imul(te, _e) | 0, g = g + Math.imul(te, Te) | 0, g = g + Math.imul(le, _e) | 0, k = k + Math.imul(le, Te) | 0, x = x + Math.imul(ie, Pe) | 0, g = g + Math.imul(ie, He) | 0, g = g + Math.imul(de, Pe) | 0, k = k + Math.imul(de, He) | 0;
      var Ft = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Ft >>> 26) | 0, Ft &= 67108863, x = Math.imul(pe, at), g = Math.imul(pe, ht), g = g + Math.imul(re, at) | 0, k = Math.imul(re, ht), x = x + Math.imul(Fe, ot) | 0, g = g + Math.imul(Fe, ct) | 0, g = g + Math.imul(Ue, ot) | 0, k = k + Math.imul(Ue, ct) | 0, x = x + Math.imul($e, ft) | 0, g = g + Math.imul($e, pt) | 0, g = g + Math.imul(Re, ft) | 0, k = k + Math.imul(Re, pt) | 0, x = x + Math.imul(Se, nt) | 0, g = g + Math.imul(Se, lt) | 0, g = g + Math.imul(Ce, nt) | 0, k = k + Math.imul(Ce, lt) | 0, x = x + Math.imul(ce, be) | 0, g = g + Math.imul(ce, Ae) | 0, g = g + Math.imul(ye, be) | 0, k = k + Math.imul(ye, Ae) | 0, x = x + Math.imul(ve, _e) | 0, g = g + Math.imul(ve, Te) | 0, g = g + Math.imul(he, _e) | 0, k = k + Math.imul(he, Te) | 0, x = x + Math.imul(te, Pe) | 0, g = g + Math.imul(te, He) | 0, g = g + Math.imul(le, Pe) | 0, k = k + Math.imul(le, He) | 0;
      var Ut = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, x = Math.imul(pe, ot), g = Math.imul(pe, ct), g = g + Math.imul(re, ot) | 0, k = Math.imul(re, ct), x = x + Math.imul(Fe, ft) | 0, g = g + Math.imul(Fe, pt) | 0, g = g + Math.imul(Ue, ft) | 0, k = k + Math.imul(Ue, pt) | 0, x = x + Math.imul($e, nt) | 0, g = g + Math.imul($e, lt) | 0, g = g + Math.imul(Re, nt) | 0, k = k + Math.imul(Re, lt) | 0, x = x + Math.imul(Se, be) | 0, g = g + Math.imul(Se, Ae) | 0, g = g + Math.imul(Ce, be) | 0, k = k + Math.imul(Ce, Ae) | 0, x = x + Math.imul(ce, _e) | 0, g = g + Math.imul(ce, Te) | 0, g = g + Math.imul(ye, _e) | 0, k = k + Math.imul(ye, Te) | 0, x = x + Math.imul(ve, Pe) | 0, g = g + Math.imul(ve, He) | 0, g = g + Math.imul(he, Pe) | 0, k = k + Math.imul(he, He) | 0;
      var Mt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, x = Math.imul(pe, ft), g = Math.imul(pe, pt), g = g + Math.imul(re, ft) | 0, k = Math.imul(re, pt), x = x + Math.imul(Fe, nt) | 0, g = g + Math.imul(Fe, lt) | 0, g = g + Math.imul(Ue, nt) | 0, k = k + Math.imul(Ue, lt) | 0, x = x + Math.imul($e, be) | 0, g = g + Math.imul($e, Ae) | 0, g = g + Math.imul(Re, be) | 0, k = k + Math.imul(Re, Ae) | 0, x = x + Math.imul(Se, _e) | 0, g = g + Math.imul(Se, Te) | 0, g = g + Math.imul(Ce, _e) | 0, k = k + Math.imul(Ce, Te) | 0, x = x + Math.imul(ce, Pe) | 0, g = g + Math.imul(ce, He) | 0, g = g + Math.imul(ye, Pe) | 0, k = k + Math.imul(ye, He) | 0;
      var Pt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, x = Math.imul(pe, nt), g = Math.imul(pe, lt), g = g + Math.imul(re, nt) | 0, k = Math.imul(re, lt), x = x + Math.imul(Fe, be) | 0, g = g + Math.imul(Fe, Ae) | 0, g = g + Math.imul(Ue, be) | 0, k = k + Math.imul(Ue, Ae) | 0, x = x + Math.imul($e, _e) | 0, g = g + Math.imul($e, Te) | 0, g = g + Math.imul(Re, _e) | 0, k = k + Math.imul(Re, Te) | 0, x = x + Math.imul(Se, Pe) | 0, g = g + Math.imul(Se, He) | 0, g = g + Math.imul(Ce, Pe) | 0, k = k + Math.imul(Ce, He) | 0;
      var Nt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, x = Math.imul(pe, be), g = Math.imul(pe, Ae), g = g + Math.imul(re, be) | 0, k = Math.imul(re, Ae), x = x + Math.imul(Fe, _e) | 0, g = g + Math.imul(Fe, Te) | 0, g = g + Math.imul(Ue, _e) | 0, k = k + Math.imul(Ue, Te) | 0, x = x + Math.imul($e, Pe) | 0, g = g + Math.imul($e, He) | 0, g = g + Math.imul(Re, Pe) | 0, k = k + Math.imul(Re, He) | 0;
      var It = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, x = Math.imul(pe, _e), g = Math.imul(pe, Te), g = g + Math.imul(re, _e) | 0, k = Math.imul(re, Te), x = x + Math.imul(Fe, Pe) | 0, g = g + Math.imul(Fe, He) | 0, g = g + Math.imul(Ue, Pe) | 0, k = k + Math.imul(Ue, He) | 0;
      var tt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, x = Math.imul(pe, Pe), g = Math.imul(pe, He), g = g + Math.imul(re, Pe) | 0, k = Math.imul(re, He);
      var rt = (M + x | 0) + ((g & 8191) << 13) | 0;
      return M = (k + (g >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, E[0] = _t, E[1] = vt, E[2] = cr, E[3] = Tt, E[4] = Gt, E[5] = Yt, E[6] = or, E[7] = sr, E[8] = Wt, E[9] = tr, E[10] = Jt, E[11] = Ft, E[12] = Ut, E[13] = Mt, E[14] = Pt, E[15] = Nt, E[16] = It, E[17] = tt, E[18] = rt, M !== 0 && (E[19] = M, d.length++), d;
    };
    Math.imul || (A = b);
    function _(B, u, p) {
      p.negative = u.negative ^ B.negative, p.length = B.length + u.length;
      for (var d = 0, y = 0, w = 0; w < p.length - 1; w++) {
        var E = y;
        y = 0;
        for (var M = d & 67108863, x = Math.min(w, u.length - 1), g = Math.max(0, w - B.length + 1); g <= x; g++) {
          var k = w - g, T = B.words[k] | 0, O = u.words[g] | 0, K = T * O, Y = K & 67108863;
          E = E + (K / 67108864 | 0) | 0, Y = Y + M | 0, M = Y & 67108863, E = E + (Y >>> 26) | 0, y += E >>> 26, E &= 67108863;
        }
        p.words[w] = M, d = E, E = y;
      }
      return d !== 0 ? p.words[w] = d : p.length--, p.strip();
    }
    function C(B, u, p) {
      var d = new I();
      return d.mulp(B, u, p);
    }
    i.prototype.mulTo = function(u, p) {
      var d, y = this.length + u.length;
      return this.length === 10 && u.length === 10 ? d = A(this, u, p) : y < 63 ? d = b(this, u, p) : y < 1024 ? d = _(this, u, p) : d = C(this, u, p), d;
    };
    function I(B, u) {
      this.x = B, this.y = u;
    }
    I.prototype.makeRBT = function(u) {
      for (var p = new Array(u), d = i.prototype._countBits(u) - 1, y = 0; y < u; y++) p[y] = this.revBin(y, d, u);
      return p;
    }, I.prototype.revBin = function(u, p, d) {
      if (u === 0 || u === d - 1) return u;
      for (var y = 0, w = 0; w < p; w++) y |= (u & 1) << p - w - 1, u >>= 1;
      return y;
    }, I.prototype.permute = function(u, p, d, y, w, E) {
      for (var M = 0; M < E; M++) y[M] = p[u[M]], w[M] = d[u[M]];
    }, I.prototype.transform = function(u, p, d, y, w, E) {
      this.permute(E, u, p, d, y, w);
      for (var M = 1; M < w; M <<= 1) for (var x = M << 1, g = Math.cos(2 * Math.PI / x), k = Math.sin(2 * Math.PI / x), T = 0; T < w; T += x) for (var O = g, K = k, Y = 0; Y < M; Y++) {
        var J = d[T + Y], G = y[T + Y], X = d[T + Y + M], ie = y[T + Y + M], de = O * X - K * ie;
        ie = O * ie + K * X, X = de, d[T + Y] = J + X, y[T + Y] = G + ie, d[T + Y + M] = J - X, y[T + Y + M] = G - ie, Y !== x && (de = g * O - k * K, K = g * K + k * O, O = de);
      }
    }, I.prototype.guessLen13b = function(u, p) {
      var d = Math.max(p, u) | 1, y = d & 1, w = 0;
      for (d = d / 2 | 0; d; d = d >>> 1) w++;
      return 1 << w + 1 + y;
    }, I.prototype.conjugate = function(u, p, d) {
      if (!(d <= 1)) for (var y = 0; y < d / 2; y++) {
        var w = u[y];
        u[y] = u[d - y - 1], u[d - y - 1] = w, w = p[y], p[y] = -p[d - y - 1], p[d - y - 1] = -w;
      }
    }, I.prototype.normalize13b = function(u, p) {
      for (var d = 0, y = 0; y < p / 2; y++) {
        var w = Math.round(u[2 * y + 1] / p) * 8192 + Math.round(u[2 * y] / p) + d;
        u[y] = w & 67108863, w < 67108864 ? d = 0 : d = w / 67108864 | 0;
      }
      return u;
    }, I.prototype.convert13b = function(u, p, d, y) {
      for (var w = 0, E = 0; E < p; E++) w = w + (u[E] | 0), d[2 * E] = w & 8191, w = w >>> 13, d[2 * E + 1] = w & 8191, w = w >>> 13;
      for (E = 2 * p; E < y; ++E) d[E] = 0;
      r(w === 0), r((w & -8192) === 0);
    }, I.prototype.stub = function(u) {
      for (var p = new Array(u), d = 0; d < u; d++) p[d] = 0;
      return p;
    }, I.prototype.mulp = function(u, p, d) {
      var y = 2 * this.guessLen13b(u.length, p.length), w = this.makeRBT(y), E = this.stub(y), M = new Array(y), x = new Array(y), g = new Array(y), k = new Array(y), T = new Array(y), O = new Array(y), K = d.words;
      K.length = y, this.convert13b(u.words, u.length, M, y), this.convert13b(p.words, p.length, k, y), this.transform(M, E, x, g, y, w), this.transform(k, E, T, O, y, w);
      for (var Y = 0; Y < y; Y++) {
        var J = x[Y] * T[Y] - g[Y] * O[Y];
        g[Y] = x[Y] * O[Y] + g[Y] * T[Y], x[Y] = J;
      }
      return this.conjugate(x, g, y), this.transform(x, g, K, E, y, w), this.conjugate(K, E, y), this.normalize13b(K, y), d.negative = u.negative ^ p.negative, d.length = u.length + p.length, d.strip();
    }, i.prototype.mul = function(u) {
      var p = new i(null);
      return p.words = new Array(this.length + u.length), this.mulTo(u, p);
    }, i.prototype.mulf = function(u) {
      var p = new i(null);
      return p.words = new Array(this.length + u.length), C(this, u, p);
    }, i.prototype.imul = function(u) {
      return this.clone().mulTo(u, this);
    }, i.prototype.imuln = function(u) {
      r(typeof u == "number"), r(u < 67108864);
      for (var p = 0, d = 0; d < this.length; d++) {
        var y = (this.words[d] | 0) * u, w = (y & 67108863) + (p & 67108863);
        p >>= 26, p += y / 67108864 | 0, p += w >>> 26, this.words[d] = w & 67108863;
      }
      return p !== 0 && (this.words[d] = p, this.length++), this.length = u === 0 ? 1 : this.length, this;
    }, i.prototype.muln = function(u) {
      return this.clone().imuln(u);
    }, i.prototype.sqr = function() {
      return this.mul(this);
    }, i.prototype.isqr = function() {
      return this.imul(this.clone());
    }, i.prototype.pow = function(u) {
      var p = v(u);
      if (p.length === 0) return new i(1);
      for (var d = this, y = 0; y < p.length && p[y] === 0; y++, d = d.sqr()) ;
      if (++y < p.length) for (var w = d.sqr(); y < p.length; y++, w = w.sqr()) p[y] !== 0 && (d = d.mul(w));
      return d;
    }, i.prototype.iushln = function(u) {
      r(typeof u == "number" && u >= 0);
      var p = u % 26, d = (u - p) / 26, y = 67108863 >>> 26 - p << 26 - p, w;
      if (p !== 0) {
        var E = 0;
        for (w = 0; w < this.length; w++) {
          var M = this.words[w] & y, x = (this.words[w] | 0) - M << p;
          this.words[w] = x | E, E = M >>> 26 - p;
        }
        E && (this.words[w] = E, this.length++);
      }
      if (d !== 0) {
        for (w = this.length - 1; w >= 0; w--) this.words[w + d] = this.words[w];
        for (w = 0; w < d; w++) this.words[w] = 0;
        this.length += d;
      }
      return this.strip();
    }, i.prototype.ishln = function(u) {
      return r(this.negative === 0), this.iushln(u);
    }, i.prototype.iushrn = function(u, p, d) {
      r(typeof u == "number" && u >= 0);
      var y;
      p ? y = (p - p % 26) / 26 : y = 0;
      var w = u % 26, E = Math.min((u - w) / 26, this.length), M = 67108863 ^ 67108863 >>> w << w, x = d;
      if (y -= E, y = Math.max(0, y), x) {
        for (var g = 0; g < E; g++) x.words[g] = this.words[g];
        x.length = E;
      }
      if (E !== 0) if (this.length > E) for (this.length -= E, g = 0; g < this.length; g++) this.words[g] = this.words[g + E];
      else this.words[0] = 0, this.length = 1;
      var k = 0;
      for (g = this.length - 1; g >= 0 && (k !== 0 || g >= y); g--) {
        var T = this.words[g] | 0;
        this.words[g] = k << 26 - w | T >>> w, k = T & M;
      }
      return x && k !== 0 && (x.words[x.length++] = k), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, i.prototype.ishrn = function(u, p, d) {
      return r(this.negative === 0), this.iushrn(u, p, d);
    }, i.prototype.shln = function(u) {
      return this.clone().ishln(u);
    }, i.prototype.ushln = function(u) {
      return this.clone().iushln(u);
    }, i.prototype.shrn = function(u) {
      return this.clone().ishrn(u);
    }, i.prototype.ushrn = function(u) {
      return this.clone().iushrn(u);
    }, i.prototype.testn = function(u) {
      r(typeof u == "number" && u >= 0);
      var p = u % 26, d = (u - p) / 26, y = 1 << p;
      if (this.length <= d) return false;
      var w = this.words[d];
      return !!(w & y);
    }, i.prototype.imaskn = function(u) {
      r(typeof u == "number" && u >= 0);
      var p = u % 26, d = (u - p) / 26;
      if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= d) return this;
      if (p !== 0 && d++, this.length = Math.min(d, this.length), p !== 0) {
        var y = 67108863 ^ 67108863 >>> p << p;
        this.words[this.length - 1] &= y;
      }
      return this.strip();
    }, i.prototype.maskn = function(u) {
      return this.clone().imaskn(u);
    }, i.prototype.iaddn = function(u) {
      return r(typeof u == "number"), r(u < 67108864), u < 0 ? this.isubn(-u) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < u ? (this.words[0] = u - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(u), this.negative = 1, this) : this._iaddn(u);
    }, i.prototype._iaddn = function(u) {
      this.words[0] += u;
      for (var p = 0; p < this.length && this.words[p] >= 67108864; p++) this.words[p] -= 67108864, p === this.length - 1 ? this.words[p + 1] = 1 : this.words[p + 1]++;
      return this.length = Math.max(this.length, p + 1), this;
    }, i.prototype.isubn = function(u) {
      if (r(typeof u == "number"), r(u < 67108864), u < 0) return this.iaddn(-u);
      if (this.negative !== 0) return this.negative = 0, this.iaddn(u), this.negative = 1, this;
      if (this.words[0] -= u, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
      else for (var p = 0; p < this.length && this.words[p] < 0; p++) this.words[p] += 67108864, this.words[p + 1] -= 1;
      return this.strip();
    }, i.prototype.addn = function(u) {
      return this.clone().iaddn(u);
    }, i.prototype.subn = function(u) {
      return this.clone().isubn(u);
    }, i.prototype.iabs = function() {
      return this.negative = 0, this;
    }, i.prototype.abs = function() {
      return this.clone().iabs();
    }, i.prototype._ishlnsubmul = function(u, p, d) {
      var y = u.length + d, w;
      this._expand(y);
      var E, M = 0;
      for (w = 0; w < u.length; w++) {
        E = (this.words[w + d] | 0) + M;
        var x = (u.words[w] | 0) * p;
        E -= x & 67108863, M = (E >> 26) - (x / 67108864 | 0), this.words[w + d] = E & 67108863;
      }
      for (; w < this.length - d; w++) E = (this.words[w + d] | 0) + M, M = E >> 26, this.words[w + d] = E & 67108863;
      if (M === 0) return this.strip();
      for (r(M === -1), M = 0, w = 0; w < this.length; w++) E = -(this.words[w] | 0) + M, M = E >> 26, this.words[w] = E & 67108863;
      return this.negative = 1, this.strip();
    }, i.prototype._wordDiv = function(u, p) {
      var d = this.length - u.length, y = this.clone(), w = u, E = w.words[w.length - 1] | 0, M = this._countBits(E);
      d = 26 - M, d !== 0 && (w = w.ushln(d), y.iushln(d), E = w.words[w.length - 1] | 0);
      var x = y.length - w.length, g;
      if (p !== "mod") {
        g = new i(null), g.length = x + 1, g.words = new Array(g.length);
        for (var k = 0; k < g.length; k++) g.words[k] = 0;
      }
      var T = y.clone()._ishlnsubmul(w, 1, x);
      T.negative === 0 && (y = T, g && (g.words[x] = 1));
      for (var O = x - 1; O >= 0; O--) {
        var K = (y.words[w.length + O] | 0) * 67108864 + (y.words[w.length + O - 1] | 0);
        for (K = Math.min(K / E | 0, 67108863), y._ishlnsubmul(w, K, O); y.negative !== 0; ) K--, y.negative = 0, y._ishlnsubmul(w, 1, O), y.isZero() || (y.negative ^= 1);
        g && (g.words[O] = K);
      }
      return g && g.strip(), y.strip(), p !== "div" && d !== 0 && y.iushrn(d), { div: g || null, mod: y };
    }, i.prototype.divmod = function(u, p, d) {
      if (r(!u.isZero()), this.isZero()) return { div: new i(0), mod: new i(0) };
      var y, w, E;
      return this.negative !== 0 && u.negative === 0 ? (E = this.neg().divmod(u, p), p !== "mod" && (y = E.div.neg()), p !== "div" && (w = E.mod.neg(), d && w.negative !== 0 && w.iadd(u)), { div: y, mod: w }) : this.negative === 0 && u.negative !== 0 ? (E = this.divmod(u.neg(), p), p !== "mod" && (y = E.div.neg()), { div: y, mod: E.mod }) : this.negative & u.negative ? (E = this.neg().divmod(u.neg(), p), p !== "div" && (w = E.mod.neg(), d && w.negative !== 0 && w.isub(u)), { div: E.div, mod: w }) : u.length > this.length || this.cmp(u) < 0 ? { div: new i(0), mod: this } : u.length === 1 ? p === "div" ? { div: this.divn(u.words[0]), mod: null } : p === "mod" ? { div: null, mod: new i(this.modn(u.words[0])) } : { div: this.divn(u.words[0]), mod: new i(this.modn(u.words[0])) } : this._wordDiv(u, p);
    }, i.prototype.div = function(u) {
      return this.divmod(u, "div", false).div;
    }, i.prototype.mod = function(u) {
      return this.divmod(u, "mod", false).mod;
    }, i.prototype.umod = function(u) {
      return this.divmod(u, "mod", true).mod;
    }, i.prototype.divRound = function(u) {
      var p = this.divmod(u);
      if (p.mod.isZero()) return p.div;
      var d = p.div.negative !== 0 ? p.mod.isub(u) : p.mod, y = u.ushrn(1), w = u.andln(1), E = d.cmp(y);
      return E < 0 || w === 1 && E === 0 ? p.div : p.div.negative !== 0 ? p.div.isubn(1) : p.div.iaddn(1);
    }, i.prototype.modn = function(u) {
      r(u <= 67108863);
      for (var p = (1 << 26) % u, d = 0, y = this.length - 1; y >= 0; y--) d = (p * d + (this.words[y] | 0)) % u;
      return d;
    }, i.prototype.idivn = function(u) {
      r(u <= 67108863);
      for (var p = 0, d = this.length - 1; d >= 0; d--) {
        var y = (this.words[d] | 0) + p * 67108864;
        this.words[d] = y / u | 0, p = y % u;
      }
      return this.strip();
    }, i.prototype.divn = function(u) {
      return this.clone().idivn(u);
    }, i.prototype.egcd = function(u) {
      r(u.negative === 0), r(!u.isZero());
      var p = this, d = u.clone();
      p.negative !== 0 ? p = p.umod(u) : p = p.clone();
      for (var y = new i(1), w = new i(0), E = new i(0), M = new i(1), x = 0; p.isEven() && d.isEven(); ) p.iushrn(1), d.iushrn(1), ++x;
      for (var g = d.clone(), k = p.clone(); !p.isZero(); ) {
        for (var T = 0, O = 1; !(p.words[0] & O) && T < 26; ++T, O <<= 1) ;
        if (T > 0) for (p.iushrn(T); T-- > 0; ) (y.isOdd() || w.isOdd()) && (y.iadd(g), w.isub(k)), y.iushrn(1), w.iushrn(1);
        for (var K = 0, Y = 1; !(d.words[0] & Y) && K < 26; ++K, Y <<= 1) ;
        if (K > 0) for (d.iushrn(K); K-- > 0; ) (E.isOdd() || M.isOdd()) && (E.iadd(g), M.isub(k)), E.iushrn(1), M.iushrn(1);
        p.cmp(d) >= 0 ? (p.isub(d), y.isub(E), w.isub(M)) : (d.isub(p), E.isub(y), M.isub(w));
      }
      return { a: E, b: M, gcd: d.iushln(x) };
    }, i.prototype._invmp = function(u) {
      r(u.negative === 0), r(!u.isZero());
      var p = this, d = u.clone();
      p.negative !== 0 ? p = p.umod(u) : p = p.clone();
      for (var y = new i(1), w = new i(0), E = d.clone(); p.cmpn(1) > 0 && d.cmpn(1) > 0; ) {
        for (var M = 0, x = 1; !(p.words[0] & x) && M < 26; ++M, x <<= 1) ;
        if (M > 0) for (p.iushrn(M); M-- > 0; ) y.isOdd() && y.iadd(E), y.iushrn(1);
        for (var g = 0, k = 1; !(d.words[0] & k) && g < 26; ++g, k <<= 1) ;
        if (g > 0) for (d.iushrn(g); g-- > 0; ) w.isOdd() && w.iadd(E), w.iushrn(1);
        p.cmp(d) >= 0 ? (p.isub(d), y.isub(w)) : (d.isub(p), w.isub(y));
      }
      var T;
      return p.cmpn(1) === 0 ? T = y : T = w, T.cmpn(0) < 0 && T.iadd(u), T;
    }, i.prototype.gcd = function(u) {
      if (this.isZero()) return u.abs();
      if (u.isZero()) return this.abs();
      var p = this.clone(), d = u.clone();
      p.negative = 0, d.negative = 0;
      for (var y = 0; p.isEven() && d.isEven(); y++) p.iushrn(1), d.iushrn(1);
      do {
        for (; p.isEven(); ) p.iushrn(1);
        for (; d.isEven(); ) d.iushrn(1);
        var w = p.cmp(d);
        if (w < 0) {
          var E = p;
          p = d, d = E;
        } else if (w === 0 || d.cmpn(1) === 0) break;
        p.isub(d);
      } while (true);
      return d.iushln(y);
    }, i.prototype.invm = function(u) {
      return this.egcd(u).a.umod(u);
    }, i.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, i.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, i.prototype.andln = function(u) {
      return this.words[0] & u;
    }, i.prototype.bincn = function(u) {
      r(typeof u == "number");
      var p = u % 26, d = (u - p) / 26, y = 1 << p;
      if (this.length <= d) return this._expand(d + 1), this.words[d] |= y, this;
      for (var w = y, E = d; w !== 0 && E < this.length; E++) {
        var M = this.words[E] | 0;
        M += w, w = M >>> 26, M &= 67108863, this.words[E] = M;
      }
      return w !== 0 && (this.words[E] = w, this.length++), this;
    }, i.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, i.prototype.cmpn = function(u) {
      var p = u < 0;
      if (this.negative !== 0 && !p) return -1;
      if (this.negative === 0 && p) return 1;
      this.strip();
      var d;
      if (this.length > 1) d = 1;
      else {
        p && (u = -u), r(u <= 67108863, "Number is too big");
        var y = this.words[0] | 0;
        d = y === u ? 0 : y < u ? -1 : 1;
      }
      return this.negative !== 0 ? -d | 0 : d;
    }, i.prototype.cmp = function(u) {
      if (this.negative !== 0 && u.negative === 0) return -1;
      if (this.negative === 0 && u.negative !== 0) return 1;
      var p = this.ucmp(u);
      return this.negative !== 0 ? -p | 0 : p;
    }, i.prototype.ucmp = function(u) {
      if (this.length > u.length) return 1;
      if (this.length < u.length) return -1;
      for (var p = 0, d = this.length - 1; d >= 0; d--) {
        var y = this.words[d] | 0, w = u.words[d] | 0;
        if (y !== w) {
          y < w ? p = -1 : y > w && (p = 1);
          break;
        }
      }
      return p;
    }, i.prototype.gtn = function(u) {
      return this.cmpn(u) === 1;
    }, i.prototype.gt = function(u) {
      return this.cmp(u) === 1;
    }, i.prototype.gten = function(u) {
      return this.cmpn(u) >= 0;
    }, i.prototype.gte = function(u) {
      return this.cmp(u) >= 0;
    }, i.prototype.ltn = function(u) {
      return this.cmpn(u) === -1;
    }, i.prototype.lt = function(u) {
      return this.cmp(u) === -1;
    }, i.prototype.lten = function(u) {
      return this.cmpn(u) <= 0;
    }, i.prototype.lte = function(u) {
      return this.cmp(u) <= 0;
    }, i.prototype.eqn = function(u) {
      return this.cmpn(u) === 0;
    }, i.prototype.eq = function(u) {
      return this.cmp(u) === 0;
    }, i.red = function(u) {
      return new N(u);
    }, i.prototype.toRed = function(u) {
      return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), u.convertTo(this)._forceRed(u);
    }, i.prototype.fromRed = function() {
      return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, i.prototype._forceRed = function(u) {
      return this.red = u, this;
    }, i.prototype.forceRed = function(u) {
      return r(!this.red, "Already a number in reduction context"), this._forceRed(u);
    }, i.prototype.redAdd = function(u) {
      return r(this.red, "redAdd works only with red numbers"), this.red.add(this, u);
    }, i.prototype.redIAdd = function(u) {
      return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, u);
    }, i.prototype.redSub = function(u) {
      return r(this.red, "redSub works only with red numbers"), this.red.sub(this, u);
    }, i.prototype.redISub = function(u) {
      return r(this.red, "redISub works only with red numbers"), this.red.isub(this, u);
    }, i.prototype.redShl = function(u) {
      return r(this.red, "redShl works only with red numbers"), this.red.shl(this, u);
    }, i.prototype.redMul = function(u) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, u), this.red.mul(this, u);
    }, i.prototype.redIMul = function(u) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, u), this.red.imul(this, u);
    }, i.prototype.redSqr = function() {
      return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, i.prototype.redISqr = function() {
      return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, i.prototype.redSqrt = function() {
      return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, i.prototype.redInvm = function() {
      return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, i.prototype.redNeg = function() {
      return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, i.prototype.redPow = function(u) {
      return r(this.red && !u.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, u);
    };
    var S = { k256: null, p224: null, p192: null, p25519: null };
    function $(B, u) {
      this.name = B, this.p = new i(u, 16), this.n = this.p.bitLength(), this.k = new i(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    $.prototype._tmp = function() {
      var u = new i(null);
      return u.words = new Array(Math.ceil(this.n / 13)), u;
    }, $.prototype.ireduce = function(u) {
      var p = u, d;
      do
        this.split(p, this.tmp), p = this.imulK(p), p = p.iadd(this.tmp), d = p.bitLength();
      while (d > this.n);
      var y = d < this.n ? -1 : p.ucmp(this.p);
      return y === 0 ? (p.words[0] = 0, p.length = 1) : y > 0 ? p.isub(this.p) : p.strip !== void 0 ? p.strip() : p._strip(), p;
    }, $.prototype.split = function(u, p) {
      u.iushrn(this.n, 0, p);
    }, $.prototype.imulK = function(u) {
      return u.imul(this.k);
    };
    function F() {
      $.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    s(F, $), F.prototype.split = function(u, p) {
      for (var d = 4194303, y = Math.min(u.length, 9), w = 0; w < y; w++) p.words[w] = u.words[w];
      if (p.length = y, u.length <= 9) {
        u.words[0] = 0, u.length = 1;
        return;
      }
      var E = u.words[9];
      for (p.words[p.length++] = E & d, w = 10; w < u.length; w++) {
        var M = u.words[w] | 0;
        u.words[w - 10] = (M & d) << 4 | E >>> 22, E = M;
      }
      E >>>= 22, u.words[w - 10] = E, E === 0 && u.length > 10 ? u.length -= 10 : u.length -= 9;
    }, F.prototype.imulK = function(u) {
      u.words[u.length] = 0, u.words[u.length + 1] = 0, u.length += 2;
      for (var p = 0, d = 0; d < u.length; d++) {
        var y = u.words[d] | 0;
        p += y * 977, u.words[d] = p & 67108863, p = y * 64 + (p / 67108864 | 0);
      }
      return u.words[u.length - 1] === 0 && (u.length--, u.words[u.length - 1] === 0 && u.length--), u;
    };
    function U() {
      $.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    s(U, $);
    function Q() {
      $.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    s(Q, $);
    function P() {
      $.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    s(P, $), P.prototype.imulK = function(u) {
      for (var p = 0, d = 0; d < u.length; d++) {
        var y = (u.words[d] | 0) * 19 + p, w = y & 67108863;
        y >>>= 26, u.words[d] = w, p = y;
      }
      return p !== 0 && (u.words[u.length++] = p), u;
    }, i._prime = function(u) {
      if (S[u]) return S[u];
      var p;
      if (u === "k256") p = new F();
      else if (u === "p224") p = new U();
      else if (u === "p192") p = new Q();
      else if (u === "p25519") p = new P();
      else throw new Error("Unknown prime " + u);
      return S[u] = p, p;
    };
    function N(B) {
      if (typeof B == "string") {
        var u = i._prime(B);
        this.m = u.p, this.prime = u;
      } else r(B.gtn(1), "modulus must be greater than 1"), this.m = B, this.prime = null;
    }
    N.prototype._verify1 = function(u) {
      r(u.negative === 0, "red works only with positives"), r(u.red, "red works only with red numbers");
    }, N.prototype._verify2 = function(u, p) {
      r((u.negative | p.negative) === 0, "red works only with positives"), r(u.red && u.red === p.red, "red works only with red numbers");
    }, N.prototype.imod = function(u) {
      return this.prime ? this.prime.ireduce(u)._forceRed(this) : u.umod(this.m)._forceRed(this);
    }, N.prototype.neg = function(u) {
      return u.isZero() ? u.clone() : this.m.sub(u)._forceRed(this);
    }, N.prototype.add = function(u, p) {
      this._verify2(u, p);
      var d = u.add(p);
      return d.cmp(this.m) >= 0 && d.isub(this.m), d._forceRed(this);
    }, N.prototype.iadd = function(u, p) {
      this._verify2(u, p);
      var d = u.iadd(p);
      return d.cmp(this.m) >= 0 && d.isub(this.m), d;
    }, N.prototype.sub = function(u, p) {
      this._verify2(u, p);
      var d = u.sub(p);
      return d.cmpn(0) < 0 && d.iadd(this.m), d._forceRed(this);
    }, N.prototype.isub = function(u, p) {
      this._verify2(u, p);
      var d = u.isub(p);
      return d.cmpn(0) < 0 && d.iadd(this.m), d;
    }, N.prototype.shl = function(u, p) {
      return this._verify1(u), this.imod(u.ushln(p));
    }, N.prototype.imul = function(u, p) {
      return this._verify2(u, p), this.imod(u.imul(p));
    }, N.prototype.mul = function(u, p) {
      return this._verify2(u, p), this.imod(u.mul(p));
    }, N.prototype.isqr = function(u) {
      return this.imul(u, u.clone());
    }, N.prototype.sqr = function(u) {
      return this.mul(u, u);
    }, N.prototype.sqrt = function(u) {
      if (u.isZero()) return u.clone();
      var p = this.m.andln(3);
      if (r(p % 2 === 1), p === 3) {
        var d = this.m.add(new i(1)).iushrn(2);
        return this.pow(u, d);
      }
      for (var y = this.m.subn(1), w = 0; !y.isZero() && y.andln(1) === 0; ) w++, y.iushrn(1);
      r(!y.isZero());
      var E = new i(1).toRed(this), M = E.redNeg(), x = this.m.subn(1).iushrn(1), g = this.m.bitLength();
      for (g = new i(2 * g * g).toRed(this); this.pow(g, x).cmp(M) !== 0; ) g.redIAdd(M);
      for (var k = this.pow(g, y), T = this.pow(u, y.addn(1).iushrn(1)), O = this.pow(u, y), K = w; O.cmp(E) !== 0; ) {
        for (var Y = O, J = 0; Y.cmp(E) !== 0; J++) Y = Y.redSqr();
        r(J < K);
        var G = this.pow(k, new i(1).iushln(K - J - 1));
        T = T.redMul(G), k = G.redSqr(), O = O.redMul(k), K = J;
      }
      return T;
    }, N.prototype.invm = function(u) {
      var p = u._invmp(this.m);
      return p.negative !== 0 ? (p.negative = 0, this.imod(p).redNeg()) : this.imod(p);
    }, N.prototype.pow = function(u, p) {
      if (p.isZero()) return new i(1).toRed(this);
      if (p.cmpn(1) === 0) return u.clone();
      var d = 4, y = new Array(1 << d);
      y[0] = new i(1).toRed(this), y[1] = u;
      for (var w = 2; w < y.length; w++) y[w] = this.mul(y[w - 1], u);
      var E = y[0], M = 0, x = 0, g = p.bitLength() % 26;
      for (g === 0 && (g = 26), w = p.length - 1; w >= 0; w--) {
        for (var k = p.words[w], T = g - 1; T >= 0; T--) {
          var O = k >> T & 1;
          if (E !== y[0] && (E = this.sqr(E)), O === 0 && M === 0) {
            x = 0;
            continue;
          }
          M <<= 1, M |= O, x++, !(x !== d && (w !== 0 || T !== 0)) && (E = this.mul(E, y[M]), x = 0, M = 0);
        }
        g = 26;
      }
      return E;
    }, N.prototype.convertTo = function(u) {
      var p = u.umod(this.m);
      return p === u ? p.clone() : p;
    }, N.prototype.convertFrom = function(u) {
      var p = u.clone();
      return p.red = null, p;
    }, i.mont = function(u) {
      return new L(u);
    };
    function L(B) {
      N.call(this, B), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new i(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    s(L, N), L.prototype.convertTo = function(u) {
      return this.imod(u.ushln(this.shift));
    }, L.prototype.convertFrom = function(u) {
      var p = this.imod(u.mul(this.rinv));
      return p.red = null, p;
    }, L.prototype.imul = function(u, p) {
      if (u.isZero() || p.isZero()) return u.words[0] = 0, u.length = 1, u;
      var d = u.imul(p), y = d.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = d.isub(y).iushrn(this.shift), E = w;
      return w.cmp(this.m) >= 0 ? E = w.isub(this.m) : w.cmpn(0) < 0 && (E = w.iadd(this.m)), E._forceRed(this);
    }, L.prototype.mul = function(u, p) {
      if (u.isZero() || p.isZero()) return new i(0)._forceRed(this);
      var d = u.mul(p), y = d.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = d.isub(y).iushrn(this.shift), E = w;
      return w.cmp(this.m) >= 0 ? E = w.isub(this.m) : w.cmpn(0) < 0 && (E = w.iadd(this.m)), E._forceRed(this);
    }, L.prototype.invm = function(u) {
      var p = this.imod(u._invmp(this.m).mul(this.r2));
      return p._forceRed(this);
    };
  })(t3, mt);
})(HA);
var SW = HA.exports, tp = { exports: {} }, Dw;
function qA() {
  if (Dw) return tp.exports;
  Dw = 1;
  var t3;
  tp.exports = function(s) {
    return t3 || (t3 = new e(null)), t3.generate(s);
  };
  function e(r) {
    this.rand = r;
  }
  if (tp.exports.Rand = e, e.prototype.generate = function(s) {
    return this._rand(s);
  }, e.prototype._rand = function(s) {
    if (this.rand.getBytes) return this.rand.getBytes(s);
    for (var i = new Uint8Array(s), a = 0; a < i.length; a++) i[a] = this.rand.getByte();
    return i;
  }, typeof self == "object") self.crypto && self.crypto.getRandomValues ? e.prototype._rand = function(s) {
    var i = new Uint8Array(s);
    return self.crypto.getRandomValues(i), i;
  } : self.msCrypto && self.msCrypto.getRandomValues ? e.prototype._rand = function(s) {
    var i = new Uint8Array(s);
    return self.msCrypto.getRandomValues(i), i;
  } : typeof window == "object" && (e.prototype._rand = function() {
    throw new Error("Not implemented yet");
  });
  else try {
    var n = vl();
    if (typeof n.randomBytes != "function") throw new Error("Not supported");
    e.prototype._rand = function(s) {
      return n.randomBytes(s);
    };
  } catch {
  }
  return tp.exports;
}
var q2, Rw;
function b$() {
  if (Rw) return q2;
  Rw = 1;
  var t3 = SW, e = qA();
  function n(r) {
    this.rand = r || new e.Rand();
  }
  return q2 = n, n.create = function(s) {
    return new n(s);
  }, n.prototype._randbelow = function(s) {
    var i = s.bitLength(), a = Math.ceil(i / 8);
    do
      var o = new t3(this.rand.generate(a));
    while (o.cmp(s) >= 0);
    return o;
  }, n.prototype._randrange = function(s, i) {
    var a = i.sub(s);
    return s.add(this._randbelow(a));
  }, n.prototype.test = function(s, i, a) {
    var o = s.bitLength(), f = t3.mont(s), c = new t3(1).toRed(f);
    i || (i = Math.max(1, o / 48 | 0));
    for (var l = s.subn(1), h = 0; !l.testn(h); h++) ;
    for (var m = s.shrn(h), v = l.toRed(f), b = true; i > 0; i--) {
      var A = this._randrange(new t3(2), l);
      a && a(A);
      var _ = A.toRed(f).redPow(m);
      if (!(_.cmp(c) === 0 || _.cmp(v) === 0)) {
        for (var C = 1; C < h; C++) {
          if (_ = _.redSqr(), _.cmp(c) === 0) return false;
          if (_.cmp(v) === 0) break;
        }
        if (C === h) return false;
      }
    }
    return b;
  }, n.prototype.getDivisor = function(s, i) {
    var a = s.bitLength(), o = t3.mont(s), f = new t3(1).toRed(o);
    i || (i = Math.max(1, a / 48 | 0));
    for (var c = s.subn(1), l = 0; !c.testn(l); l++) ;
    for (var h = s.shrn(l), m = c.toRed(o); i > 0; i--) {
      var v = this._randrange(new t3(2), c), b = s.gcd(v);
      if (b.cmpn(1) !== 0) return b;
      var A = v.toRed(o).redPow(h);
      if (!(A.cmp(f) === 0 || A.cmp(m) === 0)) {
        for (var _ = 1; _ < l; _++) {
          if (A = A.redSqr(), A.cmp(f) === 0) return A.fromRed().subn(1).gcd(s);
          if (A.cmp(m) === 0) break;
        }
        if (_ === l) return A = A.redSqr(), A.fromRed().subn(1).gcd(s);
      }
    }
    return false;
  }, q2;
}
var z2, Fw;
function A$() {
  if (Fw) return z2;
  Fw = 1;
  var t3 = Yu;
  z2 = _, _.simpleSieve = b, _.fermatTest = A;
  var e = y$, n = new e(24), r = b$(), s = new r(), i = new e(1), a = new e(2), o = new e(5);
  new e(16), new e(8);
  var f = new e(10), c = new e(3);
  new e(7);
  var l = new e(11), h = new e(4);
  new e(12);
  var m = null;
  function v() {
    if (m !== null) return m;
    var C = 1048576, I = [];
    I[0] = 2;
    for (var S = 1, $ = 3; $ < C; $ += 2) {
      for (var F = Math.ceil(Math.sqrt($)), U = 0; U < S && I[U] <= F && $ % I[U] !== 0; U++) ;
      S !== U && I[U] <= F || (I[S++] = $);
    }
    return m = I, I;
  }
  function b(C) {
    for (var I = v(), S = 0; S < I.length; S++) if (C.modn(I[S]) === 0) return C.cmpn(I[S]) === 0;
    return true;
  }
  function A(C) {
    var I = e.mont(C);
    return a.toRed(I).redPow(C.subn(1)).fromRed().cmpn(1) === 0;
  }
  function _(C, I) {
    if (C < 16) return I === 2 || I === 5 ? new e([140, 123]) : new e([140, 39]);
    I = new e(I);
    for (var S, $; ; ) {
      for (S = new e(t3(Math.ceil(C / 8))); S.bitLength() > C; ) S.ishrn(1);
      if (S.isEven() && S.iadd(i), S.testn(1) || S.iadd(a), I.cmp(a)) {
        if (!I.cmp(o)) for (; S.mod(f).cmp(c); ) S.iadd(h);
      } else for (; S.mod(n).cmp(l); ) S.iadd(h);
      if ($ = S.shrn(1), b($) && b(S) && A($) && A(S) && s.test($) && s.test(S)) return S;
    }
  }
  return z2;
}
const MW = { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff" }, $W = { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff" }, TW = { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff" }, DW = { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff" }, RW = { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff" }, FW = { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff" }, PW = { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff" }, NW = { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff" }, UW = { modp1: MW, modp2: $W, modp5: TW, modp14: DW, modp15: RW, modp16: FW, modp17: PW, modp18: NW };
var G2, Pw;
function LW() {
  if (Pw) return G2;
  Pw = 1;
  var t3 = y$, e = b$(), n = new e(), r = new t3(24), s = new t3(11), i = new t3(10), a = new t3(3), o = new t3(7), f = A$(), c = Yu;
  G2 = b;
  function l(_, C) {
    return C = C || "utf8", hr.isBuffer(_) || (_ = new hr(_, C)), this._pub = new t3(_), this;
  }
  function h(_, C) {
    return C = C || "utf8", hr.isBuffer(_) || (_ = new hr(_, C)), this._priv = new t3(_), this;
  }
  var m = {};
  function v(_, C) {
    var I = C.toString("hex"), S = [I, _.toString(16)].join("_");
    if (S in m) return m[S];
    var $ = 0;
    if (_.isEven() || !f.simpleSieve || !f.fermatTest(_) || !n.test(_)) return $ += 1, I === "02" || I === "05" ? $ += 8 : $ += 4, m[S] = $, $;
    n.test(_.shrn(1)) || ($ += 2);
    var F;
    switch (I) {
      case "02":
        _.mod(r).cmp(s) && ($ += 8);
        break;
      case "05":
        F = _.mod(i), F.cmp(a) && F.cmp(o) && ($ += 8);
        break;
      default:
        $ += 4;
    }
    return m[S] = $, $;
  }
  function b(_, C, I) {
    this.setGenerator(C), this.__prime = new t3(_), this._prime = t3.mont(this.__prime), this._primeLen = _.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, I ? (this.setPublicKey = l, this.setPrivateKey = h) : this._primeCode = 8;
  }
  Object.defineProperty(b.prototype, "verifyError", { enumerable: true, get: function() {
    return typeof this._primeCode != "number" && (this._primeCode = v(this.__prime, this.__gen)), this._primeCode;
  } }), b.prototype.generateKeys = function() {
    return this._priv || (this._priv = new t3(c(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, b.prototype.computeSecret = function(_) {
    _ = new t3(_), _ = _.toRed(this._prime);
    var C = _.redPow(this._priv).fromRed(), I = new hr(C.toArray()), S = this.getPrime();
    if (I.length < S.length) {
      var $ = new hr(S.length - I.length);
      $.fill(0), I = hr.concat([$, I]);
    }
    return I;
  }, b.prototype.getPublicKey = function(C) {
    return A(this._pub, C);
  }, b.prototype.getPrivateKey = function(C) {
    return A(this._priv, C);
  }, b.prototype.getPrime = function(_) {
    return A(this.__prime, _);
  }, b.prototype.getGenerator = function(_) {
    return A(this._gen, _);
  }, b.prototype.setGenerator = function(_, C) {
    return C = C || "utf8", hr.isBuffer(_) || (_ = new hr(_, C)), this.__gen = _, this._gen = new t3(_), this;
  };
  function A(_, C) {
    var I = new hr(_.toArray());
    return C ? I.toString(C) : I;
  }
  return G2;
}
var Nw;
function OW() {
  if (Nw) return $l;
  Nw = 1;
  var t3 = A$(), e = UW, n = LW();
  function r(a) {
    var o = new hr(e[a].prime, "hex"), f = new hr(e[a].gen, "hex");
    return new n(o, f);
  }
  var s = { binary: true, hex: true, base64: true };
  function i(a, o, f, c) {
    return hr.isBuffer(o) || s[o] === void 0 ? i(a, "binary", o, f) : (o = o || "binary", c = c || "binary", f = f || new hr([2]), hr.isBuffer(f) || (f = new hr(f, c)), typeof a == "number" ? new n(t3(a, f), f, true) : (hr.isBuffer(a) || (a = new hr(a, o)), new n(a, f, true)));
  }
  return $l.DiffieHellmanGroup = $l.createDiffieHellmanGroup = $l.getDiffieHellman = r, $l.createDiffieHellman = $l.DiffieHellman = i, $l;
}
var V3 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(t3, e) {
  var n = $n, r = n.Buffer;
  function s(a, o) {
    for (var f in a) o[f] = a[f];
  }
  r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow ? t3.exports = n : (s(n, e), e.Buffer = i);
  function i(a, o, f) {
    return r(a, o, f);
  }
  i.prototype = Object.create(r.prototype), s(r, i), i.from = function(a, o, f) {
    if (typeof a == "number") throw new TypeError("Argument must not be a number");
    return r(a, o, f);
  }, i.alloc = function(a, o, f) {
    if (typeof a != "number") throw new TypeError("Argument must be a number");
    var c = r(a);
    return o !== void 0 ? typeof f == "string" ? c.fill(o, f) : c.fill(o) : c.fill(0), c;
  }, i.allocUnsafe = function(a) {
    if (typeof a != "number") throw new TypeError("Argument must be a number");
    return r(a);
  }, i.allocUnsafeSlow = function(a) {
    if (typeof a != "number") throw new TypeError("Argument must be a number");
    return n.SlowBuffer(a);
  };
})(V3, V3.exports);
var zA = V3.exports, $c = { exports: {} }, GA = { exports: {} };
GA.exports;
(function(t3) {
  (function(e, n) {
    function r(p, d) {
      if (!p) throw new Error(d || "Assertion failed");
    }
    function s(p, d) {
      p.super_ = d;
      var y = function() {
      };
      y.prototype = d.prototype, p.prototype = new y(), p.prototype.constructor = p;
    }
    function i(p, d, y) {
      if (i.isBN(p)) return p;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, p !== null && ((d === "le" || d === "be") && (y = d, d = 10), this._init(p || 0, d || 10, y || "be"));
    }
    typeof e == "object" ? e.exports = i : n.BN = i, i.BN = i, i.wordSize = 26;
    var a;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? a = window.Buffer : a = $n.Buffer;
    } catch {
    }
    i.isBN = function(d) {
      return d instanceof i ? true : d !== null && typeof d == "object" && d.constructor.wordSize === i.wordSize && Array.isArray(d.words);
    }, i.max = function(d, y) {
      return d.cmp(y) > 0 ? d : y;
    }, i.min = function(d, y) {
      return d.cmp(y) < 0 ? d : y;
    }, i.prototype._init = function(d, y, w) {
      if (typeof d == "number") return this._initNumber(d, y, w);
      if (typeof d == "object") return this._initArray(d, y, w);
      y === "hex" && (y = 16), r(y === (y | 0) && y >= 2 && y <= 36), d = d.toString().replace(/\s+/g, "");
      var E = 0;
      d[0] === "-" && (E++, this.negative = 1), E < d.length && (y === 16 ? this._parseHex(d, E, w) : (this._parseBase(d, y, E), w === "le" && this._initArray(this.toArray(), y, w)));
    }, i.prototype._initNumber = function(d, y, w) {
      d < 0 && (this.negative = 1, d = -d), d < 67108864 ? (this.words = [d & 67108863], this.length = 1) : d < 4503599627370496 ? (this.words = [d & 67108863, d / 67108864 & 67108863], this.length = 2) : (r(d < 9007199254740992), this.words = [d & 67108863, d / 67108864 & 67108863, 1], this.length = 3), w === "le" && this._initArray(this.toArray(), y, w);
    }, i.prototype._initArray = function(d, y, w) {
      if (r(typeof d.length == "number"), d.length <= 0) return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(d.length / 3), this.words = new Array(this.length);
      for (var E = 0; E < this.length; E++) this.words[E] = 0;
      var M, x, g = 0;
      if (w === "be") for (E = d.length - 1, M = 0; E >= 0; E -= 3) x = d[E] | d[E - 1] << 8 | d[E - 2] << 16, this.words[M] |= x << g & 67108863, this.words[M + 1] = x >>> 26 - g & 67108863, g += 24, g >= 26 && (g -= 26, M++);
      else if (w === "le") for (E = 0, M = 0; E < d.length; E += 3) x = d[E] | d[E + 1] << 8 | d[E + 2] << 16, this.words[M] |= x << g & 67108863, this.words[M + 1] = x >>> 26 - g & 67108863, g += 24, g >= 26 && (g -= 26, M++);
      return this._strip();
    };
    function o(p, d) {
      var y = p.charCodeAt(d);
      if (y >= 48 && y <= 57) return y - 48;
      if (y >= 65 && y <= 70) return y - 55;
      if (y >= 97 && y <= 102) return y - 87;
      r(false, "Invalid character in " + p);
    }
    function f(p, d, y) {
      var w = o(p, y);
      return y - 1 >= d && (w |= o(p, y - 1) << 4), w;
    }
    i.prototype._parseHex = function(d, y, w) {
      this.length = Math.ceil((d.length - y) / 6), this.words = new Array(this.length);
      for (var E = 0; E < this.length; E++) this.words[E] = 0;
      var M = 0, x = 0, g;
      if (w === "be") for (E = d.length - 1; E >= y; E -= 2) g = f(d, y, E) << M, this.words[x] |= g & 67108863, M >= 18 ? (M -= 18, x += 1, this.words[x] |= g >>> 26) : M += 8;
      else {
        var k = d.length - y;
        for (E = k % 2 === 0 ? y + 1 : y; E < d.length; E += 2) g = f(d, y, E) << M, this.words[x] |= g & 67108863, M >= 18 ? (M -= 18, x += 1, this.words[x] |= g >>> 26) : M += 8;
      }
      this._strip();
    };
    function c(p, d, y, w) {
      for (var E = 0, M = 0, x = Math.min(p.length, y), g = d; g < x; g++) {
        var k = p.charCodeAt(g) - 48;
        E *= w, k >= 49 ? M = k - 49 + 10 : k >= 17 ? M = k - 17 + 10 : M = k, r(k >= 0 && M < w, "Invalid character"), E += M;
      }
      return E;
    }
    i.prototype._parseBase = function(d, y, w) {
      this.words = [0], this.length = 1;
      for (var E = 0, M = 1; M <= 67108863; M *= y) E++;
      E--, M = M / y | 0;
      for (var x = d.length - w, g = x % E, k = Math.min(x, x - g) + w, T = 0, O = w; O < k; O += E) T = c(d, O, O + E, y), this.imuln(M), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      if (g !== 0) {
        var K = 1;
        for (T = c(d, O, d.length, y), O = 0; O < g; O++) K *= y;
        this.imuln(K), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      }
      this._strip();
    }, i.prototype.copy = function(d) {
      d.words = new Array(this.length);
      for (var y = 0; y < this.length; y++) d.words[y] = this.words[y];
      d.length = this.length, d.negative = this.negative, d.red = this.red;
    };
    function l(p, d) {
      p.words = d.words, p.length = d.length, p.negative = d.negative, p.red = d.red;
    }
    if (i.prototype._move = function(d) {
      l(d, this);
    }, i.prototype.clone = function() {
      var d = new i(null);
      return this.copy(d), d;
    }, i.prototype._expand = function(d) {
      for (; this.length < d; ) this.words[this.length++] = 0;
      return this;
    }, i.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; ) this.length--;
      return this._normSign();
    }, i.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function") try {
      i.prototype[Symbol.for("nodejs.util.inspect.custom")] = h;
    } catch {
      i.prototype.inspect = h;
    }
    else i.prototype.inspect = h;
    function h() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var m = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], v = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], b = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    i.prototype.toString = function(d, y) {
      d = d || 10, y = y | 0 || 1;
      var w;
      if (d === 16 || d === "hex") {
        w = "";
        for (var E = 0, M = 0, x = 0; x < this.length; x++) {
          var g = this.words[x], k = ((g << E | M) & 16777215).toString(16);
          M = g >>> 24 - E & 16777215, E += 2, E >= 26 && (E -= 26, x--), M !== 0 || x !== this.length - 1 ? w = m[6 - k.length] + k + w : w = k + w;
        }
        for (M !== 0 && (w = M.toString(16) + w); w.length % y !== 0; ) w = "0" + w;
        return this.negative !== 0 && (w = "-" + w), w;
      }
      if (d === (d | 0) && d >= 2 && d <= 36) {
        var T = v[d], O = b[d];
        w = "";
        var K = this.clone();
        for (K.negative = 0; !K.isZero(); ) {
          var Y = K.modrn(O).toString(d);
          K = K.idivn(O), K.isZero() ? w = Y + w : w = m[T - Y.length] + Y + w;
        }
        for (this.isZero() && (w = "0" + w); w.length % y !== 0; ) w = "0" + w;
        return this.negative !== 0 && (w = "-" + w), w;
      }
      r(false, "Base should be between 2 and 36");
    }, i.prototype.toNumber = function() {
      var d = this.words[0];
      return this.length === 2 ? d += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? d += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -d : d;
    }, i.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, a && (i.prototype.toBuffer = function(d, y) {
      return this.toArrayLike(a, d, y);
    }), i.prototype.toArray = function(d, y) {
      return this.toArrayLike(Array, d, y);
    };
    var A = function(d, y) {
      return d.allocUnsafe ? d.allocUnsafe(y) : new d(y);
    };
    i.prototype.toArrayLike = function(d, y, w) {
      this._strip();
      var E = this.byteLength(), M = w || Math.max(1, E);
      r(E <= M, "byte array longer than desired length"), r(M > 0, "Requested array length <= 0");
      var x = A(d, M), g = y === "le" ? "LE" : "BE";
      return this["_toArrayLike" + g](x, E), x;
    }, i.prototype._toArrayLikeLE = function(d, y) {
      for (var w = 0, E = 0, M = 0, x = 0; M < this.length; M++) {
        var g = this.words[M] << x | E;
        d[w++] = g & 255, w < d.length && (d[w++] = g >> 8 & 255), w < d.length && (d[w++] = g >> 16 & 255), x === 6 ? (w < d.length && (d[w++] = g >> 24 & 255), E = 0, x = 0) : (E = g >>> 24, x += 2);
      }
      if (w < d.length) for (d[w++] = E; w < d.length; ) d[w++] = 0;
    }, i.prototype._toArrayLikeBE = function(d, y) {
      for (var w = d.length - 1, E = 0, M = 0, x = 0; M < this.length; M++) {
        var g = this.words[M] << x | E;
        d[w--] = g & 255, w >= 0 && (d[w--] = g >> 8 & 255), w >= 0 && (d[w--] = g >> 16 & 255), x === 6 ? (w >= 0 && (d[w--] = g >> 24 & 255), E = 0, x = 0) : (E = g >>> 24, x += 2);
      }
      if (w >= 0) for (d[w--] = E; w >= 0; ) d[w--] = 0;
    }, Math.clz32 ? i.prototype._countBits = function(d) {
      return 32 - Math.clz32(d);
    } : i.prototype._countBits = function(d) {
      var y = d, w = 0;
      return y >= 4096 && (w += 13, y >>>= 13), y >= 64 && (w += 7, y >>>= 7), y >= 8 && (w += 4, y >>>= 4), y >= 2 && (w += 2, y >>>= 2), w + y;
    }, i.prototype._zeroBits = function(d) {
      if (d === 0) return 26;
      var y = d, w = 0;
      return y & 8191 || (w += 13, y >>>= 13), y & 127 || (w += 7, y >>>= 7), y & 15 || (w += 4, y >>>= 4), y & 3 || (w += 2, y >>>= 2), y & 1 || w++, w;
    }, i.prototype.bitLength = function() {
      var d = this.words[this.length - 1], y = this._countBits(d);
      return (this.length - 1) * 26 + y;
    };
    function _(p) {
      for (var d = new Array(p.bitLength()), y = 0; y < d.length; y++) {
        var w = y / 26 | 0, E = y % 26;
        d[y] = p.words[w] >>> E & 1;
      }
      return d;
    }
    i.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var d = 0, y = 0; y < this.length; y++) {
        var w = this._zeroBits(this.words[y]);
        if (d += w, w !== 26) break;
      }
      return d;
    }, i.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, i.prototype.toTwos = function(d) {
      return this.negative !== 0 ? this.abs().inotn(d).iaddn(1) : this.clone();
    }, i.prototype.fromTwos = function(d) {
      return this.testn(d - 1) ? this.notn(d).iaddn(1).ineg() : this.clone();
    }, i.prototype.isNeg = function() {
      return this.negative !== 0;
    }, i.prototype.neg = function() {
      return this.clone().ineg();
    }, i.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, i.prototype.iuor = function(d) {
      for (; this.length < d.length; ) this.words[this.length++] = 0;
      for (var y = 0; y < d.length; y++) this.words[y] = this.words[y] | d.words[y];
      return this._strip();
    }, i.prototype.ior = function(d) {
      return r((this.negative | d.negative) === 0), this.iuor(d);
    }, i.prototype.or = function(d) {
      return this.length > d.length ? this.clone().ior(d) : d.clone().ior(this);
    }, i.prototype.uor = function(d) {
      return this.length > d.length ? this.clone().iuor(d) : d.clone().iuor(this);
    }, i.prototype.iuand = function(d) {
      var y;
      this.length > d.length ? y = d : y = this;
      for (var w = 0; w < y.length; w++) this.words[w] = this.words[w] & d.words[w];
      return this.length = y.length, this._strip();
    }, i.prototype.iand = function(d) {
      return r((this.negative | d.negative) === 0), this.iuand(d);
    }, i.prototype.and = function(d) {
      return this.length > d.length ? this.clone().iand(d) : d.clone().iand(this);
    }, i.prototype.uand = function(d) {
      return this.length > d.length ? this.clone().iuand(d) : d.clone().iuand(this);
    }, i.prototype.iuxor = function(d) {
      var y, w;
      this.length > d.length ? (y = this, w = d) : (y = d, w = this);
      for (var E = 0; E < w.length; E++) this.words[E] = y.words[E] ^ w.words[E];
      if (this !== y) for (; E < y.length; E++) this.words[E] = y.words[E];
      return this.length = y.length, this._strip();
    }, i.prototype.ixor = function(d) {
      return r((this.negative | d.negative) === 0), this.iuxor(d);
    }, i.prototype.xor = function(d) {
      return this.length > d.length ? this.clone().ixor(d) : d.clone().ixor(this);
    }, i.prototype.uxor = function(d) {
      return this.length > d.length ? this.clone().iuxor(d) : d.clone().iuxor(this);
    }, i.prototype.inotn = function(d) {
      r(typeof d == "number" && d >= 0);
      var y = Math.ceil(d / 26) | 0, w = d % 26;
      this._expand(y), w > 0 && y--;
      for (var E = 0; E < y; E++) this.words[E] = ~this.words[E] & 67108863;
      return w > 0 && (this.words[E] = ~this.words[E] & 67108863 >> 26 - w), this._strip();
    }, i.prototype.notn = function(d) {
      return this.clone().inotn(d);
    }, i.prototype.setn = function(d, y) {
      r(typeof d == "number" && d >= 0);
      var w = d / 26 | 0, E = d % 26;
      return this._expand(w + 1), y ? this.words[w] = this.words[w] | 1 << E : this.words[w] = this.words[w] & ~(1 << E), this._strip();
    }, i.prototype.iadd = function(d) {
      var y;
      if (this.negative !== 0 && d.negative === 0) return this.negative = 0, y = this.isub(d), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && d.negative !== 0) return d.negative = 0, y = this.isub(d), d.negative = 1, y._normSign();
      var w, E;
      this.length > d.length ? (w = this, E = d) : (w = d, E = this);
      for (var M = 0, x = 0; x < E.length; x++) y = (w.words[x] | 0) + (E.words[x] | 0) + M, this.words[x] = y & 67108863, M = y >>> 26;
      for (; M !== 0 && x < w.length; x++) y = (w.words[x] | 0) + M, this.words[x] = y & 67108863, M = y >>> 26;
      if (this.length = w.length, M !== 0) this.words[this.length] = M, this.length++;
      else if (w !== this) for (; x < w.length; x++) this.words[x] = w.words[x];
      return this;
    }, i.prototype.add = function(d) {
      var y;
      return d.negative !== 0 && this.negative === 0 ? (d.negative = 0, y = this.sub(d), d.negative ^= 1, y) : d.negative === 0 && this.negative !== 0 ? (this.negative = 0, y = d.sub(this), this.negative = 1, y) : this.length > d.length ? this.clone().iadd(d) : d.clone().iadd(this);
    }, i.prototype.isub = function(d) {
      if (d.negative !== 0) {
        d.negative = 0;
        var y = this.iadd(d);
        return d.negative = 1, y._normSign();
      } else if (this.negative !== 0) return this.negative = 0, this.iadd(d), this.negative = 1, this._normSign();
      var w = this.cmp(d);
      if (w === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var E, M;
      w > 0 ? (E = this, M = d) : (E = d, M = this);
      for (var x = 0, g = 0; g < M.length; g++) y = (E.words[g] | 0) - (M.words[g] | 0) + x, x = y >> 26, this.words[g] = y & 67108863;
      for (; x !== 0 && g < E.length; g++) y = (E.words[g] | 0) + x, x = y >> 26, this.words[g] = y & 67108863;
      if (x === 0 && g < E.length && E !== this) for (; g < E.length; g++) this.words[g] = E.words[g];
      return this.length = Math.max(this.length, g), E !== this && (this.negative = 1), this._strip();
    }, i.prototype.sub = function(d) {
      return this.clone().isub(d);
    };
    function C(p, d, y) {
      y.negative = d.negative ^ p.negative;
      var w = p.length + d.length | 0;
      y.length = w, w = w - 1 | 0;
      var E = p.words[0] | 0, M = d.words[0] | 0, x = E * M, g = x & 67108863, k = x / 67108864 | 0;
      y.words[0] = g;
      for (var T = 1; T < w; T++) {
        for (var O = k >>> 26, K = k & 67108863, Y = Math.min(T, d.length - 1), J = Math.max(0, T - p.length + 1); J <= Y; J++) {
          var G = T - J | 0;
          E = p.words[G] | 0, M = d.words[J] | 0, x = E * M + K, O += x / 67108864 | 0, K = x & 67108863;
        }
        y.words[T] = K | 0, k = O | 0;
      }
      return k !== 0 ? y.words[T] = k | 0 : y.length--, y._strip();
    }
    var I = function(d, y, w) {
      var E = d.words, M = y.words, x = w.words, g = 0, k, T, O, K = E[0] | 0, Y = K & 8191, J = K >>> 13, G = E[1] | 0, X = G & 8191, ie = G >>> 13, de = E[2] | 0, se = de & 8191, te = de >>> 13, le = E[3] | 0, Z = le & 8191, ve = le >>> 13, he = E[4] | 0, me = he & 8191, ce = he >>> 13, ye = E[5] | 0, Oe = ye & 8191, Se = ye >>> 13, Ce = E[6] | 0, Ne = Ce & 8191, $e = Ce >>> 13, Re = E[7] | 0, Ge = Re & 8191, Fe = Re >>> 13, Ue = E[8] | 0, kt = Ue & 8191, pe = Ue >>> 13, re = E[9] | 0, ue = re & 8191, xe = re >>> 13, Me = M[0] | 0, We = Me & 8191, De = Me >>> 13, je = M[1] | 0, ir = je & 8191, Xe = je >>> 13, st = M[2] | 0, Vt = st & 8191, at = st >>> 13, ht = M[3] | 0, br = ht & 8191, ot = ht >>> 13, ct = M[4] | 0, _r = ct & 8191, ft = ct >>> 13, pt = M[5] | 0, Cr = pt & 8191, nt = pt >>> 13, lt = M[6] | 0, ge = lt & 8191, be = lt >>> 13, Ae = M[7] | 0, ne = Ae & 8191, _e = Ae >>> 13, Te = M[8] | 0, Ye = Te & 8191, Pe = Te >>> 13, He = M[9] | 0, _t = He & 8191, vt = He >>> 13;
      w.negative = d.negative ^ y.negative, w.length = 19, k = Math.imul(Y, We), T = Math.imul(Y, De), T = T + Math.imul(J, We) | 0, O = Math.imul(J, De);
      var cr = (g + k | 0) + ((T & 8191) << 13) | 0;
      g = (O + (T >>> 13) | 0) + (cr >>> 26) | 0, cr &= 67108863, k = Math.imul(X, We), T = Math.imul(X, De), T = T + Math.imul(ie, We) | 0, O = Math.imul(ie, De), k = k + Math.imul(Y, ir) | 0, T = T + Math.imul(Y, Xe) | 0, T = T + Math.imul(J, ir) | 0, O = O + Math.imul(J, Xe) | 0;
      var Tt = (g + k | 0) + ((T & 8191) << 13) | 0;
      g = (O + (T >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, k = Math.imul(se, We), T = Math.imul(se, De), T = T + Math.imul(te, We) | 0, O = Math.imul(te, De), k = k + Math.imul(X, ir) | 0, T = T + Math.imul(X, Xe) | 0, T = T + Math.imul(ie, ir) | 0, O = O + Math.imul(ie, Xe) | 0, k = k + Math.imul(Y, Vt) | 0, T = T + Math.imul(Y, at) | 0, T = T + Math.imul(J, Vt) | 0, O = O + Math.imul(J, at) | 0;
      var Gt = (g + k | 0) + ((T & 8191) << 13) | 0;
      g = (O + (T >>> 13) | 0) + (Gt >>> 26) | 0, Gt &= 67108863, k = Math.imul(Z, We), T = Math.imul(Z, De), T = T + Math.imul(ve, We) | 0, O = Math.imul(ve, De), k = k + Math.imul(se, ir) | 0, T = T + Math.imul(se, Xe) | 0, T = T + Math.imul(te, ir) | 0, O = O + Math.imul(te, Xe) | 0, k = k + Math.imul(X, Vt) | 0, T = T + Math.imul(X, at) | 0, T = T + Math.imul(ie, Vt) | 0, O = O + Math.imul(ie, at) | 0, k = k + Math.imul(Y, br) | 0, T = T + Math.imul(Y, ot) | 0, T = T + Math.imul(J, br) | 0, O = O + Math.imul(J, ot) | 0;
      var Yt = (g + k | 0) + ((T & 8191) << 13) | 0;
      g = (O + (T >>> 13) | 0) + (Yt >>> 26) | 0, Yt &= 67108863, k = Math.imul(me, We), T = Math.imul(me, De), T = T + Math.imul(ce, We) | 0, O = Math.imul(ce, De), k = k + Math.imul(Z, ir) | 0, T = T + Math.imul(Z, Xe) | 0, T = T + Math.imul(ve, ir) | 0, O = O + Math.imul(ve, Xe) | 0, k = k + Math.imul(se, Vt) | 0, T = T + Math.imul(se, at) | 0, T = T + Math.imul(te, Vt) | 0, O = O + Math.imul(te, at) | 0, k = k + Math.imul(X, br) | 0, T = T + Math.imul(X, ot) | 0, T = T + Math.imul(ie, br) | 0, O = O + Math.imul(ie, ot) | 0, k = k + Math.imul(Y, _r) | 0, T = T + Math.imul(Y, ft) | 0, T = T + Math.imul(J, _r) | 0, O = O + Math.imul(J, ft) | 0;
      var or = (g + k | 0) + ((T & 8191) << 13) | 0;
      g = (O + (T >>> 13) | 0) + (or >>> 26) | 0, or &= 67108863, k = Math.imul(Oe, We), T = Math.imul(Oe, De), T = T + Math.imul(Se, We) | 0, O = Math.imul(Se, De), k = k + Math.imul(me, ir) | 0, T = T + Math.imul(me, Xe) | 0, T = T + Math.imul(ce, ir) | 0, O = O + Math.imul(ce, Xe) | 0, k = k + Math.imul(Z, Vt) | 0, T = T + Math.imul(Z, at) | 0, T = T + Math.imul(ve, Vt) | 0, O = O + Math.imul(ve, at) | 0, k = k + Math.imul(se, br) | 0, T = T + Math.imul(se, ot) | 0, T = T + Math.imul(te, br) | 0, O = O + Math.imul(te, ot) | 0, k = k + Math.imul(X, _r) | 0, T = T + Math.imul(X, ft) | 0, T = T + Math.imul(ie, _r) | 0, O = O + Math.imul(ie, ft) | 0, k = k + Math.imul(Y, Cr) | 0, T = T + Math.imul(Y, nt) | 0, T = T + Math.imul(J, Cr) | 0, O = O + Math.imul(J, nt) | 0;
      var sr = (g + k | 0) + ((T & 8191) << 13) | 0;
      g = (O + (T >>> 13) | 0) + (sr >>> 26) | 0, sr &= 67108863, k = Math.imul(Ne, We), T = Math.imul(Ne, De), T = T + Math.imul($e, We) | 0, O = Math.imul($e, De), k = k + Math.imul(Oe, ir) | 0, T = T + Math.imul(Oe, Xe) | 0, T = T + Math.imul(Se, ir) | 0, O = O + Math.imul(Se, Xe) | 0, k = k + Math.imul(me, Vt) | 0, T = T + Math.imul(me, at) | 0, T = T + Math.imul(ce, Vt) | 0, O = O + Math.imul(ce, at) | 0, k = k + Math.imul(Z, br) | 0, T = T + Math.imul(Z, ot) | 0, T = T + Math.imul(ve, br) | 0, O = O + Math.imul(ve, ot) | 0, k = k + Math.imul(se, _r) | 0, T = T + Math.imul(se, ft) | 0, T = T + Math.imul(te, _r) | 0, O = O + Math.imul(te, ft) | 0, k = k + Math.imul(X, Cr) | 0, T = T + Math.imul(X, nt) | 0, T = T + Math.imul(ie, Cr) | 0, O = O + Math.imul(ie, nt) | 0, k = k + Math.imul(Y, ge) | 0, T = T + Math.imul(Y, be) | 0, T = T + Math.imul(J, ge) | 0, O = O + Math.imul(J, be) | 0;
      var Wt = (g + k | 0) + ((T & 8191) << 13) | 0;
      g = (O + (T >>> 13) | 0) + (Wt >>> 26) | 0, Wt &= 67108863, k = Math.imul(Ge, We), T = Math.imul(Ge, De), T = T + Math.imul(Fe, We) | 0, O = Math.imul(Fe, De), k = k + Math.imul(Ne, ir) | 0, T = T + Math.imul(Ne, Xe) | 0, T = T + Math.imul($e, ir) | 0, O = O + Math.imul($e, Xe) | 0, k = k + Math.imul(Oe, Vt) | 0, T = T + Math.imul(Oe, at) | 0, T = T + Math.imul(Se, Vt) | 0, O = O + Math.imul(Se, at) | 0, k = k + Math.imul(me, br) | 0, T = T + Math.imul(me, ot) | 0, T = T + Math.imul(ce, br) | 0, O = O + Math.imul(ce, ot) | 0, k = k + Math.imul(Z, _r) | 0, T = T + Math.imul(Z, ft) | 0, T = T + Math.imul(ve, _r) | 0, O = O + Math.imul(ve, ft) | 0, k = k + Math.imul(se, Cr) | 0, T = T + Math.imul(se, nt) | 0, T = T + Math.imul(te, Cr) | 0, O = O + Math.imul(te, nt) | 0, k = k + Math.imul(X, ge) | 0, T = T + Math.imul(X, be) | 0, T = T + Math.imul(ie, ge) | 0, O = O + Math.imul(ie, be) | 0, k = k + Math.imul(Y, ne) | 0, T = T + Math.imul(Y, _e) | 0, T = T + Math.imul(J, ne) | 0, O = O + Math.imul(J, _e) | 0;
      var tr = (g + k | 0) + ((T & 8191) << 13) | 0;
      g = (O + (T >>> 13) | 0) + (tr >>> 26) | 0, tr &= 67108863, k = Math.imul(kt, We), T = Math.imul(kt, De), T = T + Math.imul(pe, We) | 0, O = Math.imul(pe, De), k = k + Math.imul(Ge, ir) | 0, T = T + Math.imul(Ge, Xe) | 0, T = T + Math.imul(Fe, ir) | 0, O = O + Math.imul(Fe, Xe) | 0, k = k + Math.imul(Ne, Vt) | 0, T = T + Math.imul(Ne, at) | 0, T = T + Math.imul($e, Vt) | 0, O = O + Math.imul($e, at) | 0, k = k + Math.imul(Oe, br) | 0, T = T + Math.imul(Oe, ot) | 0, T = T + Math.imul(Se, br) | 0, O = O + Math.imul(Se, ot) | 0, k = k + Math.imul(me, _r) | 0, T = T + Math.imul(me, ft) | 0, T = T + Math.imul(ce, _r) | 0, O = O + Math.imul(ce, ft) | 0, k = k + Math.imul(Z, Cr) | 0, T = T + Math.imul(Z, nt) | 0, T = T + Math.imul(ve, Cr) | 0, O = O + Math.imul(ve, nt) | 0, k = k + Math.imul(se, ge) | 0, T = T + Math.imul(se, be) | 0, T = T + Math.imul(te, ge) | 0, O = O + Math.imul(te, be) | 0, k = k + Math.imul(X, ne) | 0, T = T + Math.imul(X, _e) | 0, T = T + Math.imul(ie, ne) | 0, O = O + Math.imul(ie, _e) | 0, k = k + Math.imul(Y, Ye) | 0, T = T + Math.imul(Y, Pe) | 0, T = T + Math.imul(J, Ye) | 0, O = O + Math.imul(J, Pe) | 0;
      var Jt = (g + k | 0) + ((T & 8191) << 13) | 0;
      g = (O + (T >>> 13) | 0) + (Jt >>> 26) | 0, Jt &= 67108863, k = Math.imul(ue, We), T = Math.imul(ue, De), T = T + Math.imul(xe, We) | 0, O = Math.imul(xe, De), k = k + Math.imul(kt, ir) | 0, T = T + Math.imul(kt, Xe) | 0, T = T + Math.imul(pe, ir) | 0, O = O + Math.imul(pe, Xe) | 0, k = k + Math.imul(Ge, Vt) | 0, T = T + Math.imul(Ge, at) | 0, T = T + Math.imul(Fe, Vt) | 0, O = O + Math.imul(Fe, at) | 0, k = k + Math.imul(Ne, br) | 0, T = T + Math.imul(Ne, ot) | 0, T = T + Math.imul($e, br) | 0, O = O + Math.imul($e, ot) | 0, k = k + Math.imul(Oe, _r) | 0, T = T + Math.imul(Oe, ft) | 0, T = T + Math.imul(Se, _r) | 0, O = O + Math.imul(Se, ft) | 0, k = k + Math.imul(me, Cr) | 0, T = T + Math.imul(me, nt) | 0, T = T + Math.imul(ce, Cr) | 0, O = O + Math.imul(ce, nt) | 0, k = k + Math.imul(Z, ge) | 0, T = T + Math.imul(Z, be) | 0, T = T + Math.imul(ve, ge) | 0, O = O + Math.imul(ve, be) | 0, k = k + Math.imul(se, ne) | 0, T = T + Math.imul(se, _e) | 0, T = T + Math.imul(te, ne) | 0, O = O + Math.imul(te, _e) | 0, k = k + Math.imul(X, Ye) | 0, T = T + Math.imul(X, Pe) | 0, T = T + Math.imul(ie, Ye) | 0, O = O + Math.imul(ie, Pe) | 0, k = k + Math.imul(Y, _t) | 0, T = T + Math.imul(Y, vt) | 0, T = T + Math.imul(J, _t) | 0, O = O + Math.imul(J, vt) | 0;
      var Ft = (g + k | 0) + ((T & 8191) << 13) | 0;
      g = (O + (T >>> 13) | 0) + (Ft >>> 26) | 0, Ft &= 67108863, k = Math.imul(ue, ir), T = Math.imul(ue, Xe), T = T + Math.imul(xe, ir) | 0, O = Math.imul(xe, Xe), k = k + Math.imul(kt, Vt) | 0, T = T + Math.imul(kt, at) | 0, T = T + Math.imul(pe, Vt) | 0, O = O + Math.imul(pe, at) | 0, k = k + Math.imul(Ge, br) | 0, T = T + Math.imul(Ge, ot) | 0, T = T + Math.imul(Fe, br) | 0, O = O + Math.imul(Fe, ot) | 0, k = k + Math.imul(Ne, _r) | 0, T = T + Math.imul(Ne, ft) | 0, T = T + Math.imul($e, _r) | 0, O = O + Math.imul($e, ft) | 0, k = k + Math.imul(Oe, Cr) | 0, T = T + Math.imul(Oe, nt) | 0, T = T + Math.imul(Se, Cr) | 0, O = O + Math.imul(Se, nt) | 0, k = k + Math.imul(me, ge) | 0, T = T + Math.imul(me, be) | 0, T = T + Math.imul(ce, ge) | 0, O = O + Math.imul(ce, be) | 0, k = k + Math.imul(Z, ne) | 0, T = T + Math.imul(Z, _e) | 0, T = T + Math.imul(ve, ne) | 0, O = O + Math.imul(ve, _e) | 0, k = k + Math.imul(se, Ye) | 0, T = T + Math.imul(se, Pe) | 0, T = T + Math.imul(te, Ye) | 0, O = O + Math.imul(te, Pe) | 0, k = k + Math.imul(X, _t) | 0, T = T + Math.imul(X, vt) | 0, T = T + Math.imul(ie, _t) | 0, O = O + Math.imul(ie, vt) | 0;
      var Ut = (g + k | 0) + ((T & 8191) << 13) | 0;
      g = (O + (T >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, k = Math.imul(ue, Vt), T = Math.imul(ue, at), T = T + Math.imul(xe, Vt) | 0, O = Math.imul(xe, at), k = k + Math.imul(kt, br) | 0, T = T + Math.imul(kt, ot) | 0, T = T + Math.imul(pe, br) | 0, O = O + Math.imul(pe, ot) | 0, k = k + Math.imul(Ge, _r) | 0, T = T + Math.imul(Ge, ft) | 0, T = T + Math.imul(Fe, _r) | 0, O = O + Math.imul(Fe, ft) | 0, k = k + Math.imul(Ne, Cr) | 0, T = T + Math.imul(Ne, nt) | 0, T = T + Math.imul($e, Cr) | 0, O = O + Math.imul($e, nt) | 0, k = k + Math.imul(Oe, ge) | 0, T = T + Math.imul(Oe, be) | 0, T = T + Math.imul(Se, ge) | 0, O = O + Math.imul(Se, be) | 0, k = k + Math.imul(me, ne) | 0, T = T + Math.imul(me, _e) | 0, T = T + Math.imul(ce, ne) | 0, O = O + Math.imul(ce, _e) | 0, k = k + Math.imul(Z, Ye) | 0, T = T + Math.imul(Z, Pe) | 0, T = T + Math.imul(ve, Ye) | 0, O = O + Math.imul(ve, Pe) | 0, k = k + Math.imul(se, _t) | 0, T = T + Math.imul(se, vt) | 0, T = T + Math.imul(te, _t) | 0, O = O + Math.imul(te, vt) | 0;
      var Mt = (g + k | 0) + ((T & 8191) << 13) | 0;
      g = (O + (T >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, k = Math.imul(ue, br), T = Math.imul(ue, ot), T = T + Math.imul(xe, br) | 0, O = Math.imul(xe, ot), k = k + Math.imul(kt, _r) | 0, T = T + Math.imul(kt, ft) | 0, T = T + Math.imul(pe, _r) | 0, O = O + Math.imul(pe, ft) | 0, k = k + Math.imul(Ge, Cr) | 0, T = T + Math.imul(Ge, nt) | 0, T = T + Math.imul(Fe, Cr) | 0, O = O + Math.imul(Fe, nt) | 0, k = k + Math.imul(Ne, ge) | 0, T = T + Math.imul(Ne, be) | 0, T = T + Math.imul($e, ge) | 0, O = O + Math.imul($e, be) | 0, k = k + Math.imul(Oe, ne) | 0, T = T + Math.imul(Oe, _e) | 0, T = T + Math.imul(Se, ne) | 0, O = O + Math.imul(Se, _e) | 0, k = k + Math.imul(me, Ye) | 0, T = T + Math.imul(me, Pe) | 0, T = T + Math.imul(ce, Ye) | 0, O = O + Math.imul(ce, Pe) | 0, k = k + Math.imul(Z, _t) | 0, T = T + Math.imul(Z, vt) | 0, T = T + Math.imul(ve, _t) | 0, O = O + Math.imul(ve, vt) | 0;
      var Pt = (g + k | 0) + ((T & 8191) << 13) | 0;
      g = (O + (T >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, k = Math.imul(ue, _r), T = Math.imul(ue, ft), T = T + Math.imul(xe, _r) | 0, O = Math.imul(xe, ft), k = k + Math.imul(kt, Cr) | 0, T = T + Math.imul(kt, nt) | 0, T = T + Math.imul(pe, Cr) | 0, O = O + Math.imul(pe, nt) | 0, k = k + Math.imul(Ge, ge) | 0, T = T + Math.imul(Ge, be) | 0, T = T + Math.imul(Fe, ge) | 0, O = O + Math.imul(Fe, be) | 0, k = k + Math.imul(Ne, ne) | 0, T = T + Math.imul(Ne, _e) | 0, T = T + Math.imul($e, ne) | 0, O = O + Math.imul($e, _e) | 0, k = k + Math.imul(Oe, Ye) | 0, T = T + Math.imul(Oe, Pe) | 0, T = T + Math.imul(Se, Ye) | 0, O = O + Math.imul(Se, Pe) | 0, k = k + Math.imul(me, _t) | 0, T = T + Math.imul(me, vt) | 0, T = T + Math.imul(ce, _t) | 0, O = O + Math.imul(ce, vt) | 0;
      var Nt = (g + k | 0) + ((T & 8191) << 13) | 0;
      g = (O + (T >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, k = Math.imul(ue, Cr), T = Math.imul(ue, nt), T = T + Math.imul(xe, Cr) | 0, O = Math.imul(xe, nt), k = k + Math.imul(kt, ge) | 0, T = T + Math.imul(kt, be) | 0, T = T + Math.imul(pe, ge) | 0, O = O + Math.imul(pe, be) | 0, k = k + Math.imul(Ge, ne) | 0, T = T + Math.imul(Ge, _e) | 0, T = T + Math.imul(Fe, ne) | 0, O = O + Math.imul(Fe, _e) | 0, k = k + Math.imul(Ne, Ye) | 0, T = T + Math.imul(Ne, Pe) | 0, T = T + Math.imul($e, Ye) | 0, O = O + Math.imul($e, Pe) | 0, k = k + Math.imul(Oe, _t) | 0, T = T + Math.imul(Oe, vt) | 0, T = T + Math.imul(Se, _t) | 0, O = O + Math.imul(Se, vt) | 0;
      var It = (g + k | 0) + ((T & 8191) << 13) | 0;
      g = (O + (T >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, k = Math.imul(ue, ge), T = Math.imul(ue, be), T = T + Math.imul(xe, ge) | 0, O = Math.imul(xe, be), k = k + Math.imul(kt, ne) | 0, T = T + Math.imul(kt, _e) | 0, T = T + Math.imul(pe, ne) | 0, O = O + Math.imul(pe, _e) | 0, k = k + Math.imul(Ge, Ye) | 0, T = T + Math.imul(Ge, Pe) | 0, T = T + Math.imul(Fe, Ye) | 0, O = O + Math.imul(Fe, Pe) | 0, k = k + Math.imul(Ne, _t) | 0, T = T + Math.imul(Ne, vt) | 0, T = T + Math.imul($e, _t) | 0, O = O + Math.imul($e, vt) | 0;
      var tt = (g + k | 0) + ((T & 8191) << 13) | 0;
      g = (O + (T >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, k = Math.imul(ue, ne), T = Math.imul(ue, _e), T = T + Math.imul(xe, ne) | 0, O = Math.imul(xe, _e), k = k + Math.imul(kt, Ye) | 0, T = T + Math.imul(kt, Pe) | 0, T = T + Math.imul(pe, Ye) | 0, O = O + Math.imul(pe, Pe) | 0, k = k + Math.imul(Ge, _t) | 0, T = T + Math.imul(Ge, vt) | 0, T = T + Math.imul(Fe, _t) | 0, O = O + Math.imul(Fe, vt) | 0;
      var rt = (g + k | 0) + ((T & 8191) << 13) | 0;
      g = (O + (T >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, k = Math.imul(ue, Ye), T = Math.imul(ue, Pe), T = T + Math.imul(xe, Ye) | 0, O = Math.imul(xe, Pe), k = k + Math.imul(kt, _t) | 0, T = T + Math.imul(kt, vt) | 0, T = T + Math.imul(pe, _t) | 0, O = O + Math.imul(pe, vt) | 0;
      var Et = (g + k | 0) + ((T & 8191) << 13) | 0;
      g = (O + (T >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, k = Math.imul(ue, _t), T = Math.imul(ue, vt), T = T + Math.imul(xe, _t) | 0, O = Math.imul(xe, vt);
      var yt = (g + k | 0) + ((T & 8191) << 13) | 0;
      return g = (O + (T >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, x[0] = cr, x[1] = Tt, x[2] = Gt, x[3] = Yt, x[4] = or, x[5] = sr, x[6] = Wt, x[7] = tr, x[8] = Jt, x[9] = Ft, x[10] = Ut, x[11] = Mt, x[12] = Pt, x[13] = Nt, x[14] = It, x[15] = tt, x[16] = rt, x[17] = Et, x[18] = yt, g !== 0 && (x[19] = g, w.length++), w;
    };
    Math.imul || (I = C);
    function S(p, d, y) {
      y.negative = d.negative ^ p.negative, y.length = p.length + d.length;
      for (var w = 0, E = 0, M = 0; M < y.length - 1; M++) {
        var x = E;
        E = 0;
        for (var g = w & 67108863, k = Math.min(M, d.length - 1), T = Math.max(0, M - p.length + 1); T <= k; T++) {
          var O = M - T, K = p.words[O] | 0, Y = d.words[T] | 0, J = K * Y, G = J & 67108863;
          x = x + (J / 67108864 | 0) | 0, G = G + g | 0, g = G & 67108863, x = x + (G >>> 26) | 0, E += x >>> 26, x &= 67108863;
        }
        y.words[M] = g, w = x, x = E;
      }
      return w !== 0 ? y.words[M] = w : y.length--, y._strip();
    }
    function $(p, d, y) {
      return S(p, d, y);
    }
    i.prototype.mulTo = function(d, y) {
      var w, E = this.length + d.length;
      return this.length === 10 && d.length === 10 ? w = I(this, d, y) : E < 63 ? w = C(this, d, y) : E < 1024 ? w = S(this, d, y) : w = $(this, d, y), w;
    }, i.prototype.mul = function(d) {
      var y = new i(null);
      return y.words = new Array(this.length + d.length), this.mulTo(d, y);
    }, i.prototype.mulf = function(d) {
      var y = new i(null);
      return y.words = new Array(this.length + d.length), $(this, d, y);
    }, i.prototype.imul = function(d) {
      return this.clone().mulTo(d, this);
    }, i.prototype.imuln = function(d) {
      var y = d < 0;
      y && (d = -d), r(typeof d == "number"), r(d < 67108864);
      for (var w = 0, E = 0; E < this.length; E++) {
        var M = (this.words[E] | 0) * d, x = (M & 67108863) + (w & 67108863);
        w >>= 26, w += M / 67108864 | 0, w += x >>> 26, this.words[E] = x & 67108863;
      }
      return w !== 0 && (this.words[E] = w, this.length++), this.length = d === 0 ? 1 : this.length, y ? this.ineg() : this;
    }, i.prototype.muln = function(d) {
      return this.clone().imuln(d);
    }, i.prototype.sqr = function() {
      return this.mul(this);
    }, i.prototype.isqr = function() {
      return this.imul(this.clone());
    }, i.prototype.pow = function(d) {
      var y = _(d);
      if (y.length === 0) return new i(1);
      for (var w = this, E = 0; E < y.length && y[E] === 0; E++, w = w.sqr()) ;
      if (++E < y.length) for (var M = w.sqr(); E < y.length; E++, M = M.sqr()) y[E] !== 0 && (w = w.mul(M));
      return w;
    }, i.prototype.iushln = function(d) {
      r(typeof d == "number" && d >= 0);
      var y = d % 26, w = (d - y) / 26, E = 67108863 >>> 26 - y << 26 - y, M;
      if (y !== 0) {
        var x = 0;
        for (M = 0; M < this.length; M++) {
          var g = this.words[M] & E, k = (this.words[M] | 0) - g << y;
          this.words[M] = k | x, x = g >>> 26 - y;
        }
        x && (this.words[M] = x, this.length++);
      }
      if (w !== 0) {
        for (M = this.length - 1; M >= 0; M--) this.words[M + w] = this.words[M];
        for (M = 0; M < w; M++) this.words[M] = 0;
        this.length += w;
      }
      return this._strip();
    }, i.prototype.ishln = function(d) {
      return r(this.negative === 0), this.iushln(d);
    }, i.prototype.iushrn = function(d, y, w) {
      r(typeof d == "number" && d >= 0);
      var E;
      y ? E = (y - y % 26) / 26 : E = 0;
      var M = d % 26, x = Math.min((d - M) / 26, this.length), g = 67108863 ^ 67108863 >>> M << M, k = w;
      if (E -= x, E = Math.max(0, E), k) {
        for (var T = 0; T < x; T++) k.words[T] = this.words[T];
        k.length = x;
      }
      if (x !== 0) if (this.length > x) for (this.length -= x, T = 0; T < this.length; T++) this.words[T] = this.words[T + x];
      else this.words[0] = 0, this.length = 1;
      var O = 0;
      for (T = this.length - 1; T >= 0 && (O !== 0 || T >= E); T--) {
        var K = this.words[T] | 0;
        this.words[T] = O << 26 - M | K >>> M, O = K & g;
      }
      return k && O !== 0 && (k.words[k.length++] = O), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, i.prototype.ishrn = function(d, y, w) {
      return r(this.negative === 0), this.iushrn(d, y, w);
    }, i.prototype.shln = function(d) {
      return this.clone().ishln(d);
    }, i.prototype.ushln = function(d) {
      return this.clone().iushln(d);
    }, i.prototype.shrn = function(d) {
      return this.clone().ishrn(d);
    }, i.prototype.ushrn = function(d) {
      return this.clone().iushrn(d);
    }, i.prototype.testn = function(d) {
      r(typeof d == "number" && d >= 0);
      var y = d % 26, w = (d - y) / 26, E = 1 << y;
      if (this.length <= w) return false;
      var M = this.words[w];
      return !!(M & E);
    }, i.prototype.imaskn = function(d) {
      r(typeof d == "number" && d >= 0);
      var y = d % 26, w = (d - y) / 26;
      if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= w) return this;
      if (y !== 0 && w++, this.length = Math.min(w, this.length), y !== 0) {
        var E = 67108863 ^ 67108863 >>> y << y;
        this.words[this.length - 1] &= E;
      }
      return this._strip();
    }, i.prototype.maskn = function(d) {
      return this.clone().imaskn(d);
    }, i.prototype.iaddn = function(d) {
      return r(typeof d == "number"), r(d < 67108864), d < 0 ? this.isubn(-d) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= d ? (this.words[0] = d - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(d), this.negative = 1, this) : this._iaddn(d);
    }, i.prototype._iaddn = function(d) {
      this.words[0] += d;
      for (var y = 0; y < this.length && this.words[y] >= 67108864; y++) this.words[y] -= 67108864, y === this.length - 1 ? this.words[y + 1] = 1 : this.words[y + 1]++;
      return this.length = Math.max(this.length, y + 1), this;
    }, i.prototype.isubn = function(d) {
      if (r(typeof d == "number"), r(d < 67108864), d < 0) return this.iaddn(-d);
      if (this.negative !== 0) return this.negative = 0, this.iaddn(d), this.negative = 1, this;
      if (this.words[0] -= d, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
      else for (var y = 0; y < this.length && this.words[y] < 0; y++) this.words[y] += 67108864, this.words[y + 1] -= 1;
      return this._strip();
    }, i.prototype.addn = function(d) {
      return this.clone().iaddn(d);
    }, i.prototype.subn = function(d) {
      return this.clone().isubn(d);
    }, i.prototype.iabs = function() {
      return this.negative = 0, this;
    }, i.prototype.abs = function() {
      return this.clone().iabs();
    }, i.prototype._ishlnsubmul = function(d, y, w) {
      var E = d.length + w, M;
      this._expand(E);
      var x, g = 0;
      for (M = 0; M < d.length; M++) {
        x = (this.words[M + w] | 0) + g;
        var k = (d.words[M] | 0) * y;
        x -= k & 67108863, g = (x >> 26) - (k / 67108864 | 0), this.words[M + w] = x & 67108863;
      }
      for (; M < this.length - w; M++) x = (this.words[M + w] | 0) + g, g = x >> 26, this.words[M + w] = x & 67108863;
      if (g === 0) return this._strip();
      for (r(g === -1), g = 0, M = 0; M < this.length; M++) x = -(this.words[M] | 0) + g, g = x >> 26, this.words[M] = x & 67108863;
      return this.negative = 1, this._strip();
    }, i.prototype._wordDiv = function(d, y) {
      var w = this.length - d.length, E = this.clone(), M = d, x = M.words[M.length - 1] | 0, g = this._countBits(x);
      w = 26 - g, w !== 0 && (M = M.ushln(w), E.iushln(w), x = M.words[M.length - 1] | 0);
      var k = E.length - M.length, T;
      if (y !== "mod") {
        T = new i(null), T.length = k + 1, T.words = new Array(T.length);
        for (var O = 0; O < T.length; O++) T.words[O] = 0;
      }
      var K = E.clone()._ishlnsubmul(M, 1, k);
      K.negative === 0 && (E = K, T && (T.words[k] = 1));
      for (var Y = k - 1; Y >= 0; Y--) {
        var J = (E.words[M.length + Y] | 0) * 67108864 + (E.words[M.length + Y - 1] | 0);
        for (J = Math.min(J / x | 0, 67108863), E._ishlnsubmul(M, J, Y); E.negative !== 0; ) J--, E.negative = 0, E._ishlnsubmul(M, 1, Y), E.isZero() || (E.negative ^= 1);
        T && (T.words[Y] = J);
      }
      return T && T._strip(), E._strip(), y !== "div" && w !== 0 && E.iushrn(w), { div: T || null, mod: E };
    }, i.prototype.divmod = function(d, y, w) {
      if (r(!d.isZero()), this.isZero()) return { div: new i(0), mod: new i(0) };
      var E, M, x;
      return this.negative !== 0 && d.negative === 0 ? (x = this.neg().divmod(d, y), y !== "mod" && (E = x.div.neg()), y !== "div" && (M = x.mod.neg(), w && M.negative !== 0 && M.iadd(d)), { div: E, mod: M }) : this.negative === 0 && d.negative !== 0 ? (x = this.divmod(d.neg(), y), y !== "mod" && (E = x.div.neg()), { div: E, mod: x.mod }) : this.negative & d.negative ? (x = this.neg().divmod(d.neg(), y), y !== "div" && (M = x.mod.neg(), w && M.negative !== 0 && M.isub(d)), { div: x.div, mod: M }) : d.length > this.length || this.cmp(d) < 0 ? { div: new i(0), mod: this } : d.length === 1 ? y === "div" ? { div: this.divn(d.words[0]), mod: null } : y === "mod" ? { div: null, mod: new i(this.modrn(d.words[0])) } : { div: this.divn(d.words[0]), mod: new i(this.modrn(d.words[0])) } : this._wordDiv(d, y);
    }, i.prototype.div = function(d) {
      return this.divmod(d, "div", false).div;
    }, i.prototype.mod = function(d) {
      return this.divmod(d, "mod", false).mod;
    }, i.prototype.umod = function(d) {
      return this.divmod(d, "mod", true).mod;
    }, i.prototype.divRound = function(d) {
      var y = this.divmod(d);
      if (y.mod.isZero()) return y.div;
      var w = y.div.negative !== 0 ? y.mod.isub(d) : y.mod, E = d.ushrn(1), M = d.andln(1), x = w.cmp(E);
      return x < 0 || M === 1 && x === 0 ? y.div : y.div.negative !== 0 ? y.div.isubn(1) : y.div.iaddn(1);
    }, i.prototype.modrn = function(d) {
      var y = d < 0;
      y && (d = -d), r(d <= 67108863);
      for (var w = (1 << 26) % d, E = 0, M = this.length - 1; M >= 0; M--) E = (w * E + (this.words[M] | 0)) % d;
      return y ? -E : E;
    }, i.prototype.modn = function(d) {
      return this.modrn(d);
    }, i.prototype.idivn = function(d) {
      var y = d < 0;
      y && (d = -d), r(d <= 67108863);
      for (var w = 0, E = this.length - 1; E >= 0; E--) {
        var M = (this.words[E] | 0) + w * 67108864;
        this.words[E] = M / d | 0, w = M % d;
      }
      return this._strip(), y ? this.ineg() : this;
    }, i.prototype.divn = function(d) {
      return this.clone().idivn(d);
    }, i.prototype.egcd = function(d) {
      r(d.negative === 0), r(!d.isZero());
      var y = this, w = d.clone();
      y.negative !== 0 ? y = y.umod(d) : y = y.clone();
      for (var E = new i(1), M = new i(0), x = new i(0), g = new i(1), k = 0; y.isEven() && w.isEven(); ) y.iushrn(1), w.iushrn(1), ++k;
      for (var T = w.clone(), O = y.clone(); !y.isZero(); ) {
        for (var K = 0, Y = 1; !(y.words[0] & Y) && K < 26; ++K, Y <<= 1) ;
        if (K > 0) for (y.iushrn(K); K-- > 0; ) (E.isOdd() || M.isOdd()) && (E.iadd(T), M.isub(O)), E.iushrn(1), M.iushrn(1);
        for (var J = 0, G = 1; !(w.words[0] & G) && J < 26; ++J, G <<= 1) ;
        if (J > 0) for (w.iushrn(J); J-- > 0; ) (x.isOdd() || g.isOdd()) && (x.iadd(T), g.isub(O)), x.iushrn(1), g.iushrn(1);
        y.cmp(w) >= 0 ? (y.isub(w), E.isub(x), M.isub(g)) : (w.isub(y), x.isub(E), g.isub(M));
      }
      return { a: x, b: g, gcd: w.iushln(k) };
    }, i.prototype._invmp = function(d) {
      r(d.negative === 0), r(!d.isZero());
      var y = this, w = d.clone();
      y.negative !== 0 ? y = y.umod(d) : y = y.clone();
      for (var E = new i(1), M = new i(0), x = w.clone(); y.cmpn(1) > 0 && w.cmpn(1) > 0; ) {
        for (var g = 0, k = 1; !(y.words[0] & k) && g < 26; ++g, k <<= 1) ;
        if (g > 0) for (y.iushrn(g); g-- > 0; ) E.isOdd() && E.iadd(x), E.iushrn(1);
        for (var T = 0, O = 1; !(w.words[0] & O) && T < 26; ++T, O <<= 1) ;
        if (T > 0) for (w.iushrn(T); T-- > 0; ) M.isOdd() && M.iadd(x), M.iushrn(1);
        y.cmp(w) >= 0 ? (y.isub(w), E.isub(M)) : (w.isub(y), M.isub(E));
      }
      var K;
      return y.cmpn(1) === 0 ? K = E : K = M, K.cmpn(0) < 0 && K.iadd(d), K;
    }, i.prototype.gcd = function(d) {
      if (this.isZero()) return d.abs();
      if (d.isZero()) return this.abs();
      var y = this.clone(), w = d.clone();
      y.negative = 0, w.negative = 0;
      for (var E = 0; y.isEven() && w.isEven(); E++) y.iushrn(1), w.iushrn(1);
      do {
        for (; y.isEven(); ) y.iushrn(1);
        for (; w.isEven(); ) w.iushrn(1);
        var M = y.cmp(w);
        if (M < 0) {
          var x = y;
          y = w, w = x;
        } else if (M === 0 || w.cmpn(1) === 0) break;
        y.isub(w);
      } while (true);
      return w.iushln(E);
    }, i.prototype.invm = function(d) {
      return this.egcd(d).a.umod(d);
    }, i.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, i.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, i.prototype.andln = function(d) {
      return this.words[0] & d;
    }, i.prototype.bincn = function(d) {
      r(typeof d == "number");
      var y = d % 26, w = (d - y) / 26, E = 1 << y;
      if (this.length <= w) return this._expand(w + 1), this.words[w] |= E, this;
      for (var M = E, x = w; M !== 0 && x < this.length; x++) {
        var g = this.words[x] | 0;
        g += M, M = g >>> 26, g &= 67108863, this.words[x] = g;
      }
      return M !== 0 && (this.words[x] = M, this.length++), this;
    }, i.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, i.prototype.cmpn = function(d) {
      var y = d < 0;
      if (this.negative !== 0 && !y) return -1;
      if (this.negative === 0 && y) return 1;
      this._strip();
      var w;
      if (this.length > 1) w = 1;
      else {
        y && (d = -d), r(d <= 67108863, "Number is too big");
        var E = this.words[0] | 0;
        w = E === d ? 0 : E < d ? -1 : 1;
      }
      return this.negative !== 0 ? -w | 0 : w;
    }, i.prototype.cmp = function(d) {
      if (this.negative !== 0 && d.negative === 0) return -1;
      if (this.negative === 0 && d.negative !== 0) return 1;
      var y = this.ucmp(d);
      return this.negative !== 0 ? -y | 0 : y;
    }, i.prototype.ucmp = function(d) {
      if (this.length > d.length) return 1;
      if (this.length < d.length) return -1;
      for (var y = 0, w = this.length - 1; w >= 0; w--) {
        var E = this.words[w] | 0, M = d.words[w] | 0;
        if (E !== M) {
          E < M ? y = -1 : E > M && (y = 1);
          break;
        }
      }
      return y;
    }, i.prototype.gtn = function(d) {
      return this.cmpn(d) === 1;
    }, i.prototype.gt = function(d) {
      return this.cmp(d) === 1;
    }, i.prototype.gten = function(d) {
      return this.cmpn(d) >= 0;
    }, i.prototype.gte = function(d) {
      return this.cmp(d) >= 0;
    }, i.prototype.ltn = function(d) {
      return this.cmpn(d) === -1;
    }, i.prototype.lt = function(d) {
      return this.cmp(d) === -1;
    }, i.prototype.lten = function(d) {
      return this.cmpn(d) <= 0;
    }, i.prototype.lte = function(d) {
      return this.cmp(d) <= 0;
    }, i.prototype.eqn = function(d) {
      return this.cmpn(d) === 0;
    }, i.prototype.eq = function(d) {
      return this.cmp(d) === 0;
    }, i.red = function(d) {
      return new B(d);
    }, i.prototype.toRed = function(d) {
      return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), d.convertTo(this)._forceRed(d);
    }, i.prototype.fromRed = function() {
      return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, i.prototype._forceRed = function(d) {
      return this.red = d, this;
    }, i.prototype.forceRed = function(d) {
      return r(!this.red, "Already a number in reduction context"), this._forceRed(d);
    }, i.prototype.redAdd = function(d) {
      return r(this.red, "redAdd works only with red numbers"), this.red.add(this, d);
    }, i.prototype.redIAdd = function(d) {
      return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, d);
    }, i.prototype.redSub = function(d) {
      return r(this.red, "redSub works only with red numbers"), this.red.sub(this, d);
    }, i.prototype.redISub = function(d) {
      return r(this.red, "redISub works only with red numbers"), this.red.isub(this, d);
    }, i.prototype.redShl = function(d) {
      return r(this.red, "redShl works only with red numbers"), this.red.shl(this, d);
    }, i.prototype.redMul = function(d) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, d), this.red.mul(this, d);
    }, i.prototype.redIMul = function(d) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, d), this.red.imul(this, d);
    }, i.prototype.redSqr = function() {
      return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, i.prototype.redISqr = function() {
      return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, i.prototype.redSqrt = function() {
      return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, i.prototype.redInvm = function() {
      return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, i.prototype.redNeg = function() {
      return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, i.prototype.redPow = function(d) {
      return r(this.red && !d.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, d);
    };
    var F = { k256: null, p224: null, p192: null, p25519: null };
    function U(p, d) {
      this.name = p, this.p = new i(d, 16), this.n = this.p.bitLength(), this.k = new i(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    U.prototype._tmp = function() {
      var d = new i(null);
      return d.words = new Array(Math.ceil(this.n / 13)), d;
    }, U.prototype.ireduce = function(d) {
      var y = d, w;
      do
        this.split(y, this.tmp), y = this.imulK(y), y = y.iadd(this.tmp), w = y.bitLength();
      while (w > this.n);
      var E = w < this.n ? -1 : y.ucmp(this.p);
      return E === 0 ? (y.words[0] = 0, y.length = 1) : E > 0 ? y.isub(this.p) : y.strip !== void 0 ? y.strip() : y._strip(), y;
    }, U.prototype.split = function(d, y) {
      d.iushrn(this.n, 0, y);
    }, U.prototype.imulK = function(d) {
      return d.imul(this.k);
    };
    function Q() {
      U.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    s(Q, U), Q.prototype.split = function(d, y) {
      for (var w = 4194303, E = Math.min(d.length, 9), M = 0; M < E; M++) y.words[M] = d.words[M];
      if (y.length = E, d.length <= 9) {
        d.words[0] = 0, d.length = 1;
        return;
      }
      var x = d.words[9];
      for (y.words[y.length++] = x & w, M = 10; M < d.length; M++) {
        var g = d.words[M] | 0;
        d.words[M - 10] = (g & w) << 4 | x >>> 22, x = g;
      }
      x >>>= 22, d.words[M - 10] = x, x === 0 && d.length > 10 ? d.length -= 10 : d.length -= 9;
    }, Q.prototype.imulK = function(d) {
      d.words[d.length] = 0, d.words[d.length + 1] = 0, d.length += 2;
      for (var y = 0, w = 0; w < d.length; w++) {
        var E = d.words[w] | 0;
        y += E * 977, d.words[w] = y & 67108863, y = E * 64 + (y / 67108864 | 0);
      }
      return d.words[d.length - 1] === 0 && (d.length--, d.words[d.length - 1] === 0 && d.length--), d;
    };
    function P() {
      U.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    s(P, U);
    function N() {
      U.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    s(N, U);
    function L() {
      U.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    s(L, U), L.prototype.imulK = function(d) {
      for (var y = 0, w = 0; w < d.length; w++) {
        var E = (d.words[w] | 0) * 19 + y, M = E & 67108863;
        E >>>= 26, d.words[w] = M, y = E;
      }
      return y !== 0 && (d.words[d.length++] = y), d;
    }, i._prime = function(d) {
      if (F[d]) return F[d];
      var y;
      if (d === "k256") y = new Q();
      else if (d === "p224") y = new P();
      else if (d === "p192") y = new N();
      else if (d === "p25519") y = new L();
      else throw new Error("Unknown prime " + d);
      return F[d] = y, y;
    };
    function B(p) {
      if (typeof p == "string") {
        var d = i._prime(p);
        this.m = d.p, this.prime = d;
      } else r(p.gtn(1), "modulus must be greater than 1"), this.m = p, this.prime = null;
    }
    B.prototype._verify1 = function(d) {
      r(d.negative === 0, "red works only with positives"), r(d.red, "red works only with red numbers");
    }, B.prototype._verify2 = function(d, y) {
      r((d.negative | y.negative) === 0, "red works only with positives"), r(d.red && d.red === y.red, "red works only with red numbers");
    }, B.prototype.imod = function(d) {
      return this.prime ? this.prime.ireduce(d)._forceRed(this) : (l(d, d.umod(this.m)._forceRed(this)), d);
    }, B.prototype.neg = function(d) {
      return d.isZero() ? d.clone() : this.m.sub(d)._forceRed(this);
    }, B.prototype.add = function(d, y) {
      this._verify2(d, y);
      var w = d.add(y);
      return w.cmp(this.m) >= 0 && w.isub(this.m), w._forceRed(this);
    }, B.prototype.iadd = function(d, y) {
      this._verify2(d, y);
      var w = d.iadd(y);
      return w.cmp(this.m) >= 0 && w.isub(this.m), w;
    }, B.prototype.sub = function(d, y) {
      this._verify2(d, y);
      var w = d.sub(y);
      return w.cmpn(0) < 0 && w.iadd(this.m), w._forceRed(this);
    }, B.prototype.isub = function(d, y) {
      this._verify2(d, y);
      var w = d.isub(y);
      return w.cmpn(0) < 0 && w.iadd(this.m), w;
    }, B.prototype.shl = function(d, y) {
      return this._verify1(d), this.imod(d.ushln(y));
    }, B.prototype.imul = function(d, y) {
      return this._verify2(d, y), this.imod(d.imul(y));
    }, B.prototype.mul = function(d, y) {
      return this._verify2(d, y), this.imod(d.mul(y));
    }, B.prototype.isqr = function(d) {
      return this.imul(d, d.clone());
    }, B.prototype.sqr = function(d) {
      return this.mul(d, d);
    }, B.prototype.sqrt = function(d) {
      if (d.isZero()) return d.clone();
      var y = this.m.andln(3);
      if (r(y % 2 === 1), y === 3) {
        var w = this.m.add(new i(1)).iushrn(2);
        return this.pow(d, w);
      }
      for (var E = this.m.subn(1), M = 0; !E.isZero() && E.andln(1) === 0; ) M++, E.iushrn(1);
      r(!E.isZero());
      var x = new i(1).toRed(this), g = x.redNeg(), k = this.m.subn(1).iushrn(1), T = this.m.bitLength();
      for (T = new i(2 * T * T).toRed(this); this.pow(T, k).cmp(g) !== 0; ) T.redIAdd(g);
      for (var O = this.pow(T, E), K = this.pow(d, E.addn(1).iushrn(1)), Y = this.pow(d, E), J = M; Y.cmp(x) !== 0; ) {
        for (var G = Y, X = 0; G.cmp(x) !== 0; X++) G = G.redSqr();
        r(X < J);
        var ie = this.pow(O, new i(1).iushln(J - X - 1));
        K = K.redMul(ie), O = ie.redSqr(), Y = Y.redMul(O), J = X;
      }
      return K;
    }, B.prototype.invm = function(d) {
      var y = d._invmp(this.m);
      return y.negative !== 0 ? (y.negative = 0, this.imod(y).redNeg()) : this.imod(y);
    }, B.prototype.pow = function(d, y) {
      if (y.isZero()) return new i(1).toRed(this);
      if (y.cmpn(1) === 0) return d.clone();
      var w = 4, E = new Array(1 << w);
      E[0] = new i(1).toRed(this), E[1] = d;
      for (var M = 2; M < E.length; M++) E[M] = this.mul(E[M - 1], d);
      var x = E[0], g = 0, k = 0, T = y.bitLength() % 26;
      for (T === 0 && (T = 26), M = y.length - 1; M >= 0; M--) {
        for (var O = y.words[M], K = T - 1; K >= 0; K--) {
          var Y = O >> K & 1;
          if (x !== E[0] && (x = this.sqr(x)), Y === 0 && g === 0) {
            k = 0;
            continue;
          }
          g <<= 1, g |= Y, k++, !(k !== w && (M !== 0 || K !== 0)) && (x = this.mul(x, E[g]), k = 0, g = 0);
        }
        T = 26;
      }
      return x;
    }, B.prototype.convertTo = function(d) {
      var y = d.umod(this.m);
      return y === d ? y.clone() : y;
    }, B.prototype.convertFrom = function(d) {
      var y = d.clone();
      return y.red = null, y;
    }, i.mont = function(d) {
      return new u(d);
    };
    function u(p) {
      B.call(this, p), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new i(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    s(u, B), u.prototype.convertTo = function(d) {
      return this.imod(d.ushln(this.shift));
    }, u.prototype.convertFrom = function(d) {
      var y = this.imod(d.mul(this.rinv));
      return y.red = null, y;
    }, u.prototype.imul = function(d, y) {
      if (d.isZero() || y.isZero()) return d.words[0] = 0, d.length = 1, d;
      var w = d.imul(y), E = w.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), M = w.isub(E).iushrn(this.shift), x = M;
      return M.cmp(this.m) >= 0 ? x = M.isub(this.m) : M.cmpn(0) < 0 && (x = M.iadd(this.m)), x._forceRed(this);
    }, u.prototype.mul = function(d, y) {
      if (d.isZero() || y.isZero()) return new i(0)._forceRed(this);
      var w = d.mul(y), E = w.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), M = w.isub(E).iushrn(this.shift), x = M;
      return M.cmp(this.m) >= 0 ? x = M.isub(this.m) : M.cmpn(0) < 0 && (x = M.iadd(this.m)), x._forceRed(this);
    }, u.prototype.invm = function(d) {
      var y = this.imod(d._invmp(this.m).mul(this.r2));
      return y._forceRed(this);
    };
  })(t3, mt);
})(GA);
var VA = GA.exports, Y3 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(t3, e) {
  var n = $n, r = n.Buffer;
  function s(a, o) {
    for (var f in a) o[f] = a[f];
  }
  r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow ? t3.exports = n : (s(n, e), e.Buffer = i);
  function i(a, o, f) {
    return r(a, o, f);
  }
  i.prototype = Object.create(r.prototype), s(r, i), i.from = function(a, o, f) {
    if (typeof a == "number") throw new TypeError("Argument must not be a number");
    return r(a, o, f);
  }, i.alloc = function(a, o, f) {
    if (typeof a != "number") throw new TypeError("Argument must be a number");
    var c = r(a);
    return o !== void 0 ? typeof f == "string" ? c.fill(o, f) : c.fill(o) : c.fill(0), c;
  }, i.allocUnsafe = function(a) {
    if (typeof a != "number") throw new TypeError("Argument must be a number");
    return r(a);
  }, i.allocUnsafeSlow = function(a) {
    if (typeof a != "number") throw new TypeError("Argument must be a number");
    return n.SlowBuffer(a);
  };
})(Y3, Y3.exports);
var QW = Y3.exports, du = VA, KW = Yu, HW = QW.Buffer;
function w$(t3) {
  var e = t3.modulus.byteLength(), n;
  do
    n = new du(KW(e));
  while (n.cmp(t3.modulus) >= 0 || !n.umod(t3.prime1) || !n.umod(t3.prime2));
  return n;
}
function qW(t3) {
  var e = w$(t3), n = e.toRed(du.mont(t3.modulus)).redPow(new du(t3.publicExponent)).fromRed();
  return { blinder: n, unblinder: e.invm(t3.modulus) };
}
function x$(t3, e) {
  var n = qW(e), r = e.modulus.byteLength(), s = new du(t3).mul(n.blinder).umod(e.modulus), i = s.toRed(du.mont(e.prime1)), a = s.toRed(du.mont(e.prime2)), o = e.coefficient, f = e.prime1, c = e.prime2, l = i.redPow(e.exponent1).fromRed(), h = a.redPow(e.exponent2).fromRed(), m = l.isub(h).imul(o).umod(f).imul(c);
  return h.iadd(m).imul(n.unblinder).umod(e.modulus).toArrayLike(HW, "be", r);
}
x$.getr = w$;
var YA = x$, V2 = {};
const zW = "6.6.1", GW = { version: zW };
var Gs = {}, WA = { exports: {} };
WA.exports;
(function(t3) {
  (function(e, n) {
    function r(B, u) {
      if (!B) throw new Error(u || "Assertion failed");
    }
    function s(B, u) {
      B.super_ = u;
      var p = function() {
      };
      p.prototype = u.prototype, B.prototype = new p(), B.prototype.constructor = B;
    }
    function i(B, u, p) {
      if (i.isBN(B)) return B;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, B !== null && ((u === "le" || u === "be") && (p = u, u = 10), this._init(B || 0, u || 10, p || "be"));
    }
    typeof e == "object" ? e.exports = i : n.BN = i, i.BN = i, i.wordSize = 26;
    var a;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? a = window.Buffer : a = $n.Buffer;
    } catch {
    }
    i.isBN = function(u) {
      return u instanceof i ? true : u !== null && typeof u == "object" && u.constructor.wordSize === i.wordSize && Array.isArray(u.words);
    }, i.max = function(u, p) {
      return u.cmp(p) > 0 ? u : p;
    }, i.min = function(u, p) {
      return u.cmp(p) < 0 ? u : p;
    }, i.prototype._init = function(u, p, d) {
      if (typeof u == "number") return this._initNumber(u, p, d);
      if (typeof u == "object") return this._initArray(u, p, d);
      p === "hex" && (p = 16), r(p === (p | 0) && p >= 2 && p <= 36), u = u.toString().replace(/\s+/g, "");
      var y = 0;
      u[0] === "-" && (y++, this.negative = 1), y < u.length && (p === 16 ? this._parseHex(u, y, d) : (this._parseBase(u, p, y), d === "le" && this._initArray(this.toArray(), p, d)));
    }, i.prototype._initNumber = function(u, p, d) {
      u < 0 && (this.negative = 1, u = -u), u < 67108864 ? (this.words = [u & 67108863], this.length = 1) : u < 4503599627370496 ? (this.words = [u & 67108863, u / 67108864 & 67108863], this.length = 2) : (r(u < 9007199254740992), this.words = [u & 67108863, u / 67108864 & 67108863, 1], this.length = 3), d === "le" && this._initArray(this.toArray(), p, d);
    }, i.prototype._initArray = function(u, p, d) {
      if (r(typeof u.length == "number"), u.length <= 0) return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(u.length / 3), this.words = new Array(this.length);
      for (var y = 0; y < this.length; y++) this.words[y] = 0;
      var w, E, M = 0;
      if (d === "be") for (y = u.length - 1, w = 0; y >= 0; y -= 3) E = u[y] | u[y - 1] << 8 | u[y - 2] << 16, this.words[w] |= E << M & 67108863, this.words[w + 1] = E >>> 26 - M & 67108863, M += 24, M >= 26 && (M -= 26, w++);
      else if (d === "le") for (y = 0, w = 0; y < u.length; y += 3) E = u[y] | u[y + 1] << 8 | u[y + 2] << 16, this.words[w] |= E << M & 67108863, this.words[w + 1] = E >>> 26 - M & 67108863, M += 24, M >= 26 && (M -= 26, w++);
      return this.strip();
    };
    function o(B, u) {
      var p = B.charCodeAt(u);
      return p >= 65 && p <= 70 ? p - 55 : p >= 97 && p <= 102 ? p - 87 : p - 48 & 15;
    }
    function f(B, u, p) {
      var d = o(B, p);
      return p - 1 >= u && (d |= o(B, p - 1) << 4), d;
    }
    i.prototype._parseHex = function(u, p, d) {
      this.length = Math.ceil((u.length - p) / 6), this.words = new Array(this.length);
      for (var y = 0; y < this.length; y++) this.words[y] = 0;
      var w = 0, E = 0, M;
      if (d === "be") for (y = u.length - 1; y >= p; y -= 2) M = f(u, p, y) << w, this.words[E] |= M & 67108863, w >= 18 ? (w -= 18, E += 1, this.words[E] |= M >>> 26) : w += 8;
      else {
        var x = u.length - p;
        for (y = x % 2 === 0 ? p + 1 : p; y < u.length; y += 2) M = f(u, p, y) << w, this.words[E] |= M & 67108863, w >= 18 ? (w -= 18, E += 1, this.words[E] |= M >>> 26) : w += 8;
      }
      this.strip();
    };
    function c(B, u, p, d) {
      for (var y = 0, w = Math.min(B.length, p), E = u; E < w; E++) {
        var M = B.charCodeAt(E) - 48;
        y *= d, M >= 49 ? y += M - 49 + 10 : M >= 17 ? y += M - 17 + 10 : y += M;
      }
      return y;
    }
    i.prototype._parseBase = function(u, p, d) {
      this.words = [0], this.length = 1;
      for (var y = 0, w = 1; w <= 67108863; w *= p) y++;
      y--, w = w / p | 0;
      for (var E = u.length - d, M = E % y, x = Math.min(E, E - M) + d, g = 0, k = d; k < x; k += y) g = c(u, k, k + y, p), this.imuln(w), this.words[0] + g < 67108864 ? this.words[0] += g : this._iaddn(g);
      if (M !== 0) {
        var T = 1;
        for (g = c(u, k, u.length, p), k = 0; k < M; k++) T *= p;
        this.imuln(T), this.words[0] + g < 67108864 ? this.words[0] += g : this._iaddn(g);
      }
      this.strip();
    }, i.prototype.copy = function(u) {
      u.words = new Array(this.length);
      for (var p = 0; p < this.length; p++) u.words[p] = this.words[p];
      u.length = this.length, u.negative = this.negative, u.red = this.red;
    }, i.prototype.clone = function() {
      var u = new i(null);
      return this.copy(u), u;
    }, i.prototype._expand = function(u) {
      for (; this.length < u; ) this.words[this.length++] = 0;
      return this;
    }, i.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; ) this.length--;
      return this._normSign();
    }, i.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, i.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var l = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], h = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], m = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    i.prototype.toString = function(u, p) {
      u = u || 10, p = p | 0 || 1;
      var d;
      if (u === 16 || u === "hex") {
        d = "";
        for (var y = 0, w = 0, E = 0; E < this.length; E++) {
          var M = this.words[E], x = ((M << y | w) & 16777215).toString(16);
          w = M >>> 24 - y & 16777215, y += 2, y >= 26 && (y -= 26, E--), w !== 0 || E !== this.length - 1 ? d = l[6 - x.length] + x + d : d = x + d;
        }
        for (w !== 0 && (d = w.toString(16) + d); d.length % p !== 0; ) d = "0" + d;
        return this.negative !== 0 && (d = "-" + d), d;
      }
      if (u === (u | 0) && u >= 2 && u <= 36) {
        var g = h[u], k = m[u];
        d = "";
        var T = this.clone();
        for (T.negative = 0; !T.isZero(); ) {
          var O = T.modn(k).toString(u);
          T = T.idivn(k), T.isZero() ? d = O + d : d = l[g - O.length] + O + d;
        }
        for (this.isZero() && (d = "0" + d); d.length % p !== 0; ) d = "0" + d;
        return this.negative !== 0 && (d = "-" + d), d;
      }
      r(false, "Base should be between 2 and 36");
    }, i.prototype.toNumber = function() {
      var u = this.words[0];
      return this.length === 2 ? u += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? u += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -u : u;
    }, i.prototype.toJSON = function() {
      return this.toString(16);
    }, i.prototype.toBuffer = function(u, p) {
      return r(typeof a < "u"), this.toArrayLike(a, u, p);
    }, i.prototype.toArray = function(u, p) {
      return this.toArrayLike(Array, u, p);
    }, i.prototype.toArrayLike = function(u, p, d) {
      var y = this.byteLength(), w = d || Math.max(1, y);
      r(y <= w, "byte array longer than desired length"), r(w > 0, "Requested array length <= 0"), this.strip();
      var E = p === "le", M = new u(w), x, g, k = this.clone();
      if (E) {
        for (g = 0; !k.isZero(); g++) x = k.andln(255), k.iushrn(8), M[g] = x;
        for (; g < w; g++) M[g] = 0;
      } else {
        for (g = 0; g < w - y; g++) M[g] = 0;
        for (g = 0; !k.isZero(); g++) x = k.andln(255), k.iushrn(8), M[w - g - 1] = x;
      }
      return M;
    }, Math.clz32 ? i.prototype._countBits = function(u) {
      return 32 - Math.clz32(u);
    } : i.prototype._countBits = function(u) {
      var p = u, d = 0;
      return p >= 4096 && (d += 13, p >>>= 13), p >= 64 && (d += 7, p >>>= 7), p >= 8 && (d += 4, p >>>= 4), p >= 2 && (d += 2, p >>>= 2), d + p;
    }, i.prototype._zeroBits = function(u) {
      if (u === 0) return 26;
      var p = u, d = 0;
      return p & 8191 || (d += 13, p >>>= 13), p & 127 || (d += 7, p >>>= 7), p & 15 || (d += 4, p >>>= 4), p & 3 || (d += 2, p >>>= 2), p & 1 || d++, d;
    }, i.prototype.bitLength = function() {
      var u = this.words[this.length - 1], p = this._countBits(u);
      return (this.length - 1) * 26 + p;
    };
    function v(B) {
      for (var u = new Array(B.bitLength()), p = 0; p < u.length; p++) {
        var d = p / 26 | 0, y = p % 26;
        u[p] = (B.words[d] & 1 << y) >>> y;
      }
      return u;
    }
    i.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var u = 0, p = 0; p < this.length; p++) {
        var d = this._zeroBits(this.words[p]);
        if (u += d, d !== 26) break;
      }
      return u;
    }, i.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, i.prototype.toTwos = function(u) {
      return this.negative !== 0 ? this.abs().inotn(u).iaddn(1) : this.clone();
    }, i.prototype.fromTwos = function(u) {
      return this.testn(u - 1) ? this.notn(u).iaddn(1).ineg() : this.clone();
    }, i.prototype.isNeg = function() {
      return this.negative !== 0;
    }, i.prototype.neg = function() {
      return this.clone().ineg();
    }, i.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, i.prototype.iuor = function(u) {
      for (; this.length < u.length; ) this.words[this.length++] = 0;
      for (var p = 0; p < u.length; p++) this.words[p] = this.words[p] | u.words[p];
      return this.strip();
    }, i.prototype.ior = function(u) {
      return r((this.negative | u.negative) === 0), this.iuor(u);
    }, i.prototype.or = function(u) {
      return this.length > u.length ? this.clone().ior(u) : u.clone().ior(this);
    }, i.prototype.uor = function(u) {
      return this.length > u.length ? this.clone().iuor(u) : u.clone().iuor(this);
    }, i.prototype.iuand = function(u) {
      var p;
      this.length > u.length ? p = u : p = this;
      for (var d = 0; d < p.length; d++) this.words[d] = this.words[d] & u.words[d];
      return this.length = p.length, this.strip();
    }, i.prototype.iand = function(u) {
      return r((this.negative | u.negative) === 0), this.iuand(u);
    }, i.prototype.and = function(u) {
      return this.length > u.length ? this.clone().iand(u) : u.clone().iand(this);
    }, i.prototype.uand = function(u) {
      return this.length > u.length ? this.clone().iuand(u) : u.clone().iuand(this);
    }, i.prototype.iuxor = function(u) {
      var p, d;
      this.length > u.length ? (p = this, d = u) : (p = u, d = this);
      for (var y = 0; y < d.length; y++) this.words[y] = p.words[y] ^ d.words[y];
      if (this !== p) for (; y < p.length; y++) this.words[y] = p.words[y];
      return this.length = p.length, this.strip();
    }, i.prototype.ixor = function(u) {
      return r((this.negative | u.negative) === 0), this.iuxor(u);
    }, i.prototype.xor = function(u) {
      return this.length > u.length ? this.clone().ixor(u) : u.clone().ixor(this);
    }, i.prototype.uxor = function(u) {
      return this.length > u.length ? this.clone().iuxor(u) : u.clone().iuxor(this);
    }, i.prototype.inotn = function(u) {
      r(typeof u == "number" && u >= 0);
      var p = Math.ceil(u / 26) | 0, d = u % 26;
      this._expand(p), d > 0 && p--;
      for (var y = 0; y < p; y++) this.words[y] = ~this.words[y] & 67108863;
      return d > 0 && (this.words[y] = ~this.words[y] & 67108863 >> 26 - d), this.strip();
    }, i.prototype.notn = function(u) {
      return this.clone().inotn(u);
    }, i.prototype.setn = function(u, p) {
      r(typeof u == "number" && u >= 0);
      var d = u / 26 | 0, y = u % 26;
      return this._expand(d + 1), p ? this.words[d] = this.words[d] | 1 << y : this.words[d] = this.words[d] & ~(1 << y), this.strip();
    }, i.prototype.iadd = function(u) {
      var p;
      if (this.negative !== 0 && u.negative === 0) return this.negative = 0, p = this.isub(u), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && u.negative !== 0) return u.negative = 0, p = this.isub(u), u.negative = 1, p._normSign();
      var d, y;
      this.length > u.length ? (d = this, y = u) : (d = u, y = this);
      for (var w = 0, E = 0; E < y.length; E++) p = (d.words[E] | 0) + (y.words[E] | 0) + w, this.words[E] = p & 67108863, w = p >>> 26;
      for (; w !== 0 && E < d.length; E++) p = (d.words[E] | 0) + w, this.words[E] = p & 67108863, w = p >>> 26;
      if (this.length = d.length, w !== 0) this.words[this.length] = w, this.length++;
      else if (d !== this) for (; E < d.length; E++) this.words[E] = d.words[E];
      return this;
    }, i.prototype.add = function(u) {
      var p;
      return u.negative !== 0 && this.negative === 0 ? (u.negative = 0, p = this.sub(u), u.negative ^= 1, p) : u.negative === 0 && this.negative !== 0 ? (this.negative = 0, p = u.sub(this), this.negative = 1, p) : this.length > u.length ? this.clone().iadd(u) : u.clone().iadd(this);
    }, i.prototype.isub = function(u) {
      if (u.negative !== 0) {
        u.negative = 0;
        var p = this.iadd(u);
        return u.negative = 1, p._normSign();
      } else if (this.negative !== 0) return this.negative = 0, this.iadd(u), this.negative = 1, this._normSign();
      var d = this.cmp(u);
      if (d === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var y, w;
      d > 0 ? (y = this, w = u) : (y = u, w = this);
      for (var E = 0, M = 0; M < w.length; M++) p = (y.words[M] | 0) - (w.words[M] | 0) + E, E = p >> 26, this.words[M] = p & 67108863;
      for (; E !== 0 && M < y.length; M++) p = (y.words[M] | 0) + E, E = p >> 26, this.words[M] = p & 67108863;
      if (E === 0 && M < y.length && y !== this) for (; M < y.length; M++) this.words[M] = y.words[M];
      return this.length = Math.max(this.length, M), y !== this && (this.negative = 1), this.strip();
    }, i.prototype.sub = function(u) {
      return this.clone().isub(u);
    };
    function b(B, u, p) {
      p.negative = u.negative ^ B.negative;
      var d = B.length + u.length | 0;
      p.length = d, d = d - 1 | 0;
      var y = B.words[0] | 0, w = u.words[0] | 0, E = y * w, M = E & 67108863, x = E / 67108864 | 0;
      p.words[0] = M;
      for (var g = 1; g < d; g++) {
        for (var k = x >>> 26, T = x & 67108863, O = Math.min(g, u.length - 1), K = Math.max(0, g - B.length + 1); K <= O; K++) {
          var Y = g - K | 0;
          y = B.words[Y] | 0, w = u.words[K] | 0, E = y * w + T, k += E / 67108864 | 0, T = E & 67108863;
        }
        p.words[g] = T | 0, x = k | 0;
      }
      return x !== 0 ? p.words[g] = x | 0 : p.length--, p.strip();
    }
    var A = function(u, p, d) {
      var y = u.words, w = p.words, E = d.words, M = 0, x, g, k, T = y[0] | 0, O = T & 8191, K = T >>> 13, Y = y[1] | 0, J = Y & 8191, G = Y >>> 13, X = y[2] | 0, ie = X & 8191, de = X >>> 13, se = y[3] | 0, te = se & 8191, le = se >>> 13, Z = y[4] | 0, ve = Z & 8191, he = Z >>> 13, me = y[5] | 0, ce = me & 8191, ye = me >>> 13, Oe = y[6] | 0, Se = Oe & 8191, Ce = Oe >>> 13, Ne = y[7] | 0, $e = Ne & 8191, Re = Ne >>> 13, Ge = y[8] | 0, Fe = Ge & 8191, Ue = Ge >>> 13, kt = y[9] | 0, pe = kt & 8191, re = kt >>> 13, ue = w[0] | 0, xe = ue & 8191, Me = ue >>> 13, We = w[1] | 0, De = We & 8191, je = We >>> 13, ir = w[2] | 0, Xe = ir & 8191, st = ir >>> 13, Vt = w[3] | 0, at = Vt & 8191, ht = Vt >>> 13, br = w[4] | 0, ot = br & 8191, ct = br >>> 13, _r = w[5] | 0, ft = _r & 8191, pt = _r >>> 13, Cr = w[6] | 0, nt = Cr & 8191, lt = Cr >>> 13, ge = w[7] | 0, be = ge & 8191, Ae = ge >>> 13, ne = w[8] | 0, _e = ne & 8191, Te = ne >>> 13, Ye = w[9] | 0, Pe = Ye & 8191, He = Ye >>> 13;
      d.negative = u.negative ^ p.negative, d.length = 19, x = Math.imul(O, xe), g = Math.imul(O, Me), g = g + Math.imul(K, xe) | 0, k = Math.imul(K, Me);
      var _t = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, x = Math.imul(J, xe), g = Math.imul(J, Me), g = g + Math.imul(G, xe) | 0, k = Math.imul(G, Me), x = x + Math.imul(O, De) | 0, g = g + Math.imul(O, je) | 0, g = g + Math.imul(K, De) | 0, k = k + Math.imul(K, je) | 0;
      var vt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, x = Math.imul(ie, xe), g = Math.imul(ie, Me), g = g + Math.imul(de, xe) | 0, k = Math.imul(de, Me), x = x + Math.imul(J, De) | 0, g = g + Math.imul(J, je) | 0, g = g + Math.imul(G, De) | 0, k = k + Math.imul(G, je) | 0, x = x + Math.imul(O, Xe) | 0, g = g + Math.imul(O, st) | 0, g = g + Math.imul(K, Xe) | 0, k = k + Math.imul(K, st) | 0;
      var cr = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (cr >>> 26) | 0, cr &= 67108863, x = Math.imul(te, xe), g = Math.imul(te, Me), g = g + Math.imul(le, xe) | 0, k = Math.imul(le, Me), x = x + Math.imul(ie, De) | 0, g = g + Math.imul(ie, je) | 0, g = g + Math.imul(de, De) | 0, k = k + Math.imul(de, je) | 0, x = x + Math.imul(J, Xe) | 0, g = g + Math.imul(J, st) | 0, g = g + Math.imul(G, Xe) | 0, k = k + Math.imul(G, st) | 0, x = x + Math.imul(O, at) | 0, g = g + Math.imul(O, ht) | 0, g = g + Math.imul(K, at) | 0, k = k + Math.imul(K, ht) | 0;
      var Tt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, x = Math.imul(ve, xe), g = Math.imul(ve, Me), g = g + Math.imul(he, xe) | 0, k = Math.imul(he, Me), x = x + Math.imul(te, De) | 0, g = g + Math.imul(te, je) | 0, g = g + Math.imul(le, De) | 0, k = k + Math.imul(le, je) | 0, x = x + Math.imul(ie, Xe) | 0, g = g + Math.imul(ie, st) | 0, g = g + Math.imul(de, Xe) | 0, k = k + Math.imul(de, st) | 0, x = x + Math.imul(J, at) | 0, g = g + Math.imul(J, ht) | 0, g = g + Math.imul(G, at) | 0, k = k + Math.imul(G, ht) | 0, x = x + Math.imul(O, ot) | 0, g = g + Math.imul(O, ct) | 0, g = g + Math.imul(K, ot) | 0, k = k + Math.imul(K, ct) | 0;
      var Gt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Gt >>> 26) | 0, Gt &= 67108863, x = Math.imul(ce, xe), g = Math.imul(ce, Me), g = g + Math.imul(ye, xe) | 0, k = Math.imul(ye, Me), x = x + Math.imul(ve, De) | 0, g = g + Math.imul(ve, je) | 0, g = g + Math.imul(he, De) | 0, k = k + Math.imul(he, je) | 0, x = x + Math.imul(te, Xe) | 0, g = g + Math.imul(te, st) | 0, g = g + Math.imul(le, Xe) | 0, k = k + Math.imul(le, st) | 0, x = x + Math.imul(ie, at) | 0, g = g + Math.imul(ie, ht) | 0, g = g + Math.imul(de, at) | 0, k = k + Math.imul(de, ht) | 0, x = x + Math.imul(J, ot) | 0, g = g + Math.imul(J, ct) | 0, g = g + Math.imul(G, ot) | 0, k = k + Math.imul(G, ct) | 0, x = x + Math.imul(O, ft) | 0, g = g + Math.imul(O, pt) | 0, g = g + Math.imul(K, ft) | 0, k = k + Math.imul(K, pt) | 0;
      var Yt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Yt >>> 26) | 0, Yt &= 67108863, x = Math.imul(Se, xe), g = Math.imul(Se, Me), g = g + Math.imul(Ce, xe) | 0, k = Math.imul(Ce, Me), x = x + Math.imul(ce, De) | 0, g = g + Math.imul(ce, je) | 0, g = g + Math.imul(ye, De) | 0, k = k + Math.imul(ye, je) | 0, x = x + Math.imul(ve, Xe) | 0, g = g + Math.imul(ve, st) | 0, g = g + Math.imul(he, Xe) | 0, k = k + Math.imul(he, st) | 0, x = x + Math.imul(te, at) | 0, g = g + Math.imul(te, ht) | 0, g = g + Math.imul(le, at) | 0, k = k + Math.imul(le, ht) | 0, x = x + Math.imul(ie, ot) | 0, g = g + Math.imul(ie, ct) | 0, g = g + Math.imul(de, ot) | 0, k = k + Math.imul(de, ct) | 0, x = x + Math.imul(J, ft) | 0, g = g + Math.imul(J, pt) | 0, g = g + Math.imul(G, ft) | 0, k = k + Math.imul(G, pt) | 0, x = x + Math.imul(O, nt) | 0, g = g + Math.imul(O, lt) | 0, g = g + Math.imul(K, nt) | 0, k = k + Math.imul(K, lt) | 0;
      var or = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (or >>> 26) | 0, or &= 67108863, x = Math.imul($e, xe), g = Math.imul($e, Me), g = g + Math.imul(Re, xe) | 0, k = Math.imul(Re, Me), x = x + Math.imul(Se, De) | 0, g = g + Math.imul(Se, je) | 0, g = g + Math.imul(Ce, De) | 0, k = k + Math.imul(Ce, je) | 0, x = x + Math.imul(ce, Xe) | 0, g = g + Math.imul(ce, st) | 0, g = g + Math.imul(ye, Xe) | 0, k = k + Math.imul(ye, st) | 0, x = x + Math.imul(ve, at) | 0, g = g + Math.imul(ve, ht) | 0, g = g + Math.imul(he, at) | 0, k = k + Math.imul(he, ht) | 0, x = x + Math.imul(te, ot) | 0, g = g + Math.imul(te, ct) | 0, g = g + Math.imul(le, ot) | 0, k = k + Math.imul(le, ct) | 0, x = x + Math.imul(ie, ft) | 0, g = g + Math.imul(ie, pt) | 0, g = g + Math.imul(de, ft) | 0, k = k + Math.imul(de, pt) | 0, x = x + Math.imul(J, nt) | 0, g = g + Math.imul(J, lt) | 0, g = g + Math.imul(G, nt) | 0, k = k + Math.imul(G, lt) | 0, x = x + Math.imul(O, be) | 0, g = g + Math.imul(O, Ae) | 0, g = g + Math.imul(K, be) | 0, k = k + Math.imul(K, Ae) | 0;
      var sr = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (sr >>> 26) | 0, sr &= 67108863, x = Math.imul(Fe, xe), g = Math.imul(Fe, Me), g = g + Math.imul(Ue, xe) | 0, k = Math.imul(Ue, Me), x = x + Math.imul($e, De) | 0, g = g + Math.imul($e, je) | 0, g = g + Math.imul(Re, De) | 0, k = k + Math.imul(Re, je) | 0, x = x + Math.imul(Se, Xe) | 0, g = g + Math.imul(Se, st) | 0, g = g + Math.imul(Ce, Xe) | 0, k = k + Math.imul(Ce, st) | 0, x = x + Math.imul(ce, at) | 0, g = g + Math.imul(ce, ht) | 0, g = g + Math.imul(ye, at) | 0, k = k + Math.imul(ye, ht) | 0, x = x + Math.imul(ve, ot) | 0, g = g + Math.imul(ve, ct) | 0, g = g + Math.imul(he, ot) | 0, k = k + Math.imul(he, ct) | 0, x = x + Math.imul(te, ft) | 0, g = g + Math.imul(te, pt) | 0, g = g + Math.imul(le, ft) | 0, k = k + Math.imul(le, pt) | 0, x = x + Math.imul(ie, nt) | 0, g = g + Math.imul(ie, lt) | 0, g = g + Math.imul(de, nt) | 0, k = k + Math.imul(de, lt) | 0, x = x + Math.imul(J, be) | 0, g = g + Math.imul(J, Ae) | 0, g = g + Math.imul(G, be) | 0, k = k + Math.imul(G, Ae) | 0, x = x + Math.imul(O, _e) | 0, g = g + Math.imul(O, Te) | 0, g = g + Math.imul(K, _e) | 0, k = k + Math.imul(K, Te) | 0;
      var Wt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Wt >>> 26) | 0, Wt &= 67108863, x = Math.imul(pe, xe), g = Math.imul(pe, Me), g = g + Math.imul(re, xe) | 0, k = Math.imul(re, Me), x = x + Math.imul(Fe, De) | 0, g = g + Math.imul(Fe, je) | 0, g = g + Math.imul(Ue, De) | 0, k = k + Math.imul(Ue, je) | 0, x = x + Math.imul($e, Xe) | 0, g = g + Math.imul($e, st) | 0, g = g + Math.imul(Re, Xe) | 0, k = k + Math.imul(Re, st) | 0, x = x + Math.imul(Se, at) | 0, g = g + Math.imul(Se, ht) | 0, g = g + Math.imul(Ce, at) | 0, k = k + Math.imul(Ce, ht) | 0, x = x + Math.imul(ce, ot) | 0, g = g + Math.imul(ce, ct) | 0, g = g + Math.imul(ye, ot) | 0, k = k + Math.imul(ye, ct) | 0, x = x + Math.imul(ve, ft) | 0, g = g + Math.imul(ve, pt) | 0, g = g + Math.imul(he, ft) | 0, k = k + Math.imul(he, pt) | 0, x = x + Math.imul(te, nt) | 0, g = g + Math.imul(te, lt) | 0, g = g + Math.imul(le, nt) | 0, k = k + Math.imul(le, lt) | 0, x = x + Math.imul(ie, be) | 0, g = g + Math.imul(ie, Ae) | 0, g = g + Math.imul(de, be) | 0, k = k + Math.imul(de, Ae) | 0, x = x + Math.imul(J, _e) | 0, g = g + Math.imul(J, Te) | 0, g = g + Math.imul(G, _e) | 0, k = k + Math.imul(G, Te) | 0, x = x + Math.imul(O, Pe) | 0, g = g + Math.imul(O, He) | 0, g = g + Math.imul(K, Pe) | 0, k = k + Math.imul(K, He) | 0;
      var tr = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (tr >>> 26) | 0, tr &= 67108863, x = Math.imul(pe, De), g = Math.imul(pe, je), g = g + Math.imul(re, De) | 0, k = Math.imul(re, je), x = x + Math.imul(Fe, Xe) | 0, g = g + Math.imul(Fe, st) | 0, g = g + Math.imul(Ue, Xe) | 0, k = k + Math.imul(Ue, st) | 0, x = x + Math.imul($e, at) | 0, g = g + Math.imul($e, ht) | 0, g = g + Math.imul(Re, at) | 0, k = k + Math.imul(Re, ht) | 0, x = x + Math.imul(Se, ot) | 0, g = g + Math.imul(Se, ct) | 0, g = g + Math.imul(Ce, ot) | 0, k = k + Math.imul(Ce, ct) | 0, x = x + Math.imul(ce, ft) | 0, g = g + Math.imul(ce, pt) | 0, g = g + Math.imul(ye, ft) | 0, k = k + Math.imul(ye, pt) | 0, x = x + Math.imul(ve, nt) | 0, g = g + Math.imul(ve, lt) | 0, g = g + Math.imul(he, nt) | 0, k = k + Math.imul(he, lt) | 0, x = x + Math.imul(te, be) | 0, g = g + Math.imul(te, Ae) | 0, g = g + Math.imul(le, be) | 0, k = k + Math.imul(le, Ae) | 0, x = x + Math.imul(ie, _e) | 0, g = g + Math.imul(ie, Te) | 0, g = g + Math.imul(de, _e) | 0, k = k + Math.imul(de, Te) | 0, x = x + Math.imul(J, Pe) | 0, g = g + Math.imul(J, He) | 0, g = g + Math.imul(G, Pe) | 0, k = k + Math.imul(G, He) | 0;
      var Jt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Jt >>> 26) | 0, Jt &= 67108863, x = Math.imul(pe, Xe), g = Math.imul(pe, st), g = g + Math.imul(re, Xe) | 0, k = Math.imul(re, st), x = x + Math.imul(Fe, at) | 0, g = g + Math.imul(Fe, ht) | 0, g = g + Math.imul(Ue, at) | 0, k = k + Math.imul(Ue, ht) | 0, x = x + Math.imul($e, ot) | 0, g = g + Math.imul($e, ct) | 0, g = g + Math.imul(Re, ot) | 0, k = k + Math.imul(Re, ct) | 0, x = x + Math.imul(Se, ft) | 0, g = g + Math.imul(Se, pt) | 0, g = g + Math.imul(Ce, ft) | 0, k = k + Math.imul(Ce, pt) | 0, x = x + Math.imul(ce, nt) | 0, g = g + Math.imul(ce, lt) | 0, g = g + Math.imul(ye, nt) | 0, k = k + Math.imul(ye, lt) | 0, x = x + Math.imul(ve, be) | 0, g = g + Math.imul(ve, Ae) | 0, g = g + Math.imul(he, be) | 0, k = k + Math.imul(he, Ae) | 0, x = x + Math.imul(te, _e) | 0, g = g + Math.imul(te, Te) | 0, g = g + Math.imul(le, _e) | 0, k = k + Math.imul(le, Te) | 0, x = x + Math.imul(ie, Pe) | 0, g = g + Math.imul(ie, He) | 0, g = g + Math.imul(de, Pe) | 0, k = k + Math.imul(de, He) | 0;
      var Ft = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Ft >>> 26) | 0, Ft &= 67108863, x = Math.imul(pe, at), g = Math.imul(pe, ht), g = g + Math.imul(re, at) | 0, k = Math.imul(re, ht), x = x + Math.imul(Fe, ot) | 0, g = g + Math.imul(Fe, ct) | 0, g = g + Math.imul(Ue, ot) | 0, k = k + Math.imul(Ue, ct) | 0, x = x + Math.imul($e, ft) | 0, g = g + Math.imul($e, pt) | 0, g = g + Math.imul(Re, ft) | 0, k = k + Math.imul(Re, pt) | 0, x = x + Math.imul(Se, nt) | 0, g = g + Math.imul(Se, lt) | 0, g = g + Math.imul(Ce, nt) | 0, k = k + Math.imul(Ce, lt) | 0, x = x + Math.imul(ce, be) | 0, g = g + Math.imul(ce, Ae) | 0, g = g + Math.imul(ye, be) | 0, k = k + Math.imul(ye, Ae) | 0, x = x + Math.imul(ve, _e) | 0, g = g + Math.imul(ve, Te) | 0, g = g + Math.imul(he, _e) | 0, k = k + Math.imul(he, Te) | 0, x = x + Math.imul(te, Pe) | 0, g = g + Math.imul(te, He) | 0, g = g + Math.imul(le, Pe) | 0, k = k + Math.imul(le, He) | 0;
      var Ut = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, x = Math.imul(pe, ot), g = Math.imul(pe, ct), g = g + Math.imul(re, ot) | 0, k = Math.imul(re, ct), x = x + Math.imul(Fe, ft) | 0, g = g + Math.imul(Fe, pt) | 0, g = g + Math.imul(Ue, ft) | 0, k = k + Math.imul(Ue, pt) | 0, x = x + Math.imul($e, nt) | 0, g = g + Math.imul($e, lt) | 0, g = g + Math.imul(Re, nt) | 0, k = k + Math.imul(Re, lt) | 0, x = x + Math.imul(Se, be) | 0, g = g + Math.imul(Se, Ae) | 0, g = g + Math.imul(Ce, be) | 0, k = k + Math.imul(Ce, Ae) | 0, x = x + Math.imul(ce, _e) | 0, g = g + Math.imul(ce, Te) | 0, g = g + Math.imul(ye, _e) | 0, k = k + Math.imul(ye, Te) | 0, x = x + Math.imul(ve, Pe) | 0, g = g + Math.imul(ve, He) | 0, g = g + Math.imul(he, Pe) | 0, k = k + Math.imul(he, He) | 0;
      var Mt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, x = Math.imul(pe, ft), g = Math.imul(pe, pt), g = g + Math.imul(re, ft) | 0, k = Math.imul(re, pt), x = x + Math.imul(Fe, nt) | 0, g = g + Math.imul(Fe, lt) | 0, g = g + Math.imul(Ue, nt) | 0, k = k + Math.imul(Ue, lt) | 0, x = x + Math.imul($e, be) | 0, g = g + Math.imul($e, Ae) | 0, g = g + Math.imul(Re, be) | 0, k = k + Math.imul(Re, Ae) | 0, x = x + Math.imul(Se, _e) | 0, g = g + Math.imul(Se, Te) | 0, g = g + Math.imul(Ce, _e) | 0, k = k + Math.imul(Ce, Te) | 0, x = x + Math.imul(ce, Pe) | 0, g = g + Math.imul(ce, He) | 0, g = g + Math.imul(ye, Pe) | 0, k = k + Math.imul(ye, He) | 0;
      var Pt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, x = Math.imul(pe, nt), g = Math.imul(pe, lt), g = g + Math.imul(re, nt) | 0, k = Math.imul(re, lt), x = x + Math.imul(Fe, be) | 0, g = g + Math.imul(Fe, Ae) | 0, g = g + Math.imul(Ue, be) | 0, k = k + Math.imul(Ue, Ae) | 0, x = x + Math.imul($e, _e) | 0, g = g + Math.imul($e, Te) | 0, g = g + Math.imul(Re, _e) | 0, k = k + Math.imul(Re, Te) | 0, x = x + Math.imul(Se, Pe) | 0, g = g + Math.imul(Se, He) | 0, g = g + Math.imul(Ce, Pe) | 0, k = k + Math.imul(Ce, He) | 0;
      var Nt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, x = Math.imul(pe, be), g = Math.imul(pe, Ae), g = g + Math.imul(re, be) | 0, k = Math.imul(re, Ae), x = x + Math.imul(Fe, _e) | 0, g = g + Math.imul(Fe, Te) | 0, g = g + Math.imul(Ue, _e) | 0, k = k + Math.imul(Ue, Te) | 0, x = x + Math.imul($e, Pe) | 0, g = g + Math.imul($e, He) | 0, g = g + Math.imul(Re, Pe) | 0, k = k + Math.imul(Re, He) | 0;
      var It = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, x = Math.imul(pe, _e), g = Math.imul(pe, Te), g = g + Math.imul(re, _e) | 0, k = Math.imul(re, Te), x = x + Math.imul(Fe, Pe) | 0, g = g + Math.imul(Fe, He) | 0, g = g + Math.imul(Ue, Pe) | 0, k = k + Math.imul(Ue, He) | 0;
      var tt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, x = Math.imul(pe, Pe), g = Math.imul(pe, He), g = g + Math.imul(re, Pe) | 0, k = Math.imul(re, He);
      var rt = (M + x | 0) + ((g & 8191) << 13) | 0;
      return M = (k + (g >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, E[0] = _t, E[1] = vt, E[2] = cr, E[3] = Tt, E[4] = Gt, E[5] = Yt, E[6] = or, E[7] = sr, E[8] = Wt, E[9] = tr, E[10] = Jt, E[11] = Ft, E[12] = Ut, E[13] = Mt, E[14] = Pt, E[15] = Nt, E[16] = It, E[17] = tt, E[18] = rt, M !== 0 && (E[19] = M, d.length++), d;
    };
    Math.imul || (A = b);
    function _(B, u, p) {
      p.negative = u.negative ^ B.negative, p.length = B.length + u.length;
      for (var d = 0, y = 0, w = 0; w < p.length - 1; w++) {
        var E = y;
        y = 0;
        for (var M = d & 67108863, x = Math.min(w, u.length - 1), g = Math.max(0, w - B.length + 1); g <= x; g++) {
          var k = w - g, T = B.words[k] | 0, O = u.words[g] | 0, K = T * O, Y = K & 67108863;
          E = E + (K / 67108864 | 0) | 0, Y = Y + M | 0, M = Y & 67108863, E = E + (Y >>> 26) | 0, y += E >>> 26, E &= 67108863;
        }
        p.words[w] = M, d = E, E = y;
      }
      return d !== 0 ? p.words[w] = d : p.length--, p.strip();
    }
    function C(B, u, p) {
      var d = new I();
      return d.mulp(B, u, p);
    }
    i.prototype.mulTo = function(u, p) {
      var d, y = this.length + u.length;
      return this.length === 10 && u.length === 10 ? d = A(this, u, p) : y < 63 ? d = b(this, u, p) : y < 1024 ? d = _(this, u, p) : d = C(this, u, p), d;
    };
    function I(B, u) {
      this.x = B, this.y = u;
    }
    I.prototype.makeRBT = function(u) {
      for (var p = new Array(u), d = i.prototype._countBits(u) - 1, y = 0; y < u; y++) p[y] = this.revBin(y, d, u);
      return p;
    }, I.prototype.revBin = function(u, p, d) {
      if (u === 0 || u === d - 1) return u;
      for (var y = 0, w = 0; w < p; w++) y |= (u & 1) << p - w - 1, u >>= 1;
      return y;
    }, I.prototype.permute = function(u, p, d, y, w, E) {
      for (var M = 0; M < E; M++) y[M] = p[u[M]], w[M] = d[u[M]];
    }, I.prototype.transform = function(u, p, d, y, w, E) {
      this.permute(E, u, p, d, y, w);
      for (var M = 1; M < w; M <<= 1) for (var x = M << 1, g = Math.cos(2 * Math.PI / x), k = Math.sin(2 * Math.PI / x), T = 0; T < w; T += x) for (var O = g, K = k, Y = 0; Y < M; Y++) {
        var J = d[T + Y], G = y[T + Y], X = d[T + Y + M], ie = y[T + Y + M], de = O * X - K * ie;
        ie = O * ie + K * X, X = de, d[T + Y] = J + X, y[T + Y] = G + ie, d[T + Y + M] = J - X, y[T + Y + M] = G - ie, Y !== x && (de = g * O - k * K, K = g * K + k * O, O = de);
      }
    }, I.prototype.guessLen13b = function(u, p) {
      var d = Math.max(p, u) | 1, y = d & 1, w = 0;
      for (d = d / 2 | 0; d; d = d >>> 1) w++;
      return 1 << w + 1 + y;
    }, I.prototype.conjugate = function(u, p, d) {
      if (!(d <= 1)) for (var y = 0; y < d / 2; y++) {
        var w = u[y];
        u[y] = u[d - y - 1], u[d - y - 1] = w, w = p[y], p[y] = -p[d - y - 1], p[d - y - 1] = -w;
      }
    }, I.prototype.normalize13b = function(u, p) {
      for (var d = 0, y = 0; y < p / 2; y++) {
        var w = Math.round(u[2 * y + 1] / p) * 8192 + Math.round(u[2 * y] / p) + d;
        u[y] = w & 67108863, w < 67108864 ? d = 0 : d = w / 67108864 | 0;
      }
      return u;
    }, I.prototype.convert13b = function(u, p, d, y) {
      for (var w = 0, E = 0; E < p; E++) w = w + (u[E] | 0), d[2 * E] = w & 8191, w = w >>> 13, d[2 * E + 1] = w & 8191, w = w >>> 13;
      for (E = 2 * p; E < y; ++E) d[E] = 0;
      r(w === 0), r((w & -8192) === 0);
    }, I.prototype.stub = function(u) {
      for (var p = new Array(u), d = 0; d < u; d++) p[d] = 0;
      return p;
    }, I.prototype.mulp = function(u, p, d) {
      var y = 2 * this.guessLen13b(u.length, p.length), w = this.makeRBT(y), E = this.stub(y), M = new Array(y), x = new Array(y), g = new Array(y), k = new Array(y), T = new Array(y), O = new Array(y), K = d.words;
      K.length = y, this.convert13b(u.words, u.length, M, y), this.convert13b(p.words, p.length, k, y), this.transform(M, E, x, g, y, w), this.transform(k, E, T, O, y, w);
      for (var Y = 0; Y < y; Y++) {
        var J = x[Y] * T[Y] - g[Y] * O[Y];
        g[Y] = x[Y] * O[Y] + g[Y] * T[Y], x[Y] = J;
      }
      return this.conjugate(x, g, y), this.transform(x, g, K, E, y, w), this.conjugate(K, E, y), this.normalize13b(K, y), d.negative = u.negative ^ p.negative, d.length = u.length + p.length, d.strip();
    }, i.prototype.mul = function(u) {
      var p = new i(null);
      return p.words = new Array(this.length + u.length), this.mulTo(u, p);
    }, i.prototype.mulf = function(u) {
      var p = new i(null);
      return p.words = new Array(this.length + u.length), C(this, u, p);
    }, i.prototype.imul = function(u) {
      return this.clone().mulTo(u, this);
    }, i.prototype.imuln = function(u) {
      r(typeof u == "number"), r(u < 67108864);
      for (var p = 0, d = 0; d < this.length; d++) {
        var y = (this.words[d] | 0) * u, w = (y & 67108863) + (p & 67108863);
        p >>= 26, p += y / 67108864 | 0, p += w >>> 26, this.words[d] = w & 67108863;
      }
      return p !== 0 && (this.words[d] = p, this.length++), this.length = u === 0 ? 1 : this.length, this;
    }, i.prototype.muln = function(u) {
      return this.clone().imuln(u);
    }, i.prototype.sqr = function() {
      return this.mul(this);
    }, i.prototype.isqr = function() {
      return this.imul(this.clone());
    }, i.prototype.pow = function(u) {
      var p = v(u);
      if (p.length === 0) return new i(1);
      for (var d = this, y = 0; y < p.length && p[y] === 0; y++, d = d.sqr()) ;
      if (++y < p.length) for (var w = d.sqr(); y < p.length; y++, w = w.sqr()) p[y] !== 0 && (d = d.mul(w));
      return d;
    }, i.prototype.iushln = function(u) {
      r(typeof u == "number" && u >= 0);
      var p = u % 26, d = (u - p) / 26, y = 67108863 >>> 26 - p << 26 - p, w;
      if (p !== 0) {
        var E = 0;
        for (w = 0; w < this.length; w++) {
          var M = this.words[w] & y, x = (this.words[w] | 0) - M << p;
          this.words[w] = x | E, E = M >>> 26 - p;
        }
        E && (this.words[w] = E, this.length++);
      }
      if (d !== 0) {
        for (w = this.length - 1; w >= 0; w--) this.words[w + d] = this.words[w];
        for (w = 0; w < d; w++) this.words[w] = 0;
        this.length += d;
      }
      return this.strip();
    }, i.prototype.ishln = function(u) {
      return r(this.negative === 0), this.iushln(u);
    }, i.prototype.iushrn = function(u, p, d) {
      r(typeof u == "number" && u >= 0);
      var y;
      p ? y = (p - p % 26) / 26 : y = 0;
      var w = u % 26, E = Math.min((u - w) / 26, this.length), M = 67108863 ^ 67108863 >>> w << w, x = d;
      if (y -= E, y = Math.max(0, y), x) {
        for (var g = 0; g < E; g++) x.words[g] = this.words[g];
        x.length = E;
      }
      if (E !== 0) if (this.length > E) for (this.length -= E, g = 0; g < this.length; g++) this.words[g] = this.words[g + E];
      else this.words[0] = 0, this.length = 1;
      var k = 0;
      for (g = this.length - 1; g >= 0 && (k !== 0 || g >= y); g--) {
        var T = this.words[g] | 0;
        this.words[g] = k << 26 - w | T >>> w, k = T & M;
      }
      return x && k !== 0 && (x.words[x.length++] = k), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, i.prototype.ishrn = function(u, p, d) {
      return r(this.negative === 0), this.iushrn(u, p, d);
    }, i.prototype.shln = function(u) {
      return this.clone().ishln(u);
    }, i.prototype.ushln = function(u) {
      return this.clone().iushln(u);
    }, i.prototype.shrn = function(u) {
      return this.clone().ishrn(u);
    }, i.prototype.ushrn = function(u) {
      return this.clone().iushrn(u);
    }, i.prototype.testn = function(u) {
      r(typeof u == "number" && u >= 0);
      var p = u % 26, d = (u - p) / 26, y = 1 << p;
      if (this.length <= d) return false;
      var w = this.words[d];
      return !!(w & y);
    }, i.prototype.imaskn = function(u) {
      r(typeof u == "number" && u >= 0);
      var p = u % 26, d = (u - p) / 26;
      if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= d) return this;
      if (p !== 0 && d++, this.length = Math.min(d, this.length), p !== 0) {
        var y = 67108863 ^ 67108863 >>> p << p;
        this.words[this.length - 1] &= y;
      }
      return this.strip();
    }, i.prototype.maskn = function(u) {
      return this.clone().imaskn(u);
    }, i.prototype.iaddn = function(u) {
      return r(typeof u == "number"), r(u < 67108864), u < 0 ? this.isubn(-u) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < u ? (this.words[0] = u - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(u), this.negative = 1, this) : this._iaddn(u);
    }, i.prototype._iaddn = function(u) {
      this.words[0] += u;
      for (var p = 0; p < this.length && this.words[p] >= 67108864; p++) this.words[p] -= 67108864, p === this.length - 1 ? this.words[p + 1] = 1 : this.words[p + 1]++;
      return this.length = Math.max(this.length, p + 1), this;
    }, i.prototype.isubn = function(u) {
      if (r(typeof u == "number"), r(u < 67108864), u < 0) return this.iaddn(-u);
      if (this.negative !== 0) return this.negative = 0, this.iaddn(u), this.negative = 1, this;
      if (this.words[0] -= u, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
      else for (var p = 0; p < this.length && this.words[p] < 0; p++) this.words[p] += 67108864, this.words[p + 1] -= 1;
      return this.strip();
    }, i.prototype.addn = function(u) {
      return this.clone().iaddn(u);
    }, i.prototype.subn = function(u) {
      return this.clone().isubn(u);
    }, i.prototype.iabs = function() {
      return this.negative = 0, this;
    }, i.prototype.abs = function() {
      return this.clone().iabs();
    }, i.prototype._ishlnsubmul = function(u, p, d) {
      var y = u.length + d, w;
      this._expand(y);
      var E, M = 0;
      for (w = 0; w < u.length; w++) {
        E = (this.words[w + d] | 0) + M;
        var x = (u.words[w] | 0) * p;
        E -= x & 67108863, M = (E >> 26) - (x / 67108864 | 0), this.words[w + d] = E & 67108863;
      }
      for (; w < this.length - d; w++) E = (this.words[w + d] | 0) + M, M = E >> 26, this.words[w + d] = E & 67108863;
      if (M === 0) return this.strip();
      for (r(M === -1), M = 0, w = 0; w < this.length; w++) E = -(this.words[w] | 0) + M, M = E >> 26, this.words[w] = E & 67108863;
      return this.negative = 1, this.strip();
    }, i.prototype._wordDiv = function(u, p) {
      var d = this.length - u.length, y = this.clone(), w = u, E = w.words[w.length - 1] | 0, M = this._countBits(E);
      d = 26 - M, d !== 0 && (w = w.ushln(d), y.iushln(d), E = w.words[w.length - 1] | 0);
      var x = y.length - w.length, g;
      if (p !== "mod") {
        g = new i(null), g.length = x + 1, g.words = new Array(g.length);
        for (var k = 0; k < g.length; k++) g.words[k] = 0;
      }
      var T = y.clone()._ishlnsubmul(w, 1, x);
      T.negative === 0 && (y = T, g && (g.words[x] = 1));
      for (var O = x - 1; O >= 0; O--) {
        var K = (y.words[w.length + O] | 0) * 67108864 + (y.words[w.length + O - 1] | 0);
        for (K = Math.min(K / E | 0, 67108863), y._ishlnsubmul(w, K, O); y.negative !== 0; ) K--, y.negative = 0, y._ishlnsubmul(w, 1, O), y.isZero() || (y.negative ^= 1);
        g && (g.words[O] = K);
      }
      return g && g.strip(), y.strip(), p !== "div" && d !== 0 && y.iushrn(d), { div: g || null, mod: y };
    }, i.prototype.divmod = function(u, p, d) {
      if (r(!u.isZero()), this.isZero()) return { div: new i(0), mod: new i(0) };
      var y, w, E;
      return this.negative !== 0 && u.negative === 0 ? (E = this.neg().divmod(u, p), p !== "mod" && (y = E.div.neg()), p !== "div" && (w = E.mod.neg(), d && w.negative !== 0 && w.iadd(u)), { div: y, mod: w }) : this.negative === 0 && u.negative !== 0 ? (E = this.divmod(u.neg(), p), p !== "mod" && (y = E.div.neg()), { div: y, mod: E.mod }) : this.negative & u.negative ? (E = this.neg().divmod(u.neg(), p), p !== "div" && (w = E.mod.neg(), d && w.negative !== 0 && w.isub(u)), { div: E.div, mod: w }) : u.length > this.length || this.cmp(u) < 0 ? { div: new i(0), mod: this } : u.length === 1 ? p === "div" ? { div: this.divn(u.words[0]), mod: null } : p === "mod" ? { div: null, mod: new i(this.modn(u.words[0])) } : { div: this.divn(u.words[0]), mod: new i(this.modn(u.words[0])) } : this._wordDiv(u, p);
    }, i.prototype.div = function(u) {
      return this.divmod(u, "div", false).div;
    }, i.prototype.mod = function(u) {
      return this.divmod(u, "mod", false).mod;
    }, i.prototype.umod = function(u) {
      return this.divmod(u, "mod", true).mod;
    }, i.prototype.divRound = function(u) {
      var p = this.divmod(u);
      if (p.mod.isZero()) return p.div;
      var d = p.div.negative !== 0 ? p.mod.isub(u) : p.mod, y = u.ushrn(1), w = u.andln(1), E = d.cmp(y);
      return E < 0 || w === 1 && E === 0 ? p.div : p.div.negative !== 0 ? p.div.isubn(1) : p.div.iaddn(1);
    }, i.prototype.modn = function(u) {
      r(u <= 67108863);
      for (var p = (1 << 26) % u, d = 0, y = this.length - 1; y >= 0; y--) d = (p * d + (this.words[y] | 0)) % u;
      return d;
    }, i.prototype.idivn = function(u) {
      r(u <= 67108863);
      for (var p = 0, d = this.length - 1; d >= 0; d--) {
        var y = (this.words[d] | 0) + p * 67108864;
        this.words[d] = y / u | 0, p = y % u;
      }
      return this.strip();
    }, i.prototype.divn = function(u) {
      return this.clone().idivn(u);
    }, i.prototype.egcd = function(u) {
      r(u.negative === 0), r(!u.isZero());
      var p = this, d = u.clone();
      p.negative !== 0 ? p = p.umod(u) : p = p.clone();
      for (var y = new i(1), w = new i(0), E = new i(0), M = new i(1), x = 0; p.isEven() && d.isEven(); ) p.iushrn(1), d.iushrn(1), ++x;
      for (var g = d.clone(), k = p.clone(); !p.isZero(); ) {
        for (var T = 0, O = 1; !(p.words[0] & O) && T < 26; ++T, O <<= 1) ;
        if (T > 0) for (p.iushrn(T); T-- > 0; ) (y.isOdd() || w.isOdd()) && (y.iadd(g), w.isub(k)), y.iushrn(1), w.iushrn(1);
        for (var K = 0, Y = 1; !(d.words[0] & Y) && K < 26; ++K, Y <<= 1) ;
        if (K > 0) for (d.iushrn(K); K-- > 0; ) (E.isOdd() || M.isOdd()) && (E.iadd(g), M.isub(k)), E.iushrn(1), M.iushrn(1);
        p.cmp(d) >= 0 ? (p.isub(d), y.isub(E), w.isub(M)) : (d.isub(p), E.isub(y), M.isub(w));
      }
      return { a: E, b: M, gcd: d.iushln(x) };
    }, i.prototype._invmp = function(u) {
      r(u.negative === 0), r(!u.isZero());
      var p = this, d = u.clone();
      p.negative !== 0 ? p = p.umod(u) : p = p.clone();
      for (var y = new i(1), w = new i(0), E = d.clone(); p.cmpn(1) > 0 && d.cmpn(1) > 0; ) {
        for (var M = 0, x = 1; !(p.words[0] & x) && M < 26; ++M, x <<= 1) ;
        if (M > 0) for (p.iushrn(M); M-- > 0; ) y.isOdd() && y.iadd(E), y.iushrn(1);
        for (var g = 0, k = 1; !(d.words[0] & k) && g < 26; ++g, k <<= 1) ;
        if (g > 0) for (d.iushrn(g); g-- > 0; ) w.isOdd() && w.iadd(E), w.iushrn(1);
        p.cmp(d) >= 0 ? (p.isub(d), y.isub(w)) : (d.isub(p), w.isub(y));
      }
      var T;
      return p.cmpn(1) === 0 ? T = y : T = w, T.cmpn(0) < 0 && T.iadd(u), T;
    }, i.prototype.gcd = function(u) {
      if (this.isZero()) return u.abs();
      if (u.isZero()) return this.abs();
      var p = this.clone(), d = u.clone();
      p.negative = 0, d.negative = 0;
      for (var y = 0; p.isEven() && d.isEven(); y++) p.iushrn(1), d.iushrn(1);
      do {
        for (; p.isEven(); ) p.iushrn(1);
        for (; d.isEven(); ) d.iushrn(1);
        var w = p.cmp(d);
        if (w < 0) {
          var E = p;
          p = d, d = E;
        } else if (w === 0 || d.cmpn(1) === 0) break;
        p.isub(d);
      } while (true);
      return d.iushln(y);
    }, i.prototype.invm = function(u) {
      return this.egcd(u).a.umod(u);
    }, i.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, i.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, i.prototype.andln = function(u) {
      return this.words[0] & u;
    }, i.prototype.bincn = function(u) {
      r(typeof u == "number");
      var p = u % 26, d = (u - p) / 26, y = 1 << p;
      if (this.length <= d) return this._expand(d + 1), this.words[d] |= y, this;
      for (var w = y, E = d; w !== 0 && E < this.length; E++) {
        var M = this.words[E] | 0;
        M += w, w = M >>> 26, M &= 67108863, this.words[E] = M;
      }
      return w !== 0 && (this.words[E] = w, this.length++), this;
    }, i.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, i.prototype.cmpn = function(u) {
      var p = u < 0;
      if (this.negative !== 0 && !p) return -1;
      if (this.negative === 0 && p) return 1;
      this.strip();
      var d;
      if (this.length > 1) d = 1;
      else {
        p && (u = -u), r(u <= 67108863, "Number is too big");
        var y = this.words[0] | 0;
        d = y === u ? 0 : y < u ? -1 : 1;
      }
      return this.negative !== 0 ? -d | 0 : d;
    }, i.prototype.cmp = function(u) {
      if (this.negative !== 0 && u.negative === 0) return -1;
      if (this.negative === 0 && u.negative !== 0) return 1;
      var p = this.ucmp(u);
      return this.negative !== 0 ? -p | 0 : p;
    }, i.prototype.ucmp = function(u) {
      if (this.length > u.length) return 1;
      if (this.length < u.length) return -1;
      for (var p = 0, d = this.length - 1; d >= 0; d--) {
        var y = this.words[d] | 0, w = u.words[d] | 0;
        if (y !== w) {
          y < w ? p = -1 : y > w && (p = 1);
          break;
        }
      }
      return p;
    }, i.prototype.gtn = function(u) {
      return this.cmpn(u) === 1;
    }, i.prototype.gt = function(u) {
      return this.cmp(u) === 1;
    }, i.prototype.gten = function(u) {
      return this.cmpn(u) >= 0;
    }, i.prototype.gte = function(u) {
      return this.cmp(u) >= 0;
    }, i.prototype.ltn = function(u) {
      return this.cmpn(u) === -1;
    }, i.prototype.lt = function(u) {
      return this.cmp(u) === -1;
    }, i.prototype.lten = function(u) {
      return this.cmpn(u) <= 0;
    }, i.prototype.lte = function(u) {
      return this.cmp(u) <= 0;
    }, i.prototype.eqn = function(u) {
      return this.cmpn(u) === 0;
    }, i.prototype.eq = function(u) {
      return this.cmp(u) === 0;
    }, i.red = function(u) {
      return new N(u);
    }, i.prototype.toRed = function(u) {
      return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), u.convertTo(this)._forceRed(u);
    }, i.prototype.fromRed = function() {
      return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, i.prototype._forceRed = function(u) {
      return this.red = u, this;
    }, i.prototype.forceRed = function(u) {
      return r(!this.red, "Already a number in reduction context"), this._forceRed(u);
    }, i.prototype.redAdd = function(u) {
      return r(this.red, "redAdd works only with red numbers"), this.red.add(this, u);
    }, i.prototype.redIAdd = function(u) {
      return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, u);
    }, i.prototype.redSub = function(u) {
      return r(this.red, "redSub works only with red numbers"), this.red.sub(this, u);
    }, i.prototype.redISub = function(u) {
      return r(this.red, "redISub works only with red numbers"), this.red.isub(this, u);
    }, i.prototype.redShl = function(u) {
      return r(this.red, "redShl works only with red numbers"), this.red.shl(this, u);
    }, i.prototype.redMul = function(u) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, u), this.red.mul(this, u);
    }, i.prototype.redIMul = function(u) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, u), this.red.imul(this, u);
    }, i.prototype.redSqr = function() {
      return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, i.prototype.redISqr = function() {
      return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, i.prototype.redSqrt = function() {
      return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, i.prototype.redInvm = function() {
      return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, i.prototype.redNeg = function() {
      return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, i.prototype.redPow = function(u) {
      return r(this.red && !u.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, u);
    };
    var S = { k256: null, p224: null, p192: null, p25519: null };
    function $(B, u) {
      this.name = B, this.p = new i(u, 16), this.n = this.p.bitLength(), this.k = new i(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    $.prototype._tmp = function() {
      var u = new i(null);
      return u.words = new Array(Math.ceil(this.n / 13)), u;
    }, $.prototype.ireduce = function(u) {
      var p = u, d;
      do
        this.split(p, this.tmp), p = this.imulK(p), p = p.iadd(this.tmp), d = p.bitLength();
      while (d > this.n);
      var y = d < this.n ? -1 : p.ucmp(this.p);
      return y === 0 ? (p.words[0] = 0, p.length = 1) : y > 0 ? p.isub(this.p) : p.strip !== void 0 ? p.strip() : p._strip(), p;
    }, $.prototype.split = function(u, p) {
      u.iushrn(this.n, 0, p);
    }, $.prototype.imulK = function(u) {
      return u.imul(this.k);
    };
    function F() {
      $.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    s(F, $), F.prototype.split = function(u, p) {
      for (var d = 4194303, y = Math.min(u.length, 9), w = 0; w < y; w++) p.words[w] = u.words[w];
      if (p.length = y, u.length <= 9) {
        u.words[0] = 0, u.length = 1;
        return;
      }
      var E = u.words[9];
      for (p.words[p.length++] = E & d, w = 10; w < u.length; w++) {
        var M = u.words[w] | 0;
        u.words[w - 10] = (M & d) << 4 | E >>> 22, E = M;
      }
      E >>>= 22, u.words[w - 10] = E, E === 0 && u.length > 10 ? u.length -= 10 : u.length -= 9;
    }, F.prototype.imulK = function(u) {
      u.words[u.length] = 0, u.words[u.length + 1] = 0, u.length += 2;
      for (var p = 0, d = 0; d < u.length; d++) {
        var y = u.words[d] | 0;
        p += y * 977, u.words[d] = p & 67108863, p = y * 64 + (p / 67108864 | 0);
      }
      return u.words[u.length - 1] === 0 && (u.length--, u.words[u.length - 1] === 0 && u.length--), u;
    };
    function U() {
      $.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    s(U, $);
    function Q() {
      $.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    s(Q, $);
    function P() {
      $.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    s(P, $), P.prototype.imulK = function(u) {
      for (var p = 0, d = 0; d < u.length; d++) {
        var y = (u.words[d] | 0) * 19 + p, w = y & 67108863;
        y >>>= 26, u.words[d] = w, p = y;
      }
      return p !== 0 && (u.words[u.length++] = p), u;
    }, i._prime = function(u) {
      if (S[u]) return S[u];
      var p;
      if (u === "k256") p = new F();
      else if (u === "p224") p = new U();
      else if (u === "p192") p = new Q();
      else if (u === "p25519") p = new P();
      else throw new Error("Unknown prime " + u);
      return S[u] = p, p;
    };
    function N(B) {
      if (typeof B == "string") {
        var u = i._prime(B);
        this.m = u.p, this.prime = u;
      } else r(B.gtn(1), "modulus must be greater than 1"), this.m = B, this.prime = null;
    }
    N.prototype._verify1 = function(u) {
      r(u.negative === 0, "red works only with positives"), r(u.red, "red works only with red numbers");
    }, N.prototype._verify2 = function(u, p) {
      r((u.negative | p.negative) === 0, "red works only with positives"), r(u.red && u.red === p.red, "red works only with red numbers");
    }, N.prototype.imod = function(u) {
      return this.prime ? this.prime.ireduce(u)._forceRed(this) : u.umod(this.m)._forceRed(this);
    }, N.prototype.neg = function(u) {
      return u.isZero() ? u.clone() : this.m.sub(u)._forceRed(this);
    }, N.prototype.add = function(u, p) {
      this._verify2(u, p);
      var d = u.add(p);
      return d.cmp(this.m) >= 0 && d.isub(this.m), d._forceRed(this);
    }, N.prototype.iadd = function(u, p) {
      this._verify2(u, p);
      var d = u.iadd(p);
      return d.cmp(this.m) >= 0 && d.isub(this.m), d;
    }, N.prototype.sub = function(u, p) {
      this._verify2(u, p);
      var d = u.sub(p);
      return d.cmpn(0) < 0 && d.iadd(this.m), d._forceRed(this);
    }, N.prototype.isub = function(u, p) {
      this._verify2(u, p);
      var d = u.isub(p);
      return d.cmpn(0) < 0 && d.iadd(this.m), d;
    }, N.prototype.shl = function(u, p) {
      return this._verify1(u), this.imod(u.ushln(p));
    }, N.prototype.imul = function(u, p) {
      return this._verify2(u, p), this.imod(u.imul(p));
    }, N.prototype.mul = function(u, p) {
      return this._verify2(u, p), this.imod(u.mul(p));
    }, N.prototype.isqr = function(u) {
      return this.imul(u, u.clone());
    }, N.prototype.sqr = function(u) {
      return this.mul(u, u);
    }, N.prototype.sqrt = function(u) {
      if (u.isZero()) return u.clone();
      var p = this.m.andln(3);
      if (r(p % 2 === 1), p === 3) {
        var d = this.m.add(new i(1)).iushrn(2);
        return this.pow(u, d);
      }
      for (var y = this.m.subn(1), w = 0; !y.isZero() && y.andln(1) === 0; ) w++, y.iushrn(1);
      r(!y.isZero());
      var E = new i(1).toRed(this), M = E.redNeg(), x = this.m.subn(1).iushrn(1), g = this.m.bitLength();
      for (g = new i(2 * g * g).toRed(this); this.pow(g, x).cmp(M) !== 0; ) g.redIAdd(M);
      for (var k = this.pow(g, y), T = this.pow(u, y.addn(1).iushrn(1)), O = this.pow(u, y), K = w; O.cmp(E) !== 0; ) {
        for (var Y = O, J = 0; Y.cmp(E) !== 0; J++) Y = Y.redSqr();
        r(J < K);
        var G = this.pow(k, new i(1).iushln(K - J - 1));
        T = T.redMul(G), k = G.redSqr(), O = O.redMul(k), K = J;
      }
      return T;
    }, N.prototype.invm = function(u) {
      var p = u._invmp(this.m);
      return p.negative !== 0 ? (p.negative = 0, this.imod(p).redNeg()) : this.imod(p);
    }, N.prototype.pow = function(u, p) {
      if (p.isZero()) return new i(1).toRed(this);
      if (p.cmpn(1) === 0) return u.clone();
      var d = 4, y = new Array(1 << d);
      y[0] = new i(1).toRed(this), y[1] = u;
      for (var w = 2; w < y.length; w++) y[w] = this.mul(y[w - 1], u);
      var E = y[0], M = 0, x = 0, g = p.bitLength() % 26;
      for (g === 0 && (g = 26), w = p.length - 1; w >= 0; w--) {
        for (var k = p.words[w], T = g - 1; T >= 0; T--) {
          var O = k >> T & 1;
          if (E !== y[0] && (E = this.sqr(E)), O === 0 && M === 0) {
            x = 0;
            continue;
          }
          M <<= 1, M |= O, x++, !(x !== d && (w !== 0 || T !== 0)) && (E = this.mul(E, y[M]), x = 0, M = 0);
        }
        g = 26;
      }
      return E;
    }, N.prototype.convertTo = function(u) {
      var p = u.umod(this.m);
      return p === u ? p.clone() : p;
    }, N.prototype.convertFrom = function(u) {
      var p = u.clone();
      return p.red = null, p;
    }, i.mont = function(u) {
      return new L(u);
    };
    function L(B) {
      N.call(this, B), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new i(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    s(L, N), L.prototype.convertTo = function(u) {
      return this.imod(u.ushln(this.shift));
    }, L.prototype.convertFrom = function(u) {
      var p = this.imod(u.mul(this.rinv));
      return p.red = null, p;
    }, L.prototype.imul = function(u, p) {
      if (u.isZero() || p.isZero()) return u.words[0] = 0, u.length = 1, u;
      var d = u.imul(p), y = d.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = d.isub(y).iushrn(this.shift), E = w;
      return w.cmp(this.m) >= 0 ? E = w.isub(this.m) : w.cmpn(0) < 0 && (E = w.iadd(this.m)), E._forceRed(this);
    }, L.prototype.mul = function(u, p) {
      if (u.isZero() || p.isZero()) return new i(0)._forceRed(this);
      var d = u.mul(p), y = d.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = d.isub(y).iushrn(this.shift), E = w;
      return w.cmp(this.m) >= 0 ? E = w.isub(this.m) : w.cmpn(0) < 0 && (E = w.iadd(this.m)), E._forceRed(this);
    }, L.prototype.invm = function(u) {
      var p = this.imod(u._invmp(this.m).mul(this.r2));
      return p._forceRed(this);
    };
  })(t3, mt);
})(WA);
var gf = WA.exports, JA = {};
(function(t3) {
  var e = t3;
  function n(i, a) {
    if (Array.isArray(i)) return i.slice();
    if (!i) return [];
    var o = [];
    if (typeof i != "string") {
      for (var f = 0; f < i.length; f++) o[f] = i[f] | 0;
      return o;
    }
    if (a === "hex") {
      i = i.replace(/[^a-z0-9]+/ig, ""), i.length % 2 !== 0 && (i = "0" + i);
      for (var f = 0; f < i.length; f += 2) o.push(parseInt(i[f] + i[f + 1], 16));
    } else for (var f = 0; f < i.length; f++) {
      var c = i.charCodeAt(f), l = c >> 8, h = c & 255;
      l ? o.push(l, h) : o.push(h);
    }
    return o;
  }
  e.toArray = n;
  function r(i) {
    return i.length === 1 ? "0" + i : i;
  }
  e.zero2 = r;
  function s(i) {
    for (var a = "", o = 0; o < i.length; o++) a += r(i[o].toString(16));
    return a;
  }
  e.toHex = s, e.encode = function(a, o) {
    return o === "hex" ? s(a) : a;
  };
})(JA);
(function(t3) {
  var e = t3, n = gf, r = ha, s = JA;
  e.assert = r, e.toArray = s.toArray, e.zero2 = s.zero2, e.toHex = s.toHex, e.encode = s.encode;
  function i(l, h, m) {
    var v = new Array(Math.max(l.bitLength(), m) + 1), b;
    for (b = 0; b < v.length; b += 1) v[b] = 0;
    var A = 1 << h + 1, _ = l.clone();
    for (b = 0; b < v.length; b++) {
      var C, I = _.andln(A - 1);
      _.isOdd() ? (I > (A >> 1) - 1 ? C = (A >> 1) - I : C = I, _.isubn(C)) : C = 0, v[b] = C, _.iushrn(1);
    }
    return v;
  }
  e.getNAF = i;
  function a(l, h) {
    var m = [[], []];
    l = l.clone(), h = h.clone();
    for (var v = 0, b = 0, A; l.cmpn(-v) > 0 || h.cmpn(-b) > 0; ) {
      var _ = l.andln(3) + v & 3, C = h.andln(3) + b & 3;
      _ === 3 && (_ = -1), C === 3 && (C = -1);
      var I;
      _ & 1 ? (A = l.andln(7) + v & 7, (A === 3 || A === 5) && C === 2 ? I = -_ : I = _) : I = 0, m[0].push(I);
      var S;
      C & 1 ? (A = h.andln(7) + b & 7, (A === 3 || A === 5) && _ === 2 ? S = -C : S = C) : S = 0, m[1].push(S), 2 * v === I + 1 && (v = 1 - v), 2 * b === S + 1 && (b = 1 - b), l.iushrn(1), h.iushrn(1);
    }
    return m;
  }
  e.getJSF = a;
  function o(l, h, m) {
    var v = "_" + h;
    l.prototype[h] = function() {
      return this[v] !== void 0 ? this[v] : this[v] = m.call(this);
    };
  }
  e.cachedProperty = o;
  function f(l) {
    return typeof l == "string" ? e.toArray(l, "hex") : l;
  }
  e.parseBytes = f;
  function c(l) {
    return new n(l, "hex", "le");
  }
  e.intFromLE = c;
})(Gs);
var ZA = {}, Tl = gf, _d = Gs, I1 = _d.getNAF, VW = _d.getJSF, S1 = _d.assert;
function ml(t3, e) {
  this.type = t3, this.p = new Tl(e.p, 16), this.red = e.prime ? Tl.red(e.prime) : Tl.mont(this.p), this.zero = new Tl(0).toRed(this.red), this.one = new Tl(1).toRed(this.red), this.two = new Tl(2).toRed(this.red), this.n = e.n && new Tl(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var n = this.n && this.p.div(this.n);
  !n || n.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = true, this.redN = this.n.toRed(this.red));
}
var Xg = ml;
ml.prototype.point = function() {
  throw new Error("Not implemented");
};
ml.prototype.validate = function() {
  throw new Error("Not implemented");
};
ml.prototype._fixedNafMul = function(e, n) {
  S1(e.precomputed);
  var r = e._getDoubles(), s = I1(n, 1, this._bitLength), i = (1 << r.step + 1) - (r.step % 2 === 0 ? 2 : 1);
  i /= 3;
  var a = [], o, f;
  for (o = 0; o < s.length; o += r.step) {
    f = 0;
    for (var c = o + r.step - 1; c >= o; c--) f = (f << 1) + s[c];
    a.push(f);
  }
  for (var l = this.jpoint(null, null, null), h = this.jpoint(null, null, null), m = i; m > 0; m--) {
    for (o = 0; o < a.length; o++) f = a[o], f === m ? h = h.mixedAdd(r.points[o]) : f === -m && (h = h.mixedAdd(r.points[o].neg()));
    l = l.add(h);
  }
  return l.toP();
};
ml.prototype._wnafMul = function(e, n) {
  var r = 4, s = e._getNAFPoints(r);
  r = s.wnd;
  for (var i = s.points, a = I1(n, r, this._bitLength), o = this.jpoint(null, null, null), f = a.length - 1; f >= 0; f--) {
    for (var c = 0; f >= 0 && a[f] === 0; f--) c++;
    if (f >= 0 && c++, o = o.dblp(c), f < 0) break;
    var l = a[f];
    S1(l !== 0), e.type === "affine" ? l > 0 ? o = o.mixedAdd(i[l - 1 >> 1]) : o = o.mixedAdd(i[-l - 1 >> 1].neg()) : l > 0 ? o = o.add(i[l - 1 >> 1]) : o = o.add(i[-l - 1 >> 1].neg());
  }
  return e.type === "affine" ? o.toP() : o;
};
ml.prototype._wnafMulAdd = function(e, n, r, s, i) {
  var a = this._wnafT1, o = this._wnafT2, f = this._wnafT3, c = 0, l, h, m;
  for (l = 0; l < s; l++) {
    m = n[l];
    var v = m._getNAFPoints(e);
    a[l] = v.wnd, o[l] = v.points;
  }
  for (l = s - 1; l >= 1; l -= 2) {
    var b = l - 1, A = l;
    if (a[b] !== 1 || a[A] !== 1) {
      f[b] = I1(r[b], a[b], this._bitLength), f[A] = I1(r[A], a[A], this._bitLength), c = Math.max(f[b].length, c), c = Math.max(f[A].length, c);
      continue;
    }
    var _ = [n[b], null, null, n[A]];
    n[b].y.cmp(n[A].y) === 0 ? (_[1] = n[b].add(n[A]), _[2] = n[b].toJ().mixedAdd(n[A].neg())) : n[b].y.cmp(n[A].y.redNeg()) === 0 ? (_[1] = n[b].toJ().mixedAdd(n[A]), _[2] = n[b].add(n[A].neg())) : (_[1] = n[b].toJ().mixedAdd(n[A]), _[2] = n[b].toJ().mixedAdd(n[A].neg()));
    var C = [-3, -1, -5, -7, 0, 7, 5, 1, 3], I = VW(r[b], r[A]);
    for (c = Math.max(I[0].length, c), f[b] = new Array(c), f[A] = new Array(c), h = 0; h < c; h++) {
      var S = I[0][h] | 0, $ = I[1][h] | 0;
      f[b][h] = C[(S + 1) * 3 + ($ + 1)], f[A][h] = 0, o[b] = _;
    }
  }
  var F = this.jpoint(null, null, null), U = this._wnafT4;
  for (l = c; l >= 0; l--) {
    for (var Q = 0; l >= 0; ) {
      var P = true;
      for (h = 0; h < s; h++) U[h] = f[h][l] | 0, U[h] !== 0 && (P = false);
      if (!P) break;
      Q++, l--;
    }
    if (l >= 0 && Q++, F = F.dblp(Q), l < 0) break;
    for (h = 0; h < s; h++) {
      var N = U[h];
      N !== 0 && (N > 0 ? m = o[h][N - 1 >> 1] : N < 0 && (m = o[h][-N - 1 >> 1].neg()), m.type === "affine" ? F = F.mixedAdd(m) : F = F.add(m));
    }
  }
  for (l = 0; l < s; l++) o[l] = null;
  return i ? F : F.toP();
};
function pa(t3, e) {
  this.curve = t3, this.type = e, this.precomputed = null;
}
ml.BasePoint = pa;
pa.prototype.eq = function() {
  throw new Error("Not implemented");
};
pa.prototype.validate = function() {
  return this.curve.validate(this);
};
ml.prototype.decodePoint = function(e, n) {
  e = _d.toArray(e, n);
  var r = this.p.byteLength();
  if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * r) {
    e[0] === 6 ? S1(e[e.length - 1] % 2 === 0) : e[0] === 7 && S1(e[e.length - 1] % 2 === 1);
    var s = this.point(e.slice(1, 1 + r), e.slice(1 + r, 1 + 2 * r));
    return s;
  } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === r) return this.pointFromX(e.slice(1, 1 + r), e[0] === 3);
  throw new Error("Unknown point format");
};
pa.prototype.encodeCompressed = function(e) {
  return this.encode(e, true);
};
pa.prototype._encode = function(e) {
  var n = this.curve.p.byteLength(), r = this.getX().toArray("be", n);
  return e ? [this.getY().isEven() ? 2 : 3].concat(r) : [4].concat(r, this.getY().toArray("be", n));
};
pa.prototype.encode = function(e, n) {
  return _d.encode(this._encode(n), e);
};
pa.prototype.precompute = function(e) {
  if (this.precomputed) return this;
  var n = { doubles: null, naf: null, beta: null };
  return n.naf = this._getNAFPoints(8), n.doubles = this._getDoubles(4, e), n.beta = this._getBeta(), this.precomputed = n, this;
};
pa.prototype._hasDoubles = function(e) {
  if (!this.precomputed) return false;
  var n = this.precomputed.doubles;
  return n ? n.points.length >= Math.ceil((e.bitLength() + 1) / n.step) : false;
};
pa.prototype._getDoubles = function(e, n) {
  if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
  for (var r = [this], s = this, i = 0; i < n; i += e) {
    for (var a = 0; a < e; a++) s = s.dbl();
    r.push(s);
  }
  return { step: e, points: r };
};
pa.prototype._getNAFPoints = function(e) {
  if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
  for (var n = [this], r = (1 << e) - 1, s = r === 1 ? null : this.dbl(), i = 1; i < r; i++) n[i] = n[i - 1].add(s);
  return { wnd: e, points: n };
};
pa.prototype._getBeta = function() {
  return null;
};
pa.prototype.dblp = function(e) {
  for (var n = this, r = 0; r < e; r++) n = n.dbl();
  return n;
};
var YW = Gs, zn = gf, jA = wr, tc = Xg, WW = YW.assert;
function ga(t3) {
  tc.call(this, "short", t3), this.a = new zn(t3.a, 16).toRed(this.red), this.b = new zn(t3.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(t3), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
jA(ga, tc);
var JW = ga;
ga.prototype._getEndomorphism = function(e) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var n, r;
    if (e.beta) n = new zn(e.beta, 16).toRed(this.red);
    else {
      var s = this._getEndoRoots(this.p);
      n = s[0].cmp(s[1]) < 0 ? s[0] : s[1], n = n.toRed(this.red);
    }
    if (e.lambda) r = new zn(e.lambda, 16);
    else {
      var i = this._getEndoRoots(this.n);
      this.g.mul(i[0]).x.cmp(this.g.x.redMul(n)) === 0 ? r = i[0] : (r = i[1], WW(this.g.mul(r).x.cmp(this.g.x.redMul(n)) === 0));
    }
    var a;
    return e.basis ? a = e.basis.map(function(o) {
      return { a: new zn(o.a, 16), b: new zn(o.b, 16) };
    }) : a = this._getEndoBasis(r), { beta: n, lambda: r, basis: a };
  }
};
ga.prototype._getEndoRoots = function(e) {
  var n = e === this.p ? this.red : zn.mont(e), r = new zn(2).toRed(n).redInvm(), s = r.redNeg(), i = new zn(3).toRed(n).redNeg().redSqrt().redMul(r), a = s.redAdd(i).fromRed(), o = s.redSub(i).fromRed();
  return [a, o];
};
ga.prototype._getEndoBasis = function(e) {
  for (var n = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), r = e, s = this.n.clone(), i = new zn(1), a = new zn(0), o = new zn(0), f = new zn(1), c, l, h, m, v, b, A, _ = 0, C, I; r.cmpn(0) !== 0; ) {
    var S = s.div(r);
    C = s.sub(S.mul(r)), I = o.sub(S.mul(i));
    var $ = f.sub(S.mul(a));
    if (!h && C.cmp(n) < 0) c = A.neg(), l = i, h = C.neg(), m = I;
    else if (h && ++_ === 2) break;
    A = C, s = r, r = C, o = i, i = I, f = a, a = $;
  }
  v = C.neg(), b = I;
  var F = h.sqr().add(m.sqr()), U = v.sqr().add(b.sqr());
  return U.cmp(F) >= 0 && (v = c, b = l), h.negative && (h = h.neg(), m = m.neg()), v.negative && (v = v.neg(), b = b.neg()), [{ a: h, b: m }, { a: v, b }];
};
ga.prototype._endoSplit = function(e) {
  var n = this.endo.basis, r = n[0], s = n[1], i = s.b.mul(e).divRound(this.n), a = r.b.neg().mul(e).divRound(this.n), o = i.mul(r.a), f = a.mul(s.a), c = i.mul(r.b), l = a.mul(s.b), h = e.sub(o).sub(f), m = c.add(l).neg();
  return { k1: h, k2: m };
};
ga.prototype.pointFromX = function(e, n) {
  e = new zn(e, 16), e.red || (e = e.toRed(this.red));
  var r = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), s = r.redSqrt();
  if (s.redSqr().redSub(r).cmp(this.zero) !== 0) throw new Error("invalid point");
  var i = s.fromRed().isOdd();
  return (n && !i || !n && i) && (s = s.redNeg()), this.point(e, s);
};
ga.prototype.validate = function(e) {
  if (e.inf) return true;
  var n = e.x, r = e.y, s = this.a.redMul(n), i = n.redSqr().redMul(n).redIAdd(s).redIAdd(this.b);
  return r.redSqr().redISub(i).cmpn(0) === 0;
};
ga.prototype._endoWnafMulAdd = function(e, n, r) {
  for (var s = this._endoWnafT1, i = this._endoWnafT2, a = 0; a < e.length; a++) {
    var o = this._endoSplit(n[a]), f = e[a], c = f._getBeta();
    o.k1.negative && (o.k1.ineg(), f = f.neg(true)), o.k2.negative && (o.k2.ineg(), c = c.neg(true)), s[a * 2] = f, s[a * 2 + 1] = c, i[a * 2] = o.k1, i[a * 2 + 1] = o.k2;
  }
  for (var l = this._wnafMulAdd(1, s, i, a * 2, r), h = 0; h < a * 2; h++) s[h] = null, i[h] = null;
  return l;
};
function ki(t3, e, n, r) {
  tc.BasePoint.call(this, t3, "affine"), e === null && n === null ? (this.x = null, this.y = null, this.inf = true) : (this.x = new zn(e, 16), this.y = new zn(n, 16), r && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = false);
}
jA(ki, tc.BasePoint);
ga.prototype.point = function(e, n, r) {
  return new ki(this, e, n, r);
};
ga.prototype.pointFromJSON = function(e, n) {
  return ki.fromJSON(this, e, n);
};
ki.prototype._getBeta = function() {
  if (this.curve.endo) {
    var e = this.precomputed;
    if (e && e.beta) return e.beta;
    var n = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (e) {
      var r = this.curve, s = function(i) {
        return r.point(i.x.redMul(r.endo.beta), i.y);
      };
      e.beta = n, n.precomputed = { beta: null, naf: e.naf && { wnd: e.naf.wnd, points: e.naf.points.map(s) }, doubles: e.doubles && { step: e.doubles.step, points: e.doubles.points.map(s) } };
    }
    return n;
  }
};
ki.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }] : [this.x, this.y];
};
ki.fromJSON = function(e, n, r) {
  typeof n == "string" && (n = JSON.parse(n));
  var s = e.point(n[0], n[1], r);
  if (!n[2]) return s;
  function i(o) {
    return e.point(o[0], o[1], r);
  }
  var a = n[2];
  return s.precomputed = { beta: null, doubles: a.doubles && { step: a.doubles.step, points: [s].concat(a.doubles.points.map(i)) }, naf: a.naf && { wnd: a.naf.wnd, points: [s].concat(a.naf.points.map(i)) } }, s;
};
ki.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
ki.prototype.isInfinity = function() {
  return this.inf;
};
ki.prototype.add = function(e) {
  if (this.inf) return e;
  if (e.inf) return this;
  if (this.eq(e)) return this.dbl();
  if (this.neg().eq(e)) return this.curve.point(null, null);
  if (this.x.cmp(e.x) === 0) return this.curve.point(null, null);
  var n = this.y.redSub(e.y);
  n.cmpn(0) !== 0 && (n = n.redMul(this.x.redSub(e.x).redInvm()));
  var r = n.redSqr().redISub(this.x).redISub(e.x), s = n.redMul(this.x.redSub(r)).redISub(this.y);
  return this.curve.point(r, s);
};
ki.prototype.dbl = function() {
  if (this.inf) return this;
  var e = this.y.redAdd(this.y);
  if (e.cmpn(0) === 0) return this.curve.point(null, null);
  var n = this.curve.a, r = this.x.redSqr(), s = e.redInvm(), i = r.redAdd(r).redIAdd(r).redIAdd(n).redMul(s), a = i.redSqr().redISub(this.x.redAdd(this.x)), o = i.redMul(this.x.redSub(a)).redISub(this.y);
  return this.curve.point(a, o);
};
ki.prototype.getX = function() {
  return this.x.fromRed();
};
ki.prototype.getY = function() {
  return this.y.fromRed();
};
ki.prototype.mul = function(e) {
  return e = new zn(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e);
};
ki.prototype.mulAdd = function(e, n, r) {
  var s = [this, n], i = [e, r];
  return this.curve.endo ? this.curve._endoWnafMulAdd(s, i) : this.curve._wnafMulAdd(1, s, i, 2);
};
ki.prototype.jmulAdd = function(e, n, r) {
  var s = [this, n], i = [e, r];
  return this.curve.endo ? this.curve._endoWnafMulAdd(s, i, true) : this.curve._wnafMulAdd(1, s, i, 2, true);
};
ki.prototype.eq = function(e) {
  return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
};
ki.prototype.neg = function(e) {
  if (this.inf) return this;
  var n = this.curve.point(this.x, this.y.redNeg());
  if (e && this.precomputed) {
    var r = this.precomputed, s = function(i) {
      return i.neg();
    };
    n.precomputed = { naf: r.naf && { wnd: r.naf.wnd, points: r.naf.points.map(s) }, doubles: r.doubles && { step: r.doubles.step, points: r.doubles.points.map(s) } };
  }
  return n;
};
ki.prototype.toJ = function() {
  if (this.inf) return this.curve.jpoint(null, null, null);
  var e = this.curve.jpoint(this.x, this.y, this.curve.one);
  return e;
};
function Oi(t3, e, n, r) {
  tc.BasePoint.call(this, t3, "jacobian"), e === null && n === null && r === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new zn(0)) : (this.x = new zn(e, 16), this.y = new zn(n, 16), this.z = new zn(r, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
jA(Oi, tc.BasePoint);
ga.prototype.jpoint = function(e, n, r) {
  return new Oi(this, e, n, r);
};
Oi.prototype.toP = function() {
  if (this.isInfinity()) return this.curve.point(null, null);
  var e = this.z.redInvm(), n = e.redSqr(), r = this.x.redMul(n), s = this.y.redMul(n).redMul(e);
  return this.curve.point(r, s);
};
Oi.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
Oi.prototype.add = function(e) {
  if (this.isInfinity()) return e;
  if (e.isInfinity()) return this;
  var n = e.z.redSqr(), r = this.z.redSqr(), s = this.x.redMul(n), i = e.x.redMul(r), a = this.y.redMul(n.redMul(e.z)), o = e.y.redMul(r.redMul(this.z)), f = s.redSub(i), c = a.redSub(o);
  if (f.cmpn(0) === 0) return c.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var l = f.redSqr(), h = l.redMul(f), m = s.redMul(l), v = c.redSqr().redIAdd(h).redISub(m).redISub(m), b = c.redMul(m.redISub(v)).redISub(a.redMul(h)), A = this.z.redMul(e.z).redMul(f);
  return this.curve.jpoint(v, b, A);
};
Oi.prototype.mixedAdd = function(e) {
  if (this.isInfinity()) return e.toJ();
  if (e.isInfinity()) return this;
  var n = this.z.redSqr(), r = this.x, s = e.x.redMul(n), i = this.y, a = e.y.redMul(n).redMul(this.z), o = r.redSub(s), f = i.redSub(a);
  if (o.cmpn(0) === 0) return f.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var c = o.redSqr(), l = c.redMul(o), h = r.redMul(c), m = f.redSqr().redIAdd(l).redISub(h).redISub(h), v = f.redMul(h.redISub(m)).redISub(i.redMul(l)), b = this.z.redMul(o);
  return this.curve.jpoint(m, v, b);
};
Oi.prototype.dblp = function(e) {
  if (e === 0) return this;
  if (this.isInfinity()) return this;
  if (!e) return this.dbl();
  var n;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (n = 0; n < e; n++) r = r.dbl();
    return r;
  }
  var s = this.curve.a, i = this.curve.tinv, a = this.x, o = this.y, f = this.z, c = f.redSqr().redSqr(), l = o.redAdd(o);
  for (n = 0; n < e; n++) {
    var h = a.redSqr(), m = l.redSqr(), v = m.redSqr(), b = h.redAdd(h).redIAdd(h).redIAdd(s.redMul(c)), A = a.redMul(m), _ = b.redSqr().redISub(A.redAdd(A)), C = A.redISub(_), I = b.redMul(C);
    I = I.redIAdd(I).redISub(v);
    var S = l.redMul(f);
    n + 1 < e && (c = c.redMul(v)), a = _, f = S, l = I;
  }
  return this.curve.jpoint(a, l.redMul(i), f);
};
Oi.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
Oi.prototype._zeroDbl = function() {
  var e, n, r;
  if (this.zOne) {
    var s = this.x.redSqr(), i = this.y.redSqr(), a = i.redSqr(), o = this.x.redAdd(i).redSqr().redISub(s).redISub(a);
    o = o.redIAdd(o);
    var f = s.redAdd(s).redIAdd(s), c = f.redSqr().redISub(o).redISub(o), l = a.redIAdd(a);
    l = l.redIAdd(l), l = l.redIAdd(l), e = c, n = f.redMul(o.redISub(c)).redISub(l), r = this.y.redAdd(this.y);
  } else {
    var h = this.x.redSqr(), m = this.y.redSqr(), v = m.redSqr(), b = this.x.redAdd(m).redSqr().redISub(h).redISub(v);
    b = b.redIAdd(b);
    var A = h.redAdd(h).redIAdd(h), _ = A.redSqr(), C = v.redIAdd(v);
    C = C.redIAdd(C), C = C.redIAdd(C), e = _.redISub(b).redISub(b), n = A.redMul(b.redISub(e)).redISub(C), r = this.y.redMul(this.z), r = r.redIAdd(r);
  }
  return this.curve.jpoint(e, n, r);
};
Oi.prototype._threeDbl = function() {
  var e, n, r;
  if (this.zOne) {
    var s = this.x.redSqr(), i = this.y.redSqr(), a = i.redSqr(), o = this.x.redAdd(i).redSqr().redISub(s).redISub(a);
    o = o.redIAdd(o);
    var f = s.redAdd(s).redIAdd(s).redIAdd(this.curve.a), c = f.redSqr().redISub(o).redISub(o);
    e = c;
    var l = a.redIAdd(a);
    l = l.redIAdd(l), l = l.redIAdd(l), n = f.redMul(o.redISub(c)).redISub(l), r = this.y.redAdd(this.y);
  } else {
    var h = this.z.redSqr(), m = this.y.redSqr(), v = this.x.redMul(m), b = this.x.redSub(h).redMul(this.x.redAdd(h));
    b = b.redAdd(b).redIAdd(b);
    var A = v.redIAdd(v);
    A = A.redIAdd(A);
    var _ = A.redAdd(A);
    e = b.redSqr().redISub(_), r = this.y.redAdd(this.z).redSqr().redISub(m).redISub(h);
    var C = m.redSqr();
    C = C.redIAdd(C), C = C.redIAdd(C), C = C.redIAdd(C), n = b.redMul(A.redISub(e)).redISub(C);
  }
  return this.curve.jpoint(e, n, r);
};
Oi.prototype._dbl = function() {
  var e = this.curve.a, n = this.x, r = this.y, s = this.z, i = s.redSqr().redSqr(), a = n.redSqr(), o = r.redSqr(), f = a.redAdd(a).redIAdd(a).redIAdd(e.redMul(i)), c = n.redAdd(n);
  c = c.redIAdd(c);
  var l = c.redMul(o), h = f.redSqr().redISub(l.redAdd(l)), m = l.redISub(h), v = o.redSqr();
  v = v.redIAdd(v), v = v.redIAdd(v), v = v.redIAdd(v);
  var b = f.redMul(m).redISub(v), A = r.redAdd(r).redMul(s);
  return this.curve.jpoint(h, b, A);
};
Oi.prototype.trpl = function() {
  if (!this.curve.zeroA) return this.dbl().add(this);
  var e = this.x.redSqr(), n = this.y.redSqr(), r = this.z.redSqr(), s = n.redSqr(), i = e.redAdd(e).redIAdd(e), a = i.redSqr(), o = this.x.redAdd(n).redSqr().redISub(e).redISub(s);
  o = o.redIAdd(o), o = o.redAdd(o).redIAdd(o), o = o.redISub(a);
  var f = o.redSqr(), c = s.redIAdd(s);
  c = c.redIAdd(c), c = c.redIAdd(c), c = c.redIAdd(c);
  var l = i.redIAdd(o).redSqr().redISub(a).redISub(f).redISub(c), h = n.redMul(l);
  h = h.redIAdd(h), h = h.redIAdd(h);
  var m = this.x.redMul(f).redISub(h);
  m = m.redIAdd(m), m = m.redIAdd(m);
  var v = this.y.redMul(l.redMul(c.redISub(l)).redISub(o.redMul(f)));
  v = v.redIAdd(v), v = v.redIAdd(v), v = v.redIAdd(v);
  var b = this.z.redAdd(o).redSqr().redISub(r).redISub(f);
  return this.curve.jpoint(m, v, b);
};
Oi.prototype.mul = function(e, n) {
  return e = new zn(e, n), this.curve._wnafMul(this, e);
};
Oi.prototype.eq = function(e) {
  if (e.type === "affine") return this.eq(e.toJ());
  if (this === e) return true;
  var n = this.z.redSqr(), r = e.z.redSqr();
  if (this.x.redMul(r).redISub(e.x.redMul(n)).cmpn(0) !== 0) return false;
  var s = n.redMul(this.z), i = r.redMul(e.z);
  return this.y.redMul(i).redISub(e.y.redMul(s)).cmpn(0) === 0;
};
Oi.prototype.eqXToP = function(e) {
  var n = this.z.redSqr(), r = e.toRed(this.curve.red).redMul(n);
  if (this.x.cmp(r) === 0) return true;
  for (var s = e.clone(), i = this.curve.redN.redMul(n); ; ) {
    if (s.iadd(this.curve.n), s.cmp(this.curve.p) >= 0) return false;
    if (r.redIAdd(i), this.x.cmp(r) === 0) return true;
  }
};
Oi.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
Oi.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var ru = gf, _$ = wr, em = Xg, ZW = Gs;
function rc(t3) {
  em.call(this, "mont", t3), this.a = new ru(t3.a, 16).toRed(this.red), this.b = new ru(t3.b, 16).toRed(this.red), this.i4 = new ru(4).toRed(this.red).redInvm(), this.two = new ru(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
_$(rc, em);
var jW = rc;
rc.prototype.validate = function(e) {
  var n = e.normalize().x, r = n.redSqr(), s = r.redMul(n).redAdd(r.redMul(this.a)).redAdd(n), i = s.redSqrt();
  return i.redSqr().cmp(s) === 0;
};
function Ci(t3, e, n) {
  em.BasePoint.call(this, t3, "projective"), e === null && n === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new ru(e, 16), this.z = new ru(n, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
}
_$(Ci, em.BasePoint);
rc.prototype.decodePoint = function(e, n) {
  return this.point(ZW.toArray(e, n), 1);
};
rc.prototype.point = function(e, n) {
  return new Ci(this, e, n);
};
rc.prototype.pointFromJSON = function(e) {
  return Ci.fromJSON(this, e);
};
Ci.prototype.precompute = function() {
};
Ci.prototype._encode = function() {
  return this.getX().toArray("be", this.curve.p.byteLength());
};
Ci.fromJSON = function(e, n) {
  return new Ci(e, n[0], n[1] || e.one);
};
Ci.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Ci.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
Ci.prototype.dbl = function() {
  var e = this.x.redAdd(this.z), n = e.redSqr(), r = this.x.redSub(this.z), s = r.redSqr(), i = n.redSub(s), a = n.redMul(s), o = i.redMul(s.redAdd(this.curve.a24.redMul(i)));
  return this.curve.point(a, o);
};
Ci.prototype.add = function() {
  throw new Error("Not supported on Montgomery curve");
};
Ci.prototype.diffAdd = function(e, n) {
  var r = this.x.redAdd(this.z), s = this.x.redSub(this.z), i = e.x.redAdd(e.z), a = e.x.redSub(e.z), o = a.redMul(r), f = i.redMul(s), c = n.z.redMul(o.redAdd(f).redSqr()), l = n.x.redMul(o.redISub(f).redSqr());
  return this.curve.point(c, l);
};
Ci.prototype.mul = function(e) {
  for (var n = e.clone(), r = this, s = this.curve.point(null, null), i = this, a = []; n.cmpn(0) !== 0; n.iushrn(1)) a.push(n.andln(1));
  for (var o = a.length - 1; o >= 0; o--) a[o] === 0 ? (r = r.diffAdd(s, i), s = s.dbl()) : (s = r.diffAdd(s, i), r = r.dbl());
  return s;
};
Ci.prototype.mulAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
Ci.prototype.jumlAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
Ci.prototype.eq = function(e) {
  return this.getX().cmp(e.getX()) === 0;
};
Ci.prototype.normalize = function() {
  return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
};
Ci.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
var XW = Gs, Zo = gf, E$ = wr, tm = Xg, eJ = XW.assert;
function Mo(t3) {
  this.twisted = (t3.a | 0) !== 1, this.mOneA = this.twisted && (t3.a | 0) === -1, this.extended = this.mOneA, tm.call(this, "edwards", t3), this.a = new Zo(t3.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new Zo(t3.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new Zo(t3.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), eJ(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (t3.c | 0) === 1;
}
E$(Mo, tm);
var tJ = Mo;
Mo.prototype._mulA = function(e) {
  return this.mOneA ? e.redNeg() : this.a.redMul(e);
};
Mo.prototype._mulC = function(e) {
  return this.oneC ? e : this.c.redMul(e);
};
Mo.prototype.jpoint = function(e, n, r, s) {
  return this.point(e, n, r, s);
};
Mo.prototype.pointFromX = function(e, n) {
  e = new Zo(e, 16), e.red || (e = e.toRed(this.red));
  var r = e.redSqr(), s = this.c2.redSub(this.a.redMul(r)), i = this.one.redSub(this.c2.redMul(this.d).redMul(r)), a = s.redMul(i.redInvm()), o = a.redSqrt();
  if (o.redSqr().redSub(a).cmp(this.zero) !== 0) throw new Error("invalid point");
  var f = o.fromRed().isOdd();
  return (n && !f || !n && f) && (o = o.redNeg()), this.point(e, o);
};
Mo.prototype.pointFromY = function(e, n) {
  e = new Zo(e, 16), e.red || (e = e.toRed(this.red));
  var r = e.redSqr(), s = r.redSub(this.c2), i = r.redMul(this.d).redMul(this.c2).redSub(this.a), a = s.redMul(i.redInvm());
  if (a.cmp(this.zero) === 0) {
    if (n) throw new Error("invalid point");
    return this.point(this.zero, e);
  }
  var o = a.redSqrt();
  if (o.redSqr().redSub(a).cmp(this.zero) !== 0) throw new Error("invalid point");
  return o.fromRed().isOdd() !== n && (o = o.redNeg()), this.point(o, e);
};
Mo.prototype.validate = function(e) {
  if (e.isInfinity()) return true;
  e.normalize();
  var n = e.x.redSqr(), r = e.y.redSqr(), s = n.redMul(this.a).redAdd(r), i = this.c2.redMul(this.one.redAdd(this.d.redMul(n).redMul(r)));
  return s.cmp(i) === 0;
};
function xn(t3, e, n, r, s) {
  tm.BasePoint.call(this, t3, "projective"), e === null && n === null && r === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = true) : (this.x = new Zo(e, 16), this.y = new Zo(n, 16), this.z = r ? new Zo(r, 16) : this.curve.one, this.t = s && new Zo(s, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
}
E$(xn, tm.BasePoint);
Mo.prototype.pointFromJSON = function(e) {
  return xn.fromJSON(this, e);
};
Mo.prototype.point = function(e, n, r, s) {
  return new xn(this, e, n, r, s);
};
xn.fromJSON = function(e, n) {
  return new xn(e, n[0], n[1], n[2]);
};
xn.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
xn.prototype.isInfinity = function() {
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};
xn.prototype._extDbl = function() {
  var e = this.x.redSqr(), n = this.y.redSqr(), r = this.z.redSqr();
  r = r.redIAdd(r);
  var s = this.curve._mulA(e), i = this.x.redAdd(this.y).redSqr().redISub(e).redISub(n), a = s.redAdd(n), o = a.redSub(r), f = s.redSub(n), c = i.redMul(o), l = a.redMul(f), h = i.redMul(f), m = o.redMul(a);
  return this.curve.point(c, l, m, h);
};
xn.prototype._projDbl = function() {
  var e = this.x.redAdd(this.y).redSqr(), n = this.x.redSqr(), r = this.y.redSqr(), s, i, a, o, f, c;
  if (this.curve.twisted) {
    o = this.curve._mulA(n);
    var l = o.redAdd(r);
    this.zOne ? (s = e.redSub(n).redSub(r).redMul(l.redSub(this.curve.two)), i = l.redMul(o.redSub(r)), a = l.redSqr().redSub(l).redSub(l)) : (f = this.z.redSqr(), c = l.redSub(f).redISub(f), s = e.redSub(n).redISub(r).redMul(c), i = l.redMul(o.redSub(r)), a = l.redMul(c));
  } else o = n.redAdd(r), f = this.curve._mulC(this.z).redSqr(), c = o.redSub(f).redSub(f), s = this.curve._mulC(e.redISub(o)).redMul(c), i = this.curve._mulC(o).redMul(n.redISub(r)), a = o.redMul(c);
  return this.curve.point(s, i, a);
};
xn.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
};
xn.prototype._extAdd = function(e) {
  var n = this.y.redSub(this.x).redMul(e.y.redSub(e.x)), r = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)), s = this.t.redMul(this.curve.dd).redMul(e.t), i = this.z.redMul(e.z.redAdd(e.z)), a = r.redSub(n), o = i.redSub(s), f = i.redAdd(s), c = r.redAdd(n), l = a.redMul(o), h = f.redMul(c), m = a.redMul(c), v = o.redMul(f);
  return this.curve.point(l, h, v, m);
};
xn.prototype._projAdd = function(e) {
  var n = this.z.redMul(e.z), r = n.redSqr(), s = this.x.redMul(e.x), i = this.y.redMul(e.y), a = this.curve.d.redMul(s).redMul(i), o = r.redSub(a), f = r.redAdd(a), c = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(s).redISub(i), l = n.redMul(o).redMul(c), h, m;
  return this.curve.twisted ? (h = n.redMul(f).redMul(i.redSub(this.curve._mulA(s))), m = o.redMul(f)) : (h = n.redMul(f).redMul(i.redSub(s)), m = this.curve._mulC(o).redMul(f)), this.curve.point(l, h, m);
};
xn.prototype.add = function(e) {
  return this.isInfinity() ? e : e.isInfinity() ? this : this.curve.extended ? this._extAdd(e) : this._projAdd(e);
};
xn.prototype.mul = function(e) {
  return this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve._wnafMul(this, e);
};
xn.prototype.mulAdd = function(e, n, r) {
  return this.curve._wnafMulAdd(1, [this, n], [e, r], 2, false);
};
xn.prototype.jmulAdd = function(e, n, r) {
  return this.curve._wnafMulAdd(1, [this, n], [e, r], 2, true);
};
xn.prototype.normalize = function() {
  if (this.zOne) return this;
  var e = this.z.redInvm();
  return this.x = this.x.redMul(e), this.y = this.y.redMul(e), this.t && (this.t = this.t.redMul(e)), this.z = this.curve.one, this.zOne = true, this;
};
xn.prototype.neg = function() {
  return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
};
xn.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
xn.prototype.getY = function() {
  return this.normalize(), this.y.fromRed();
};
xn.prototype.eq = function(e) {
  return this === e || this.getX().cmp(e.getX()) === 0 && this.getY().cmp(e.getY()) === 0;
};
xn.prototype.eqXToP = function(e) {
  var n = e.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(n) === 0) return true;
  for (var r = e.clone(), s = this.curve.redN.redMul(this.z); ; ) {
    if (r.iadd(this.curve.n), r.cmp(this.curve.p) >= 0) return false;
    if (n.redIAdd(s), this.x.cmp(n) === 0) return true;
  }
};
xn.prototype.toP = xn.prototype.normalize;
xn.prototype.mixedAdd = xn.prototype.add;
(function(t3) {
  var e = t3;
  e.base = Xg, e.short = JW, e.mont = jW, e.edwards = tJ;
})(ZA);
var rm = {}, nm = {}, Gr = {}, rJ = ha, nJ = wr;
Gr.inherits = nJ;
function iJ(t3, e) {
  return (t3.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= t3.length ? false : (t3.charCodeAt(e + 1) & 64512) === 56320;
}
function sJ(t3, e) {
  if (Array.isArray(t3)) return t3.slice();
  if (!t3) return [];
  var n = [];
  if (typeof t3 == "string") if (e) {
    if (e === "hex") for (t3 = t3.replace(/[^a-z0-9]+/ig, ""), t3.length % 2 !== 0 && (t3 = "0" + t3), s = 0; s < t3.length; s += 2) n.push(parseInt(t3[s] + t3[s + 1], 16));
  } else for (var r = 0, s = 0; s < t3.length; s++) {
    var i = t3.charCodeAt(s);
    i < 128 ? n[r++] = i : i < 2048 ? (n[r++] = i >> 6 | 192, n[r++] = i & 63 | 128) : iJ(t3, s) ? (i = 65536 + ((i & 1023) << 10) + (t3.charCodeAt(++s) & 1023), n[r++] = i >> 18 | 240, n[r++] = i >> 12 & 63 | 128, n[r++] = i >> 6 & 63 | 128, n[r++] = i & 63 | 128) : (n[r++] = i >> 12 | 224, n[r++] = i >> 6 & 63 | 128, n[r++] = i & 63 | 128);
  }
  else for (s = 0; s < t3.length; s++) n[s] = t3[s] | 0;
  return n;
}
Gr.toArray = sJ;
function aJ(t3) {
  for (var e = "", n = 0; n < t3.length; n++) e += C$(t3[n].toString(16));
  return e;
}
Gr.toHex = aJ;
function B$(t3) {
  var e = t3 >>> 24 | t3 >>> 8 & 65280 | t3 << 8 & 16711680 | (t3 & 255) << 24;
  return e >>> 0;
}
Gr.htonl = B$;
function oJ(t3, e) {
  for (var n = "", r = 0; r < t3.length; r++) {
    var s = t3[r];
    e === "little" && (s = B$(s)), n += k$(s.toString(16));
  }
  return n;
}
Gr.toHex32 = oJ;
function C$(t3) {
  return t3.length === 1 ? "0" + t3 : t3;
}
Gr.zero2 = C$;
function k$(t3) {
  return t3.length === 7 ? "0" + t3 : t3.length === 6 ? "00" + t3 : t3.length === 5 ? "000" + t3 : t3.length === 4 ? "0000" + t3 : t3.length === 3 ? "00000" + t3 : t3.length === 2 ? "000000" + t3 : t3.length === 1 ? "0000000" + t3 : t3;
}
Gr.zero8 = k$;
function fJ(t3, e, n, r) {
  var s = n - e;
  rJ(s % 4 === 0);
  for (var i = new Array(s / 4), a = 0, o = e; a < i.length; a++, o += 4) {
    var f;
    r === "big" ? f = t3[o] << 24 | t3[o + 1] << 16 | t3[o + 2] << 8 | t3[o + 3] : f = t3[o + 3] << 24 | t3[o + 2] << 16 | t3[o + 1] << 8 | t3[o], i[a] = f >>> 0;
  }
  return i;
}
Gr.join32 = fJ;
function lJ(t3, e) {
  for (var n = new Array(t3.length * 4), r = 0, s = 0; r < t3.length; r++, s += 4) {
    var i = t3[r];
    e === "big" ? (n[s] = i >>> 24, n[s + 1] = i >>> 16 & 255, n[s + 2] = i >>> 8 & 255, n[s + 3] = i & 255) : (n[s + 3] = i >>> 24, n[s + 2] = i >>> 16 & 255, n[s + 1] = i >>> 8 & 255, n[s] = i & 255);
  }
  return n;
}
Gr.split32 = lJ;
function uJ(t3, e) {
  return t3 >>> e | t3 << 32 - e;
}
Gr.rotr32 = uJ;
function cJ(t3, e) {
  return t3 << e | t3 >>> 32 - e;
}
Gr.rotl32 = cJ;
function hJ(t3, e) {
  return t3 + e >>> 0;
}
Gr.sum32 = hJ;
function dJ(t3, e, n) {
  return t3 + e + n >>> 0;
}
Gr.sum32_3 = dJ;
function pJ(t3, e, n, r) {
  return t3 + e + n + r >>> 0;
}
Gr.sum32_4 = pJ;
function gJ(t3, e, n, r, s) {
  return t3 + e + n + r + s >>> 0;
}
Gr.sum32_5 = gJ;
function mJ(t3, e, n, r) {
  var s = t3[e], i = t3[e + 1], a = r + i >>> 0, o = (a < r ? 1 : 0) + n + s;
  t3[e] = o >>> 0, t3[e + 1] = a;
}
Gr.sum64 = mJ;
function vJ(t3, e, n, r) {
  var s = e + r >>> 0, i = (s < e ? 1 : 0) + t3 + n;
  return i >>> 0;
}
Gr.sum64_hi = vJ;
function yJ(t3, e, n, r) {
  var s = e + r;
  return s >>> 0;
}
Gr.sum64_lo = yJ;
function bJ(t3, e, n, r, s, i, a, o) {
  var f = 0, c = e;
  c = c + r >>> 0, f += c < e ? 1 : 0, c = c + i >>> 0, f += c < i ? 1 : 0, c = c + o >>> 0, f += c < o ? 1 : 0;
  var l = t3 + n + s + a + f;
  return l >>> 0;
}
Gr.sum64_4_hi = bJ;
function AJ(t3, e, n, r, s, i, a, o) {
  var f = e + r + i + o;
  return f >>> 0;
}
Gr.sum64_4_lo = AJ;
function wJ(t3, e, n, r, s, i, a, o, f, c) {
  var l = 0, h = e;
  h = h + r >>> 0, l += h < e ? 1 : 0, h = h + i >>> 0, l += h < i ? 1 : 0, h = h + o >>> 0, l += h < o ? 1 : 0, h = h + c >>> 0, l += h < c ? 1 : 0;
  var m = t3 + n + s + a + f + l;
  return m >>> 0;
}
Gr.sum64_5_hi = wJ;
function xJ(t3, e, n, r, s, i, a, o, f, c) {
  var l = e + r + i + o + c;
  return l >>> 0;
}
Gr.sum64_5_lo = xJ;
function _J(t3, e, n) {
  var r = e << 32 - n | t3 >>> n;
  return r >>> 0;
}
Gr.rotr64_hi = _J;
function EJ(t3, e, n) {
  var r = t3 << 32 - n | e >>> n;
  return r >>> 0;
}
Gr.rotr64_lo = EJ;
function BJ(t3, e, n) {
  return t3 >>> n;
}
Gr.shr64_hi = BJ;
function CJ(t3, e, n) {
  var r = t3 << 32 - n | e >>> n;
  return r >>> 0;
}
Gr.shr64_lo = CJ;
var nc = {}, Uw = Gr, kJ = ha;
function im() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
nc.BlockHash = im;
im.prototype.update = function(e, n) {
  if (e = Uw.toArray(e, n), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
    e = this.pending;
    var r = e.length % this._delta8;
    this.pending = e.slice(e.length - r, e.length), this.pending.length === 0 && (this.pending = null), e = Uw.join32(e, 0, e.length - r, this.endian);
    for (var s = 0; s < e.length; s += this._delta32) this._update(e, s, s + this._delta32);
  }
  return this;
};
im.prototype.digest = function(e) {
  return this.update(this._pad()), kJ(this.pending === null), this._digest(e);
};
im.prototype._pad = function() {
  var e = this.pendingTotal, n = this._delta8, r = n - (e + this.padLength) % n, s = new Array(r + this.padLength);
  s[0] = 128;
  for (var i = 1; i < r; i++) s[i] = 0;
  if (e <<= 3, this.endian === "big") {
    for (var a = 8; a < this.padLength; a++) s[i++] = 0;
    s[i++] = 0, s[i++] = 0, s[i++] = 0, s[i++] = 0, s[i++] = e >>> 24 & 255, s[i++] = e >>> 16 & 255, s[i++] = e >>> 8 & 255, s[i++] = e & 255;
  } else for (s[i++] = e & 255, s[i++] = e >>> 8 & 255, s[i++] = e >>> 16 & 255, s[i++] = e >>> 24 & 255, s[i++] = 0, s[i++] = 0, s[i++] = 0, s[i++] = 0, a = 8; a < this.padLength; a++) s[i++] = 0;
  return s;
};
var ic = {}, $o = {}, IJ = Gr, yo = IJ.rotr32;
function SJ(t3, e, n, r) {
  if (t3 === 0) return I$(e, n, r);
  if (t3 === 1 || t3 === 3) return M$(e, n, r);
  if (t3 === 2) return S$(e, n, r);
}
$o.ft_1 = SJ;
function I$(t3, e, n) {
  return t3 & e ^ ~t3 & n;
}
$o.ch32 = I$;
function S$(t3, e, n) {
  return t3 & e ^ t3 & n ^ e & n;
}
$o.maj32 = S$;
function M$(t3, e, n) {
  return t3 ^ e ^ n;
}
$o.p32 = M$;
function MJ(t3) {
  return yo(t3, 2) ^ yo(t3, 13) ^ yo(t3, 22);
}
$o.s0_256 = MJ;
function $J(t3) {
  return yo(t3, 6) ^ yo(t3, 11) ^ yo(t3, 25);
}
$o.s1_256 = $J;
function TJ(t3) {
  return yo(t3, 7) ^ yo(t3, 18) ^ t3 >>> 3;
}
$o.g0_256 = TJ;
function DJ(t3) {
  return yo(t3, 17) ^ yo(t3, 19) ^ t3 >>> 10;
}
$o.g1_256 = DJ;
var Tu = Gr, RJ = nc, FJ = $o, Y2 = Tu.rotl32, Tc = Tu.sum32, PJ = Tu.sum32_5, NJ = FJ.ft_1, $$ = RJ.BlockHash, UJ = [1518500249, 1859775393, 2400959708, 3395469782];
function Co() {
  if (!(this instanceof Co)) return new Co();
  $$.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80);
}
Tu.inherits(Co, $$);
var LJ = Co;
Co.blockSize = 512;
Co.outSize = 160;
Co.hmacStrength = 80;
Co.padLength = 64;
Co.prototype._update = function(e, n) {
  for (var r = this.W, s = 0; s < 16; s++) r[s] = e[n + s];
  for (; s < r.length; s++) r[s] = Y2(r[s - 3] ^ r[s - 8] ^ r[s - 14] ^ r[s - 16], 1);
  var i = this.h[0], a = this.h[1], o = this.h[2], f = this.h[3], c = this.h[4];
  for (s = 0; s < r.length; s++) {
    var l = ~~(s / 20), h = PJ(Y2(i, 5), NJ(l, a, o, f), c, r[s], UJ[l]);
    c = f, f = o, o = Y2(a, 30), a = i, i = h;
  }
  this.h[0] = Tc(this.h[0], i), this.h[1] = Tc(this.h[1], a), this.h[2] = Tc(this.h[2], o), this.h[3] = Tc(this.h[3], f), this.h[4] = Tc(this.h[4], c);
};
Co.prototype._digest = function(e) {
  return e === "hex" ? Tu.toHex32(this.h, "big") : Tu.split32(this.h, "big");
};
var Du = Gr, OJ = nc, sc = $o, QJ = ha, ya = Du.sum32, KJ = Du.sum32_4, HJ = Du.sum32_5, qJ = sc.ch32, zJ = sc.maj32, GJ = sc.s0_256, VJ = sc.s1_256, YJ = sc.g0_256, WJ = sc.g1_256, T$ = OJ.BlockHash, JJ = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
function ko() {
  if (!(this instanceof ko)) return new ko();
  T$.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = JJ, this.W = new Array(64);
}
Du.inherits(ko, T$);
var D$ = ko;
ko.blockSize = 512;
ko.outSize = 256;
ko.hmacStrength = 192;
ko.padLength = 64;
ko.prototype._update = function(e, n) {
  for (var r = this.W, s = 0; s < 16; s++) r[s] = e[n + s];
  for (; s < r.length; s++) r[s] = KJ(WJ(r[s - 2]), r[s - 7], YJ(r[s - 15]), r[s - 16]);
  var i = this.h[0], a = this.h[1], o = this.h[2], f = this.h[3], c = this.h[4], l = this.h[5], h = this.h[6], m = this.h[7];
  for (QJ(this.k.length === r.length), s = 0; s < r.length; s++) {
    var v = HJ(m, VJ(c), qJ(c, l, h), this.k[s], r[s]), b = ya(GJ(i), zJ(i, a, o));
    m = h, h = l, l = c, c = ya(f, v), f = o, o = a, a = i, i = ya(v, b);
  }
  this.h[0] = ya(this.h[0], i), this.h[1] = ya(this.h[1], a), this.h[2] = ya(this.h[2], o), this.h[3] = ya(this.h[3], f), this.h[4] = ya(this.h[4], c), this.h[5] = ya(this.h[5], l), this.h[6] = ya(this.h[6], h), this.h[7] = ya(this.h[7], m);
};
ko.prototype._digest = function(e) {
  return e === "hex" ? Du.toHex32(this.h, "big") : Du.split32(this.h, "big");
};
var W3 = Gr, R$ = D$;
function of() {
  if (!(this instanceof of)) return new of();
  R$.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
}
W3.inherits(of, R$);
var ZJ = of;
of.blockSize = 512;
of.outSize = 224;
of.hmacStrength = 192;
of.padLength = 64;
of.prototype._digest = function(e) {
  return e === "hex" ? W3.toHex32(this.h.slice(0, 7), "big") : W3.split32(this.h.slice(0, 7), "big");
};
var Is = Gr, jJ = nc, XJ = ha, bo = Is.rotr64_hi, Ao = Is.rotr64_lo, F$ = Is.shr64_hi, P$ = Is.shr64_lo, Bf = Is.sum64, W2 = Is.sum64_hi, J2 = Is.sum64_lo, eZ = Is.sum64_4_hi, tZ = Is.sum64_4_lo, rZ = Is.sum64_5_hi, nZ = Is.sum64_5_lo, N$ = jJ.BlockHash, iZ = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
function Da() {
  if (!(this instanceof Da)) return new Da();
  N$.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = iZ, this.W = new Array(160);
}
Is.inherits(Da, N$);
var U$ = Da;
Da.blockSize = 1024;
Da.outSize = 512;
Da.hmacStrength = 192;
Da.padLength = 128;
Da.prototype._prepareBlock = function(e, n) {
  for (var r = this.W, s = 0; s < 32; s++) r[s] = e[n + s];
  for (; s < r.length; s += 2) {
    var i = gZ(r[s - 4], r[s - 3]), a = mZ(r[s - 4], r[s - 3]), o = r[s - 14], f = r[s - 13], c = dZ(r[s - 30], r[s - 29]), l = pZ(r[s - 30], r[s - 29]), h = r[s - 32], m = r[s - 31];
    r[s] = eZ(i, a, o, f, c, l, h, m), r[s + 1] = tZ(i, a, o, f, c, l, h, m);
  }
};
Da.prototype._update = function(e, n) {
  this._prepareBlock(e, n);
  var r = this.W, s = this.h[0], i = this.h[1], a = this.h[2], o = this.h[3], f = this.h[4], c = this.h[5], l = this.h[6], h = this.h[7], m = this.h[8], v = this.h[9], b = this.h[10], A = this.h[11], _ = this.h[12], C = this.h[13], I = this.h[14], S = this.h[15];
  XJ(this.k.length === r.length);
  for (var $ = 0; $ < r.length; $ += 2) {
    var F = I, U = S, Q = cZ(m, v), P = hZ(m, v), N = sZ(m, v, b, A, _), L = aZ(m, v, b, A, _, C), B = this.k[$], u = this.k[$ + 1], p = r[$], d = r[$ + 1], y = rZ(F, U, Q, P, N, L, B, u, p, d), w = nZ(F, U, Q, P, N, L, B, u, p, d);
    F = lZ(s, i), U = uZ(s, i), Q = oZ(s, i, a, o, f), P = fZ(s, i, a, o, f, c);
    var E = W2(F, U, Q, P), M = J2(F, U, Q, P);
    I = _, S = C, _ = b, C = A, b = m, A = v, m = W2(l, h, y, w), v = J2(h, h, y, w), l = f, h = c, f = a, c = o, a = s, o = i, s = W2(y, w, E, M), i = J2(y, w, E, M);
  }
  Bf(this.h, 0, s, i), Bf(this.h, 2, a, o), Bf(this.h, 4, f, c), Bf(this.h, 6, l, h), Bf(this.h, 8, m, v), Bf(this.h, 10, b, A), Bf(this.h, 12, _, C), Bf(this.h, 14, I, S);
};
Da.prototype._digest = function(e) {
  return e === "hex" ? Is.toHex32(this.h, "big") : Is.split32(this.h, "big");
};
function sZ(t3, e, n, r, s) {
  var i = t3 & n ^ ~t3 & s;
  return i < 0 && (i += 4294967296), i;
}
function aZ(t3, e, n, r, s, i) {
  var a = e & r ^ ~e & i;
  return a < 0 && (a += 4294967296), a;
}
function oZ(t3, e, n, r, s) {
  var i = t3 & n ^ t3 & s ^ n & s;
  return i < 0 && (i += 4294967296), i;
}
function fZ(t3, e, n, r, s, i) {
  var a = e & r ^ e & i ^ r & i;
  return a < 0 && (a += 4294967296), a;
}
function lZ(t3, e) {
  var n = bo(t3, e, 28), r = bo(e, t3, 2), s = bo(e, t3, 7), i = n ^ r ^ s;
  return i < 0 && (i += 4294967296), i;
}
function uZ(t3, e) {
  var n = Ao(t3, e, 28), r = Ao(e, t3, 2), s = Ao(e, t3, 7), i = n ^ r ^ s;
  return i < 0 && (i += 4294967296), i;
}
function cZ(t3, e) {
  var n = bo(t3, e, 14), r = bo(t3, e, 18), s = bo(e, t3, 9), i = n ^ r ^ s;
  return i < 0 && (i += 4294967296), i;
}
function hZ(t3, e) {
  var n = Ao(t3, e, 14), r = Ao(t3, e, 18), s = Ao(e, t3, 9), i = n ^ r ^ s;
  return i < 0 && (i += 4294967296), i;
}
function dZ(t3, e) {
  var n = bo(t3, e, 1), r = bo(t3, e, 8), s = F$(t3, e, 7), i = n ^ r ^ s;
  return i < 0 && (i += 4294967296), i;
}
function pZ(t3, e) {
  var n = Ao(t3, e, 1), r = Ao(t3, e, 8), s = P$(t3, e, 7), i = n ^ r ^ s;
  return i < 0 && (i += 4294967296), i;
}
function gZ(t3, e) {
  var n = bo(t3, e, 19), r = bo(e, t3, 29), s = F$(t3, e, 6), i = n ^ r ^ s;
  return i < 0 && (i += 4294967296), i;
}
function mZ(t3, e) {
  var n = Ao(t3, e, 19), r = Ao(e, t3, 29), s = P$(t3, e, 6), i = n ^ r ^ s;
  return i < 0 && (i += 4294967296), i;
}
var J3 = Gr, L$ = U$;
function ff() {
  if (!(this instanceof ff)) return new ff();
  L$.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
}
J3.inherits(ff, L$);
var vZ = ff;
ff.blockSize = 1024;
ff.outSize = 384;
ff.hmacStrength = 192;
ff.padLength = 128;
ff.prototype._digest = function(e) {
  return e === "hex" ? J3.toHex32(this.h.slice(0, 12), "big") : J3.split32(this.h.slice(0, 12), "big");
};
ic.sha1 = LJ;
ic.sha224 = ZJ;
ic.sha256 = D$;
ic.sha384 = vZ;
ic.sha512 = U$;
var O$ = {}, c0 = Gr, yZ = nc, rp = c0.rotl32, Lw = c0.sum32, Dc = c0.sum32_3, Ow = c0.sum32_4, Q$ = yZ.BlockHash;
function Io() {
  if (!(this instanceof Io)) return new Io();
  Q$.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
c0.inherits(Io, Q$);
O$.ripemd160 = Io;
Io.blockSize = 512;
Io.outSize = 160;
Io.hmacStrength = 192;
Io.padLength = 64;
Io.prototype._update = function(e, n) {
  for (var r = this.h[0], s = this.h[1], i = this.h[2], a = this.h[3], o = this.h[4], f = r, c = s, l = i, h = a, m = o, v = 0; v < 80; v++) {
    var b = Lw(rp(Ow(r, Qw(v, s, i, a), e[wZ[v] + n], bZ(v)), _Z[v]), o);
    r = o, o = a, a = rp(i, 10), i = s, s = b, b = Lw(rp(Ow(f, Qw(79 - v, c, l, h), e[xZ[v] + n], AZ(v)), EZ[v]), m), f = m, m = h, h = rp(l, 10), l = c, c = b;
  }
  b = Dc(this.h[1], i, h), this.h[1] = Dc(this.h[2], a, m), this.h[2] = Dc(this.h[3], o, f), this.h[3] = Dc(this.h[4], r, c), this.h[4] = Dc(this.h[0], s, l), this.h[0] = b;
};
Io.prototype._digest = function(e) {
  return e === "hex" ? c0.toHex32(this.h, "little") : c0.split32(this.h, "little");
};
function Qw(t3, e, n, r) {
  return t3 <= 15 ? e ^ n ^ r : t3 <= 31 ? e & n | ~e & r : t3 <= 47 ? (e | ~n) ^ r : t3 <= 63 ? e & r | n & ~r : e ^ (n | ~r);
}
function bZ(t3) {
  return t3 <= 15 ? 0 : t3 <= 31 ? 1518500249 : t3 <= 47 ? 1859775393 : t3 <= 63 ? 2400959708 : 2840853838;
}
function AZ(t3) {
  return t3 <= 15 ? 1352829926 : t3 <= 31 ? 1548603684 : t3 <= 47 ? 1836072691 : t3 <= 63 ? 2053994217 : 0;
}
var wZ = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], xZ = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], _Z = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], EZ = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11], BZ = Gr, CZ = ha;
function Ru(t3, e, n) {
  if (!(this instanceof Ru)) return new Ru(t3, e, n);
  this.Hash = t3, this.blockSize = t3.blockSize / 8, this.outSize = t3.outSize / 8, this.inner = null, this.outer = null, this._init(BZ.toArray(e, n));
}
var kZ = Ru;
Ru.prototype._init = function(e) {
  e.length > this.blockSize && (e = new this.Hash().update(e).digest()), CZ(e.length <= this.blockSize);
  for (var n = e.length; n < this.blockSize; n++) e.push(0);
  for (n = 0; n < e.length; n++) e[n] ^= 54;
  for (this.inner = new this.Hash().update(e), n = 0; n < e.length; n++) e[n] ^= 106;
  this.outer = new this.Hash().update(e);
};
Ru.prototype.update = function(e, n) {
  return this.inner.update(e, n), this;
};
Ru.prototype.digest = function(e) {
  return this.outer.update(this.inner.digest()), this.outer.digest(e);
};
(function(t3) {
  var e = t3;
  e.utils = Gr, e.common = nc, e.sha = ic, e.ripemd = O$, e.hmac = kZ, e.sha1 = e.sha.sha1, e.sha256 = e.sha.sha256, e.sha224 = e.sha.sha224, e.sha384 = e.sha.sha384, e.sha512 = e.sha.sha512, e.ripemd160 = e.ripemd.ripemd160;
})(nm);
var Z2, Kw;
function IZ() {
  return Kw || (Kw = 1, Z2 = { doubles: { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, naf: { wnd: 7, points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]] } }), Z2;
}
(function(t3) {
  var e = t3, n = nm, r = ZA, s = Gs, i = s.assert;
  function a(c) {
    c.type === "short" ? this.curve = new r.short(c) : c.type === "edwards" ? this.curve = new r.edwards(c) : this.curve = new r.mont(c), this.g = this.curve.g, this.n = this.curve.n, this.hash = c.hash, i(this.g.validate(), "Invalid curve"), i(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  e.PresetCurve = a;
  function o(c, l) {
    Object.defineProperty(e, c, { configurable: true, enumerable: true, get: function() {
      var h = new a(l);
      return Object.defineProperty(e, c, { configurable: true, enumerable: true, value: h }), h;
    } });
  }
  o("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: n.sha256, gRed: false, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] }), o("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: n.sha256, gRed: false, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] }), o("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: n.sha256, gRed: false, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] }), o("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: n.sha384, gRed: false, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] }), o("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: n.sha512, gRed: false, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] }), o("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: n.sha256, gRed: false, g: ["9"] }), o("ed25519", { type: "edwards", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "-1", c: "1", d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: n.sha256, gRed: false, g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"] });
  var f;
  try {
    f = IZ();
  } catch {
    f = void 0;
  }
  o("secp256k1", { type: "short", prime: "k256", p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f", a: "0", b: "7", n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141", h: "1", hash: n.sha256, beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee", lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72", basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], gRed: false, g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", f] });
})(rm);
var SZ = nm, e0 = JA, K$ = ha;
function al(t3) {
  if (!(this instanceof al)) return new al(t3);
  this.hash = t3.hash, this.predResist = !!t3.predResist, this.outLen = this.hash.outSize, this.minEntropy = t3.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var e = e0.toArray(t3.entropy, t3.entropyEnc || "hex"), n = e0.toArray(t3.nonce, t3.nonceEnc || "hex"), r = e0.toArray(t3.pers, t3.persEnc || "hex");
  K$(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(e, n, r);
}
var MZ = al;
al.prototype._init = function(e, n, r) {
  var s = e.concat(n).concat(r);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) this.K[i] = 0, this.V[i] = 1;
  this._update(s), this._reseed = 1, this.reseedInterval = 281474976710656;
};
al.prototype._hmac = function() {
  return new SZ.hmac(this.hash, this.K);
};
al.prototype._update = function(e) {
  var n = this._hmac().update(this.V).update([0]);
  e && (n = n.update(e)), this.K = n.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
};
al.prototype.reseed = function(e, n, r, s) {
  typeof n != "string" && (s = r, r = n, n = null), e = e0.toArray(e, n), r = e0.toArray(r, s), K$(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(e.concat(r || [])), this._reseed = 1;
};
al.prototype.generate = function(e, n, r, s) {
  if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
  typeof n != "string" && (s = r, r = n, n = null), r && (r = e0.toArray(r, s || "hex"), this._update(r));
  for (var i = []; i.length < e; ) this.V = this._hmac().update(this.V).digest(), i = i.concat(this.V);
  var a = i.slice(0, e);
  return this._update(r), this._reseed++, e0.encode(a, n);
};
var $Z = gf, TZ = Gs, Z3 = TZ.assert;
function ts(t3, e) {
  this.ec = t3, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
}
var DZ = ts;
ts.fromPublic = function(e, n, r) {
  return n instanceof ts ? n : new ts(e, { pub: n, pubEnc: r });
};
ts.fromPrivate = function(e, n, r) {
  return n instanceof ts ? n : new ts(e, { priv: n, privEnc: r });
};
ts.prototype.validate = function() {
  var e = this.getPublic();
  return e.isInfinity() ? { result: false, reason: "Invalid public key" } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: true, reason: null } : { result: false, reason: "Public key * N != O" } : { result: false, reason: "Public key is not a point" };
};
ts.prototype.getPublic = function(e, n) {
  return typeof e == "string" && (n = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), n ? this.pub.encode(n, e) : this.pub;
};
ts.prototype.getPrivate = function(e) {
  return e === "hex" ? this.priv.toString(16, 2) : this.priv;
};
ts.prototype._importPrivate = function(e, n) {
  this.priv = new $Z(e, n || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
ts.prototype._importPublic = function(e, n) {
  if (e.x || e.y) {
    this.ec.curve.type === "mont" ? Z3(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && Z3(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(e, n);
};
ts.prototype.derive = function(e) {
  return e.validate() || Z3(e.validate(), "public point not validated"), e.mul(this.priv).getX();
};
ts.prototype.sign = function(e, n, r) {
  return this.ec.sign(e, this, n, r);
};
ts.prototype.verify = function(e, n, r) {
  return this.ec.verify(e, n, this, void 0, r);
};
ts.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var M1 = gf, XA = Gs, RZ = XA.assert;
function sm(t3, e) {
  if (t3 instanceof sm) return t3;
  this._importDER(t3, e) || (RZ(t3.r && t3.s, "Signature without r or s"), this.r = new M1(t3.r, 16), this.s = new M1(t3.s, 16), t3.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = t3.recoveryParam);
}
var FZ = sm;
function PZ() {
  this.place = 0;
}
function j2(t3, e) {
  var n = t3[e.place++];
  if (!(n & 128)) return n;
  var r = n & 15;
  if (r === 0 || r > 4 || t3[e.place] === 0) return false;
  for (var s = 0, i = 0, a = e.place; i < r; i++, a++) s <<= 8, s |= t3[a], s >>>= 0;
  return s <= 127 ? false : (e.place = a, s);
}
function Hw(t3) {
  for (var e = 0, n = t3.length - 1; !t3[e] && !(t3[e + 1] & 128) && e < n; ) e++;
  return e === 0 ? t3 : t3.slice(e);
}
sm.prototype._importDER = function(e, n) {
  e = XA.toArray(e, n);
  var r = new PZ();
  if (e[r.place++] !== 48) return false;
  var s = j2(e, r);
  if (s === false || s + r.place !== e.length || e[r.place++] !== 2) return false;
  var i = j2(e, r);
  if (i === false || e[r.place] & 128) return false;
  var a = e.slice(r.place, i + r.place);
  if (r.place += i, e[r.place++] !== 2) return false;
  var o = j2(e, r);
  if (o === false || e.length !== o + r.place || e[r.place] & 128) return false;
  var f = e.slice(r.place, o + r.place);
  if (a[0] === 0) if (a[1] & 128) a = a.slice(1);
  else return false;
  if (f[0] === 0) if (f[1] & 128) f = f.slice(1);
  else return false;
  return this.r = new M1(a), this.s = new M1(f), this.recoveryParam = null, true;
};
function X2(t3, e) {
  if (e < 128) {
    t3.push(e);
    return;
  }
  var n = 1 + (Math.log(e) / Math.LN2 >>> 3);
  for (t3.push(n | 128); --n; ) t3.push(e >>> (n << 3) & 255);
  t3.push(e);
}
sm.prototype.toDER = function(e) {
  var n = this.r.toArray(), r = this.s.toArray();
  for (n[0] & 128 && (n = [0].concat(n)), r[0] & 128 && (r = [0].concat(r)), n = Hw(n), r = Hw(r); !r[0] && !(r[1] & 128); ) r = r.slice(1);
  var s = [2];
  X2(s, n.length), s = s.concat(n), s.push(2), X2(s, r.length);
  var i = s.concat(r), a = [48];
  return X2(a, i.length), a = a.concat(i), XA.encode(a, e);
};
var ev, qw;
function NZ() {
  if (qw) return ev;
  qw = 1;
  var t3 = gf, e = MZ, n = Gs, r = rm, s = qA(), i = n.assert, a = DZ, o = FZ;
  function f(c) {
    if (!(this instanceof f)) return new f(c);
    typeof c == "string" && (i(Object.prototype.hasOwnProperty.call(r, c), "Unknown curve " + c), c = r[c]), c instanceof r.PresetCurve && (c = { curve: c }), this.curve = c.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = c.curve.g, this.g.precompute(c.curve.n.bitLength() + 1), this.hash = c.hash || c.curve.hash;
  }
  return ev = f, f.prototype.keyPair = function(l) {
    return new a(this, l);
  }, f.prototype.keyFromPrivate = function(l, h) {
    return a.fromPrivate(this, l, h);
  }, f.prototype.keyFromPublic = function(l, h) {
    return a.fromPublic(this, l, h);
  }, f.prototype.genKeyPair = function(l) {
    l || (l = {});
    for (var h = new e({ hash: this.hash, pers: l.pers, persEnc: l.persEnc || "utf8", entropy: l.entropy || s(this.hash.hmacStrength), entropyEnc: l.entropy && l.entropyEnc || "utf8", nonce: this.n.toArray() }), m = this.n.byteLength(), v = this.n.sub(new t3(2)); ; ) {
      var b = new t3(h.generate(m));
      if (!(b.cmp(v) > 0)) return b.iaddn(1), this.keyFromPrivate(b);
    }
  }, f.prototype._truncateToN = function(l, h, m) {
    var v;
    if (t3.isBN(l) || typeof l == "number") l = new t3(l, 16), v = l.byteLength();
    else if (typeof l == "object") v = l.length, l = new t3(l, 16);
    else {
      var b = l.toString();
      v = b.length + 1 >>> 1, l = new t3(b, 16);
    }
    typeof m != "number" && (m = v * 8);
    var A = m - this.n.bitLength();
    return A > 0 && (l = l.ushrn(A)), !h && l.cmp(this.n) >= 0 ? l.sub(this.n) : l;
  }, f.prototype.sign = function(l, h, m, v) {
    if (typeof m == "object" && (v = m, m = null), v || (v = {}), typeof l != "string" && typeof l != "number" && !t3.isBN(l)) {
      i(typeof l == "object" && l && typeof l.length == "number", "Expected message to be an array-like, a hex string, or a BN instance"), i(l.length >>> 0 === l.length);
      for (var b = 0; b < l.length; b++) i((l[b] & 255) === l[b]);
    }
    h = this.keyFromPrivate(h, m), l = this._truncateToN(l, false, v.msgBitLength), i(!l.isNeg(), "Can not sign a negative message");
    var A = this.n.byteLength(), _ = h.getPrivate().toArray("be", A), C = l.toArray("be", A);
    i(new t3(C).eq(l), "Can not sign message");
    for (var I = new e({ hash: this.hash, entropy: _, nonce: C, pers: v.pers, persEnc: v.persEnc || "utf8" }), S = this.n.sub(new t3(1)), $ = 0; ; $++) {
      var F = v.k ? v.k($) : new t3(I.generate(this.n.byteLength()));
      if (F = this._truncateToN(F, true), !(F.cmpn(1) <= 0 || F.cmp(S) >= 0)) {
        var U = this.g.mul(F);
        if (!U.isInfinity()) {
          var Q = U.getX(), P = Q.umod(this.n);
          if (P.cmpn(0) !== 0) {
            var N = F.invm(this.n).mul(P.mul(h.getPrivate()).iadd(l));
            if (N = N.umod(this.n), N.cmpn(0) !== 0) {
              var L = (U.getY().isOdd() ? 1 : 0) | (Q.cmp(P) !== 0 ? 2 : 0);
              return v.canonical && N.cmp(this.nh) > 0 && (N = this.n.sub(N), L ^= 1), new o({ r: P, s: N, recoveryParam: L });
            }
          }
        }
      }
    }
  }, f.prototype.verify = function(l, h, m, v, b) {
    b || (b = {}), l = this._truncateToN(l, false, b.msgBitLength), m = this.keyFromPublic(m, v), h = new o(h, "hex");
    var A = h.r, _ = h.s;
    if (A.cmpn(1) < 0 || A.cmp(this.n) >= 0 || _.cmpn(1) < 0 || _.cmp(this.n) >= 0) return false;
    var C = _.invm(this.n), I = C.mul(l).umod(this.n), S = C.mul(A).umod(this.n), $;
    return this.curve._maxwellTrick ? ($ = this.g.jmulAdd(I, m.getPublic(), S), $.isInfinity() ? false : $.eqXToP(A)) : ($ = this.g.mulAdd(I, m.getPublic(), S), $.isInfinity() ? false : $.getX().umod(this.n).cmp(A) === 0);
  }, f.prototype.recoverPubKey = function(c, l, h, m) {
    i((3 & h) === h, "The recovery param is more than two bits"), l = new o(l, m);
    var v = this.n, b = new t3(c), A = l.r, _ = l.s, C = h & 1, I = h >> 1;
    if (A.cmp(this.curve.p.umod(this.curve.n)) >= 0 && I) throw new Error("Unable to find sencond key candinate");
    I ? A = this.curve.pointFromX(A.add(this.curve.n), C) : A = this.curve.pointFromX(A, C);
    var S = l.r.invm(v), $ = v.sub(b).mul(S).umod(v), F = _.mul(S).umod(v);
    return this.g.mulAdd($, A, F);
  }, f.prototype.getKeyRecoveryParam = function(c, l, h, m) {
    if (l = new o(l, m), l.recoveryParam !== null) return l.recoveryParam;
    for (var v = 0; v < 4; v++) {
      var b;
      try {
        b = this.recoverPubKey(c, l, v);
      } catch {
        continue;
      }
      if (b.eq(h)) return v;
    }
    throw new Error("Unable to find valid recovery factor");
  }, ev;
}
var Ed = Gs, H$ = Ed.assert, zw = Ed.parseBytes, ac = Ed.cachedProperty;
function Bi(t3, e) {
  this.eddsa = t3, this._secret = zw(e.secret), t3.isPoint(e.pub) ? this._pub = e.pub : this._pubBytes = zw(e.pub);
}
Bi.fromPublic = function(e, n) {
  return n instanceof Bi ? n : new Bi(e, { pub: n });
};
Bi.fromSecret = function(e, n) {
  return n instanceof Bi ? n : new Bi(e, { secret: n });
};
Bi.prototype.secret = function() {
  return this._secret;
};
ac(Bi, "pubBytes", function() {
  return this.eddsa.encodePoint(this.pub());
});
ac(Bi, "pub", function() {
  return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
});
ac(Bi, "privBytes", function() {
  var e = this.eddsa, n = this.hash(), r = e.encodingLength - 1, s = n.slice(0, e.encodingLength);
  return s[0] &= 248, s[r] &= 127, s[r] |= 64, s;
});
ac(Bi, "priv", function() {
  return this.eddsa.decodeInt(this.privBytes());
});
ac(Bi, "hash", function() {
  return this.eddsa.hash().update(this.secret()).digest();
});
ac(Bi, "messagePrefix", function() {
  return this.hash().slice(this.eddsa.encodingLength);
});
Bi.prototype.sign = function(e) {
  return H$(this._secret, "KeyPair can only verify"), this.eddsa.sign(e, this);
};
Bi.prototype.verify = function(e, n) {
  return this.eddsa.verify(e, n, this);
};
Bi.prototype.getSecret = function(e) {
  return H$(this._secret, "KeyPair is public only"), Ed.encode(this.secret(), e);
};
Bi.prototype.getPublic = function(e) {
  return Ed.encode(this.pubBytes(), e);
};
var UZ = Bi, LZ = gf, am = Gs, Gw = am.assert, om = am.cachedProperty, OZ = am.parseBytes;
function A0(t3, e) {
  this.eddsa = t3, typeof e != "object" && (e = OZ(e)), Array.isArray(e) && (Gw(e.length === t3.encodingLength * 2, "Signature has invalid size"), e = { R: e.slice(0, t3.encodingLength), S: e.slice(t3.encodingLength) }), Gw(e.R && e.S, "Signature without R or S"), t3.isPoint(e.R) && (this._R = e.R), e.S instanceof LZ && (this._S = e.S), this._Rencoded = Array.isArray(e.R) ? e.R : e.Rencoded, this._Sencoded = Array.isArray(e.S) ? e.S : e.Sencoded;
}
om(A0, "S", function() {
  return this.eddsa.decodeInt(this.Sencoded());
});
om(A0, "R", function() {
  return this.eddsa.decodePoint(this.Rencoded());
});
om(A0, "Rencoded", function() {
  return this.eddsa.encodePoint(this.R());
});
om(A0, "Sencoded", function() {
  return this.eddsa.encodeInt(this.S());
});
A0.prototype.toBytes = function() {
  return this.Rencoded().concat(this.Sencoded());
};
A0.prototype.toHex = function() {
  return am.encode(this.toBytes(), "hex").toUpperCase();
};
var QZ = A0, KZ = nm, HZ = rm, Fu = Gs, qZ = Fu.assert, q$ = Fu.parseBytes, z$ = UZ, Vw = QZ;
function Ss(t3) {
  if (qZ(t3 === "ed25519", "only tested with ed25519 so far"), !(this instanceof Ss)) return new Ss(t3);
  t3 = HZ[t3].curve, this.curve = t3, this.g = t3.g, this.g.precompute(t3.n.bitLength() + 1), this.pointClass = t3.point().constructor, this.encodingLength = Math.ceil(t3.n.bitLength() / 8), this.hash = KZ.sha512;
}
var zZ = Ss;
Ss.prototype.sign = function(e, n) {
  e = q$(e);
  var r = this.keyFromSecret(n), s = this.hashInt(r.messagePrefix(), e), i = this.g.mul(s), a = this.encodePoint(i), o = this.hashInt(a, r.pubBytes(), e).mul(r.priv()), f = s.add(o).umod(this.curve.n);
  return this.makeSignature({ R: i, S: f, Rencoded: a });
};
Ss.prototype.verify = function(e, n, r) {
  if (e = q$(e), n = this.makeSignature(n), n.S().gte(n.eddsa.curve.n) || n.S().isNeg()) return false;
  var s = this.keyFromPublic(r), i = this.hashInt(n.Rencoded(), s.pubBytes(), e), a = this.g.mul(n.S()), o = n.R().add(s.pub().mul(i));
  return o.eq(a);
};
Ss.prototype.hashInt = function() {
  for (var e = this.hash(), n = 0; n < arguments.length; n++) e.update(arguments[n]);
  return Fu.intFromLE(e.digest()).umod(this.curve.n);
};
Ss.prototype.keyFromPublic = function(e) {
  return z$.fromPublic(this, e);
};
Ss.prototype.keyFromSecret = function(e) {
  return z$.fromSecret(this, e);
};
Ss.prototype.makeSignature = function(e) {
  return e instanceof Vw ? e : new Vw(this, e);
};
Ss.prototype.encodePoint = function(e) {
  var n = e.getY().toArray("le", this.encodingLength);
  return n[this.encodingLength - 1] |= e.getX().isOdd() ? 128 : 0, n;
};
Ss.prototype.decodePoint = function(e) {
  e = Fu.parseBytes(e);
  var n = e.length - 1, r = e.slice(0, n).concat(e[n] & -129), s = (e[n] & 128) !== 0, i = Fu.intFromLE(r);
  return this.curve.pointFromY(i, s);
};
Ss.prototype.encodeInt = function(e) {
  return e.toArray("le", this.encodingLength);
};
Ss.prototype.decodeInt = function(e) {
  return Fu.intFromLE(e);
};
Ss.prototype.isPoint = function(e) {
  return e instanceof this.pointClass;
};
var Yw;
function e4() {
  return Yw || (Yw = 1, function(t3) {
    var e = t3;
    e.version = GW.version, e.utils = Gs, e.rand = qA(), e.curve = ZA, e.curves = rm, e.ec = NZ(), e.eddsa = zZ;
  }(V2)), V2;
}
var Na = {}, tv = {}, t4 = { exports: {} };
t4.exports;
(function(t3) {
  (function(e, n) {
    function r(B, u) {
      if (!B) throw new Error(u || "Assertion failed");
    }
    function s(B, u) {
      B.super_ = u;
      var p = function() {
      };
      p.prototype = u.prototype, B.prototype = new p(), B.prototype.constructor = B;
    }
    function i(B, u, p) {
      if (i.isBN(B)) return B;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, B !== null && ((u === "le" || u === "be") && (p = u, u = 10), this._init(B || 0, u || 10, p || "be"));
    }
    typeof e == "object" ? e.exports = i : n.BN = i, i.BN = i, i.wordSize = 26;
    var a;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? a = window.Buffer : a = $n.Buffer;
    } catch {
    }
    i.isBN = function(u) {
      return u instanceof i ? true : u !== null && typeof u == "object" && u.constructor.wordSize === i.wordSize && Array.isArray(u.words);
    }, i.max = function(u, p) {
      return u.cmp(p) > 0 ? u : p;
    }, i.min = function(u, p) {
      return u.cmp(p) < 0 ? u : p;
    }, i.prototype._init = function(u, p, d) {
      if (typeof u == "number") return this._initNumber(u, p, d);
      if (typeof u == "object") return this._initArray(u, p, d);
      p === "hex" && (p = 16), r(p === (p | 0) && p >= 2 && p <= 36), u = u.toString().replace(/\s+/g, "");
      var y = 0;
      u[0] === "-" && (y++, this.negative = 1), y < u.length && (p === 16 ? this._parseHex(u, y, d) : (this._parseBase(u, p, y), d === "le" && this._initArray(this.toArray(), p, d)));
    }, i.prototype._initNumber = function(u, p, d) {
      u < 0 && (this.negative = 1, u = -u), u < 67108864 ? (this.words = [u & 67108863], this.length = 1) : u < 4503599627370496 ? (this.words = [u & 67108863, u / 67108864 & 67108863], this.length = 2) : (r(u < 9007199254740992), this.words = [u & 67108863, u / 67108864 & 67108863, 1], this.length = 3), d === "le" && this._initArray(this.toArray(), p, d);
    }, i.prototype._initArray = function(u, p, d) {
      if (r(typeof u.length == "number"), u.length <= 0) return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(u.length / 3), this.words = new Array(this.length);
      for (var y = 0; y < this.length; y++) this.words[y] = 0;
      var w, E, M = 0;
      if (d === "be") for (y = u.length - 1, w = 0; y >= 0; y -= 3) E = u[y] | u[y - 1] << 8 | u[y - 2] << 16, this.words[w] |= E << M & 67108863, this.words[w + 1] = E >>> 26 - M & 67108863, M += 24, M >= 26 && (M -= 26, w++);
      else if (d === "le") for (y = 0, w = 0; y < u.length; y += 3) E = u[y] | u[y + 1] << 8 | u[y + 2] << 16, this.words[w] |= E << M & 67108863, this.words[w + 1] = E >>> 26 - M & 67108863, M += 24, M >= 26 && (M -= 26, w++);
      return this.strip();
    };
    function o(B, u) {
      var p = B.charCodeAt(u);
      return p >= 65 && p <= 70 ? p - 55 : p >= 97 && p <= 102 ? p - 87 : p - 48 & 15;
    }
    function f(B, u, p) {
      var d = o(B, p);
      return p - 1 >= u && (d |= o(B, p - 1) << 4), d;
    }
    i.prototype._parseHex = function(u, p, d) {
      this.length = Math.ceil((u.length - p) / 6), this.words = new Array(this.length);
      for (var y = 0; y < this.length; y++) this.words[y] = 0;
      var w = 0, E = 0, M;
      if (d === "be") for (y = u.length - 1; y >= p; y -= 2) M = f(u, p, y) << w, this.words[E] |= M & 67108863, w >= 18 ? (w -= 18, E += 1, this.words[E] |= M >>> 26) : w += 8;
      else {
        var x = u.length - p;
        for (y = x % 2 === 0 ? p + 1 : p; y < u.length; y += 2) M = f(u, p, y) << w, this.words[E] |= M & 67108863, w >= 18 ? (w -= 18, E += 1, this.words[E] |= M >>> 26) : w += 8;
      }
      this.strip();
    };
    function c(B, u, p, d) {
      for (var y = 0, w = Math.min(B.length, p), E = u; E < w; E++) {
        var M = B.charCodeAt(E) - 48;
        y *= d, M >= 49 ? y += M - 49 + 10 : M >= 17 ? y += M - 17 + 10 : y += M;
      }
      return y;
    }
    i.prototype._parseBase = function(u, p, d) {
      this.words = [0], this.length = 1;
      for (var y = 0, w = 1; w <= 67108863; w *= p) y++;
      y--, w = w / p | 0;
      for (var E = u.length - d, M = E % y, x = Math.min(E, E - M) + d, g = 0, k = d; k < x; k += y) g = c(u, k, k + y, p), this.imuln(w), this.words[0] + g < 67108864 ? this.words[0] += g : this._iaddn(g);
      if (M !== 0) {
        var T = 1;
        for (g = c(u, k, u.length, p), k = 0; k < M; k++) T *= p;
        this.imuln(T), this.words[0] + g < 67108864 ? this.words[0] += g : this._iaddn(g);
      }
      this.strip();
    }, i.prototype.copy = function(u) {
      u.words = new Array(this.length);
      for (var p = 0; p < this.length; p++) u.words[p] = this.words[p];
      u.length = this.length, u.negative = this.negative, u.red = this.red;
    }, i.prototype.clone = function() {
      var u = new i(null);
      return this.copy(u), u;
    }, i.prototype._expand = function(u) {
      for (; this.length < u; ) this.words[this.length++] = 0;
      return this;
    }, i.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; ) this.length--;
      return this._normSign();
    }, i.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, i.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var l = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], h = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], m = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    i.prototype.toString = function(u, p) {
      u = u || 10, p = p | 0 || 1;
      var d;
      if (u === 16 || u === "hex") {
        d = "";
        for (var y = 0, w = 0, E = 0; E < this.length; E++) {
          var M = this.words[E], x = ((M << y | w) & 16777215).toString(16);
          w = M >>> 24 - y & 16777215, y += 2, y >= 26 && (y -= 26, E--), w !== 0 || E !== this.length - 1 ? d = l[6 - x.length] + x + d : d = x + d;
        }
        for (w !== 0 && (d = w.toString(16) + d); d.length % p !== 0; ) d = "0" + d;
        return this.negative !== 0 && (d = "-" + d), d;
      }
      if (u === (u | 0) && u >= 2 && u <= 36) {
        var g = h[u], k = m[u];
        d = "";
        var T = this.clone();
        for (T.negative = 0; !T.isZero(); ) {
          var O = T.modn(k).toString(u);
          T = T.idivn(k), T.isZero() ? d = O + d : d = l[g - O.length] + O + d;
        }
        for (this.isZero() && (d = "0" + d); d.length % p !== 0; ) d = "0" + d;
        return this.negative !== 0 && (d = "-" + d), d;
      }
      r(false, "Base should be between 2 and 36");
    }, i.prototype.toNumber = function() {
      var u = this.words[0];
      return this.length === 2 ? u += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? u += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -u : u;
    }, i.prototype.toJSON = function() {
      return this.toString(16);
    }, i.prototype.toBuffer = function(u, p) {
      return r(typeof a < "u"), this.toArrayLike(a, u, p);
    }, i.prototype.toArray = function(u, p) {
      return this.toArrayLike(Array, u, p);
    }, i.prototype.toArrayLike = function(u, p, d) {
      var y = this.byteLength(), w = d || Math.max(1, y);
      r(y <= w, "byte array longer than desired length"), r(w > 0, "Requested array length <= 0"), this.strip();
      var E = p === "le", M = new u(w), x, g, k = this.clone();
      if (E) {
        for (g = 0; !k.isZero(); g++) x = k.andln(255), k.iushrn(8), M[g] = x;
        for (; g < w; g++) M[g] = 0;
      } else {
        for (g = 0; g < w - y; g++) M[g] = 0;
        for (g = 0; !k.isZero(); g++) x = k.andln(255), k.iushrn(8), M[w - g - 1] = x;
      }
      return M;
    }, Math.clz32 ? i.prototype._countBits = function(u) {
      return 32 - Math.clz32(u);
    } : i.prototype._countBits = function(u) {
      var p = u, d = 0;
      return p >= 4096 && (d += 13, p >>>= 13), p >= 64 && (d += 7, p >>>= 7), p >= 8 && (d += 4, p >>>= 4), p >= 2 && (d += 2, p >>>= 2), d + p;
    }, i.prototype._zeroBits = function(u) {
      if (u === 0) return 26;
      var p = u, d = 0;
      return p & 8191 || (d += 13, p >>>= 13), p & 127 || (d += 7, p >>>= 7), p & 15 || (d += 4, p >>>= 4), p & 3 || (d += 2, p >>>= 2), p & 1 || d++, d;
    }, i.prototype.bitLength = function() {
      var u = this.words[this.length - 1], p = this._countBits(u);
      return (this.length - 1) * 26 + p;
    };
    function v(B) {
      for (var u = new Array(B.bitLength()), p = 0; p < u.length; p++) {
        var d = p / 26 | 0, y = p % 26;
        u[p] = (B.words[d] & 1 << y) >>> y;
      }
      return u;
    }
    i.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var u = 0, p = 0; p < this.length; p++) {
        var d = this._zeroBits(this.words[p]);
        if (u += d, d !== 26) break;
      }
      return u;
    }, i.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, i.prototype.toTwos = function(u) {
      return this.negative !== 0 ? this.abs().inotn(u).iaddn(1) : this.clone();
    }, i.prototype.fromTwos = function(u) {
      return this.testn(u - 1) ? this.notn(u).iaddn(1).ineg() : this.clone();
    }, i.prototype.isNeg = function() {
      return this.negative !== 0;
    }, i.prototype.neg = function() {
      return this.clone().ineg();
    }, i.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, i.prototype.iuor = function(u) {
      for (; this.length < u.length; ) this.words[this.length++] = 0;
      for (var p = 0; p < u.length; p++) this.words[p] = this.words[p] | u.words[p];
      return this.strip();
    }, i.prototype.ior = function(u) {
      return r((this.negative | u.negative) === 0), this.iuor(u);
    }, i.prototype.or = function(u) {
      return this.length > u.length ? this.clone().ior(u) : u.clone().ior(this);
    }, i.prototype.uor = function(u) {
      return this.length > u.length ? this.clone().iuor(u) : u.clone().iuor(this);
    }, i.prototype.iuand = function(u) {
      var p;
      this.length > u.length ? p = u : p = this;
      for (var d = 0; d < p.length; d++) this.words[d] = this.words[d] & u.words[d];
      return this.length = p.length, this.strip();
    }, i.prototype.iand = function(u) {
      return r((this.negative | u.negative) === 0), this.iuand(u);
    }, i.prototype.and = function(u) {
      return this.length > u.length ? this.clone().iand(u) : u.clone().iand(this);
    }, i.prototype.uand = function(u) {
      return this.length > u.length ? this.clone().iuand(u) : u.clone().iuand(this);
    }, i.prototype.iuxor = function(u) {
      var p, d;
      this.length > u.length ? (p = this, d = u) : (p = u, d = this);
      for (var y = 0; y < d.length; y++) this.words[y] = p.words[y] ^ d.words[y];
      if (this !== p) for (; y < p.length; y++) this.words[y] = p.words[y];
      return this.length = p.length, this.strip();
    }, i.prototype.ixor = function(u) {
      return r((this.negative | u.negative) === 0), this.iuxor(u);
    }, i.prototype.xor = function(u) {
      return this.length > u.length ? this.clone().ixor(u) : u.clone().ixor(this);
    }, i.prototype.uxor = function(u) {
      return this.length > u.length ? this.clone().iuxor(u) : u.clone().iuxor(this);
    }, i.prototype.inotn = function(u) {
      r(typeof u == "number" && u >= 0);
      var p = Math.ceil(u / 26) | 0, d = u % 26;
      this._expand(p), d > 0 && p--;
      for (var y = 0; y < p; y++) this.words[y] = ~this.words[y] & 67108863;
      return d > 0 && (this.words[y] = ~this.words[y] & 67108863 >> 26 - d), this.strip();
    }, i.prototype.notn = function(u) {
      return this.clone().inotn(u);
    }, i.prototype.setn = function(u, p) {
      r(typeof u == "number" && u >= 0);
      var d = u / 26 | 0, y = u % 26;
      return this._expand(d + 1), p ? this.words[d] = this.words[d] | 1 << y : this.words[d] = this.words[d] & ~(1 << y), this.strip();
    }, i.prototype.iadd = function(u) {
      var p;
      if (this.negative !== 0 && u.negative === 0) return this.negative = 0, p = this.isub(u), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && u.negative !== 0) return u.negative = 0, p = this.isub(u), u.negative = 1, p._normSign();
      var d, y;
      this.length > u.length ? (d = this, y = u) : (d = u, y = this);
      for (var w = 0, E = 0; E < y.length; E++) p = (d.words[E] | 0) + (y.words[E] | 0) + w, this.words[E] = p & 67108863, w = p >>> 26;
      for (; w !== 0 && E < d.length; E++) p = (d.words[E] | 0) + w, this.words[E] = p & 67108863, w = p >>> 26;
      if (this.length = d.length, w !== 0) this.words[this.length] = w, this.length++;
      else if (d !== this) for (; E < d.length; E++) this.words[E] = d.words[E];
      return this;
    }, i.prototype.add = function(u) {
      var p;
      return u.negative !== 0 && this.negative === 0 ? (u.negative = 0, p = this.sub(u), u.negative ^= 1, p) : u.negative === 0 && this.negative !== 0 ? (this.negative = 0, p = u.sub(this), this.negative = 1, p) : this.length > u.length ? this.clone().iadd(u) : u.clone().iadd(this);
    }, i.prototype.isub = function(u) {
      if (u.negative !== 0) {
        u.negative = 0;
        var p = this.iadd(u);
        return u.negative = 1, p._normSign();
      } else if (this.negative !== 0) return this.negative = 0, this.iadd(u), this.negative = 1, this._normSign();
      var d = this.cmp(u);
      if (d === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var y, w;
      d > 0 ? (y = this, w = u) : (y = u, w = this);
      for (var E = 0, M = 0; M < w.length; M++) p = (y.words[M] | 0) - (w.words[M] | 0) + E, E = p >> 26, this.words[M] = p & 67108863;
      for (; E !== 0 && M < y.length; M++) p = (y.words[M] | 0) + E, E = p >> 26, this.words[M] = p & 67108863;
      if (E === 0 && M < y.length && y !== this) for (; M < y.length; M++) this.words[M] = y.words[M];
      return this.length = Math.max(this.length, M), y !== this && (this.negative = 1), this.strip();
    }, i.prototype.sub = function(u) {
      return this.clone().isub(u);
    };
    function b(B, u, p) {
      p.negative = u.negative ^ B.negative;
      var d = B.length + u.length | 0;
      p.length = d, d = d - 1 | 0;
      var y = B.words[0] | 0, w = u.words[0] | 0, E = y * w, M = E & 67108863, x = E / 67108864 | 0;
      p.words[0] = M;
      for (var g = 1; g < d; g++) {
        for (var k = x >>> 26, T = x & 67108863, O = Math.min(g, u.length - 1), K = Math.max(0, g - B.length + 1); K <= O; K++) {
          var Y = g - K | 0;
          y = B.words[Y] | 0, w = u.words[K] | 0, E = y * w + T, k += E / 67108864 | 0, T = E & 67108863;
        }
        p.words[g] = T | 0, x = k | 0;
      }
      return x !== 0 ? p.words[g] = x | 0 : p.length--, p.strip();
    }
    var A = function(u, p, d) {
      var y = u.words, w = p.words, E = d.words, M = 0, x, g, k, T = y[0] | 0, O = T & 8191, K = T >>> 13, Y = y[1] | 0, J = Y & 8191, G = Y >>> 13, X = y[2] | 0, ie = X & 8191, de = X >>> 13, se = y[3] | 0, te = se & 8191, le = se >>> 13, Z = y[4] | 0, ve = Z & 8191, he = Z >>> 13, me = y[5] | 0, ce = me & 8191, ye = me >>> 13, Oe = y[6] | 0, Se = Oe & 8191, Ce = Oe >>> 13, Ne = y[7] | 0, $e = Ne & 8191, Re = Ne >>> 13, Ge = y[8] | 0, Fe = Ge & 8191, Ue = Ge >>> 13, kt = y[9] | 0, pe = kt & 8191, re = kt >>> 13, ue = w[0] | 0, xe = ue & 8191, Me = ue >>> 13, We = w[1] | 0, De = We & 8191, je = We >>> 13, ir = w[2] | 0, Xe = ir & 8191, st = ir >>> 13, Vt = w[3] | 0, at = Vt & 8191, ht = Vt >>> 13, br = w[4] | 0, ot = br & 8191, ct = br >>> 13, _r = w[5] | 0, ft = _r & 8191, pt = _r >>> 13, Cr = w[6] | 0, nt = Cr & 8191, lt = Cr >>> 13, ge = w[7] | 0, be = ge & 8191, Ae = ge >>> 13, ne = w[8] | 0, _e = ne & 8191, Te = ne >>> 13, Ye = w[9] | 0, Pe = Ye & 8191, He = Ye >>> 13;
      d.negative = u.negative ^ p.negative, d.length = 19, x = Math.imul(O, xe), g = Math.imul(O, Me), g = g + Math.imul(K, xe) | 0, k = Math.imul(K, Me);
      var _t = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, x = Math.imul(J, xe), g = Math.imul(J, Me), g = g + Math.imul(G, xe) | 0, k = Math.imul(G, Me), x = x + Math.imul(O, De) | 0, g = g + Math.imul(O, je) | 0, g = g + Math.imul(K, De) | 0, k = k + Math.imul(K, je) | 0;
      var vt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, x = Math.imul(ie, xe), g = Math.imul(ie, Me), g = g + Math.imul(de, xe) | 0, k = Math.imul(de, Me), x = x + Math.imul(J, De) | 0, g = g + Math.imul(J, je) | 0, g = g + Math.imul(G, De) | 0, k = k + Math.imul(G, je) | 0, x = x + Math.imul(O, Xe) | 0, g = g + Math.imul(O, st) | 0, g = g + Math.imul(K, Xe) | 0, k = k + Math.imul(K, st) | 0;
      var cr = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (cr >>> 26) | 0, cr &= 67108863, x = Math.imul(te, xe), g = Math.imul(te, Me), g = g + Math.imul(le, xe) | 0, k = Math.imul(le, Me), x = x + Math.imul(ie, De) | 0, g = g + Math.imul(ie, je) | 0, g = g + Math.imul(de, De) | 0, k = k + Math.imul(de, je) | 0, x = x + Math.imul(J, Xe) | 0, g = g + Math.imul(J, st) | 0, g = g + Math.imul(G, Xe) | 0, k = k + Math.imul(G, st) | 0, x = x + Math.imul(O, at) | 0, g = g + Math.imul(O, ht) | 0, g = g + Math.imul(K, at) | 0, k = k + Math.imul(K, ht) | 0;
      var Tt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, x = Math.imul(ve, xe), g = Math.imul(ve, Me), g = g + Math.imul(he, xe) | 0, k = Math.imul(he, Me), x = x + Math.imul(te, De) | 0, g = g + Math.imul(te, je) | 0, g = g + Math.imul(le, De) | 0, k = k + Math.imul(le, je) | 0, x = x + Math.imul(ie, Xe) | 0, g = g + Math.imul(ie, st) | 0, g = g + Math.imul(de, Xe) | 0, k = k + Math.imul(de, st) | 0, x = x + Math.imul(J, at) | 0, g = g + Math.imul(J, ht) | 0, g = g + Math.imul(G, at) | 0, k = k + Math.imul(G, ht) | 0, x = x + Math.imul(O, ot) | 0, g = g + Math.imul(O, ct) | 0, g = g + Math.imul(K, ot) | 0, k = k + Math.imul(K, ct) | 0;
      var Gt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Gt >>> 26) | 0, Gt &= 67108863, x = Math.imul(ce, xe), g = Math.imul(ce, Me), g = g + Math.imul(ye, xe) | 0, k = Math.imul(ye, Me), x = x + Math.imul(ve, De) | 0, g = g + Math.imul(ve, je) | 0, g = g + Math.imul(he, De) | 0, k = k + Math.imul(he, je) | 0, x = x + Math.imul(te, Xe) | 0, g = g + Math.imul(te, st) | 0, g = g + Math.imul(le, Xe) | 0, k = k + Math.imul(le, st) | 0, x = x + Math.imul(ie, at) | 0, g = g + Math.imul(ie, ht) | 0, g = g + Math.imul(de, at) | 0, k = k + Math.imul(de, ht) | 0, x = x + Math.imul(J, ot) | 0, g = g + Math.imul(J, ct) | 0, g = g + Math.imul(G, ot) | 0, k = k + Math.imul(G, ct) | 0, x = x + Math.imul(O, ft) | 0, g = g + Math.imul(O, pt) | 0, g = g + Math.imul(K, ft) | 0, k = k + Math.imul(K, pt) | 0;
      var Yt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Yt >>> 26) | 0, Yt &= 67108863, x = Math.imul(Se, xe), g = Math.imul(Se, Me), g = g + Math.imul(Ce, xe) | 0, k = Math.imul(Ce, Me), x = x + Math.imul(ce, De) | 0, g = g + Math.imul(ce, je) | 0, g = g + Math.imul(ye, De) | 0, k = k + Math.imul(ye, je) | 0, x = x + Math.imul(ve, Xe) | 0, g = g + Math.imul(ve, st) | 0, g = g + Math.imul(he, Xe) | 0, k = k + Math.imul(he, st) | 0, x = x + Math.imul(te, at) | 0, g = g + Math.imul(te, ht) | 0, g = g + Math.imul(le, at) | 0, k = k + Math.imul(le, ht) | 0, x = x + Math.imul(ie, ot) | 0, g = g + Math.imul(ie, ct) | 0, g = g + Math.imul(de, ot) | 0, k = k + Math.imul(de, ct) | 0, x = x + Math.imul(J, ft) | 0, g = g + Math.imul(J, pt) | 0, g = g + Math.imul(G, ft) | 0, k = k + Math.imul(G, pt) | 0, x = x + Math.imul(O, nt) | 0, g = g + Math.imul(O, lt) | 0, g = g + Math.imul(K, nt) | 0, k = k + Math.imul(K, lt) | 0;
      var or = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (or >>> 26) | 0, or &= 67108863, x = Math.imul($e, xe), g = Math.imul($e, Me), g = g + Math.imul(Re, xe) | 0, k = Math.imul(Re, Me), x = x + Math.imul(Se, De) | 0, g = g + Math.imul(Se, je) | 0, g = g + Math.imul(Ce, De) | 0, k = k + Math.imul(Ce, je) | 0, x = x + Math.imul(ce, Xe) | 0, g = g + Math.imul(ce, st) | 0, g = g + Math.imul(ye, Xe) | 0, k = k + Math.imul(ye, st) | 0, x = x + Math.imul(ve, at) | 0, g = g + Math.imul(ve, ht) | 0, g = g + Math.imul(he, at) | 0, k = k + Math.imul(he, ht) | 0, x = x + Math.imul(te, ot) | 0, g = g + Math.imul(te, ct) | 0, g = g + Math.imul(le, ot) | 0, k = k + Math.imul(le, ct) | 0, x = x + Math.imul(ie, ft) | 0, g = g + Math.imul(ie, pt) | 0, g = g + Math.imul(de, ft) | 0, k = k + Math.imul(de, pt) | 0, x = x + Math.imul(J, nt) | 0, g = g + Math.imul(J, lt) | 0, g = g + Math.imul(G, nt) | 0, k = k + Math.imul(G, lt) | 0, x = x + Math.imul(O, be) | 0, g = g + Math.imul(O, Ae) | 0, g = g + Math.imul(K, be) | 0, k = k + Math.imul(K, Ae) | 0;
      var sr = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (sr >>> 26) | 0, sr &= 67108863, x = Math.imul(Fe, xe), g = Math.imul(Fe, Me), g = g + Math.imul(Ue, xe) | 0, k = Math.imul(Ue, Me), x = x + Math.imul($e, De) | 0, g = g + Math.imul($e, je) | 0, g = g + Math.imul(Re, De) | 0, k = k + Math.imul(Re, je) | 0, x = x + Math.imul(Se, Xe) | 0, g = g + Math.imul(Se, st) | 0, g = g + Math.imul(Ce, Xe) | 0, k = k + Math.imul(Ce, st) | 0, x = x + Math.imul(ce, at) | 0, g = g + Math.imul(ce, ht) | 0, g = g + Math.imul(ye, at) | 0, k = k + Math.imul(ye, ht) | 0, x = x + Math.imul(ve, ot) | 0, g = g + Math.imul(ve, ct) | 0, g = g + Math.imul(he, ot) | 0, k = k + Math.imul(he, ct) | 0, x = x + Math.imul(te, ft) | 0, g = g + Math.imul(te, pt) | 0, g = g + Math.imul(le, ft) | 0, k = k + Math.imul(le, pt) | 0, x = x + Math.imul(ie, nt) | 0, g = g + Math.imul(ie, lt) | 0, g = g + Math.imul(de, nt) | 0, k = k + Math.imul(de, lt) | 0, x = x + Math.imul(J, be) | 0, g = g + Math.imul(J, Ae) | 0, g = g + Math.imul(G, be) | 0, k = k + Math.imul(G, Ae) | 0, x = x + Math.imul(O, _e) | 0, g = g + Math.imul(O, Te) | 0, g = g + Math.imul(K, _e) | 0, k = k + Math.imul(K, Te) | 0;
      var Wt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Wt >>> 26) | 0, Wt &= 67108863, x = Math.imul(pe, xe), g = Math.imul(pe, Me), g = g + Math.imul(re, xe) | 0, k = Math.imul(re, Me), x = x + Math.imul(Fe, De) | 0, g = g + Math.imul(Fe, je) | 0, g = g + Math.imul(Ue, De) | 0, k = k + Math.imul(Ue, je) | 0, x = x + Math.imul($e, Xe) | 0, g = g + Math.imul($e, st) | 0, g = g + Math.imul(Re, Xe) | 0, k = k + Math.imul(Re, st) | 0, x = x + Math.imul(Se, at) | 0, g = g + Math.imul(Se, ht) | 0, g = g + Math.imul(Ce, at) | 0, k = k + Math.imul(Ce, ht) | 0, x = x + Math.imul(ce, ot) | 0, g = g + Math.imul(ce, ct) | 0, g = g + Math.imul(ye, ot) | 0, k = k + Math.imul(ye, ct) | 0, x = x + Math.imul(ve, ft) | 0, g = g + Math.imul(ve, pt) | 0, g = g + Math.imul(he, ft) | 0, k = k + Math.imul(he, pt) | 0, x = x + Math.imul(te, nt) | 0, g = g + Math.imul(te, lt) | 0, g = g + Math.imul(le, nt) | 0, k = k + Math.imul(le, lt) | 0, x = x + Math.imul(ie, be) | 0, g = g + Math.imul(ie, Ae) | 0, g = g + Math.imul(de, be) | 0, k = k + Math.imul(de, Ae) | 0, x = x + Math.imul(J, _e) | 0, g = g + Math.imul(J, Te) | 0, g = g + Math.imul(G, _e) | 0, k = k + Math.imul(G, Te) | 0, x = x + Math.imul(O, Pe) | 0, g = g + Math.imul(O, He) | 0, g = g + Math.imul(K, Pe) | 0, k = k + Math.imul(K, He) | 0;
      var tr = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (tr >>> 26) | 0, tr &= 67108863, x = Math.imul(pe, De), g = Math.imul(pe, je), g = g + Math.imul(re, De) | 0, k = Math.imul(re, je), x = x + Math.imul(Fe, Xe) | 0, g = g + Math.imul(Fe, st) | 0, g = g + Math.imul(Ue, Xe) | 0, k = k + Math.imul(Ue, st) | 0, x = x + Math.imul($e, at) | 0, g = g + Math.imul($e, ht) | 0, g = g + Math.imul(Re, at) | 0, k = k + Math.imul(Re, ht) | 0, x = x + Math.imul(Se, ot) | 0, g = g + Math.imul(Se, ct) | 0, g = g + Math.imul(Ce, ot) | 0, k = k + Math.imul(Ce, ct) | 0, x = x + Math.imul(ce, ft) | 0, g = g + Math.imul(ce, pt) | 0, g = g + Math.imul(ye, ft) | 0, k = k + Math.imul(ye, pt) | 0, x = x + Math.imul(ve, nt) | 0, g = g + Math.imul(ve, lt) | 0, g = g + Math.imul(he, nt) | 0, k = k + Math.imul(he, lt) | 0, x = x + Math.imul(te, be) | 0, g = g + Math.imul(te, Ae) | 0, g = g + Math.imul(le, be) | 0, k = k + Math.imul(le, Ae) | 0, x = x + Math.imul(ie, _e) | 0, g = g + Math.imul(ie, Te) | 0, g = g + Math.imul(de, _e) | 0, k = k + Math.imul(de, Te) | 0, x = x + Math.imul(J, Pe) | 0, g = g + Math.imul(J, He) | 0, g = g + Math.imul(G, Pe) | 0, k = k + Math.imul(G, He) | 0;
      var Jt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Jt >>> 26) | 0, Jt &= 67108863, x = Math.imul(pe, Xe), g = Math.imul(pe, st), g = g + Math.imul(re, Xe) | 0, k = Math.imul(re, st), x = x + Math.imul(Fe, at) | 0, g = g + Math.imul(Fe, ht) | 0, g = g + Math.imul(Ue, at) | 0, k = k + Math.imul(Ue, ht) | 0, x = x + Math.imul($e, ot) | 0, g = g + Math.imul($e, ct) | 0, g = g + Math.imul(Re, ot) | 0, k = k + Math.imul(Re, ct) | 0, x = x + Math.imul(Se, ft) | 0, g = g + Math.imul(Se, pt) | 0, g = g + Math.imul(Ce, ft) | 0, k = k + Math.imul(Ce, pt) | 0, x = x + Math.imul(ce, nt) | 0, g = g + Math.imul(ce, lt) | 0, g = g + Math.imul(ye, nt) | 0, k = k + Math.imul(ye, lt) | 0, x = x + Math.imul(ve, be) | 0, g = g + Math.imul(ve, Ae) | 0, g = g + Math.imul(he, be) | 0, k = k + Math.imul(he, Ae) | 0, x = x + Math.imul(te, _e) | 0, g = g + Math.imul(te, Te) | 0, g = g + Math.imul(le, _e) | 0, k = k + Math.imul(le, Te) | 0, x = x + Math.imul(ie, Pe) | 0, g = g + Math.imul(ie, He) | 0, g = g + Math.imul(de, Pe) | 0, k = k + Math.imul(de, He) | 0;
      var Ft = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Ft >>> 26) | 0, Ft &= 67108863, x = Math.imul(pe, at), g = Math.imul(pe, ht), g = g + Math.imul(re, at) | 0, k = Math.imul(re, ht), x = x + Math.imul(Fe, ot) | 0, g = g + Math.imul(Fe, ct) | 0, g = g + Math.imul(Ue, ot) | 0, k = k + Math.imul(Ue, ct) | 0, x = x + Math.imul($e, ft) | 0, g = g + Math.imul($e, pt) | 0, g = g + Math.imul(Re, ft) | 0, k = k + Math.imul(Re, pt) | 0, x = x + Math.imul(Se, nt) | 0, g = g + Math.imul(Se, lt) | 0, g = g + Math.imul(Ce, nt) | 0, k = k + Math.imul(Ce, lt) | 0, x = x + Math.imul(ce, be) | 0, g = g + Math.imul(ce, Ae) | 0, g = g + Math.imul(ye, be) | 0, k = k + Math.imul(ye, Ae) | 0, x = x + Math.imul(ve, _e) | 0, g = g + Math.imul(ve, Te) | 0, g = g + Math.imul(he, _e) | 0, k = k + Math.imul(he, Te) | 0, x = x + Math.imul(te, Pe) | 0, g = g + Math.imul(te, He) | 0, g = g + Math.imul(le, Pe) | 0, k = k + Math.imul(le, He) | 0;
      var Ut = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, x = Math.imul(pe, ot), g = Math.imul(pe, ct), g = g + Math.imul(re, ot) | 0, k = Math.imul(re, ct), x = x + Math.imul(Fe, ft) | 0, g = g + Math.imul(Fe, pt) | 0, g = g + Math.imul(Ue, ft) | 0, k = k + Math.imul(Ue, pt) | 0, x = x + Math.imul($e, nt) | 0, g = g + Math.imul($e, lt) | 0, g = g + Math.imul(Re, nt) | 0, k = k + Math.imul(Re, lt) | 0, x = x + Math.imul(Se, be) | 0, g = g + Math.imul(Se, Ae) | 0, g = g + Math.imul(Ce, be) | 0, k = k + Math.imul(Ce, Ae) | 0, x = x + Math.imul(ce, _e) | 0, g = g + Math.imul(ce, Te) | 0, g = g + Math.imul(ye, _e) | 0, k = k + Math.imul(ye, Te) | 0, x = x + Math.imul(ve, Pe) | 0, g = g + Math.imul(ve, He) | 0, g = g + Math.imul(he, Pe) | 0, k = k + Math.imul(he, He) | 0;
      var Mt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, x = Math.imul(pe, ft), g = Math.imul(pe, pt), g = g + Math.imul(re, ft) | 0, k = Math.imul(re, pt), x = x + Math.imul(Fe, nt) | 0, g = g + Math.imul(Fe, lt) | 0, g = g + Math.imul(Ue, nt) | 0, k = k + Math.imul(Ue, lt) | 0, x = x + Math.imul($e, be) | 0, g = g + Math.imul($e, Ae) | 0, g = g + Math.imul(Re, be) | 0, k = k + Math.imul(Re, Ae) | 0, x = x + Math.imul(Se, _e) | 0, g = g + Math.imul(Se, Te) | 0, g = g + Math.imul(Ce, _e) | 0, k = k + Math.imul(Ce, Te) | 0, x = x + Math.imul(ce, Pe) | 0, g = g + Math.imul(ce, He) | 0, g = g + Math.imul(ye, Pe) | 0, k = k + Math.imul(ye, He) | 0;
      var Pt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, x = Math.imul(pe, nt), g = Math.imul(pe, lt), g = g + Math.imul(re, nt) | 0, k = Math.imul(re, lt), x = x + Math.imul(Fe, be) | 0, g = g + Math.imul(Fe, Ae) | 0, g = g + Math.imul(Ue, be) | 0, k = k + Math.imul(Ue, Ae) | 0, x = x + Math.imul($e, _e) | 0, g = g + Math.imul($e, Te) | 0, g = g + Math.imul(Re, _e) | 0, k = k + Math.imul(Re, Te) | 0, x = x + Math.imul(Se, Pe) | 0, g = g + Math.imul(Se, He) | 0, g = g + Math.imul(Ce, Pe) | 0, k = k + Math.imul(Ce, He) | 0;
      var Nt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, x = Math.imul(pe, be), g = Math.imul(pe, Ae), g = g + Math.imul(re, be) | 0, k = Math.imul(re, Ae), x = x + Math.imul(Fe, _e) | 0, g = g + Math.imul(Fe, Te) | 0, g = g + Math.imul(Ue, _e) | 0, k = k + Math.imul(Ue, Te) | 0, x = x + Math.imul($e, Pe) | 0, g = g + Math.imul($e, He) | 0, g = g + Math.imul(Re, Pe) | 0, k = k + Math.imul(Re, He) | 0;
      var It = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, x = Math.imul(pe, _e), g = Math.imul(pe, Te), g = g + Math.imul(re, _e) | 0, k = Math.imul(re, Te), x = x + Math.imul(Fe, Pe) | 0, g = g + Math.imul(Fe, He) | 0, g = g + Math.imul(Ue, Pe) | 0, k = k + Math.imul(Ue, He) | 0;
      var tt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, x = Math.imul(pe, Pe), g = Math.imul(pe, He), g = g + Math.imul(re, Pe) | 0, k = Math.imul(re, He);
      var rt = (M + x | 0) + ((g & 8191) << 13) | 0;
      return M = (k + (g >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, E[0] = _t, E[1] = vt, E[2] = cr, E[3] = Tt, E[4] = Gt, E[5] = Yt, E[6] = or, E[7] = sr, E[8] = Wt, E[9] = tr, E[10] = Jt, E[11] = Ft, E[12] = Ut, E[13] = Mt, E[14] = Pt, E[15] = Nt, E[16] = It, E[17] = tt, E[18] = rt, M !== 0 && (E[19] = M, d.length++), d;
    };
    Math.imul || (A = b);
    function _(B, u, p) {
      p.negative = u.negative ^ B.negative, p.length = B.length + u.length;
      for (var d = 0, y = 0, w = 0; w < p.length - 1; w++) {
        var E = y;
        y = 0;
        for (var M = d & 67108863, x = Math.min(w, u.length - 1), g = Math.max(0, w - B.length + 1); g <= x; g++) {
          var k = w - g, T = B.words[k] | 0, O = u.words[g] | 0, K = T * O, Y = K & 67108863;
          E = E + (K / 67108864 | 0) | 0, Y = Y + M | 0, M = Y & 67108863, E = E + (Y >>> 26) | 0, y += E >>> 26, E &= 67108863;
        }
        p.words[w] = M, d = E, E = y;
      }
      return d !== 0 ? p.words[w] = d : p.length--, p.strip();
    }
    function C(B, u, p) {
      var d = new I();
      return d.mulp(B, u, p);
    }
    i.prototype.mulTo = function(u, p) {
      var d, y = this.length + u.length;
      return this.length === 10 && u.length === 10 ? d = A(this, u, p) : y < 63 ? d = b(this, u, p) : y < 1024 ? d = _(this, u, p) : d = C(this, u, p), d;
    };
    function I(B, u) {
      this.x = B, this.y = u;
    }
    I.prototype.makeRBT = function(u) {
      for (var p = new Array(u), d = i.prototype._countBits(u) - 1, y = 0; y < u; y++) p[y] = this.revBin(y, d, u);
      return p;
    }, I.prototype.revBin = function(u, p, d) {
      if (u === 0 || u === d - 1) return u;
      for (var y = 0, w = 0; w < p; w++) y |= (u & 1) << p - w - 1, u >>= 1;
      return y;
    }, I.prototype.permute = function(u, p, d, y, w, E) {
      for (var M = 0; M < E; M++) y[M] = p[u[M]], w[M] = d[u[M]];
    }, I.prototype.transform = function(u, p, d, y, w, E) {
      this.permute(E, u, p, d, y, w);
      for (var M = 1; M < w; M <<= 1) for (var x = M << 1, g = Math.cos(2 * Math.PI / x), k = Math.sin(2 * Math.PI / x), T = 0; T < w; T += x) for (var O = g, K = k, Y = 0; Y < M; Y++) {
        var J = d[T + Y], G = y[T + Y], X = d[T + Y + M], ie = y[T + Y + M], de = O * X - K * ie;
        ie = O * ie + K * X, X = de, d[T + Y] = J + X, y[T + Y] = G + ie, d[T + Y + M] = J - X, y[T + Y + M] = G - ie, Y !== x && (de = g * O - k * K, K = g * K + k * O, O = de);
      }
    }, I.prototype.guessLen13b = function(u, p) {
      var d = Math.max(p, u) | 1, y = d & 1, w = 0;
      for (d = d / 2 | 0; d; d = d >>> 1) w++;
      return 1 << w + 1 + y;
    }, I.prototype.conjugate = function(u, p, d) {
      if (!(d <= 1)) for (var y = 0; y < d / 2; y++) {
        var w = u[y];
        u[y] = u[d - y - 1], u[d - y - 1] = w, w = p[y], p[y] = -p[d - y - 1], p[d - y - 1] = -w;
      }
    }, I.prototype.normalize13b = function(u, p) {
      for (var d = 0, y = 0; y < p / 2; y++) {
        var w = Math.round(u[2 * y + 1] / p) * 8192 + Math.round(u[2 * y] / p) + d;
        u[y] = w & 67108863, w < 67108864 ? d = 0 : d = w / 67108864 | 0;
      }
      return u;
    }, I.prototype.convert13b = function(u, p, d, y) {
      for (var w = 0, E = 0; E < p; E++) w = w + (u[E] | 0), d[2 * E] = w & 8191, w = w >>> 13, d[2 * E + 1] = w & 8191, w = w >>> 13;
      for (E = 2 * p; E < y; ++E) d[E] = 0;
      r(w === 0), r((w & -8192) === 0);
    }, I.prototype.stub = function(u) {
      for (var p = new Array(u), d = 0; d < u; d++) p[d] = 0;
      return p;
    }, I.prototype.mulp = function(u, p, d) {
      var y = 2 * this.guessLen13b(u.length, p.length), w = this.makeRBT(y), E = this.stub(y), M = new Array(y), x = new Array(y), g = new Array(y), k = new Array(y), T = new Array(y), O = new Array(y), K = d.words;
      K.length = y, this.convert13b(u.words, u.length, M, y), this.convert13b(p.words, p.length, k, y), this.transform(M, E, x, g, y, w), this.transform(k, E, T, O, y, w);
      for (var Y = 0; Y < y; Y++) {
        var J = x[Y] * T[Y] - g[Y] * O[Y];
        g[Y] = x[Y] * O[Y] + g[Y] * T[Y], x[Y] = J;
      }
      return this.conjugate(x, g, y), this.transform(x, g, K, E, y, w), this.conjugate(K, E, y), this.normalize13b(K, y), d.negative = u.negative ^ p.negative, d.length = u.length + p.length, d.strip();
    }, i.prototype.mul = function(u) {
      var p = new i(null);
      return p.words = new Array(this.length + u.length), this.mulTo(u, p);
    }, i.prototype.mulf = function(u) {
      var p = new i(null);
      return p.words = new Array(this.length + u.length), C(this, u, p);
    }, i.prototype.imul = function(u) {
      return this.clone().mulTo(u, this);
    }, i.prototype.imuln = function(u) {
      r(typeof u == "number"), r(u < 67108864);
      for (var p = 0, d = 0; d < this.length; d++) {
        var y = (this.words[d] | 0) * u, w = (y & 67108863) + (p & 67108863);
        p >>= 26, p += y / 67108864 | 0, p += w >>> 26, this.words[d] = w & 67108863;
      }
      return p !== 0 && (this.words[d] = p, this.length++), this.length = u === 0 ? 1 : this.length, this;
    }, i.prototype.muln = function(u) {
      return this.clone().imuln(u);
    }, i.prototype.sqr = function() {
      return this.mul(this);
    }, i.prototype.isqr = function() {
      return this.imul(this.clone());
    }, i.prototype.pow = function(u) {
      var p = v(u);
      if (p.length === 0) return new i(1);
      for (var d = this, y = 0; y < p.length && p[y] === 0; y++, d = d.sqr()) ;
      if (++y < p.length) for (var w = d.sqr(); y < p.length; y++, w = w.sqr()) p[y] !== 0 && (d = d.mul(w));
      return d;
    }, i.prototype.iushln = function(u) {
      r(typeof u == "number" && u >= 0);
      var p = u % 26, d = (u - p) / 26, y = 67108863 >>> 26 - p << 26 - p, w;
      if (p !== 0) {
        var E = 0;
        for (w = 0; w < this.length; w++) {
          var M = this.words[w] & y, x = (this.words[w] | 0) - M << p;
          this.words[w] = x | E, E = M >>> 26 - p;
        }
        E && (this.words[w] = E, this.length++);
      }
      if (d !== 0) {
        for (w = this.length - 1; w >= 0; w--) this.words[w + d] = this.words[w];
        for (w = 0; w < d; w++) this.words[w] = 0;
        this.length += d;
      }
      return this.strip();
    }, i.prototype.ishln = function(u) {
      return r(this.negative === 0), this.iushln(u);
    }, i.prototype.iushrn = function(u, p, d) {
      r(typeof u == "number" && u >= 0);
      var y;
      p ? y = (p - p % 26) / 26 : y = 0;
      var w = u % 26, E = Math.min((u - w) / 26, this.length), M = 67108863 ^ 67108863 >>> w << w, x = d;
      if (y -= E, y = Math.max(0, y), x) {
        for (var g = 0; g < E; g++) x.words[g] = this.words[g];
        x.length = E;
      }
      if (E !== 0) if (this.length > E) for (this.length -= E, g = 0; g < this.length; g++) this.words[g] = this.words[g + E];
      else this.words[0] = 0, this.length = 1;
      var k = 0;
      for (g = this.length - 1; g >= 0 && (k !== 0 || g >= y); g--) {
        var T = this.words[g] | 0;
        this.words[g] = k << 26 - w | T >>> w, k = T & M;
      }
      return x && k !== 0 && (x.words[x.length++] = k), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, i.prototype.ishrn = function(u, p, d) {
      return r(this.negative === 0), this.iushrn(u, p, d);
    }, i.prototype.shln = function(u) {
      return this.clone().ishln(u);
    }, i.prototype.ushln = function(u) {
      return this.clone().iushln(u);
    }, i.prototype.shrn = function(u) {
      return this.clone().ishrn(u);
    }, i.prototype.ushrn = function(u) {
      return this.clone().iushrn(u);
    }, i.prototype.testn = function(u) {
      r(typeof u == "number" && u >= 0);
      var p = u % 26, d = (u - p) / 26, y = 1 << p;
      if (this.length <= d) return false;
      var w = this.words[d];
      return !!(w & y);
    }, i.prototype.imaskn = function(u) {
      r(typeof u == "number" && u >= 0);
      var p = u % 26, d = (u - p) / 26;
      if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= d) return this;
      if (p !== 0 && d++, this.length = Math.min(d, this.length), p !== 0) {
        var y = 67108863 ^ 67108863 >>> p << p;
        this.words[this.length - 1] &= y;
      }
      return this.strip();
    }, i.prototype.maskn = function(u) {
      return this.clone().imaskn(u);
    }, i.prototype.iaddn = function(u) {
      return r(typeof u == "number"), r(u < 67108864), u < 0 ? this.isubn(-u) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < u ? (this.words[0] = u - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(u), this.negative = 1, this) : this._iaddn(u);
    }, i.prototype._iaddn = function(u) {
      this.words[0] += u;
      for (var p = 0; p < this.length && this.words[p] >= 67108864; p++) this.words[p] -= 67108864, p === this.length - 1 ? this.words[p + 1] = 1 : this.words[p + 1]++;
      return this.length = Math.max(this.length, p + 1), this;
    }, i.prototype.isubn = function(u) {
      if (r(typeof u == "number"), r(u < 67108864), u < 0) return this.iaddn(-u);
      if (this.negative !== 0) return this.negative = 0, this.iaddn(u), this.negative = 1, this;
      if (this.words[0] -= u, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
      else for (var p = 0; p < this.length && this.words[p] < 0; p++) this.words[p] += 67108864, this.words[p + 1] -= 1;
      return this.strip();
    }, i.prototype.addn = function(u) {
      return this.clone().iaddn(u);
    }, i.prototype.subn = function(u) {
      return this.clone().isubn(u);
    }, i.prototype.iabs = function() {
      return this.negative = 0, this;
    }, i.prototype.abs = function() {
      return this.clone().iabs();
    }, i.prototype._ishlnsubmul = function(u, p, d) {
      var y = u.length + d, w;
      this._expand(y);
      var E, M = 0;
      for (w = 0; w < u.length; w++) {
        E = (this.words[w + d] | 0) + M;
        var x = (u.words[w] | 0) * p;
        E -= x & 67108863, M = (E >> 26) - (x / 67108864 | 0), this.words[w + d] = E & 67108863;
      }
      for (; w < this.length - d; w++) E = (this.words[w + d] | 0) + M, M = E >> 26, this.words[w + d] = E & 67108863;
      if (M === 0) return this.strip();
      for (r(M === -1), M = 0, w = 0; w < this.length; w++) E = -(this.words[w] | 0) + M, M = E >> 26, this.words[w] = E & 67108863;
      return this.negative = 1, this.strip();
    }, i.prototype._wordDiv = function(u, p) {
      var d = this.length - u.length, y = this.clone(), w = u, E = w.words[w.length - 1] | 0, M = this._countBits(E);
      d = 26 - M, d !== 0 && (w = w.ushln(d), y.iushln(d), E = w.words[w.length - 1] | 0);
      var x = y.length - w.length, g;
      if (p !== "mod") {
        g = new i(null), g.length = x + 1, g.words = new Array(g.length);
        for (var k = 0; k < g.length; k++) g.words[k] = 0;
      }
      var T = y.clone()._ishlnsubmul(w, 1, x);
      T.negative === 0 && (y = T, g && (g.words[x] = 1));
      for (var O = x - 1; O >= 0; O--) {
        var K = (y.words[w.length + O] | 0) * 67108864 + (y.words[w.length + O - 1] | 0);
        for (K = Math.min(K / E | 0, 67108863), y._ishlnsubmul(w, K, O); y.negative !== 0; ) K--, y.negative = 0, y._ishlnsubmul(w, 1, O), y.isZero() || (y.negative ^= 1);
        g && (g.words[O] = K);
      }
      return g && g.strip(), y.strip(), p !== "div" && d !== 0 && y.iushrn(d), { div: g || null, mod: y };
    }, i.prototype.divmod = function(u, p, d) {
      if (r(!u.isZero()), this.isZero()) return { div: new i(0), mod: new i(0) };
      var y, w, E;
      return this.negative !== 0 && u.negative === 0 ? (E = this.neg().divmod(u, p), p !== "mod" && (y = E.div.neg()), p !== "div" && (w = E.mod.neg(), d && w.negative !== 0 && w.iadd(u)), { div: y, mod: w }) : this.negative === 0 && u.negative !== 0 ? (E = this.divmod(u.neg(), p), p !== "mod" && (y = E.div.neg()), { div: y, mod: E.mod }) : this.negative & u.negative ? (E = this.neg().divmod(u.neg(), p), p !== "div" && (w = E.mod.neg(), d && w.negative !== 0 && w.isub(u)), { div: E.div, mod: w }) : u.length > this.length || this.cmp(u) < 0 ? { div: new i(0), mod: this } : u.length === 1 ? p === "div" ? { div: this.divn(u.words[0]), mod: null } : p === "mod" ? { div: null, mod: new i(this.modn(u.words[0])) } : { div: this.divn(u.words[0]), mod: new i(this.modn(u.words[0])) } : this._wordDiv(u, p);
    }, i.prototype.div = function(u) {
      return this.divmod(u, "div", false).div;
    }, i.prototype.mod = function(u) {
      return this.divmod(u, "mod", false).mod;
    }, i.prototype.umod = function(u) {
      return this.divmod(u, "mod", true).mod;
    }, i.prototype.divRound = function(u) {
      var p = this.divmod(u);
      if (p.mod.isZero()) return p.div;
      var d = p.div.negative !== 0 ? p.mod.isub(u) : p.mod, y = u.ushrn(1), w = u.andln(1), E = d.cmp(y);
      return E < 0 || w === 1 && E === 0 ? p.div : p.div.negative !== 0 ? p.div.isubn(1) : p.div.iaddn(1);
    }, i.prototype.modn = function(u) {
      r(u <= 67108863);
      for (var p = (1 << 26) % u, d = 0, y = this.length - 1; y >= 0; y--) d = (p * d + (this.words[y] | 0)) % u;
      return d;
    }, i.prototype.idivn = function(u) {
      r(u <= 67108863);
      for (var p = 0, d = this.length - 1; d >= 0; d--) {
        var y = (this.words[d] | 0) + p * 67108864;
        this.words[d] = y / u | 0, p = y % u;
      }
      return this.strip();
    }, i.prototype.divn = function(u) {
      return this.clone().idivn(u);
    }, i.prototype.egcd = function(u) {
      r(u.negative === 0), r(!u.isZero());
      var p = this, d = u.clone();
      p.negative !== 0 ? p = p.umod(u) : p = p.clone();
      for (var y = new i(1), w = new i(0), E = new i(0), M = new i(1), x = 0; p.isEven() && d.isEven(); ) p.iushrn(1), d.iushrn(1), ++x;
      for (var g = d.clone(), k = p.clone(); !p.isZero(); ) {
        for (var T = 0, O = 1; !(p.words[0] & O) && T < 26; ++T, O <<= 1) ;
        if (T > 0) for (p.iushrn(T); T-- > 0; ) (y.isOdd() || w.isOdd()) && (y.iadd(g), w.isub(k)), y.iushrn(1), w.iushrn(1);
        for (var K = 0, Y = 1; !(d.words[0] & Y) && K < 26; ++K, Y <<= 1) ;
        if (K > 0) for (d.iushrn(K); K-- > 0; ) (E.isOdd() || M.isOdd()) && (E.iadd(g), M.isub(k)), E.iushrn(1), M.iushrn(1);
        p.cmp(d) >= 0 ? (p.isub(d), y.isub(E), w.isub(M)) : (d.isub(p), E.isub(y), M.isub(w));
      }
      return { a: E, b: M, gcd: d.iushln(x) };
    }, i.prototype._invmp = function(u) {
      r(u.negative === 0), r(!u.isZero());
      var p = this, d = u.clone();
      p.negative !== 0 ? p = p.umod(u) : p = p.clone();
      for (var y = new i(1), w = new i(0), E = d.clone(); p.cmpn(1) > 0 && d.cmpn(1) > 0; ) {
        for (var M = 0, x = 1; !(p.words[0] & x) && M < 26; ++M, x <<= 1) ;
        if (M > 0) for (p.iushrn(M); M-- > 0; ) y.isOdd() && y.iadd(E), y.iushrn(1);
        for (var g = 0, k = 1; !(d.words[0] & k) && g < 26; ++g, k <<= 1) ;
        if (g > 0) for (d.iushrn(g); g-- > 0; ) w.isOdd() && w.iadd(E), w.iushrn(1);
        p.cmp(d) >= 0 ? (p.isub(d), y.isub(w)) : (d.isub(p), w.isub(y));
      }
      var T;
      return p.cmpn(1) === 0 ? T = y : T = w, T.cmpn(0) < 0 && T.iadd(u), T;
    }, i.prototype.gcd = function(u) {
      if (this.isZero()) return u.abs();
      if (u.isZero()) return this.abs();
      var p = this.clone(), d = u.clone();
      p.negative = 0, d.negative = 0;
      for (var y = 0; p.isEven() && d.isEven(); y++) p.iushrn(1), d.iushrn(1);
      do {
        for (; p.isEven(); ) p.iushrn(1);
        for (; d.isEven(); ) d.iushrn(1);
        var w = p.cmp(d);
        if (w < 0) {
          var E = p;
          p = d, d = E;
        } else if (w === 0 || d.cmpn(1) === 0) break;
        p.isub(d);
      } while (true);
      return d.iushln(y);
    }, i.prototype.invm = function(u) {
      return this.egcd(u).a.umod(u);
    }, i.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, i.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, i.prototype.andln = function(u) {
      return this.words[0] & u;
    }, i.prototype.bincn = function(u) {
      r(typeof u == "number");
      var p = u % 26, d = (u - p) / 26, y = 1 << p;
      if (this.length <= d) return this._expand(d + 1), this.words[d] |= y, this;
      for (var w = y, E = d; w !== 0 && E < this.length; E++) {
        var M = this.words[E] | 0;
        M += w, w = M >>> 26, M &= 67108863, this.words[E] = M;
      }
      return w !== 0 && (this.words[E] = w, this.length++), this;
    }, i.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, i.prototype.cmpn = function(u) {
      var p = u < 0;
      if (this.negative !== 0 && !p) return -1;
      if (this.negative === 0 && p) return 1;
      this.strip();
      var d;
      if (this.length > 1) d = 1;
      else {
        p && (u = -u), r(u <= 67108863, "Number is too big");
        var y = this.words[0] | 0;
        d = y === u ? 0 : y < u ? -1 : 1;
      }
      return this.negative !== 0 ? -d | 0 : d;
    }, i.prototype.cmp = function(u) {
      if (this.negative !== 0 && u.negative === 0) return -1;
      if (this.negative === 0 && u.negative !== 0) return 1;
      var p = this.ucmp(u);
      return this.negative !== 0 ? -p | 0 : p;
    }, i.prototype.ucmp = function(u) {
      if (this.length > u.length) return 1;
      if (this.length < u.length) return -1;
      for (var p = 0, d = this.length - 1; d >= 0; d--) {
        var y = this.words[d] | 0, w = u.words[d] | 0;
        if (y !== w) {
          y < w ? p = -1 : y > w && (p = 1);
          break;
        }
      }
      return p;
    }, i.prototype.gtn = function(u) {
      return this.cmpn(u) === 1;
    }, i.prototype.gt = function(u) {
      return this.cmp(u) === 1;
    }, i.prototype.gten = function(u) {
      return this.cmpn(u) >= 0;
    }, i.prototype.gte = function(u) {
      return this.cmp(u) >= 0;
    }, i.prototype.ltn = function(u) {
      return this.cmpn(u) === -1;
    }, i.prototype.lt = function(u) {
      return this.cmp(u) === -1;
    }, i.prototype.lten = function(u) {
      return this.cmpn(u) <= 0;
    }, i.prototype.lte = function(u) {
      return this.cmp(u) <= 0;
    }, i.prototype.eqn = function(u) {
      return this.cmpn(u) === 0;
    }, i.prototype.eq = function(u) {
      return this.cmp(u) === 0;
    }, i.red = function(u) {
      return new N(u);
    }, i.prototype.toRed = function(u) {
      return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), u.convertTo(this)._forceRed(u);
    }, i.prototype.fromRed = function() {
      return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, i.prototype._forceRed = function(u) {
      return this.red = u, this;
    }, i.prototype.forceRed = function(u) {
      return r(!this.red, "Already a number in reduction context"), this._forceRed(u);
    }, i.prototype.redAdd = function(u) {
      return r(this.red, "redAdd works only with red numbers"), this.red.add(this, u);
    }, i.prototype.redIAdd = function(u) {
      return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, u);
    }, i.prototype.redSub = function(u) {
      return r(this.red, "redSub works only with red numbers"), this.red.sub(this, u);
    }, i.prototype.redISub = function(u) {
      return r(this.red, "redISub works only with red numbers"), this.red.isub(this, u);
    }, i.prototype.redShl = function(u) {
      return r(this.red, "redShl works only with red numbers"), this.red.shl(this, u);
    }, i.prototype.redMul = function(u) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, u), this.red.mul(this, u);
    }, i.prototype.redIMul = function(u) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, u), this.red.imul(this, u);
    }, i.prototype.redSqr = function() {
      return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, i.prototype.redISqr = function() {
      return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, i.prototype.redSqrt = function() {
      return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, i.prototype.redInvm = function() {
      return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, i.prototype.redNeg = function() {
      return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, i.prototype.redPow = function(u) {
      return r(this.red && !u.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, u);
    };
    var S = { k256: null, p224: null, p192: null, p25519: null };
    function $(B, u) {
      this.name = B, this.p = new i(u, 16), this.n = this.p.bitLength(), this.k = new i(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    $.prototype._tmp = function() {
      var u = new i(null);
      return u.words = new Array(Math.ceil(this.n / 13)), u;
    }, $.prototype.ireduce = function(u) {
      var p = u, d;
      do
        this.split(p, this.tmp), p = this.imulK(p), p = p.iadd(this.tmp), d = p.bitLength();
      while (d > this.n);
      var y = d < this.n ? -1 : p.ucmp(this.p);
      return y === 0 ? (p.words[0] = 0, p.length = 1) : y > 0 ? p.isub(this.p) : p.strip !== void 0 ? p.strip() : p._strip(), p;
    }, $.prototype.split = function(u, p) {
      u.iushrn(this.n, 0, p);
    }, $.prototype.imulK = function(u) {
      return u.imul(this.k);
    };
    function F() {
      $.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    s(F, $), F.prototype.split = function(u, p) {
      for (var d = 4194303, y = Math.min(u.length, 9), w = 0; w < y; w++) p.words[w] = u.words[w];
      if (p.length = y, u.length <= 9) {
        u.words[0] = 0, u.length = 1;
        return;
      }
      var E = u.words[9];
      for (p.words[p.length++] = E & d, w = 10; w < u.length; w++) {
        var M = u.words[w] | 0;
        u.words[w - 10] = (M & d) << 4 | E >>> 22, E = M;
      }
      E >>>= 22, u.words[w - 10] = E, E === 0 && u.length > 10 ? u.length -= 10 : u.length -= 9;
    }, F.prototype.imulK = function(u) {
      u.words[u.length] = 0, u.words[u.length + 1] = 0, u.length += 2;
      for (var p = 0, d = 0; d < u.length; d++) {
        var y = u.words[d] | 0;
        p += y * 977, u.words[d] = p & 67108863, p = y * 64 + (p / 67108864 | 0);
      }
      return u.words[u.length - 1] === 0 && (u.length--, u.words[u.length - 1] === 0 && u.length--), u;
    };
    function U() {
      $.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    s(U, $);
    function Q() {
      $.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    s(Q, $);
    function P() {
      $.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    s(P, $), P.prototype.imulK = function(u) {
      for (var p = 0, d = 0; d < u.length; d++) {
        var y = (u.words[d] | 0) * 19 + p, w = y & 67108863;
        y >>>= 26, u.words[d] = w, p = y;
      }
      return p !== 0 && (u.words[u.length++] = p), u;
    }, i._prime = function(u) {
      if (S[u]) return S[u];
      var p;
      if (u === "k256") p = new F();
      else if (u === "p224") p = new U();
      else if (u === "p192") p = new Q();
      else if (u === "p25519") p = new P();
      else throw new Error("Unknown prime " + u);
      return S[u] = p, p;
    };
    function N(B) {
      if (typeof B == "string") {
        var u = i._prime(B);
        this.m = u.p, this.prime = u;
      } else r(B.gtn(1), "modulus must be greater than 1"), this.m = B, this.prime = null;
    }
    N.prototype._verify1 = function(u) {
      r(u.negative === 0, "red works only with positives"), r(u.red, "red works only with red numbers");
    }, N.prototype._verify2 = function(u, p) {
      r((u.negative | p.negative) === 0, "red works only with positives"), r(u.red && u.red === p.red, "red works only with red numbers");
    }, N.prototype.imod = function(u) {
      return this.prime ? this.prime.ireduce(u)._forceRed(this) : u.umod(this.m)._forceRed(this);
    }, N.prototype.neg = function(u) {
      return u.isZero() ? u.clone() : this.m.sub(u)._forceRed(this);
    }, N.prototype.add = function(u, p) {
      this._verify2(u, p);
      var d = u.add(p);
      return d.cmp(this.m) >= 0 && d.isub(this.m), d._forceRed(this);
    }, N.prototype.iadd = function(u, p) {
      this._verify2(u, p);
      var d = u.iadd(p);
      return d.cmp(this.m) >= 0 && d.isub(this.m), d;
    }, N.prototype.sub = function(u, p) {
      this._verify2(u, p);
      var d = u.sub(p);
      return d.cmpn(0) < 0 && d.iadd(this.m), d._forceRed(this);
    }, N.prototype.isub = function(u, p) {
      this._verify2(u, p);
      var d = u.isub(p);
      return d.cmpn(0) < 0 && d.iadd(this.m), d;
    }, N.prototype.shl = function(u, p) {
      return this._verify1(u), this.imod(u.ushln(p));
    }, N.prototype.imul = function(u, p) {
      return this._verify2(u, p), this.imod(u.imul(p));
    }, N.prototype.mul = function(u, p) {
      return this._verify2(u, p), this.imod(u.mul(p));
    }, N.prototype.isqr = function(u) {
      return this.imul(u, u.clone());
    }, N.prototype.sqr = function(u) {
      return this.mul(u, u);
    }, N.prototype.sqrt = function(u) {
      if (u.isZero()) return u.clone();
      var p = this.m.andln(3);
      if (r(p % 2 === 1), p === 3) {
        var d = this.m.add(new i(1)).iushrn(2);
        return this.pow(u, d);
      }
      for (var y = this.m.subn(1), w = 0; !y.isZero() && y.andln(1) === 0; ) w++, y.iushrn(1);
      r(!y.isZero());
      var E = new i(1).toRed(this), M = E.redNeg(), x = this.m.subn(1).iushrn(1), g = this.m.bitLength();
      for (g = new i(2 * g * g).toRed(this); this.pow(g, x).cmp(M) !== 0; ) g.redIAdd(M);
      for (var k = this.pow(g, y), T = this.pow(u, y.addn(1).iushrn(1)), O = this.pow(u, y), K = w; O.cmp(E) !== 0; ) {
        for (var Y = O, J = 0; Y.cmp(E) !== 0; J++) Y = Y.redSqr();
        r(J < K);
        var G = this.pow(k, new i(1).iushln(K - J - 1));
        T = T.redMul(G), k = G.redSqr(), O = O.redMul(k), K = J;
      }
      return T;
    }, N.prototype.invm = function(u) {
      var p = u._invmp(this.m);
      return p.negative !== 0 ? (p.negative = 0, this.imod(p).redNeg()) : this.imod(p);
    }, N.prototype.pow = function(u, p) {
      if (p.isZero()) return new i(1).toRed(this);
      if (p.cmpn(1) === 0) return u.clone();
      var d = 4, y = new Array(1 << d);
      y[0] = new i(1).toRed(this), y[1] = u;
      for (var w = 2; w < y.length; w++) y[w] = this.mul(y[w - 1], u);
      var E = y[0], M = 0, x = 0, g = p.bitLength() % 26;
      for (g === 0 && (g = 26), w = p.length - 1; w >= 0; w--) {
        for (var k = p.words[w], T = g - 1; T >= 0; T--) {
          var O = k >> T & 1;
          if (E !== y[0] && (E = this.sqr(E)), O === 0 && M === 0) {
            x = 0;
            continue;
          }
          M <<= 1, M |= O, x++, !(x !== d && (w !== 0 || T !== 0)) && (E = this.mul(E, y[M]), x = 0, M = 0);
        }
        g = 26;
      }
      return E;
    }, N.prototype.convertTo = function(u) {
      var p = u.umod(this.m);
      return p === u ? p.clone() : p;
    }, N.prototype.convertFrom = function(u) {
      var p = u.clone();
      return p.red = null, p;
    }, i.mont = function(u) {
      return new L(u);
    };
    function L(B) {
      N.call(this, B), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new i(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    s(L, N), L.prototype.convertTo = function(u) {
      return this.imod(u.ushln(this.shift));
    }, L.prototype.convertFrom = function(u) {
      var p = this.imod(u.mul(this.rinv));
      return p.red = null, p;
    }, L.prototype.imul = function(u, p) {
      if (u.isZero() || p.isZero()) return u.words[0] = 0, u.length = 1, u;
      var d = u.imul(p), y = d.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = d.isub(y).iushrn(this.shift), E = w;
      return w.cmp(this.m) >= 0 ? E = w.isub(this.m) : w.cmpn(0) < 0 && (E = w.iadd(this.m)), E._forceRed(this);
    }, L.prototype.mul = function(u, p) {
      if (u.isZero() || p.isZero()) return new i(0)._forceRed(this);
      var d = u.mul(p), y = d.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = d.isub(y).iushrn(this.shift), E = w;
      return w.cmp(this.m) >= 0 ? E = w.isub(this.m) : w.cmpn(0) < 0 && (E = w.iadd(this.m)), E._forceRed(this);
    }, L.prototype.invm = function(u) {
      var p = this.imod(u._invmp(this.m).mul(this.r2));
      return p._forceRed(this);
    };
  })(t3, mt);
})(t4);
var GZ = t4.exports, rv = {};
const VZ = {}, YZ = Object.freeze(Object.defineProperty({ __proto__: null, default: VZ }, Symbol.toStringTag, { value: "Module" })), WZ = sS(YZ);
var Ww;
function JZ() {
  return Ww || (Ww = 1, function(t3) {
    var e = Bd(), n = wr, r = t3;
    r.define = function(a, o) {
      return new s(a, o);
    };
    function s(i, a) {
      this.name = i, this.body = a, this.decoders = {}, this.encoders = {};
    }
    s.prototype._createNamed = function(a) {
      var o;
      try {
        o = WZ.runInThisContext("(function " + this.name + `(entity) {
  this._initNamed(entity);
})`);
      } catch {
        o = function(c) {
          this._initNamed(c);
        };
      }
      return n(o, a), o.prototype._initNamed = function(c) {
        a.call(this, c);
      }, new o(this);
    }, s.prototype._getDecoder = function(a) {
      return a = a || "der", this.decoders.hasOwnProperty(a) || (this.decoders[a] = this._createNamed(e.decoders[a])), this.decoders[a];
    }, s.prototype.decode = function(a, o, f) {
      return this._getDecoder(o).decode(a, f);
    }, s.prototype._getEncoder = function(a) {
      return a = a || "der", this.encoders.hasOwnProperty(a) || (this.encoders[a] = this._createNamed(e.encoders[a])), this.encoders[a];
    }, s.prototype.encode = function(a, o, f) {
      return this._getEncoder(o).encode(a, f);
    };
  }(rv)), rv;
}
var nv = {}, G$ = {}, ZZ = wr;
function ma(t3) {
  this._reporterState = { obj: null, path: [], options: t3 || {}, errors: [] };
}
G$.Reporter = ma;
ma.prototype.isError = function(e) {
  return e instanceof Pu;
};
ma.prototype.save = function() {
  var e = this._reporterState;
  return { obj: e.obj, pathLen: e.path.length };
};
ma.prototype.restore = function(e) {
  var n = this._reporterState;
  n.obj = e.obj, n.path = n.path.slice(0, e.pathLen);
};
ma.prototype.enterKey = function(e) {
  return this._reporterState.path.push(e);
};
ma.prototype.exitKey = function(e) {
  var n = this._reporterState;
  n.path = n.path.slice(0, e - 1);
};
ma.prototype.leaveKey = function(e, n, r) {
  var s = this._reporterState;
  this.exitKey(e), s.obj !== null && (s.obj[n] = r);
};
ma.prototype.path = function() {
  return this._reporterState.path.join("/");
};
ma.prototype.enterObject = function() {
  var e = this._reporterState, n = e.obj;
  return e.obj = {}, n;
};
ma.prototype.leaveObject = function(e) {
  var n = this._reporterState, r = n.obj;
  return n.obj = e, r;
};
ma.prototype.error = function(e) {
  var n, r = this._reporterState, s = e instanceof Pu;
  if (s ? n = e : n = new Pu(r.path.map(function(i) {
    return "[" + JSON.stringify(i) + "]";
  }).join(""), e.message || e, e.stack), !r.options.partial) throw n;
  return s || r.errors.push(n), n;
};
ma.prototype.wrapResult = function(e) {
  var n = this._reporterState;
  return n.options.partial ? { result: this.isError(e) ? null : e, errors: n.errors } : e;
};
function Pu(t3, e) {
  this.path = t3, this.rethrow(e);
}
ZZ(Pu, Error);
Pu.prototype.rethrow = function(e) {
  if (this.message = e + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, Pu), !this.stack) try {
    throw new Error(this.message);
  } catch (n) {
    this.stack = n.stack;
  }
  return this;
};
var np = {}, Jw;
function Zw() {
  if (Jw) return np;
  Jw = 1;
  var t3 = wr, e = lh().Reporter, n = $n.Buffer;
  function r(i, a) {
    if (e.call(this, a), !n.isBuffer(i)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = i, this.offset = 0, this.length = i.length;
  }
  t3(r, e), np.DecoderBuffer = r, r.prototype.save = function() {
    return { offset: this.offset, reporter: e.prototype.save.call(this) };
  }, r.prototype.restore = function(a) {
    var o = new r(this.base);
    return o.offset = a.offset, o.length = this.offset, this.offset = a.offset, e.prototype.restore.call(this, a.reporter), o;
  }, r.prototype.isEmpty = function() {
    return this.offset === this.length;
  }, r.prototype.readUInt8 = function(a) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, true) : this.error(a || "DecoderBuffer overrun");
  }, r.prototype.skip = function(a, o) {
    if (!(this.offset + a <= this.length)) return this.error(o || "DecoderBuffer overrun");
    var f = new r(this.base);
    return f._reporterState = this._reporterState, f.offset = this.offset, f.length = this.offset + a, this.offset += a, f;
  }, r.prototype.raw = function(a) {
    return this.base.slice(a ? a.offset : this.offset, this.length);
  };
  function s(i, a) {
    if (Array.isArray(i)) this.length = 0, this.value = i.map(function(o) {
      return o instanceof s || (o = new s(o, a)), this.length += o.length, o;
    }, this);
    else if (typeof i == "number") {
      if (!(0 <= i && i <= 255)) return a.error("non-byte EncoderBuffer value");
      this.value = i, this.length = 1;
    } else if (typeof i == "string") this.value = i, this.length = n.byteLength(i);
    else if (n.isBuffer(i)) this.value = i, this.length = i.length;
    else return a.error("Unsupported type: " + typeof i);
  }
  return np.EncoderBuffer = s, s.prototype.join = function(a, o) {
    return a || (a = new n(this.length)), o || (o = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(f) {
      f.join(a, o), o += f.length;
    }) : (typeof this.value == "number" ? a[o] = this.value : typeof this.value == "string" ? a.write(this.value, o) : n.isBuffer(this.value) && this.value.copy(a, o), o += this.length)), a;
  }, np;
}
var iv, jw;
function jZ() {
  if (jw) return iv;
  jw = 1;
  var t3 = lh().Reporter, e = lh().EncoderBuffer, n = lh().DecoderBuffer, r = ha, s = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"], i = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(s), a = ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"];
  function o(c, l) {
    var h = {};
    this._baseState = h, h.enc = c, h.parent = l || null, h.children = null, h.tag = null, h.args = null, h.reverseArgs = null, h.choice = null, h.optional = false, h.any = false, h.obj = false, h.use = null, h.useDecoder = null, h.key = null, h.default = null, h.explicit = null, h.implicit = null, h.contains = null, h.parent || (h.children = [], this._wrap());
  }
  iv = o;
  var f = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
  return o.prototype.clone = function() {
    var l = this._baseState, h = {};
    f.forEach(function(v) {
      h[v] = l[v];
    });
    var m = new this.constructor(h.parent);
    return m._baseState = h, m;
  }, o.prototype._wrap = function() {
    var l = this._baseState;
    i.forEach(function(h) {
      this[h] = function() {
        var v = new this.constructor(this);
        return l.children.push(v), v[h].apply(v, arguments);
      };
    }, this);
  }, o.prototype._init = function(l) {
    var h = this._baseState;
    r(h.parent === null), l.call(this), h.children = h.children.filter(function(m) {
      return m._baseState.parent === this;
    }, this), r.equal(h.children.length, 1, "Root node can have only one child");
  }, o.prototype._useArgs = function(l) {
    var h = this._baseState, m = l.filter(function(v) {
      return v instanceof this.constructor;
    }, this);
    l = l.filter(function(v) {
      return !(v instanceof this.constructor);
    }, this), m.length !== 0 && (r(h.children === null), h.children = m, m.forEach(function(v) {
      v._baseState.parent = this;
    }, this)), l.length !== 0 && (r(h.args === null), h.args = l, h.reverseArgs = l.map(function(v) {
      if (typeof v != "object" || v.constructor !== Object) return v;
      var b = {};
      return Object.keys(v).forEach(function(A) {
        A == (A | 0) && (A |= 0);
        var _ = v[A];
        b[_] = A;
      }), b;
    }));
  }, a.forEach(function(c) {
    o.prototype[c] = function() {
      var h = this._baseState;
      throw new Error(c + " not implemented for encoding: " + h.enc);
    };
  }), s.forEach(function(c) {
    o.prototype[c] = function() {
      var h = this._baseState, m = Array.prototype.slice.call(arguments);
      return r(h.tag === null), h.tag = c, this._useArgs(m), this;
    };
  }), o.prototype.use = function(l) {
    r(l);
    var h = this._baseState;
    return r(h.use === null), h.use = l, this;
  }, o.prototype.optional = function() {
    var l = this._baseState;
    return l.optional = true, this;
  }, o.prototype.def = function(l) {
    var h = this._baseState;
    return r(h.default === null), h.default = l, h.optional = true, this;
  }, o.prototype.explicit = function(l) {
    var h = this._baseState;
    return r(h.explicit === null && h.implicit === null), h.explicit = l, this;
  }, o.prototype.implicit = function(l) {
    var h = this._baseState;
    return r(h.explicit === null && h.implicit === null), h.implicit = l, this;
  }, o.prototype.obj = function() {
    var l = this._baseState, h = Array.prototype.slice.call(arguments);
    return l.obj = true, h.length !== 0 && this._useArgs(h), this;
  }, o.prototype.key = function(l) {
    var h = this._baseState;
    return r(h.key === null), h.key = l, this;
  }, o.prototype.any = function() {
    var l = this._baseState;
    return l.any = true, this;
  }, o.prototype.choice = function(l) {
    var h = this._baseState;
    return r(h.choice === null), h.choice = l, this._useArgs(Object.keys(l).map(function(m) {
      return l[m];
    })), this;
  }, o.prototype.contains = function(l) {
    var h = this._baseState;
    return r(h.use === null), h.contains = l, this;
  }, o.prototype._decode = function(l, h) {
    var m = this._baseState;
    if (m.parent === null) return l.wrapResult(m.children[0]._decode(l, h));
    var v = m.default, b = true, A = null;
    if (m.key !== null && (A = l.enterKey(m.key)), m.optional) {
      var _ = null;
      if (m.explicit !== null ? _ = m.explicit : m.implicit !== null ? _ = m.implicit : m.tag !== null && (_ = m.tag), _ === null && !m.any) {
        var C = l.save();
        try {
          m.choice === null ? this._decodeGeneric(m.tag, l, h) : this._decodeChoice(l, h), b = true;
        } catch {
          b = false;
        }
        l.restore(C);
      } else if (b = this._peekTag(l, _, m.any), l.isError(b)) return b;
    }
    var I;
    if (m.obj && b && (I = l.enterObject()), b) {
      if (m.explicit !== null) {
        var S = this._decodeTag(l, m.explicit);
        if (l.isError(S)) return S;
        l = S;
      }
      var $ = l.offset;
      if (m.use === null && m.choice === null) {
        if (m.any) var C = l.save();
        var F = this._decodeTag(l, m.implicit !== null ? m.implicit : m.tag, m.any);
        if (l.isError(F)) return F;
        m.any ? v = l.raw(C) : l = F;
      }
      if (h && h.track && m.tag !== null && h.track(l.path(), $, l.length, "tagged"), h && h.track && m.tag !== null && h.track(l.path(), l.offset, l.length, "content"), m.any ? v = v : m.choice === null ? v = this._decodeGeneric(m.tag, l, h) : v = this._decodeChoice(l, h), l.isError(v)) return v;
      if (!m.any && m.choice === null && m.children !== null && m.children.forEach(function(P) {
        P._decode(l, h);
      }), m.contains && (m.tag === "octstr" || m.tag === "bitstr")) {
        var U = new n(v);
        v = this._getUse(m.contains, l._reporterState.obj)._decode(U, h);
      }
    }
    return m.obj && b && (v = l.leaveObject(I)), m.key !== null && (v !== null || b === true) ? l.leaveKey(A, m.key, v) : A !== null && l.exitKey(A), v;
  }, o.prototype._decodeGeneric = function(l, h, m) {
    var v = this._baseState;
    return l === "seq" || l === "set" ? null : l === "seqof" || l === "setof" ? this._decodeList(h, l, v.args[0], m) : /str$/.test(l) ? this._decodeStr(h, l, m) : l === "objid" && v.args ? this._decodeObjid(h, v.args[0], v.args[1], m) : l === "objid" ? this._decodeObjid(h, null, null, m) : l === "gentime" || l === "utctime" ? this._decodeTime(h, l, m) : l === "null_" ? this._decodeNull(h, m) : l === "bool" ? this._decodeBool(h, m) : l === "objDesc" ? this._decodeStr(h, l, m) : l === "int" || l === "enum" ? this._decodeInt(h, v.args && v.args[0], m) : v.use !== null ? this._getUse(v.use, h._reporterState.obj)._decode(h, m) : h.error("unknown tag: " + l);
  }, o.prototype._getUse = function(l, h) {
    var m = this._baseState;
    return m.useDecoder = this._use(l, h), r(m.useDecoder._baseState.parent === null), m.useDecoder = m.useDecoder._baseState.children[0], m.implicit !== m.useDecoder._baseState.implicit && (m.useDecoder = m.useDecoder.clone(), m.useDecoder._baseState.implicit = m.implicit), m.useDecoder;
  }, o.prototype._decodeChoice = function(l, h) {
    var m = this._baseState, v = null, b = false;
    return Object.keys(m.choice).some(function(A) {
      var _ = l.save(), C = m.choice[A];
      try {
        var I = C._decode(l, h);
        if (l.isError(I)) return false;
        v = { type: A, value: I }, b = true;
      } catch {
        return l.restore(_), false;
      }
      return true;
    }, this), b ? v : l.error("Choice not matched");
  }, o.prototype._createEncoderBuffer = function(l) {
    return new e(l, this.reporter);
  }, o.prototype._encode = function(l, h, m) {
    var v = this._baseState;
    if (!(v.default !== null && v.default === l)) {
      var b = this._encodeValue(l, h, m);
      if (b !== void 0 && !this._skipDefault(b, h, m)) return b;
    }
  }, o.prototype._encodeValue = function(l, h, m) {
    var v = this._baseState;
    if (v.parent === null) return v.children[0]._encode(l, h || new t3());
    var C = null;
    if (this.reporter = h, v.optional && l === void 0) if (v.default !== null) l = v.default;
    else return;
    var b = null, A = false;
    if (v.any) C = this._createEncoderBuffer(l);
    else if (v.choice) C = this._encodeChoice(l, h);
    else if (v.contains) b = this._getUse(v.contains, m)._encode(l, h), A = true;
    else if (v.children) b = v.children.map(function($) {
      if ($._baseState.tag === "null_") return $._encode(null, h, l);
      if ($._baseState.key === null) return h.error("Child should have a key");
      var F = h.enterKey($._baseState.key);
      if (typeof l != "object") return h.error("Child expected, but input is not object");
      var U = $._encode(l[$._baseState.key], h, l);
      return h.leaveKey(F), U;
    }, this).filter(function($) {
      return $;
    }), b = this._createEncoderBuffer(b);
    else if (v.tag === "seqof" || v.tag === "setof") {
      if (!(v.args && v.args.length === 1)) return h.error("Too many args for : " + v.tag);
      if (!Array.isArray(l)) return h.error("seqof/setof, but data is not Array");
      var _ = this.clone();
      _._baseState.implicit = null, b = this._createEncoderBuffer(l.map(function($) {
        var F = this._baseState;
        return this._getUse(F.args[0], l)._encode($, h);
      }, _));
    } else v.use !== null ? C = this._getUse(v.use, m)._encode(l, h) : (b = this._encodePrimitive(v.tag, l), A = true);
    var C;
    if (!v.any && v.choice === null) {
      var I = v.implicit !== null ? v.implicit : v.tag, S = v.implicit === null ? "universal" : "context";
      I === null ? v.use === null && h.error("Tag could be omitted only for .use()") : v.use === null && (C = this._encodeComposite(I, A, S, b));
    }
    return v.explicit !== null && (C = this._encodeComposite(v.explicit, false, "context", C)), C;
  }, o.prototype._encodeChoice = function(l, h) {
    var m = this._baseState, v = m.choice[l.type];
    return v || r(false, l.type + " not found in " + JSON.stringify(Object.keys(m.choice))), v._encode(l.value, h);
  }, o.prototype._encodePrimitive = function(l, h) {
    var m = this._baseState;
    if (/str$/.test(l)) return this._encodeStr(h, l);
    if (l === "objid" && m.args) return this._encodeObjid(h, m.reverseArgs[0], m.args[1]);
    if (l === "objid") return this._encodeObjid(h, null, null);
    if (l === "gentime" || l === "utctime") return this._encodeTime(h, l);
    if (l === "null_") return this._encodeNull();
    if (l === "int" || l === "enum") return this._encodeInt(h, m.args && m.reverseArgs[0]);
    if (l === "bool") return this._encodeBool(h);
    if (l === "objDesc") return this._encodeStr(h, l);
    throw new Error("Unsupported tag: " + l);
  }, o.prototype._isNumstr = function(l) {
    return /^[0-9 ]*$/.test(l);
  }, o.prototype._isPrintstr = function(l) {
    return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(l);
  }, iv;
}
var Xw;
function lh() {
  return Xw || (Xw = 1, function(t3) {
    var e = t3;
    e.Reporter = G$.Reporter, e.DecoderBuffer = Zw().DecoderBuffer, e.EncoderBuffer = Zw().EncoderBuffer, e.Node = jZ();
  }(nv)), nv;
}
var sv = {}, av = {}, ex;
function XZ() {
  return ex || (ex = 1, function(t3) {
    var e = V$();
    t3.tagClass = { 0: "universal", 1: "application", 2: "context", 3: "private" }, t3.tagClassByName = e._reverse(t3.tagClass), t3.tag = { 0: "end", 1: "bool", 2: "int", 3: "bitstr", 4: "octstr", 5: "null_", 6: "objid", 7: "objDesc", 8: "external", 9: "real", 10: "enum", 11: "embed", 12: "utf8str", 13: "relativeOid", 16: "seq", 17: "set", 18: "numstr", 19: "printstr", 20: "t61str", 21: "videostr", 22: "ia5str", 23: "utctime", 24: "gentime", 25: "graphstr", 26: "iso646str", 27: "genstr", 28: "unistr", 29: "charstr", 30: "bmpstr" }, t3.tagByName = e._reverse(t3.tag);
  }(av)), av;
}
var tx;
function V$() {
  return tx || (tx = 1, function(t3) {
    var e = t3;
    e._reverse = function(r) {
      var s = {};
      return Object.keys(r).forEach(function(i) {
        (i | 0) == i && (i = i | 0);
        var a = r[i];
        s[a] = i;
      }), s;
    }, e.der = XZ();
  }(sv)), sv;
}
var ov = {}, fv, rx;
function Y$() {
  if (rx) return fv;
  rx = 1;
  var t3 = wr, e = Bd(), n = e.base, r = e.bignum, s = e.constants.der;
  function i(c) {
    this.enc = "der", this.name = c.name, this.entity = c, this.tree = new a(), this.tree._init(c.body);
  }
  fv = i, i.prototype.decode = function(l, h) {
    return l instanceof n.DecoderBuffer || (l = new n.DecoderBuffer(l, h)), this.tree._decode(l, h);
  };
  function a(c) {
    n.Node.call(this, "der", c);
  }
  t3(a, n.Node), a.prototype._peekTag = function(l, h, m) {
    if (l.isEmpty()) return false;
    var v = l.save(), b = o(l, 'Failed to peek tag: "' + h + '"');
    return l.isError(b) ? b : (l.restore(v), b.tag === h || b.tagStr === h || b.tagStr + "of" === h || m);
  }, a.prototype._decodeTag = function(l, h, m) {
    var v = o(l, 'Failed to decode tag of "' + h + '"');
    if (l.isError(v)) return v;
    var b = f(l, v.primitive, 'Failed to get length of "' + h + '"');
    if (l.isError(b)) return b;
    if (!m && v.tag !== h && v.tagStr !== h && v.tagStr + "of" !== h) return l.error('Failed to match tag: "' + h + '"');
    if (v.primitive || b !== null) return l.skip(b, 'Failed to match body of: "' + h + '"');
    var A = l.save(), _ = this._skipUntilEnd(l, 'Failed to skip indefinite length body: "' + this.tag + '"');
    return l.isError(_) ? _ : (b = l.offset - A.offset, l.restore(A), l.skip(b, 'Failed to match body of: "' + h + '"'));
  }, a.prototype._skipUntilEnd = function(l, h) {
    for (; ; ) {
      var m = o(l, h);
      if (l.isError(m)) return m;
      var v = f(l, m.primitive, h);
      if (l.isError(v)) return v;
      var b;
      if (m.primitive || v !== null ? b = l.skip(v) : b = this._skipUntilEnd(l, h), l.isError(b)) return b;
      if (m.tagStr === "end") break;
    }
  }, a.prototype._decodeList = function(l, h, m, v) {
    for (var b = []; !l.isEmpty(); ) {
      var A = this._peekTag(l, "end");
      if (l.isError(A)) return A;
      var _ = m.decode(l, "der", v);
      if (l.isError(_) && A) break;
      b.push(_);
    }
    return b;
  }, a.prototype._decodeStr = function(l, h) {
    if (h === "bitstr") {
      var m = l.readUInt8();
      return l.isError(m) ? m : { unused: m, data: l.raw() };
    } else if (h === "bmpstr") {
      var v = l.raw();
      if (v.length % 2 === 1) return l.error("Decoding of string type: bmpstr length mismatch");
      for (var b = "", A = 0; A < v.length / 2; A++) b += String.fromCharCode(v.readUInt16BE(A * 2));
      return b;
    } else if (h === "numstr") {
      var _ = l.raw().toString("ascii");
      return this._isNumstr(_) ? _ : l.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (h === "octstr") return l.raw();
      if (h === "objDesc") return l.raw();
      if (h === "printstr") {
        var C = l.raw().toString("ascii");
        return this._isPrintstr(C) ? C : l.error("Decoding of string type: printstr unsupported characters");
      } else return /str$/.test(h) ? l.raw().toString() : l.error("Decoding of string type: " + h + " unsupported");
    }
  }, a.prototype._decodeObjid = function(l, h, m) {
    for (var v, b = [], A = 0; !l.isEmpty(); ) {
      var _ = l.readUInt8();
      A <<= 7, A |= _ & 127, _ & 128 || (b.push(A), A = 0);
    }
    _ & 128 && b.push(A);
    var C = b[0] / 40 | 0, I = b[0] % 40;
    if (m ? v = b : v = [C, I].concat(b.slice(1)), h) {
      var S = h[v.join(" ")];
      S === void 0 && (S = h[v.join(".")]), S !== void 0 && (v = S);
    }
    return v;
  }, a.prototype._decodeTime = function(l, h) {
    var m = l.raw().toString();
    if (h === "gentime") var v = m.slice(0, 4) | 0, b = m.slice(4, 6) | 0, A = m.slice(6, 8) | 0, _ = m.slice(8, 10) | 0, C = m.slice(10, 12) | 0, I = m.slice(12, 14) | 0;
    else if (h === "utctime") {
      var v = m.slice(0, 2) | 0, b = m.slice(2, 4) | 0, A = m.slice(4, 6) | 0, _ = m.slice(6, 8) | 0, C = m.slice(8, 10) | 0, I = m.slice(10, 12) | 0;
      v < 70 ? v = 2e3 + v : v = 1900 + v;
    } else return l.error("Decoding " + h + " time is not supported yet");
    return Date.UTC(v, b - 1, A, _, C, I, 0);
  }, a.prototype._decodeNull = function(l) {
    return null;
  }, a.prototype._decodeBool = function(l) {
    var h = l.readUInt8();
    return l.isError(h) ? h : h !== 0;
  }, a.prototype._decodeInt = function(l, h) {
    var m = l.raw(), v = new r(m);
    return h && (v = h[v.toString(10)] || v), v;
  }, a.prototype._use = function(l, h) {
    return typeof l == "function" && (l = l(h)), l._getDecoder("der").tree;
  };
  function o(c, l) {
    var h = c.readUInt8(l);
    if (c.isError(h)) return h;
    var m = s.tagClass[h >> 6], v = (h & 32) === 0;
    if ((h & 31) === 31) {
      var b = h;
      for (h = 0; (b & 128) === 128; ) {
        if (b = c.readUInt8(l), c.isError(b)) return b;
        h <<= 7, h |= b & 127;
      }
    } else h &= 31;
    var A = s.tag[h];
    return { cls: m, primitive: v, tag: h, tagStr: A };
  }
  function f(c, l, h) {
    var m = c.readUInt8(h);
    if (c.isError(m)) return m;
    if (!l && m === 128) return null;
    if (!(m & 128)) return m;
    var v = m & 127;
    if (v > 4) return c.error("length octect is too long");
    m = 0;
    for (var b = 0; b < v; b++) {
      m <<= 8;
      var A = c.readUInt8(h);
      if (c.isError(A)) return A;
      m |= A;
    }
    return m;
  }
  return fv;
}
var lv, nx;
function ej() {
  if (nx) return lv;
  nx = 1;
  var t3 = wr, e = $n.Buffer, n = Y$();
  function r(s) {
    n.call(this, s), this.enc = "pem";
  }
  return t3(r, n), lv = r, r.prototype.decode = function(i, a) {
    for (var o = i.toString().split(/[\r\n]+/g), f = a.label.toUpperCase(), c = /^-----(BEGIN|END) ([^-]+)-----$/, l = -1, h = -1, m = 0; m < o.length; m++) {
      var v = o[m].match(c);
      if (v !== null && v[2] === f) if (l === -1) {
        if (v[1] !== "BEGIN") break;
        l = m;
      } else {
        if (v[1] !== "END") break;
        h = m;
        break;
      }
    }
    if (l === -1 || h === -1) throw new Error("PEM section not found for: " + f);
    var b = o.slice(l + 1, h).join("");
    b.replace(/[^a-z0-9\+\/=]+/gi, "");
    var A = new e(b, "base64");
    return n.prototype.decode.call(this, A, a);
  }, lv;
}
var ix;
function tj() {
  return ix || (ix = 1, function(t3) {
    var e = t3;
    e.der = Y$(), e.pem = ej();
  }(ov)), ov;
}
var uv = {}, cv, sx;
function W$() {
  if (sx) return cv;
  sx = 1;
  var t3 = wr, e = $n.Buffer, n = Bd(), r = n.base, s = n.constants.der;
  function i(c) {
    this.enc = "der", this.name = c.name, this.entity = c, this.tree = new a(), this.tree._init(c.body);
  }
  cv = i, i.prototype.encode = function(l, h) {
    return this.tree._encode(l, h).join();
  };
  function a(c) {
    r.Node.call(this, "der", c);
  }
  t3(a, r.Node), a.prototype._encodeComposite = function(l, h, m, v) {
    var b = f(l, h, m, this.reporter);
    if (v.length < 128) {
      var C = new e(2);
      return C[0] = b, C[1] = v.length, this._createEncoderBuffer([C, v]);
    }
    for (var A = 1, _ = v.length; _ >= 256; _ >>= 8) A++;
    var C = new e(2 + A);
    C[0] = b, C[1] = 128 | A;
    for (var _ = 1 + A, I = v.length; I > 0; _--, I >>= 8) C[_] = I & 255;
    return this._createEncoderBuffer([C, v]);
  }, a.prototype._encodeStr = function(l, h) {
    if (h === "bitstr") return this._createEncoderBuffer([l.unused | 0, l.data]);
    if (h === "bmpstr") {
      for (var m = new e(l.length * 2), v = 0; v < l.length; v++) m.writeUInt16BE(l.charCodeAt(v), v * 2);
      return this._createEncoderBuffer(m);
    } else return h === "numstr" ? this._isNumstr(l) ? this._createEncoderBuffer(l) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : h === "printstr" ? this._isPrintstr(l) ? this._createEncoderBuffer(l) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(h) ? this._createEncoderBuffer(l) : h === "objDesc" ? this._createEncoderBuffer(l) : this.reporter.error("Encoding of string type: " + h + " unsupported");
  }, a.prototype._encodeObjid = function(l, h, m) {
    if (typeof l == "string") {
      if (!h) return this.reporter.error("string objid given, but no values map found");
      if (!h.hasOwnProperty(l)) return this.reporter.error("objid not found in values map");
      l = h[l].split(/[\s\.]+/g);
      for (var v = 0; v < l.length; v++) l[v] |= 0;
    } else if (Array.isArray(l)) {
      l = l.slice();
      for (var v = 0; v < l.length; v++) l[v] |= 0;
    }
    if (!Array.isArray(l)) return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(l));
    if (!m) {
      if (l[1] >= 40) return this.reporter.error("Second objid identifier OOB");
      l.splice(0, 2, l[0] * 40 + l[1]);
    }
    for (var b = 0, v = 0; v < l.length; v++) {
      var A = l[v];
      for (b++; A >= 128; A >>= 7) b++;
    }
    for (var _ = new e(b), C = _.length - 1, v = l.length - 1; v >= 0; v--) {
      var A = l[v];
      for (_[C--] = A & 127; (A >>= 7) > 0; ) _[C--] = 128 | A & 127;
    }
    return this._createEncoderBuffer(_);
  };
  function o(c) {
    return c < 10 ? "0" + c : c;
  }
  a.prototype._encodeTime = function(l, h) {
    var m, v = new Date(l);
    return h === "gentime" ? m = [o(v.getFullYear()), o(v.getUTCMonth() + 1), o(v.getUTCDate()), o(v.getUTCHours()), o(v.getUTCMinutes()), o(v.getUTCSeconds()), "Z"].join("") : h === "utctime" ? m = [o(v.getFullYear() % 100), o(v.getUTCMonth() + 1), o(v.getUTCDate()), o(v.getUTCHours()), o(v.getUTCMinutes()), o(v.getUTCSeconds()), "Z"].join("") : this.reporter.error("Encoding " + h + " time is not supported yet"), this._encodeStr(m, "octstr");
  }, a.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  }, a.prototype._encodeInt = function(l, h) {
    if (typeof l == "string") {
      if (!h) return this.reporter.error("String int or enum given, but no values map");
      if (!h.hasOwnProperty(l)) return this.reporter.error("Values map doesn't contain: " + JSON.stringify(l));
      l = h[l];
    }
    if (typeof l != "number" && !e.isBuffer(l)) {
      var m = l.toArray();
      !l.sign && m[0] & 128 && m.unshift(0), l = new e(m);
    }
    if (e.isBuffer(l)) {
      var v = l.length;
      l.length === 0 && v++;
      var A = new e(v);
      return l.copy(A), l.length === 0 && (A[0] = 0), this._createEncoderBuffer(A);
    }
    if (l < 128) return this._createEncoderBuffer(l);
    if (l < 256) return this._createEncoderBuffer([0, l]);
    for (var v = 1, b = l; b >= 256; b >>= 8) v++;
    for (var A = new Array(v), b = A.length - 1; b >= 0; b--) A[b] = l & 255, l >>= 8;
    return A[0] & 128 && A.unshift(0), this._createEncoderBuffer(new e(A));
  }, a.prototype._encodeBool = function(l) {
    return this._createEncoderBuffer(l ? 255 : 0);
  }, a.prototype._use = function(l, h) {
    return typeof l == "function" && (l = l(h)), l._getEncoder("der").tree;
  }, a.prototype._skipDefault = function(l, h, m) {
    var v = this._baseState, b;
    if (v.default === null) return false;
    var A = l.join();
    if (v.defaultBuffer === void 0 && (v.defaultBuffer = this._encodeValue(v.default, h, m).join()), A.length !== v.defaultBuffer.length) return false;
    for (b = 0; b < A.length; b++) if (A[b] !== v.defaultBuffer[b]) return false;
    return true;
  };
  function f(c, l, h, m) {
    var v;
    if (c === "seqof" ? c = "seq" : c === "setof" && (c = "set"), s.tagByName.hasOwnProperty(c)) v = s.tagByName[c];
    else if (typeof c == "number" && (c | 0) === c) v = c;
    else return m.error("Unknown tag: " + c);
    return v >= 31 ? m.error("Multi-octet tag encoding unsupported") : (l || (v |= 32), v |= s.tagClassByName[h || "universal"] << 6, v);
  }
  return cv;
}
var hv, ax;
function rj() {
  if (ax) return hv;
  ax = 1;
  var t3 = wr, e = W$();
  function n(r) {
    e.call(this, r), this.enc = "pem";
  }
  return t3(n, e), hv = n, n.prototype.encode = function(s, i) {
    for (var a = e.prototype.encode.call(this, s), o = a.toString("base64"), f = ["-----BEGIN " + i.label + "-----"], c = 0; c < o.length; c += 64) f.push(o.slice(c, c + 64));
    return f.push("-----END " + i.label + "-----"), f.join(`
`);
  }, hv;
}
var ox;
function nj() {
  return ox || (ox = 1, function(t3) {
    var e = t3;
    e.der = W$(), e.pem = rj();
  }(uv)), uv;
}
var fx;
function Bd() {
  return fx || (fx = 1, function(t3) {
    var e = t3;
    e.bignum = GZ, e.define = JZ().define, e.base = lh(), e.constants = V$(), e.decoders = tj(), e.encoders = nj();
  }(tv)), tv;
}
var Ua = Bd(), lx = Ua.define("Time", function() {
  this.choice({ utcTime: this.utctime(), generalTime: this.gentime() });
}), ij = Ua.define("AttributeTypeValue", function() {
  this.seq().obj(this.key("type").objid(), this.key("value").any());
}), r4 = Ua.define("AlgorithmIdentifier", function() {
  this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
}), sj = Ua.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(this.key("algorithm").use(r4), this.key("subjectPublicKey").bitstr());
}), aj = Ua.define("RelativeDistinguishedName", function() {
  this.setof(ij);
}), oj = Ua.define("RDNSequence", function() {
  this.seqof(aj);
}), ux = Ua.define("Name", function() {
  this.choice({ rdnSequence: this.use(oj) });
}), fj = Ua.define("Validity", function() {
  this.seq().obj(this.key("notBefore").use(lx), this.key("notAfter").use(lx));
}), lj = Ua.define("Extension", function() {
  this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
}), uj = Ua.define("TBSCertificate", function() {
  this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(r4), this.key("issuer").use(ux), this.key("validity").use(fj), this.key("subject").use(ux), this.key("subjectPublicKeyInfo").use(sj), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(lj).optional());
}), cj = Ua.define("X509Certificate", function() {
  this.seq().obj(this.key("tbsCertificate").use(uj), this.key("signatureAlgorithm").use(r4), this.key("signatureValue").bitstr());
}), hj = cj, La = Bd();
Na.certificate = hj;
var dj = La.define("RSAPrivateKey", function() {
  this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
});
Na.RSAPrivateKey = dj;
var pj = La.define("RSAPublicKey", function() {
  this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
});
Na.RSAPublicKey = pj;
var J$ = La.define("AlgorithmIdentifier", function() {
  this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
}), gj = La.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(this.key("algorithm").use(J$), this.key("subjectPublicKey").bitstr());
});
Na.PublicKey = gj;
var mj = La.define("PrivateKeyInfo", function() {
  this.seq().obj(this.key("version").int(), this.key("algorithm").use(J$), this.key("subjectPrivateKey").octstr());
});
Na.PrivateKey = mj;
var vj = La.define("EncryptedPrivateKeyInfo", function() {
  this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
});
Na.EncryptedPrivateKey = vj;
var yj = La.define("DSAPrivateKey", function() {
  this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
});
Na.DSAPrivateKey = yj;
Na.DSAparam = La.define("DSAparam", function() {
  this.int();
});
var bj = La.define("ECParameters", function() {
  this.choice({ namedCurve: this.objid() });
}), Aj = La.define("ECPrivateKey", function() {
  this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(bj), this.key("publicKey").optional().explicit(1).bitstr());
});
Na.ECPrivateKey = Aj;
Na.signature = La.define("signature", function() {
  this.seq().obj(this.key("r").int(), this.key("s").int());
});
const wj = { "2.16.840.1.101.3.4.1.1": "aes-128-ecb", "2.16.840.1.101.3.4.1.2": "aes-128-cbc", "2.16.840.1.101.3.4.1.3": "aes-128-ofb", "2.16.840.1.101.3.4.1.4": "aes-128-cfb", "2.16.840.1.101.3.4.1.21": "aes-192-ecb", "2.16.840.1.101.3.4.1.22": "aes-192-cbc", "2.16.840.1.101.3.4.1.23": "aes-192-ofb", "2.16.840.1.101.3.4.1.24": "aes-192-cfb", "2.16.840.1.101.3.4.1.41": "aes-256-ecb", "2.16.840.1.101.3.4.1.42": "aes-256-cbc", "2.16.840.1.101.3.4.1.43": "aes-256-ofb", "2.16.840.1.101.3.4.1.44": "aes-256-cfb" };
var j3 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(t3, e) {
  var n = $n, r = n.Buffer;
  function s(a, o) {
    for (var f in a) o[f] = a[f];
  }
  r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow ? t3.exports = n : (s(n, e), e.Buffer = i);
  function i(a, o, f) {
    return r(a, o, f);
  }
  i.prototype = Object.create(r.prototype), s(r, i), i.from = function(a, o, f) {
    if (typeof a == "number") throw new TypeError("Argument must not be a number");
    return r(a, o, f);
  }, i.alloc = function(a, o, f) {
    if (typeof a != "number") throw new TypeError("Argument must be a number");
    var c = r(a);
    return o !== void 0 ? typeof f == "string" ? c.fill(o, f) : c.fill(o) : c.fill(0), c;
  }, i.allocUnsafe = function(a) {
    if (typeof a != "number") throw new TypeError("Argument must be a number");
    return r(a);
  }, i.allocUnsafeSlow = function(a) {
    if (typeof a != "number") throw new TypeError("Argument must be a number");
    return n.SlowBuffer(a);
  };
})(j3, j3.exports);
var Z$ = j3.exports, xj = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, _j = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, Ej = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, Bj = Jg, Cj = qs, ip = Z$.Buffer, kj = function(t3, e) {
  var n = t3.toString(), r = n.match(xj), s;
  if (r) {
    var a = "aes" + r[1], o = ip.from(r[2], "hex"), f = ip.from(r[3].replace(/[\r\n]/g, ""), "base64"), c = Bj(e, o.slice(0, 8), parseInt(r[1], 10)).key, l = [], h = Cj.createDecipheriv(a, c, o);
    l.push(h.update(f)), l.push(h.final()), s = ip.concat(l);
  } else {
    var i = n.match(Ej);
    s = ip.from(i[2].replace(/[\r\n]/g, ""), "base64");
  }
  var m = n.match(_j)[1];
  return { tag: m, data: s };
}, bs = Na, Ij = wj, Sj = kj, Mj = qs, $j = Vg.pbkdf2Sync, X3 = Z$.Buffer;
function Tj(t3, e) {
  var n = t3.algorithm.decrypt.kde.kdeparams.salt, r = parseInt(t3.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), s = Ij[t3.algorithm.decrypt.cipher.algo.join(".")], i = t3.algorithm.decrypt.cipher.iv, a = t3.subjectPrivateKey, o = parseInt(s.split("-")[1], 10) / 8, f = $j(e, n, r, o, "sha1"), c = Mj.createDecipheriv(s, f, i), l = [];
  return l.push(c.update(a)), l.push(c.final()), X3.concat(l);
}
function j$(t3) {
  var e;
  typeof t3 == "object" && !X3.isBuffer(t3) && (e = t3.passphrase, t3 = t3.key), typeof t3 == "string" && (t3 = X3.from(t3));
  var n = Sj(t3, e), r = n.tag, s = n.data, i, a;
  switch (r) {
    case "CERTIFICATE":
      a = bs.certificate.decode(s, "der").tbsCertificate.subjectPublicKeyInfo;
    case "PUBLIC KEY":
      switch (a || (a = bs.PublicKey.decode(s, "der")), i = a.algorithm.algorithm.join("."), i) {
        case "1.2.840.113549.1.1.1":
          return bs.RSAPublicKey.decode(a.subjectPublicKey.data, "der");
        case "1.2.840.10045.2.1":
          return a.subjectPrivateKey = a.subjectPublicKey, { type: "ec", data: a };
        case "1.2.840.10040.4.1":
          return a.algorithm.params.pub_key = bs.DSAparam.decode(a.subjectPublicKey.data, "der"), { type: "dsa", data: a.algorithm.params };
        default:
          throw new Error("unknown key id " + i);
      }
    case "ENCRYPTED PRIVATE KEY":
      s = bs.EncryptedPrivateKey.decode(s, "der"), s = Tj(s, e);
    case "PRIVATE KEY":
      switch (a = bs.PrivateKey.decode(s, "der"), i = a.algorithm.algorithm.join("."), i) {
        case "1.2.840.113549.1.1.1":
          return bs.RSAPrivateKey.decode(a.subjectPrivateKey, "der");
        case "1.2.840.10045.2.1":
          return { curve: a.algorithm.curve, privateKey: bs.ECPrivateKey.decode(a.subjectPrivateKey, "der").privateKey };
        case "1.2.840.10040.4.1":
          return a.algorithm.params.priv_key = bs.DSAparam.decode(a.subjectPrivateKey, "der"), { type: "dsa", params: a.algorithm.params };
        default:
          throw new Error("unknown key id " + i);
      }
    case "RSA PUBLIC KEY":
      return bs.RSAPublicKey.decode(s, "der");
    case "RSA PRIVATE KEY":
      return bs.RSAPrivateKey.decode(s, "der");
    case "DSA PRIVATE KEY":
      return { type: "dsa", params: bs.DSAPrivateKey.decode(s, "der") };
    case "EC PRIVATE KEY":
      return s = bs.ECPrivateKey.decode(s, "der"), { curve: s.parameters.value, privateKey: s.privateKey };
    default:
      throw new Error("unknown key type " + r);
  }
}
j$.signature = bs.signature;
var fm = j$;
const X$ = { "1.3.132.0.10": "secp256k1", "1.3.132.0.33": "p224", "1.2.840.10045.3.1.1": "p192", "1.2.840.10045.3.1.7": "p256", "1.3.132.0.34": "p384", "1.3.132.0.35": "p521" };
var cx;
function Dj() {
  if (cx) return $c.exports;
  cx = 1;
  var t3 = zA.Buffer, e = IM, n = YA, r = e4().ec, s = VA, i = fm, a = X$, o = 1;
  function f(C, I, S, $, F) {
    var U = i(I);
    if (U.curve) {
      if ($ !== "ecdsa" && $ !== "ecdsa/rsa") throw new Error("wrong private key type");
      return c(C, U);
    } else if (U.type === "dsa") {
      if ($ !== "dsa") throw new Error("wrong private key type");
      return l(C, U, S);
    }
    if ($ !== "rsa" && $ !== "ecdsa/rsa") throw new Error("wrong private key type");
    if (I.padding !== void 0 && I.padding !== o) throw new Error("illegal or unsupported padding mode");
    C = t3.concat([F, C]);
    for (var Q = U.modulus.byteLength(), P = [0, 1]; C.length + P.length + 1 < Q; ) P.push(255);
    P.push(0);
    for (var N = -1; ++N < C.length; ) P.push(C[N]);
    var L = n(P, U);
    return L;
  }
  function c(C, I) {
    var S = a[I.curve.join(".")];
    if (!S) throw new Error("unknown curve " + I.curve.join("."));
    var $ = new r(S), F = $.keyFromPrivate(I.privateKey), U = F.sign(C);
    return t3.from(U.toDER());
  }
  function l(C, I, S) {
    for (var $ = I.params.priv_key, F = I.params.p, U = I.params.q, Q = I.params.g, P = new s(0), N, L = v(C, U).mod(U), B = false, u = m($, U, C, S); B === false; ) N = A(U, u, S), P = _(Q, N, F, U), B = N.invm(U).imul(L.add($.mul(P))).mod(U), B.cmpn(0) === 0 && (B = false, P = new s(0));
    return h(P, B);
  }
  function h(C, I) {
    C = C.toArray(), I = I.toArray(), C[0] & 128 && (C = [0].concat(C)), I[0] & 128 && (I = [0].concat(I));
    var S = C.length + I.length + 4, $ = [48, S, 2, C.length];
    return $ = $.concat(C, [2, I.length], I), t3.from($);
  }
  function m(C, I, S, $) {
    if (C = t3.from(C.toArray()), C.length < I.byteLength()) {
      var F = t3.alloc(I.byteLength() - C.length);
      C = t3.concat([F, C]);
    }
    var U = S.length, Q = b(S, I), P = t3.alloc(U);
    P.fill(1);
    var N = t3.alloc(U);
    return N = e($, N).update(P).update(t3.from([0])).update(C).update(Q).digest(), P = e($, N).update(P).digest(), N = e($, N).update(P).update(t3.from([1])).update(C).update(Q).digest(), P = e($, N).update(P).digest(), { k: N, v: P };
  }
  function v(C, I) {
    var S = new s(C), $ = (C.length << 3) - I.bitLength();
    return $ > 0 && S.ishrn($), S;
  }
  function b(C, I) {
    C = v(C, I), C = C.mod(I);
    var S = t3.from(C.toArray());
    if (S.length < I.byteLength()) {
      var $ = t3.alloc(I.byteLength() - S.length);
      S = t3.concat([$, S]);
    }
    return S;
  }
  function A(C, I, S) {
    var $, F;
    do {
      for ($ = t3.alloc(0); $.length * 8 < C.bitLength(); ) I.v = e(S, I.k).update(I.v).digest(), $ = t3.concat([$, I.v]);
      F = v($, C), I.k = e(S, I.k).update(I.v).update(t3.from([0])).digest(), I.v = e(S, I.k).update(I.v).digest();
    } while (F.cmp(C) !== -1);
    return F;
  }
  function _(C, I, S, $) {
    return C.toRed(s.mont(S)).redPow(I).fromRed().mod($);
  }
  return $c.exports = f, $c.exports.getKey = m, $c.exports.makeKey = A, $c.exports;
}
var dv, hx;
function Rj() {
  if (hx) return dv;
  hx = 1;
  var t3 = zA.Buffer, e = VA, n = e4().ec, r = fm, s = X$;
  function i(c, l, h, m, v) {
    var b = r(h);
    if (b.type === "ec") {
      if (m !== "ecdsa" && m !== "ecdsa/rsa") throw new Error("wrong public key type");
      return a(c, l, b);
    } else if (b.type === "dsa") {
      if (m !== "dsa") throw new Error("wrong public key type");
      return o(c, l, b);
    }
    if (m !== "rsa" && m !== "ecdsa/rsa") throw new Error("wrong public key type");
    l = t3.concat([v, l]);
    for (var A = b.modulus.byteLength(), _ = [1], C = 0; l.length + _.length + 2 < A; ) _.push(255), C += 1;
    _.push(0);
    for (var I = -1; ++I < l.length; ) _.push(l[I]);
    _ = t3.from(_);
    var S = e.mont(b.modulus);
    c = new e(c).toRed(S), c = c.redPow(new e(b.publicExponent)), c = t3.from(c.fromRed().toArray());
    var $ = C < 8 ? 1 : 0;
    for (A = Math.min(c.length, _.length), c.length !== _.length && ($ = 1), I = -1; ++I < A; ) $ |= c[I] ^ _[I];
    return $ === 0;
  }
  function a(c, l, h) {
    var m = s[h.data.algorithm.curve.join(".")];
    if (!m) throw new Error("unknown curve " + h.data.algorithm.curve.join("."));
    var v = new n(m), b = h.data.subjectPrivateKey.data;
    return v.verify(l, c, b);
  }
  function o(c, l, h) {
    var m = h.data.p, v = h.data.q, b = h.data.g, A = h.data.pub_key, _ = r.signature.decode(c, "der"), C = _.s, I = _.r;
    f(C, v), f(I, v);
    var S = e.mont(m), $ = C.invm(v), F = b.toRed(S).redPow(new e(l).mul($).mod(v)).fromRed().mul(A.toRed(S).redPow(I.mul($).mod(v)).fromRed()).mod(m).mod(v);
    return F.cmp(I) === 0;
  }
  function f(c, l) {
    if (c.cmpn(0) <= 0) throw new Error("invalid sig");
    if (c.cmp(l) >= 0) throw new Error("invalid sig");
  }
  return dv = i, dv;
}
var pv, dx;
function Fj() {
  if (dx) return pv;
  dx = 1;
  var t3 = zA.Buffer, e = vd, n = dM, r = wr, s = Dj(), i = Rj(), a = SM;
  Object.keys(a).forEach(function(h) {
    a[h].id = t3.from(a[h].id, "hex"), a[h.toLowerCase()] = a[h];
  });
  function o(h) {
    n.Writable.call(this);
    var m = a[h];
    if (!m) throw new Error("Unknown message digest");
    this._hashType = m.hash, this._hash = e(m.hash), this._tag = m.id, this._signType = m.sign;
  }
  r(o, n.Writable), o.prototype._write = function(m, v, b) {
    this._hash.update(m), b();
  }, o.prototype.update = function(m, v) {
    return this._hash.update(typeof m == "string" ? t3.from(m, v) : m), this;
  }, o.prototype.sign = function(m, v) {
    this.end();
    var b = this._hash.digest(), A = s(b, m, this._hashType, this._signType, this._tag);
    return v ? A.toString(v) : A;
  };
  function f(h) {
    n.Writable.call(this);
    var m = a[h];
    if (!m) throw new Error("Unknown message digest");
    this._hash = e(m.hash), this._tag = m.id, this._signType = m.sign;
  }
  r(f, n.Writable), f.prototype._write = function(m, v, b) {
    this._hash.update(m), b();
  }, f.prototype.update = function(m, v) {
    return this._hash.update(typeof m == "string" ? t3.from(m, v) : m), this;
  }, f.prototype.verify = function(m, v, b) {
    var A = typeof v == "string" ? t3.from(v, b) : v;
    this.end();
    var _ = this._hash.digest();
    return i(A, _, m, this._signType, this._tag);
  };
  function c(h) {
    return new o(h);
  }
  function l(h) {
    return new f(h);
  }
  return pv = { Sign: c, Verify: l, createSign: c, createVerify: l }, pv;
}
var n4 = { exports: {} };
n4.exports;
(function(t3) {
  (function(e, n) {
    function r(B, u) {
      if (!B) throw new Error(u || "Assertion failed");
    }
    function s(B, u) {
      B.super_ = u;
      var p = function() {
      };
      p.prototype = u.prototype, B.prototype = new p(), B.prototype.constructor = B;
    }
    function i(B, u, p) {
      if (i.isBN(B)) return B;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, B !== null && ((u === "le" || u === "be") && (p = u, u = 10), this._init(B || 0, u || 10, p || "be"));
    }
    typeof e == "object" ? e.exports = i : n.BN = i, i.BN = i, i.wordSize = 26;
    var a;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? a = window.Buffer : a = $n.Buffer;
    } catch {
    }
    i.isBN = function(u) {
      return u instanceof i ? true : u !== null && typeof u == "object" && u.constructor.wordSize === i.wordSize && Array.isArray(u.words);
    }, i.max = function(u, p) {
      return u.cmp(p) > 0 ? u : p;
    }, i.min = function(u, p) {
      return u.cmp(p) < 0 ? u : p;
    }, i.prototype._init = function(u, p, d) {
      if (typeof u == "number") return this._initNumber(u, p, d);
      if (typeof u == "object") return this._initArray(u, p, d);
      p === "hex" && (p = 16), r(p === (p | 0) && p >= 2 && p <= 36), u = u.toString().replace(/\s+/g, "");
      var y = 0;
      u[0] === "-" && (y++, this.negative = 1), y < u.length && (p === 16 ? this._parseHex(u, y, d) : (this._parseBase(u, p, y), d === "le" && this._initArray(this.toArray(), p, d)));
    }, i.prototype._initNumber = function(u, p, d) {
      u < 0 && (this.negative = 1, u = -u), u < 67108864 ? (this.words = [u & 67108863], this.length = 1) : u < 4503599627370496 ? (this.words = [u & 67108863, u / 67108864 & 67108863], this.length = 2) : (r(u < 9007199254740992), this.words = [u & 67108863, u / 67108864 & 67108863, 1], this.length = 3), d === "le" && this._initArray(this.toArray(), p, d);
    }, i.prototype._initArray = function(u, p, d) {
      if (r(typeof u.length == "number"), u.length <= 0) return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(u.length / 3), this.words = new Array(this.length);
      for (var y = 0; y < this.length; y++) this.words[y] = 0;
      var w, E, M = 0;
      if (d === "be") for (y = u.length - 1, w = 0; y >= 0; y -= 3) E = u[y] | u[y - 1] << 8 | u[y - 2] << 16, this.words[w] |= E << M & 67108863, this.words[w + 1] = E >>> 26 - M & 67108863, M += 24, M >= 26 && (M -= 26, w++);
      else if (d === "le") for (y = 0, w = 0; y < u.length; y += 3) E = u[y] | u[y + 1] << 8 | u[y + 2] << 16, this.words[w] |= E << M & 67108863, this.words[w + 1] = E >>> 26 - M & 67108863, M += 24, M >= 26 && (M -= 26, w++);
      return this.strip();
    };
    function o(B, u) {
      var p = B.charCodeAt(u);
      return p >= 65 && p <= 70 ? p - 55 : p >= 97 && p <= 102 ? p - 87 : p - 48 & 15;
    }
    function f(B, u, p) {
      var d = o(B, p);
      return p - 1 >= u && (d |= o(B, p - 1) << 4), d;
    }
    i.prototype._parseHex = function(u, p, d) {
      this.length = Math.ceil((u.length - p) / 6), this.words = new Array(this.length);
      for (var y = 0; y < this.length; y++) this.words[y] = 0;
      var w = 0, E = 0, M;
      if (d === "be") for (y = u.length - 1; y >= p; y -= 2) M = f(u, p, y) << w, this.words[E] |= M & 67108863, w >= 18 ? (w -= 18, E += 1, this.words[E] |= M >>> 26) : w += 8;
      else {
        var x = u.length - p;
        for (y = x % 2 === 0 ? p + 1 : p; y < u.length; y += 2) M = f(u, p, y) << w, this.words[E] |= M & 67108863, w >= 18 ? (w -= 18, E += 1, this.words[E] |= M >>> 26) : w += 8;
      }
      this.strip();
    };
    function c(B, u, p, d) {
      for (var y = 0, w = Math.min(B.length, p), E = u; E < w; E++) {
        var M = B.charCodeAt(E) - 48;
        y *= d, M >= 49 ? y += M - 49 + 10 : M >= 17 ? y += M - 17 + 10 : y += M;
      }
      return y;
    }
    i.prototype._parseBase = function(u, p, d) {
      this.words = [0], this.length = 1;
      for (var y = 0, w = 1; w <= 67108863; w *= p) y++;
      y--, w = w / p | 0;
      for (var E = u.length - d, M = E % y, x = Math.min(E, E - M) + d, g = 0, k = d; k < x; k += y) g = c(u, k, k + y, p), this.imuln(w), this.words[0] + g < 67108864 ? this.words[0] += g : this._iaddn(g);
      if (M !== 0) {
        var T = 1;
        for (g = c(u, k, u.length, p), k = 0; k < M; k++) T *= p;
        this.imuln(T), this.words[0] + g < 67108864 ? this.words[0] += g : this._iaddn(g);
      }
      this.strip();
    }, i.prototype.copy = function(u) {
      u.words = new Array(this.length);
      for (var p = 0; p < this.length; p++) u.words[p] = this.words[p];
      u.length = this.length, u.negative = this.negative, u.red = this.red;
    }, i.prototype.clone = function() {
      var u = new i(null);
      return this.copy(u), u;
    }, i.prototype._expand = function(u) {
      for (; this.length < u; ) this.words[this.length++] = 0;
      return this;
    }, i.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; ) this.length--;
      return this._normSign();
    }, i.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, i.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var l = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], h = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], m = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    i.prototype.toString = function(u, p) {
      u = u || 10, p = p | 0 || 1;
      var d;
      if (u === 16 || u === "hex") {
        d = "";
        for (var y = 0, w = 0, E = 0; E < this.length; E++) {
          var M = this.words[E], x = ((M << y | w) & 16777215).toString(16);
          w = M >>> 24 - y & 16777215, y += 2, y >= 26 && (y -= 26, E--), w !== 0 || E !== this.length - 1 ? d = l[6 - x.length] + x + d : d = x + d;
        }
        for (w !== 0 && (d = w.toString(16) + d); d.length % p !== 0; ) d = "0" + d;
        return this.negative !== 0 && (d = "-" + d), d;
      }
      if (u === (u | 0) && u >= 2 && u <= 36) {
        var g = h[u], k = m[u];
        d = "";
        var T = this.clone();
        for (T.negative = 0; !T.isZero(); ) {
          var O = T.modn(k).toString(u);
          T = T.idivn(k), T.isZero() ? d = O + d : d = l[g - O.length] + O + d;
        }
        for (this.isZero() && (d = "0" + d); d.length % p !== 0; ) d = "0" + d;
        return this.negative !== 0 && (d = "-" + d), d;
      }
      r(false, "Base should be between 2 and 36");
    }, i.prototype.toNumber = function() {
      var u = this.words[0];
      return this.length === 2 ? u += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? u += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -u : u;
    }, i.prototype.toJSON = function() {
      return this.toString(16);
    }, i.prototype.toBuffer = function(u, p) {
      return r(typeof a < "u"), this.toArrayLike(a, u, p);
    }, i.prototype.toArray = function(u, p) {
      return this.toArrayLike(Array, u, p);
    }, i.prototype.toArrayLike = function(u, p, d) {
      var y = this.byteLength(), w = d || Math.max(1, y);
      r(y <= w, "byte array longer than desired length"), r(w > 0, "Requested array length <= 0"), this.strip();
      var E = p === "le", M = new u(w), x, g, k = this.clone();
      if (E) {
        for (g = 0; !k.isZero(); g++) x = k.andln(255), k.iushrn(8), M[g] = x;
        for (; g < w; g++) M[g] = 0;
      } else {
        for (g = 0; g < w - y; g++) M[g] = 0;
        for (g = 0; !k.isZero(); g++) x = k.andln(255), k.iushrn(8), M[w - g - 1] = x;
      }
      return M;
    }, Math.clz32 ? i.prototype._countBits = function(u) {
      return 32 - Math.clz32(u);
    } : i.prototype._countBits = function(u) {
      var p = u, d = 0;
      return p >= 4096 && (d += 13, p >>>= 13), p >= 64 && (d += 7, p >>>= 7), p >= 8 && (d += 4, p >>>= 4), p >= 2 && (d += 2, p >>>= 2), d + p;
    }, i.prototype._zeroBits = function(u) {
      if (u === 0) return 26;
      var p = u, d = 0;
      return p & 8191 || (d += 13, p >>>= 13), p & 127 || (d += 7, p >>>= 7), p & 15 || (d += 4, p >>>= 4), p & 3 || (d += 2, p >>>= 2), p & 1 || d++, d;
    }, i.prototype.bitLength = function() {
      var u = this.words[this.length - 1], p = this._countBits(u);
      return (this.length - 1) * 26 + p;
    };
    function v(B) {
      for (var u = new Array(B.bitLength()), p = 0; p < u.length; p++) {
        var d = p / 26 | 0, y = p % 26;
        u[p] = (B.words[d] & 1 << y) >>> y;
      }
      return u;
    }
    i.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var u = 0, p = 0; p < this.length; p++) {
        var d = this._zeroBits(this.words[p]);
        if (u += d, d !== 26) break;
      }
      return u;
    }, i.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, i.prototype.toTwos = function(u) {
      return this.negative !== 0 ? this.abs().inotn(u).iaddn(1) : this.clone();
    }, i.prototype.fromTwos = function(u) {
      return this.testn(u - 1) ? this.notn(u).iaddn(1).ineg() : this.clone();
    }, i.prototype.isNeg = function() {
      return this.negative !== 0;
    }, i.prototype.neg = function() {
      return this.clone().ineg();
    }, i.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, i.prototype.iuor = function(u) {
      for (; this.length < u.length; ) this.words[this.length++] = 0;
      for (var p = 0; p < u.length; p++) this.words[p] = this.words[p] | u.words[p];
      return this.strip();
    }, i.prototype.ior = function(u) {
      return r((this.negative | u.negative) === 0), this.iuor(u);
    }, i.prototype.or = function(u) {
      return this.length > u.length ? this.clone().ior(u) : u.clone().ior(this);
    }, i.prototype.uor = function(u) {
      return this.length > u.length ? this.clone().iuor(u) : u.clone().iuor(this);
    }, i.prototype.iuand = function(u) {
      var p;
      this.length > u.length ? p = u : p = this;
      for (var d = 0; d < p.length; d++) this.words[d] = this.words[d] & u.words[d];
      return this.length = p.length, this.strip();
    }, i.prototype.iand = function(u) {
      return r((this.negative | u.negative) === 0), this.iuand(u);
    }, i.prototype.and = function(u) {
      return this.length > u.length ? this.clone().iand(u) : u.clone().iand(this);
    }, i.prototype.uand = function(u) {
      return this.length > u.length ? this.clone().iuand(u) : u.clone().iuand(this);
    }, i.prototype.iuxor = function(u) {
      var p, d;
      this.length > u.length ? (p = this, d = u) : (p = u, d = this);
      for (var y = 0; y < d.length; y++) this.words[y] = p.words[y] ^ d.words[y];
      if (this !== p) for (; y < p.length; y++) this.words[y] = p.words[y];
      return this.length = p.length, this.strip();
    }, i.prototype.ixor = function(u) {
      return r((this.negative | u.negative) === 0), this.iuxor(u);
    }, i.prototype.xor = function(u) {
      return this.length > u.length ? this.clone().ixor(u) : u.clone().ixor(this);
    }, i.prototype.uxor = function(u) {
      return this.length > u.length ? this.clone().iuxor(u) : u.clone().iuxor(this);
    }, i.prototype.inotn = function(u) {
      r(typeof u == "number" && u >= 0);
      var p = Math.ceil(u / 26) | 0, d = u % 26;
      this._expand(p), d > 0 && p--;
      for (var y = 0; y < p; y++) this.words[y] = ~this.words[y] & 67108863;
      return d > 0 && (this.words[y] = ~this.words[y] & 67108863 >> 26 - d), this.strip();
    }, i.prototype.notn = function(u) {
      return this.clone().inotn(u);
    }, i.prototype.setn = function(u, p) {
      r(typeof u == "number" && u >= 0);
      var d = u / 26 | 0, y = u % 26;
      return this._expand(d + 1), p ? this.words[d] = this.words[d] | 1 << y : this.words[d] = this.words[d] & ~(1 << y), this.strip();
    }, i.prototype.iadd = function(u) {
      var p;
      if (this.negative !== 0 && u.negative === 0) return this.negative = 0, p = this.isub(u), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && u.negative !== 0) return u.negative = 0, p = this.isub(u), u.negative = 1, p._normSign();
      var d, y;
      this.length > u.length ? (d = this, y = u) : (d = u, y = this);
      for (var w = 0, E = 0; E < y.length; E++) p = (d.words[E] | 0) + (y.words[E] | 0) + w, this.words[E] = p & 67108863, w = p >>> 26;
      for (; w !== 0 && E < d.length; E++) p = (d.words[E] | 0) + w, this.words[E] = p & 67108863, w = p >>> 26;
      if (this.length = d.length, w !== 0) this.words[this.length] = w, this.length++;
      else if (d !== this) for (; E < d.length; E++) this.words[E] = d.words[E];
      return this;
    }, i.prototype.add = function(u) {
      var p;
      return u.negative !== 0 && this.negative === 0 ? (u.negative = 0, p = this.sub(u), u.negative ^= 1, p) : u.negative === 0 && this.negative !== 0 ? (this.negative = 0, p = u.sub(this), this.negative = 1, p) : this.length > u.length ? this.clone().iadd(u) : u.clone().iadd(this);
    }, i.prototype.isub = function(u) {
      if (u.negative !== 0) {
        u.negative = 0;
        var p = this.iadd(u);
        return u.negative = 1, p._normSign();
      } else if (this.negative !== 0) return this.negative = 0, this.iadd(u), this.negative = 1, this._normSign();
      var d = this.cmp(u);
      if (d === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var y, w;
      d > 0 ? (y = this, w = u) : (y = u, w = this);
      for (var E = 0, M = 0; M < w.length; M++) p = (y.words[M] | 0) - (w.words[M] | 0) + E, E = p >> 26, this.words[M] = p & 67108863;
      for (; E !== 0 && M < y.length; M++) p = (y.words[M] | 0) + E, E = p >> 26, this.words[M] = p & 67108863;
      if (E === 0 && M < y.length && y !== this) for (; M < y.length; M++) this.words[M] = y.words[M];
      return this.length = Math.max(this.length, M), y !== this && (this.negative = 1), this.strip();
    }, i.prototype.sub = function(u) {
      return this.clone().isub(u);
    };
    function b(B, u, p) {
      p.negative = u.negative ^ B.negative;
      var d = B.length + u.length | 0;
      p.length = d, d = d - 1 | 0;
      var y = B.words[0] | 0, w = u.words[0] | 0, E = y * w, M = E & 67108863, x = E / 67108864 | 0;
      p.words[0] = M;
      for (var g = 1; g < d; g++) {
        for (var k = x >>> 26, T = x & 67108863, O = Math.min(g, u.length - 1), K = Math.max(0, g - B.length + 1); K <= O; K++) {
          var Y = g - K | 0;
          y = B.words[Y] | 0, w = u.words[K] | 0, E = y * w + T, k += E / 67108864 | 0, T = E & 67108863;
        }
        p.words[g] = T | 0, x = k | 0;
      }
      return x !== 0 ? p.words[g] = x | 0 : p.length--, p.strip();
    }
    var A = function(u, p, d) {
      var y = u.words, w = p.words, E = d.words, M = 0, x, g, k, T = y[0] | 0, O = T & 8191, K = T >>> 13, Y = y[1] | 0, J = Y & 8191, G = Y >>> 13, X = y[2] | 0, ie = X & 8191, de = X >>> 13, se = y[3] | 0, te = se & 8191, le = se >>> 13, Z = y[4] | 0, ve = Z & 8191, he = Z >>> 13, me = y[5] | 0, ce = me & 8191, ye = me >>> 13, Oe = y[6] | 0, Se = Oe & 8191, Ce = Oe >>> 13, Ne = y[7] | 0, $e = Ne & 8191, Re = Ne >>> 13, Ge = y[8] | 0, Fe = Ge & 8191, Ue = Ge >>> 13, kt = y[9] | 0, pe = kt & 8191, re = kt >>> 13, ue = w[0] | 0, xe = ue & 8191, Me = ue >>> 13, We = w[1] | 0, De = We & 8191, je = We >>> 13, ir = w[2] | 0, Xe = ir & 8191, st = ir >>> 13, Vt = w[3] | 0, at = Vt & 8191, ht = Vt >>> 13, br = w[4] | 0, ot = br & 8191, ct = br >>> 13, _r = w[5] | 0, ft = _r & 8191, pt = _r >>> 13, Cr = w[6] | 0, nt = Cr & 8191, lt = Cr >>> 13, ge = w[7] | 0, be = ge & 8191, Ae = ge >>> 13, ne = w[8] | 0, _e = ne & 8191, Te = ne >>> 13, Ye = w[9] | 0, Pe = Ye & 8191, He = Ye >>> 13;
      d.negative = u.negative ^ p.negative, d.length = 19, x = Math.imul(O, xe), g = Math.imul(O, Me), g = g + Math.imul(K, xe) | 0, k = Math.imul(K, Me);
      var _t = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, x = Math.imul(J, xe), g = Math.imul(J, Me), g = g + Math.imul(G, xe) | 0, k = Math.imul(G, Me), x = x + Math.imul(O, De) | 0, g = g + Math.imul(O, je) | 0, g = g + Math.imul(K, De) | 0, k = k + Math.imul(K, je) | 0;
      var vt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, x = Math.imul(ie, xe), g = Math.imul(ie, Me), g = g + Math.imul(de, xe) | 0, k = Math.imul(de, Me), x = x + Math.imul(J, De) | 0, g = g + Math.imul(J, je) | 0, g = g + Math.imul(G, De) | 0, k = k + Math.imul(G, je) | 0, x = x + Math.imul(O, Xe) | 0, g = g + Math.imul(O, st) | 0, g = g + Math.imul(K, Xe) | 0, k = k + Math.imul(K, st) | 0;
      var cr = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (cr >>> 26) | 0, cr &= 67108863, x = Math.imul(te, xe), g = Math.imul(te, Me), g = g + Math.imul(le, xe) | 0, k = Math.imul(le, Me), x = x + Math.imul(ie, De) | 0, g = g + Math.imul(ie, je) | 0, g = g + Math.imul(de, De) | 0, k = k + Math.imul(de, je) | 0, x = x + Math.imul(J, Xe) | 0, g = g + Math.imul(J, st) | 0, g = g + Math.imul(G, Xe) | 0, k = k + Math.imul(G, st) | 0, x = x + Math.imul(O, at) | 0, g = g + Math.imul(O, ht) | 0, g = g + Math.imul(K, at) | 0, k = k + Math.imul(K, ht) | 0;
      var Tt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, x = Math.imul(ve, xe), g = Math.imul(ve, Me), g = g + Math.imul(he, xe) | 0, k = Math.imul(he, Me), x = x + Math.imul(te, De) | 0, g = g + Math.imul(te, je) | 0, g = g + Math.imul(le, De) | 0, k = k + Math.imul(le, je) | 0, x = x + Math.imul(ie, Xe) | 0, g = g + Math.imul(ie, st) | 0, g = g + Math.imul(de, Xe) | 0, k = k + Math.imul(de, st) | 0, x = x + Math.imul(J, at) | 0, g = g + Math.imul(J, ht) | 0, g = g + Math.imul(G, at) | 0, k = k + Math.imul(G, ht) | 0, x = x + Math.imul(O, ot) | 0, g = g + Math.imul(O, ct) | 0, g = g + Math.imul(K, ot) | 0, k = k + Math.imul(K, ct) | 0;
      var Gt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Gt >>> 26) | 0, Gt &= 67108863, x = Math.imul(ce, xe), g = Math.imul(ce, Me), g = g + Math.imul(ye, xe) | 0, k = Math.imul(ye, Me), x = x + Math.imul(ve, De) | 0, g = g + Math.imul(ve, je) | 0, g = g + Math.imul(he, De) | 0, k = k + Math.imul(he, je) | 0, x = x + Math.imul(te, Xe) | 0, g = g + Math.imul(te, st) | 0, g = g + Math.imul(le, Xe) | 0, k = k + Math.imul(le, st) | 0, x = x + Math.imul(ie, at) | 0, g = g + Math.imul(ie, ht) | 0, g = g + Math.imul(de, at) | 0, k = k + Math.imul(de, ht) | 0, x = x + Math.imul(J, ot) | 0, g = g + Math.imul(J, ct) | 0, g = g + Math.imul(G, ot) | 0, k = k + Math.imul(G, ct) | 0, x = x + Math.imul(O, ft) | 0, g = g + Math.imul(O, pt) | 0, g = g + Math.imul(K, ft) | 0, k = k + Math.imul(K, pt) | 0;
      var Yt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Yt >>> 26) | 0, Yt &= 67108863, x = Math.imul(Se, xe), g = Math.imul(Se, Me), g = g + Math.imul(Ce, xe) | 0, k = Math.imul(Ce, Me), x = x + Math.imul(ce, De) | 0, g = g + Math.imul(ce, je) | 0, g = g + Math.imul(ye, De) | 0, k = k + Math.imul(ye, je) | 0, x = x + Math.imul(ve, Xe) | 0, g = g + Math.imul(ve, st) | 0, g = g + Math.imul(he, Xe) | 0, k = k + Math.imul(he, st) | 0, x = x + Math.imul(te, at) | 0, g = g + Math.imul(te, ht) | 0, g = g + Math.imul(le, at) | 0, k = k + Math.imul(le, ht) | 0, x = x + Math.imul(ie, ot) | 0, g = g + Math.imul(ie, ct) | 0, g = g + Math.imul(de, ot) | 0, k = k + Math.imul(de, ct) | 0, x = x + Math.imul(J, ft) | 0, g = g + Math.imul(J, pt) | 0, g = g + Math.imul(G, ft) | 0, k = k + Math.imul(G, pt) | 0, x = x + Math.imul(O, nt) | 0, g = g + Math.imul(O, lt) | 0, g = g + Math.imul(K, nt) | 0, k = k + Math.imul(K, lt) | 0;
      var or = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (or >>> 26) | 0, or &= 67108863, x = Math.imul($e, xe), g = Math.imul($e, Me), g = g + Math.imul(Re, xe) | 0, k = Math.imul(Re, Me), x = x + Math.imul(Se, De) | 0, g = g + Math.imul(Se, je) | 0, g = g + Math.imul(Ce, De) | 0, k = k + Math.imul(Ce, je) | 0, x = x + Math.imul(ce, Xe) | 0, g = g + Math.imul(ce, st) | 0, g = g + Math.imul(ye, Xe) | 0, k = k + Math.imul(ye, st) | 0, x = x + Math.imul(ve, at) | 0, g = g + Math.imul(ve, ht) | 0, g = g + Math.imul(he, at) | 0, k = k + Math.imul(he, ht) | 0, x = x + Math.imul(te, ot) | 0, g = g + Math.imul(te, ct) | 0, g = g + Math.imul(le, ot) | 0, k = k + Math.imul(le, ct) | 0, x = x + Math.imul(ie, ft) | 0, g = g + Math.imul(ie, pt) | 0, g = g + Math.imul(de, ft) | 0, k = k + Math.imul(de, pt) | 0, x = x + Math.imul(J, nt) | 0, g = g + Math.imul(J, lt) | 0, g = g + Math.imul(G, nt) | 0, k = k + Math.imul(G, lt) | 0, x = x + Math.imul(O, be) | 0, g = g + Math.imul(O, Ae) | 0, g = g + Math.imul(K, be) | 0, k = k + Math.imul(K, Ae) | 0;
      var sr = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (sr >>> 26) | 0, sr &= 67108863, x = Math.imul(Fe, xe), g = Math.imul(Fe, Me), g = g + Math.imul(Ue, xe) | 0, k = Math.imul(Ue, Me), x = x + Math.imul($e, De) | 0, g = g + Math.imul($e, je) | 0, g = g + Math.imul(Re, De) | 0, k = k + Math.imul(Re, je) | 0, x = x + Math.imul(Se, Xe) | 0, g = g + Math.imul(Se, st) | 0, g = g + Math.imul(Ce, Xe) | 0, k = k + Math.imul(Ce, st) | 0, x = x + Math.imul(ce, at) | 0, g = g + Math.imul(ce, ht) | 0, g = g + Math.imul(ye, at) | 0, k = k + Math.imul(ye, ht) | 0, x = x + Math.imul(ve, ot) | 0, g = g + Math.imul(ve, ct) | 0, g = g + Math.imul(he, ot) | 0, k = k + Math.imul(he, ct) | 0, x = x + Math.imul(te, ft) | 0, g = g + Math.imul(te, pt) | 0, g = g + Math.imul(le, ft) | 0, k = k + Math.imul(le, pt) | 0, x = x + Math.imul(ie, nt) | 0, g = g + Math.imul(ie, lt) | 0, g = g + Math.imul(de, nt) | 0, k = k + Math.imul(de, lt) | 0, x = x + Math.imul(J, be) | 0, g = g + Math.imul(J, Ae) | 0, g = g + Math.imul(G, be) | 0, k = k + Math.imul(G, Ae) | 0, x = x + Math.imul(O, _e) | 0, g = g + Math.imul(O, Te) | 0, g = g + Math.imul(K, _e) | 0, k = k + Math.imul(K, Te) | 0;
      var Wt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Wt >>> 26) | 0, Wt &= 67108863, x = Math.imul(pe, xe), g = Math.imul(pe, Me), g = g + Math.imul(re, xe) | 0, k = Math.imul(re, Me), x = x + Math.imul(Fe, De) | 0, g = g + Math.imul(Fe, je) | 0, g = g + Math.imul(Ue, De) | 0, k = k + Math.imul(Ue, je) | 0, x = x + Math.imul($e, Xe) | 0, g = g + Math.imul($e, st) | 0, g = g + Math.imul(Re, Xe) | 0, k = k + Math.imul(Re, st) | 0, x = x + Math.imul(Se, at) | 0, g = g + Math.imul(Se, ht) | 0, g = g + Math.imul(Ce, at) | 0, k = k + Math.imul(Ce, ht) | 0, x = x + Math.imul(ce, ot) | 0, g = g + Math.imul(ce, ct) | 0, g = g + Math.imul(ye, ot) | 0, k = k + Math.imul(ye, ct) | 0, x = x + Math.imul(ve, ft) | 0, g = g + Math.imul(ve, pt) | 0, g = g + Math.imul(he, ft) | 0, k = k + Math.imul(he, pt) | 0, x = x + Math.imul(te, nt) | 0, g = g + Math.imul(te, lt) | 0, g = g + Math.imul(le, nt) | 0, k = k + Math.imul(le, lt) | 0, x = x + Math.imul(ie, be) | 0, g = g + Math.imul(ie, Ae) | 0, g = g + Math.imul(de, be) | 0, k = k + Math.imul(de, Ae) | 0, x = x + Math.imul(J, _e) | 0, g = g + Math.imul(J, Te) | 0, g = g + Math.imul(G, _e) | 0, k = k + Math.imul(G, Te) | 0, x = x + Math.imul(O, Pe) | 0, g = g + Math.imul(O, He) | 0, g = g + Math.imul(K, Pe) | 0, k = k + Math.imul(K, He) | 0;
      var tr = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (tr >>> 26) | 0, tr &= 67108863, x = Math.imul(pe, De), g = Math.imul(pe, je), g = g + Math.imul(re, De) | 0, k = Math.imul(re, je), x = x + Math.imul(Fe, Xe) | 0, g = g + Math.imul(Fe, st) | 0, g = g + Math.imul(Ue, Xe) | 0, k = k + Math.imul(Ue, st) | 0, x = x + Math.imul($e, at) | 0, g = g + Math.imul($e, ht) | 0, g = g + Math.imul(Re, at) | 0, k = k + Math.imul(Re, ht) | 0, x = x + Math.imul(Se, ot) | 0, g = g + Math.imul(Se, ct) | 0, g = g + Math.imul(Ce, ot) | 0, k = k + Math.imul(Ce, ct) | 0, x = x + Math.imul(ce, ft) | 0, g = g + Math.imul(ce, pt) | 0, g = g + Math.imul(ye, ft) | 0, k = k + Math.imul(ye, pt) | 0, x = x + Math.imul(ve, nt) | 0, g = g + Math.imul(ve, lt) | 0, g = g + Math.imul(he, nt) | 0, k = k + Math.imul(he, lt) | 0, x = x + Math.imul(te, be) | 0, g = g + Math.imul(te, Ae) | 0, g = g + Math.imul(le, be) | 0, k = k + Math.imul(le, Ae) | 0, x = x + Math.imul(ie, _e) | 0, g = g + Math.imul(ie, Te) | 0, g = g + Math.imul(de, _e) | 0, k = k + Math.imul(de, Te) | 0, x = x + Math.imul(J, Pe) | 0, g = g + Math.imul(J, He) | 0, g = g + Math.imul(G, Pe) | 0, k = k + Math.imul(G, He) | 0;
      var Jt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Jt >>> 26) | 0, Jt &= 67108863, x = Math.imul(pe, Xe), g = Math.imul(pe, st), g = g + Math.imul(re, Xe) | 0, k = Math.imul(re, st), x = x + Math.imul(Fe, at) | 0, g = g + Math.imul(Fe, ht) | 0, g = g + Math.imul(Ue, at) | 0, k = k + Math.imul(Ue, ht) | 0, x = x + Math.imul($e, ot) | 0, g = g + Math.imul($e, ct) | 0, g = g + Math.imul(Re, ot) | 0, k = k + Math.imul(Re, ct) | 0, x = x + Math.imul(Se, ft) | 0, g = g + Math.imul(Se, pt) | 0, g = g + Math.imul(Ce, ft) | 0, k = k + Math.imul(Ce, pt) | 0, x = x + Math.imul(ce, nt) | 0, g = g + Math.imul(ce, lt) | 0, g = g + Math.imul(ye, nt) | 0, k = k + Math.imul(ye, lt) | 0, x = x + Math.imul(ve, be) | 0, g = g + Math.imul(ve, Ae) | 0, g = g + Math.imul(he, be) | 0, k = k + Math.imul(he, Ae) | 0, x = x + Math.imul(te, _e) | 0, g = g + Math.imul(te, Te) | 0, g = g + Math.imul(le, _e) | 0, k = k + Math.imul(le, Te) | 0, x = x + Math.imul(ie, Pe) | 0, g = g + Math.imul(ie, He) | 0, g = g + Math.imul(de, Pe) | 0, k = k + Math.imul(de, He) | 0;
      var Ft = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Ft >>> 26) | 0, Ft &= 67108863, x = Math.imul(pe, at), g = Math.imul(pe, ht), g = g + Math.imul(re, at) | 0, k = Math.imul(re, ht), x = x + Math.imul(Fe, ot) | 0, g = g + Math.imul(Fe, ct) | 0, g = g + Math.imul(Ue, ot) | 0, k = k + Math.imul(Ue, ct) | 0, x = x + Math.imul($e, ft) | 0, g = g + Math.imul($e, pt) | 0, g = g + Math.imul(Re, ft) | 0, k = k + Math.imul(Re, pt) | 0, x = x + Math.imul(Se, nt) | 0, g = g + Math.imul(Se, lt) | 0, g = g + Math.imul(Ce, nt) | 0, k = k + Math.imul(Ce, lt) | 0, x = x + Math.imul(ce, be) | 0, g = g + Math.imul(ce, Ae) | 0, g = g + Math.imul(ye, be) | 0, k = k + Math.imul(ye, Ae) | 0, x = x + Math.imul(ve, _e) | 0, g = g + Math.imul(ve, Te) | 0, g = g + Math.imul(he, _e) | 0, k = k + Math.imul(he, Te) | 0, x = x + Math.imul(te, Pe) | 0, g = g + Math.imul(te, He) | 0, g = g + Math.imul(le, Pe) | 0, k = k + Math.imul(le, He) | 0;
      var Ut = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, x = Math.imul(pe, ot), g = Math.imul(pe, ct), g = g + Math.imul(re, ot) | 0, k = Math.imul(re, ct), x = x + Math.imul(Fe, ft) | 0, g = g + Math.imul(Fe, pt) | 0, g = g + Math.imul(Ue, ft) | 0, k = k + Math.imul(Ue, pt) | 0, x = x + Math.imul($e, nt) | 0, g = g + Math.imul($e, lt) | 0, g = g + Math.imul(Re, nt) | 0, k = k + Math.imul(Re, lt) | 0, x = x + Math.imul(Se, be) | 0, g = g + Math.imul(Se, Ae) | 0, g = g + Math.imul(Ce, be) | 0, k = k + Math.imul(Ce, Ae) | 0, x = x + Math.imul(ce, _e) | 0, g = g + Math.imul(ce, Te) | 0, g = g + Math.imul(ye, _e) | 0, k = k + Math.imul(ye, Te) | 0, x = x + Math.imul(ve, Pe) | 0, g = g + Math.imul(ve, He) | 0, g = g + Math.imul(he, Pe) | 0, k = k + Math.imul(he, He) | 0;
      var Mt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, x = Math.imul(pe, ft), g = Math.imul(pe, pt), g = g + Math.imul(re, ft) | 0, k = Math.imul(re, pt), x = x + Math.imul(Fe, nt) | 0, g = g + Math.imul(Fe, lt) | 0, g = g + Math.imul(Ue, nt) | 0, k = k + Math.imul(Ue, lt) | 0, x = x + Math.imul($e, be) | 0, g = g + Math.imul($e, Ae) | 0, g = g + Math.imul(Re, be) | 0, k = k + Math.imul(Re, Ae) | 0, x = x + Math.imul(Se, _e) | 0, g = g + Math.imul(Se, Te) | 0, g = g + Math.imul(Ce, _e) | 0, k = k + Math.imul(Ce, Te) | 0, x = x + Math.imul(ce, Pe) | 0, g = g + Math.imul(ce, He) | 0, g = g + Math.imul(ye, Pe) | 0, k = k + Math.imul(ye, He) | 0;
      var Pt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, x = Math.imul(pe, nt), g = Math.imul(pe, lt), g = g + Math.imul(re, nt) | 0, k = Math.imul(re, lt), x = x + Math.imul(Fe, be) | 0, g = g + Math.imul(Fe, Ae) | 0, g = g + Math.imul(Ue, be) | 0, k = k + Math.imul(Ue, Ae) | 0, x = x + Math.imul($e, _e) | 0, g = g + Math.imul($e, Te) | 0, g = g + Math.imul(Re, _e) | 0, k = k + Math.imul(Re, Te) | 0, x = x + Math.imul(Se, Pe) | 0, g = g + Math.imul(Se, He) | 0, g = g + Math.imul(Ce, Pe) | 0, k = k + Math.imul(Ce, He) | 0;
      var Nt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, x = Math.imul(pe, be), g = Math.imul(pe, Ae), g = g + Math.imul(re, be) | 0, k = Math.imul(re, Ae), x = x + Math.imul(Fe, _e) | 0, g = g + Math.imul(Fe, Te) | 0, g = g + Math.imul(Ue, _e) | 0, k = k + Math.imul(Ue, Te) | 0, x = x + Math.imul($e, Pe) | 0, g = g + Math.imul($e, He) | 0, g = g + Math.imul(Re, Pe) | 0, k = k + Math.imul(Re, He) | 0;
      var It = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, x = Math.imul(pe, _e), g = Math.imul(pe, Te), g = g + Math.imul(re, _e) | 0, k = Math.imul(re, Te), x = x + Math.imul(Fe, Pe) | 0, g = g + Math.imul(Fe, He) | 0, g = g + Math.imul(Ue, Pe) | 0, k = k + Math.imul(Ue, He) | 0;
      var tt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, x = Math.imul(pe, Pe), g = Math.imul(pe, He), g = g + Math.imul(re, Pe) | 0, k = Math.imul(re, He);
      var rt = (M + x | 0) + ((g & 8191) << 13) | 0;
      return M = (k + (g >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, E[0] = _t, E[1] = vt, E[2] = cr, E[3] = Tt, E[4] = Gt, E[5] = Yt, E[6] = or, E[7] = sr, E[8] = Wt, E[9] = tr, E[10] = Jt, E[11] = Ft, E[12] = Ut, E[13] = Mt, E[14] = Pt, E[15] = Nt, E[16] = It, E[17] = tt, E[18] = rt, M !== 0 && (E[19] = M, d.length++), d;
    };
    Math.imul || (A = b);
    function _(B, u, p) {
      p.negative = u.negative ^ B.negative, p.length = B.length + u.length;
      for (var d = 0, y = 0, w = 0; w < p.length - 1; w++) {
        var E = y;
        y = 0;
        for (var M = d & 67108863, x = Math.min(w, u.length - 1), g = Math.max(0, w - B.length + 1); g <= x; g++) {
          var k = w - g, T = B.words[k] | 0, O = u.words[g] | 0, K = T * O, Y = K & 67108863;
          E = E + (K / 67108864 | 0) | 0, Y = Y + M | 0, M = Y & 67108863, E = E + (Y >>> 26) | 0, y += E >>> 26, E &= 67108863;
        }
        p.words[w] = M, d = E, E = y;
      }
      return d !== 0 ? p.words[w] = d : p.length--, p.strip();
    }
    function C(B, u, p) {
      var d = new I();
      return d.mulp(B, u, p);
    }
    i.prototype.mulTo = function(u, p) {
      var d, y = this.length + u.length;
      return this.length === 10 && u.length === 10 ? d = A(this, u, p) : y < 63 ? d = b(this, u, p) : y < 1024 ? d = _(this, u, p) : d = C(this, u, p), d;
    };
    function I(B, u) {
      this.x = B, this.y = u;
    }
    I.prototype.makeRBT = function(u) {
      for (var p = new Array(u), d = i.prototype._countBits(u) - 1, y = 0; y < u; y++) p[y] = this.revBin(y, d, u);
      return p;
    }, I.prototype.revBin = function(u, p, d) {
      if (u === 0 || u === d - 1) return u;
      for (var y = 0, w = 0; w < p; w++) y |= (u & 1) << p - w - 1, u >>= 1;
      return y;
    }, I.prototype.permute = function(u, p, d, y, w, E) {
      for (var M = 0; M < E; M++) y[M] = p[u[M]], w[M] = d[u[M]];
    }, I.prototype.transform = function(u, p, d, y, w, E) {
      this.permute(E, u, p, d, y, w);
      for (var M = 1; M < w; M <<= 1) for (var x = M << 1, g = Math.cos(2 * Math.PI / x), k = Math.sin(2 * Math.PI / x), T = 0; T < w; T += x) for (var O = g, K = k, Y = 0; Y < M; Y++) {
        var J = d[T + Y], G = y[T + Y], X = d[T + Y + M], ie = y[T + Y + M], de = O * X - K * ie;
        ie = O * ie + K * X, X = de, d[T + Y] = J + X, y[T + Y] = G + ie, d[T + Y + M] = J - X, y[T + Y + M] = G - ie, Y !== x && (de = g * O - k * K, K = g * K + k * O, O = de);
      }
    }, I.prototype.guessLen13b = function(u, p) {
      var d = Math.max(p, u) | 1, y = d & 1, w = 0;
      for (d = d / 2 | 0; d; d = d >>> 1) w++;
      return 1 << w + 1 + y;
    }, I.prototype.conjugate = function(u, p, d) {
      if (!(d <= 1)) for (var y = 0; y < d / 2; y++) {
        var w = u[y];
        u[y] = u[d - y - 1], u[d - y - 1] = w, w = p[y], p[y] = -p[d - y - 1], p[d - y - 1] = -w;
      }
    }, I.prototype.normalize13b = function(u, p) {
      for (var d = 0, y = 0; y < p / 2; y++) {
        var w = Math.round(u[2 * y + 1] / p) * 8192 + Math.round(u[2 * y] / p) + d;
        u[y] = w & 67108863, w < 67108864 ? d = 0 : d = w / 67108864 | 0;
      }
      return u;
    }, I.prototype.convert13b = function(u, p, d, y) {
      for (var w = 0, E = 0; E < p; E++) w = w + (u[E] | 0), d[2 * E] = w & 8191, w = w >>> 13, d[2 * E + 1] = w & 8191, w = w >>> 13;
      for (E = 2 * p; E < y; ++E) d[E] = 0;
      r(w === 0), r((w & -8192) === 0);
    }, I.prototype.stub = function(u) {
      for (var p = new Array(u), d = 0; d < u; d++) p[d] = 0;
      return p;
    }, I.prototype.mulp = function(u, p, d) {
      var y = 2 * this.guessLen13b(u.length, p.length), w = this.makeRBT(y), E = this.stub(y), M = new Array(y), x = new Array(y), g = new Array(y), k = new Array(y), T = new Array(y), O = new Array(y), K = d.words;
      K.length = y, this.convert13b(u.words, u.length, M, y), this.convert13b(p.words, p.length, k, y), this.transform(M, E, x, g, y, w), this.transform(k, E, T, O, y, w);
      for (var Y = 0; Y < y; Y++) {
        var J = x[Y] * T[Y] - g[Y] * O[Y];
        g[Y] = x[Y] * O[Y] + g[Y] * T[Y], x[Y] = J;
      }
      return this.conjugate(x, g, y), this.transform(x, g, K, E, y, w), this.conjugate(K, E, y), this.normalize13b(K, y), d.negative = u.negative ^ p.negative, d.length = u.length + p.length, d.strip();
    }, i.prototype.mul = function(u) {
      var p = new i(null);
      return p.words = new Array(this.length + u.length), this.mulTo(u, p);
    }, i.prototype.mulf = function(u) {
      var p = new i(null);
      return p.words = new Array(this.length + u.length), C(this, u, p);
    }, i.prototype.imul = function(u) {
      return this.clone().mulTo(u, this);
    }, i.prototype.imuln = function(u) {
      r(typeof u == "number"), r(u < 67108864);
      for (var p = 0, d = 0; d < this.length; d++) {
        var y = (this.words[d] | 0) * u, w = (y & 67108863) + (p & 67108863);
        p >>= 26, p += y / 67108864 | 0, p += w >>> 26, this.words[d] = w & 67108863;
      }
      return p !== 0 && (this.words[d] = p, this.length++), this.length = u === 0 ? 1 : this.length, this;
    }, i.prototype.muln = function(u) {
      return this.clone().imuln(u);
    }, i.prototype.sqr = function() {
      return this.mul(this);
    }, i.prototype.isqr = function() {
      return this.imul(this.clone());
    }, i.prototype.pow = function(u) {
      var p = v(u);
      if (p.length === 0) return new i(1);
      for (var d = this, y = 0; y < p.length && p[y] === 0; y++, d = d.sqr()) ;
      if (++y < p.length) for (var w = d.sqr(); y < p.length; y++, w = w.sqr()) p[y] !== 0 && (d = d.mul(w));
      return d;
    }, i.prototype.iushln = function(u) {
      r(typeof u == "number" && u >= 0);
      var p = u % 26, d = (u - p) / 26, y = 67108863 >>> 26 - p << 26 - p, w;
      if (p !== 0) {
        var E = 0;
        for (w = 0; w < this.length; w++) {
          var M = this.words[w] & y, x = (this.words[w] | 0) - M << p;
          this.words[w] = x | E, E = M >>> 26 - p;
        }
        E && (this.words[w] = E, this.length++);
      }
      if (d !== 0) {
        for (w = this.length - 1; w >= 0; w--) this.words[w + d] = this.words[w];
        for (w = 0; w < d; w++) this.words[w] = 0;
        this.length += d;
      }
      return this.strip();
    }, i.prototype.ishln = function(u) {
      return r(this.negative === 0), this.iushln(u);
    }, i.prototype.iushrn = function(u, p, d) {
      r(typeof u == "number" && u >= 0);
      var y;
      p ? y = (p - p % 26) / 26 : y = 0;
      var w = u % 26, E = Math.min((u - w) / 26, this.length), M = 67108863 ^ 67108863 >>> w << w, x = d;
      if (y -= E, y = Math.max(0, y), x) {
        for (var g = 0; g < E; g++) x.words[g] = this.words[g];
        x.length = E;
      }
      if (E !== 0) if (this.length > E) for (this.length -= E, g = 0; g < this.length; g++) this.words[g] = this.words[g + E];
      else this.words[0] = 0, this.length = 1;
      var k = 0;
      for (g = this.length - 1; g >= 0 && (k !== 0 || g >= y); g--) {
        var T = this.words[g] | 0;
        this.words[g] = k << 26 - w | T >>> w, k = T & M;
      }
      return x && k !== 0 && (x.words[x.length++] = k), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, i.prototype.ishrn = function(u, p, d) {
      return r(this.negative === 0), this.iushrn(u, p, d);
    }, i.prototype.shln = function(u) {
      return this.clone().ishln(u);
    }, i.prototype.ushln = function(u) {
      return this.clone().iushln(u);
    }, i.prototype.shrn = function(u) {
      return this.clone().ishrn(u);
    }, i.prototype.ushrn = function(u) {
      return this.clone().iushrn(u);
    }, i.prototype.testn = function(u) {
      r(typeof u == "number" && u >= 0);
      var p = u % 26, d = (u - p) / 26, y = 1 << p;
      if (this.length <= d) return false;
      var w = this.words[d];
      return !!(w & y);
    }, i.prototype.imaskn = function(u) {
      r(typeof u == "number" && u >= 0);
      var p = u % 26, d = (u - p) / 26;
      if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= d) return this;
      if (p !== 0 && d++, this.length = Math.min(d, this.length), p !== 0) {
        var y = 67108863 ^ 67108863 >>> p << p;
        this.words[this.length - 1] &= y;
      }
      return this.strip();
    }, i.prototype.maskn = function(u) {
      return this.clone().imaskn(u);
    }, i.prototype.iaddn = function(u) {
      return r(typeof u == "number"), r(u < 67108864), u < 0 ? this.isubn(-u) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < u ? (this.words[0] = u - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(u), this.negative = 1, this) : this._iaddn(u);
    }, i.prototype._iaddn = function(u) {
      this.words[0] += u;
      for (var p = 0; p < this.length && this.words[p] >= 67108864; p++) this.words[p] -= 67108864, p === this.length - 1 ? this.words[p + 1] = 1 : this.words[p + 1]++;
      return this.length = Math.max(this.length, p + 1), this;
    }, i.prototype.isubn = function(u) {
      if (r(typeof u == "number"), r(u < 67108864), u < 0) return this.iaddn(-u);
      if (this.negative !== 0) return this.negative = 0, this.iaddn(u), this.negative = 1, this;
      if (this.words[0] -= u, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
      else for (var p = 0; p < this.length && this.words[p] < 0; p++) this.words[p] += 67108864, this.words[p + 1] -= 1;
      return this.strip();
    }, i.prototype.addn = function(u) {
      return this.clone().iaddn(u);
    }, i.prototype.subn = function(u) {
      return this.clone().isubn(u);
    }, i.prototype.iabs = function() {
      return this.negative = 0, this;
    }, i.prototype.abs = function() {
      return this.clone().iabs();
    }, i.prototype._ishlnsubmul = function(u, p, d) {
      var y = u.length + d, w;
      this._expand(y);
      var E, M = 0;
      for (w = 0; w < u.length; w++) {
        E = (this.words[w + d] | 0) + M;
        var x = (u.words[w] | 0) * p;
        E -= x & 67108863, M = (E >> 26) - (x / 67108864 | 0), this.words[w + d] = E & 67108863;
      }
      for (; w < this.length - d; w++) E = (this.words[w + d] | 0) + M, M = E >> 26, this.words[w + d] = E & 67108863;
      if (M === 0) return this.strip();
      for (r(M === -1), M = 0, w = 0; w < this.length; w++) E = -(this.words[w] | 0) + M, M = E >> 26, this.words[w] = E & 67108863;
      return this.negative = 1, this.strip();
    }, i.prototype._wordDiv = function(u, p) {
      var d = this.length - u.length, y = this.clone(), w = u, E = w.words[w.length - 1] | 0, M = this._countBits(E);
      d = 26 - M, d !== 0 && (w = w.ushln(d), y.iushln(d), E = w.words[w.length - 1] | 0);
      var x = y.length - w.length, g;
      if (p !== "mod") {
        g = new i(null), g.length = x + 1, g.words = new Array(g.length);
        for (var k = 0; k < g.length; k++) g.words[k] = 0;
      }
      var T = y.clone()._ishlnsubmul(w, 1, x);
      T.negative === 0 && (y = T, g && (g.words[x] = 1));
      for (var O = x - 1; O >= 0; O--) {
        var K = (y.words[w.length + O] | 0) * 67108864 + (y.words[w.length + O - 1] | 0);
        for (K = Math.min(K / E | 0, 67108863), y._ishlnsubmul(w, K, O); y.negative !== 0; ) K--, y.negative = 0, y._ishlnsubmul(w, 1, O), y.isZero() || (y.negative ^= 1);
        g && (g.words[O] = K);
      }
      return g && g.strip(), y.strip(), p !== "div" && d !== 0 && y.iushrn(d), { div: g || null, mod: y };
    }, i.prototype.divmod = function(u, p, d) {
      if (r(!u.isZero()), this.isZero()) return { div: new i(0), mod: new i(0) };
      var y, w, E;
      return this.negative !== 0 && u.negative === 0 ? (E = this.neg().divmod(u, p), p !== "mod" && (y = E.div.neg()), p !== "div" && (w = E.mod.neg(), d && w.negative !== 0 && w.iadd(u)), { div: y, mod: w }) : this.negative === 0 && u.negative !== 0 ? (E = this.divmod(u.neg(), p), p !== "mod" && (y = E.div.neg()), { div: y, mod: E.mod }) : this.negative & u.negative ? (E = this.neg().divmod(u.neg(), p), p !== "div" && (w = E.mod.neg(), d && w.negative !== 0 && w.isub(u)), { div: E.div, mod: w }) : u.length > this.length || this.cmp(u) < 0 ? { div: new i(0), mod: this } : u.length === 1 ? p === "div" ? { div: this.divn(u.words[0]), mod: null } : p === "mod" ? { div: null, mod: new i(this.modn(u.words[0])) } : { div: this.divn(u.words[0]), mod: new i(this.modn(u.words[0])) } : this._wordDiv(u, p);
    }, i.prototype.div = function(u) {
      return this.divmod(u, "div", false).div;
    }, i.prototype.mod = function(u) {
      return this.divmod(u, "mod", false).mod;
    }, i.prototype.umod = function(u) {
      return this.divmod(u, "mod", true).mod;
    }, i.prototype.divRound = function(u) {
      var p = this.divmod(u);
      if (p.mod.isZero()) return p.div;
      var d = p.div.negative !== 0 ? p.mod.isub(u) : p.mod, y = u.ushrn(1), w = u.andln(1), E = d.cmp(y);
      return E < 0 || w === 1 && E === 0 ? p.div : p.div.negative !== 0 ? p.div.isubn(1) : p.div.iaddn(1);
    }, i.prototype.modn = function(u) {
      r(u <= 67108863);
      for (var p = (1 << 26) % u, d = 0, y = this.length - 1; y >= 0; y--) d = (p * d + (this.words[y] | 0)) % u;
      return d;
    }, i.prototype.idivn = function(u) {
      r(u <= 67108863);
      for (var p = 0, d = this.length - 1; d >= 0; d--) {
        var y = (this.words[d] | 0) + p * 67108864;
        this.words[d] = y / u | 0, p = y % u;
      }
      return this.strip();
    }, i.prototype.divn = function(u) {
      return this.clone().idivn(u);
    }, i.prototype.egcd = function(u) {
      r(u.negative === 0), r(!u.isZero());
      var p = this, d = u.clone();
      p.negative !== 0 ? p = p.umod(u) : p = p.clone();
      for (var y = new i(1), w = new i(0), E = new i(0), M = new i(1), x = 0; p.isEven() && d.isEven(); ) p.iushrn(1), d.iushrn(1), ++x;
      for (var g = d.clone(), k = p.clone(); !p.isZero(); ) {
        for (var T = 0, O = 1; !(p.words[0] & O) && T < 26; ++T, O <<= 1) ;
        if (T > 0) for (p.iushrn(T); T-- > 0; ) (y.isOdd() || w.isOdd()) && (y.iadd(g), w.isub(k)), y.iushrn(1), w.iushrn(1);
        for (var K = 0, Y = 1; !(d.words[0] & Y) && K < 26; ++K, Y <<= 1) ;
        if (K > 0) for (d.iushrn(K); K-- > 0; ) (E.isOdd() || M.isOdd()) && (E.iadd(g), M.isub(k)), E.iushrn(1), M.iushrn(1);
        p.cmp(d) >= 0 ? (p.isub(d), y.isub(E), w.isub(M)) : (d.isub(p), E.isub(y), M.isub(w));
      }
      return { a: E, b: M, gcd: d.iushln(x) };
    }, i.prototype._invmp = function(u) {
      r(u.negative === 0), r(!u.isZero());
      var p = this, d = u.clone();
      p.negative !== 0 ? p = p.umod(u) : p = p.clone();
      for (var y = new i(1), w = new i(0), E = d.clone(); p.cmpn(1) > 0 && d.cmpn(1) > 0; ) {
        for (var M = 0, x = 1; !(p.words[0] & x) && M < 26; ++M, x <<= 1) ;
        if (M > 0) for (p.iushrn(M); M-- > 0; ) y.isOdd() && y.iadd(E), y.iushrn(1);
        for (var g = 0, k = 1; !(d.words[0] & k) && g < 26; ++g, k <<= 1) ;
        if (g > 0) for (d.iushrn(g); g-- > 0; ) w.isOdd() && w.iadd(E), w.iushrn(1);
        p.cmp(d) >= 0 ? (p.isub(d), y.isub(w)) : (d.isub(p), w.isub(y));
      }
      var T;
      return p.cmpn(1) === 0 ? T = y : T = w, T.cmpn(0) < 0 && T.iadd(u), T;
    }, i.prototype.gcd = function(u) {
      if (this.isZero()) return u.abs();
      if (u.isZero()) return this.abs();
      var p = this.clone(), d = u.clone();
      p.negative = 0, d.negative = 0;
      for (var y = 0; p.isEven() && d.isEven(); y++) p.iushrn(1), d.iushrn(1);
      do {
        for (; p.isEven(); ) p.iushrn(1);
        for (; d.isEven(); ) d.iushrn(1);
        var w = p.cmp(d);
        if (w < 0) {
          var E = p;
          p = d, d = E;
        } else if (w === 0 || d.cmpn(1) === 0) break;
        p.isub(d);
      } while (true);
      return d.iushln(y);
    }, i.prototype.invm = function(u) {
      return this.egcd(u).a.umod(u);
    }, i.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, i.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, i.prototype.andln = function(u) {
      return this.words[0] & u;
    }, i.prototype.bincn = function(u) {
      r(typeof u == "number");
      var p = u % 26, d = (u - p) / 26, y = 1 << p;
      if (this.length <= d) return this._expand(d + 1), this.words[d] |= y, this;
      for (var w = y, E = d; w !== 0 && E < this.length; E++) {
        var M = this.words[E] | 0;
        M += w, w = M >>> 26, M &= 67108863, this.words[E] = M;
      }
      return w !== 0 && (this.words[E] = w, this.length++), this;
    }, i.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, i.prototype.cmpn = function(u) {
      var p = u < 0;
      if (this.negative !== 0 && !p) return -1;
      if (this.negative === 0 && p) return 1;
      this.strip();
      var d;
      if (this.length > 1) d = 1;
      else {
        p && (u = -u), r(u <= 67108863, "Number is too big");
        var y = this.words[0] | 0;
        d = y === u ? 0 : y < u ? -1 : 1;
      }
      return this.negative !== 0 ? -d | 0 : d;
    }, i.prototype.cmp = function(u) {
      if (this.negative !== 0 && u.negative === 0) return -1;
      if (this.negative === 0 && u.negative !== 0) return 1;
      var p = this.ucmp(u);
      return this.negative !== 0 ? -p | 0 : p;
    }, i.prototype.ucmp = function(u) {
      if (this.length > u.length) return 1;
      if (this.length < u.length) return -1;
      for (var p = 0, d = this.length - 1; d >= 0; d--) {
        var y = this.words[d] | 0, w = u.words[d] | 0;
        if (y !== w) {
          y < w ? p = -1 : y > w && (p = 1);
          break;
        }
      }
      return p;
    }, i.prototype.gtn = function(u) {
      return this.cmpn(u) === 1;
    }, i.prototype.gt = function(u) {
      return this.cmp(u) === 1;
    }, i.prototype.gten = function(u) {
      return this.cmpn(u) >= 0;
    }, i.prototype.gte = function(u) {
      return this.cmp(u) >= 0;
    }, i.prototype.ltn = function(u) {
      return this.cmpn(u) === -1;
    }, i.prototype.lt = function(u) {
      return this.cmp(u) === -1;
    }, i.prototype.lten = function(u) {
      return this.cmpn(u) <= 0;
    }, i.prototype.lte = function(u) {
      return this.cmp(u) <= 0;
    }, i.prototype.eqn = function(u) {
      return this.cmpn(u) === 0;
    }, i.prototype.eq = function(u) {
      return this.cmp(u) === 0;
    }, i.red = function(u) {
      return new N(u);
    }, i.prototype.toRed = function(u) {
      return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), u.convertTo(this)._forceRed(u);
    }, i.prototype.fromRed = function() {
      return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, i.prototype._forceRed = function(u) {
      return this.red = u, this;
    }, i.prototype.forceRed = function(u) {
      return r(!this.red, "Already a number in reduction context"), this._forceRed(u);
    }, i.prototype.redAdd = function(u) {
      return r(this.red, "redAdd works only with red numbers"), this.red.add(this, u);
    }, i.prototype.redIAdd = function(u) {
      return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, u);
    }, i.prototype.redSub = function(u) {
      return r(this.red, "redSub works only with red numbers"), this.red.sub(this, u);
    }, i.prototype.redISub = function(u) {
      return r(this.red, "redISub works only with red numbers"), this.red.isub(this, u);
    }, i.prototype.redShl = function(u) {
      return r(this.red, "redShl works only with red numbers"), this.red.shl(this, u);
    }, i.prototype.redMul = function(u) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, u), this.red.mul(this, u);
    }, i.prototype.redIMul = function(u) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, u), this.red.imul(this, u);
    }, i.prototype.redSqr = function() {
      return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, i.prototype.redISqr = function() {
      return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, i.prototype.redSqrt = function() {
      return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, i.prototype.redInvm = function() {
      return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, i.prototype.redNeg = function() {
      return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, i.prototype.redPow = function(u) {
      return r(this.red && !u.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, u);
    };
    var S = { k256: null, p224: null, p192: null, p25519: null };
    function $(B, u) {
      this.name = B, this.p = new i(u, 16), this.n = this.p.bitLength(), this.k = new i(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    $.prototype._tmp = function() {
      var u = new i(null);
      return u.words = new Array(Math.ceil(this.n / 13)), u;
    }, $.prototype.ireduce = function(u) {
      var p = u, d;
      do
        this.split(p, this.tmp), p = this.imulK(p), p = p.iadd(this.tmp), d = p.bitLength();
      while (d > this.n);
      var y = d < this.n ? -1 : p.ucmp(this.p);
      return y === 0 ? (p.words[0] = 0, p.length = 1) : y > 0 ? p.isub(this.p) : p.strip !== void 0 ? p.strip() : p._strip(), p;
    }, $.prototype.split = function(u, p) {
      u.iushrn(this.n, 0, p);
    }, $.prototype.imulK = function(u) {
      return u.imul(this.k);
    };
    function F() {
      $.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    s(F, $), F.prototype.split = function(u, p) {
      for (var d = 4194303, y = Math.min(u.length, 9), w = 0; w < y; w++) p.words[w] = u.words[w];
      if (p.length = y, u.length <= 9) {
        u.words[0] = 0, u.length = 1;
        return;
      }
      var E = u.words[9];
      for (p.words[p.length++] = E & d, w = 10; w < u.length; w++) {
        var M = u.words[w] | 0;
        u.words[w - 10] = (M & d) << 4 | E >>> 22, E = M;
      }
      E >>>= 22, u.words[w - 10] = E, E === 0 && u.length > 10 ? u.length -= 10 : u.length -= 9;
    }, F.prototype.imulK = function(u) {
      u.words[u.length] = 0, u.words[u.length + 1] = 0, u.length += 2;
      for (var p = 0, d = 0; d < u.length; d++) {
        var y = u.words[d] | 0;
        p += y * 977, u.words[d] = p & 67108863, p = y * 64 + (p / 67108864 | 0);
      }
      return u.words[u.length - 1] === 0 && (u.length--, u.words[u.length - 1] === 0 && u.length--), u;
    };
    function U() {
      $.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    s(U, $);
    function Q() {
      $.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    s(Q, $);
    function P() {
      $.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    s(P, $), P.prototype.imulK = function(u) {
      for (var p = 0, d = 0; d < u.length; d++) {
        var y = (u.words[d] | 0) * 19 + p, w = y & 67108863;
        y >>>= 26, u.words[d] = w, p = y;
      }
      return p !== 0 && (u.words[u.length++] = p), u;
    }, i._prime = function(u) {
      if (S[u]) return S[u];
      var p;
      if (u === "k256") p = new F();
      else if (u === "p224") p = new U();
      else if (u === "p192") p = new Q();
      else if (u === "p25519") p = new P();
      else throw new Error("Unknown prime " + u);
      return S[u] = p, p;
    };
    function N(B) {
      if (typeof B == "string") {
        var u = i._prime(B);
        this.m = u.p, this.prime = u;
      } else r(B.gtn(1), "modulus must be greater than 1"), this.m = B, this.prime = null;
    }
    N.prototype._verify1 = function(u) {
      r(u.negative === 0, "red works only with positives"), r(u.red, "red works only with red numbers");
    }, N.prototype._verify2 = function(u, p) {
      r((u.negative | p.negative) === 0, "red works only with positives"), r(u.red && u.red === p.red, "red works only with red numbers");
    }, N.prototype.imod = function(u) {
      return this.prime ? this.prime.ireduce(u)._forceRed(this) : u.umod(this.m)._forceRed(this);
    }, N.prototype.neg = function(u) {
      return u.isZero() ? u.clone() : this.m.sub(u)._forceRed(this);
    }, N.prototype.add = function(u, p) {
      this._verify2(u, p);
      var d = u.add(p);
      return d.cmp(this.m) >= 0 && d.isub(this.m), d._forceRed(this);
    }, N.prototype.iadd = function(u, p) {
      this._verify2(u, p);
      var d = u.iadd(p);
      return d.cmp(this.m) >= 0 && d.isub(this.m), d;
    }, N.prototype.sub = function(u, p) {
      this._verify2(u, p);
      var d = u.sub(p);
      return d.cmpn(0) < 0 && d.iadd(this.m), d._forceRed(this);
    }, N.prototype.isub = function(u, p) {
      this._verify2(u, p);
      var d = u.isub(p);
      return d.cmpn(0) < 0 && d.iadd(this.m), d;
    }, N.prototype.shl = function(u, p) {
      return this._verify1(u), this.imod(u.ushln(p));
    }, N.prototype.imul = function(u, p) {
      return this._verify2(u, p), this.imod(u.imul(p));
    }, N.prototype.mul = function(u, p) {
      return this._verify2(u, p), this.imod(u.mul(p));
    }, N.prototype.isqr = function(u) {
      return this.imul(u, u.clone());
    }, N.prototype.sqr = function(u) {
      return this.mul(u, u);
    }, N.prototype.sqrt = function(u) {
      if (u.isZero()) return u.clone();
      var p = this.m.andln(3);
      if (r(p % 2 === 1), p === 3) {
        var d = this.m.add(new i(1)).iushrn(2);
        return this.pow(u, d);
      }
      for (var y = this.m.subn(1), w = 0; !y.isZero() && y.andln(1) === 0; ) w++, y.iushrn(1);
      r(!y.isZero());
      var E = new i(1).toRed(this), M = E.redNeg(), x = this.m.subn(1).iushrn(1), g = this.m.bitLength();
      for (g = new i(2 * g * g).toRed(this); this.pow(g, x).cmp(M) !== 0; ) g.redIAdd(M);
      for (var k = this.pow(g, y), T = this.pow(u, y.addn(1).iushrn(1)), O = this.pow(u, y), K = w; O.cmp(E) !== 0; ) {
        for (var Y = O, J = 0; Y.cmp(E) !== 0; J++) Y = Y.redSqr();
        r(J < K);
        var G = this.pow(k, new i(1).iushln(K - J - 1));
        T = T.redMul(G), k = G.redSqr(), O = O.redMul(k), K = J;
      }
      return T;
    }, N.prototype.invm = function(u) {
      var p = u._invmp(this.m);
      return p.negative !== 0 ? (p.negative = 0, this.imod(p).redNeg()) : this.imod(p);
    }, N.prototype.pow = function(u, p) {
      if (p.isZero()) return new i(1).toRed(this);
      if (p.cmpn(1) === 0) return u.clone();
      var d = 4, y = new Array(1 << d);
      y[0] = new i(1).toRed(this), y[1] = u;
      for (var w = 2; w < y.length; w++) y[w] = this.mul(y[w - 1], u);
      var E = y[0], M = 0, x = 0, g = p.bitLength() % 26;
      for (g === 0 && (g = 26), w = p.length - 1; w >= 0; w--) {
        for (var k = p.words[w], T = g - 1; T >= 0; T--) {
          var O = k >> T & 1;
          if (E !== y[0] && (E = this.sqr(E)), O === 0 && M === 0) {
            x = 0;
            continue;
          }
          M <<= 1, M |= O, x++, !(x !== d && (w !== 0 || T !== 0)) && (E = this.mul(E, y[M]), x = 0, M = 0);
        }
        g = 26;
      }
      return E;
    }, N.prototype.convertTo = function(u) {
      var p = u.umod(this.m);
      return p === u ? p.clone() : p;
    }, N.prototype.convertFrom = function(u) {
      var p = u.clone();
      return p.red = null, p;
    }, i.mont = function(u) {
      return new L(u);
    };
    function L(B) {
      N.call(this, B), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new i(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    s(L, N), L.prototype.convertTo = function(u) {
      return this.imod(u.ushln(this.shift));
    }, L.prototype.convertFrom = function(u) {
      var p = this.imod(u.mul(this.rinv));
      return p.red = null, p;
    }, L.prototype.imul = function(u, p) {
      if (u.isZero() || p.isZero()) return u.words[0] = 0, u.length = 1, u;
      var d = u.imul(p), y = d.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = d.isub(y).iushrn(this.shift), E = w;
      return w.cmp(this.m) >= 0 ? E = w.isub(this.m) : w.cmpn(0) < 0 && (E = w.iadd(this.m)), E._forceRed(this);
    }, L.prototype.mul = function(u, p) {
      if (u.isZero() || p.isZero()) return new i(0)._forceRed(this);
      var d = u.mul(p), y = d.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = d.isub(y).iushrn(this.shift), E = w;
      return w.cmp(this.m) >= 0 ? E = w.isub(this.m) : w.cmpn(0) < 0 && (E = w.iadd(this.m)), E._forceRed(this);
    }, L.prototype.invm = function(u) {
      var p = this.imod(u._invmp(this.m).mul(this.r2));
      return p._forceRed(this);
    };
  })(t3, mt);
})(n4);
var Pj = n4.exports, gv, px;
function Nj() {
  if (px) return gv;
  px = 1;
  var t3 = e4(), e = Pj;
  gv = function(a) {
    return new r(a);
  };
  var n = { secp256k1: { name: "secp256k1", byteLength: 32 }, secp224r1: { name: "p224", byteLength: 28 }, prime256v1: { name: "p256", byteLength: 32 }, prime192v1: { name: "p192", byteLength: 24 }, ed25519: { name: "ed25519", byteLength: 32 }, secp384r1: { name: "p384", byteLength: 48 }, secp521r1: { name: "p521", byteLength: 66 } };
  n.p224 = n.secp224r1, n.p256 = n.secp256r1 = n.prime256v1, n.p192 = n.secp192r1 = n.prime192v1, n.p384 = n.secp384r1, n.p521 = n.secp521r1;
  function r(i) {
    this.curveType = n[i], this.curveType || (this.curveType = { name: i }), this.curve = new t3.ec(this.curveType.name), this.keys = void 0;
  }
  r.prototype.generateKeys = function(i, a) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(i, a);
  }, r.prototype.computeSecret = function(i, a, o) {
    a = a || "utf8", hr.isBuffer(i) || (i = new hr(i, a));
    var f = this.curve.keyFromPublic(i).getPublic(), c = f.mul(this.keys.getPrivate()).getX();
    return s(c, o, this.curveType.byteLength);
  }, r.prototype.getPublicKey = function(i, a) {
    var o = this.keys.getPublic(a === "compressed", true);
    return a === "hybrid" && (o[o.length - 1] % 2 ? o[0] = 7 : o[0] = 6), s(o, i);
  }, r.prototype.getPrivateKey = function(i) {
    return s(this.keys.getPrivate(), i);
  }, r.prototype.setPublicKey = function(i, a) {
    return a = a || "utf8", hr.isBuffer(i) || (i = new hr(i, a)), this.keys._importPublic(i), this;
  }, r.prototype.setPrivateKey = function(i, a) {
    a = a || "utf8", hr.isBuffer(i) || (i = new hr(i, a));
    var o = new e(i);
    return o = o.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(o), this;
  };
  function s(i, a, o) {
    Array.isArray(i) || (i = i.toArray());
    var f = new hr(i);
    if (o && f.length < o) {
      var c = new hr(o - f.length);
      c.fill(0), f = hr.concat([c, f]);
    }
    return a ? f.toString(a) : f;
  }
  return gv;
}
var eT = {}, Uj = vd, eb = Tn.Buffer, tT = function(t3, e) {
  for (var n = eb.alloc(0), r = 0, s; n.length < e; ) s = Lj(r++), n = eb.concat([n, Uj("sha1").update(t3).update(s).digest()]);
  return n.slice(0, e);
};
function Lj(t3) {
  var e = eb.allocUnsafe(4);
  return e.writeUInt32BE(t3, 0), e;
}
var rT = function(e, n) {
  for (var r = e.length, s = -1; ++s < r; ) e[s] ^= n[s];
  return e;
}, i4 = { exports: {} };
i4.exports;
(function(t3) {
  (function(e, n) {
    function r(B, u) {
      if (!B) throw new Error(u || "Assertion failed");
    }
    function s(B, u) {
      B.super_ = u;
      var p = function() {
      };
      p.prototype = u.prototype, B.prototype = new p(), B.prototype.constructor = B;
    }
    function i(B, u, p) {
      if (i.isBN(B)) return B;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, B !== null && ((u === "le" || u === "be") && (p = u, u = 10), this._init(B || 0, u || 10, p || "be"));
    }
    typeof e == "object" ? e.exports = i : n.BN = i, i.BN = i, i.wordSize = 26;
    var a;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? a = window.Buffer : a = $n.Buffer;
    } catch {
    }
    i.isBN = function(u) {
      return u instanceof i ? true : u !== null && typeof u == "object" && u.constructor.wordSize === i.wordSize && Array.isArray(u.words);
    }, i.max = function(u, p) {
      return u.cmp(p) > 0 ? u : p;
    }, i.min = function(u, p) {
      return u.cmp(p) < 0 ? u : p;
    }, i.prototype._init = function(u, p, d) {
      if (typeof u == "number") return this._initNumber(u, p, d);
      if (typeof u == "object") return this._initArray(u, p, d);
      p === "hex" && (p = 16), r(p === (p | 0) && p >= 2 && p <= 36), u = u.toString().replace(/\s+/g, "");
      var y = 0;
      u[0] === "-" && (y++, this.negative = 1), y < u.length && (p === 16 ? this._parseHex(u, y, d) : (this._parseBase(u, p, y), d === "le" && this._initArray(this.toArray(), p, d)));
    }, i.prototype._initNumber = function(u, p, d) {
      u < 0 && (this.negative = 1, u = -u), u < 67108864 ? (this.words = [u & 67108863], this.length = 1) : u < 4503599627370496 ? (this.words = [u & 67108863, u / 67108864 & 67108863], this.length = 2) : (r(u < 9007199254740992), this.words = [u & 67108863, u / 67108864 & 67108863, 1], this.length = 3), d === "le" && this._initArray(this.toArray(), p, d);
    }, i.prototype._initArray = function(u, p, d) {
      if (r(typeof u.length == "number"), u.length <= 0) return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(u.length / 3), this.words = new Array(this.length);
      for (var y = 0; y < this.length; y++) this.words[y] = 0;
      var w, E, M = 0;
      if (d === "be") for (y = u.length - 1, w = 0; y >= 0; y -= 3) E = u[y] | u[y - 1] << 8 | u[y - 2] << 16, this.words[w] |= E << M & 67108863, this.words[w + 1] = E >>> 26 - M & 67108863, M += 24, M >= 26 && (M -= 26, w++);
      else if (d === "le") for (y = 0, w = 0; y < u.length; y += 3) E = u[y] | u[y + 1] << 8 | u[y + 2] << 16, this.words[w] |= E << M & 67108863, this.words[w + 1] = E >>> 26 - M & 67108863, M += 24, M >= 26 && (M -= 26, w++);
      return this.strip();
    };
    function o(B, u) {
      var p = B.charCodeAt(u);
      return p >= 65 && p <= 70 ? p - 55 : p >= 97 && p <= 102 ? p - 87 : p - 48 & 15;
    }
    function f(B, u, p) {
      var d = o(B, p);
      return p - 1 >= u && (d |= o(B, p - 1) << 4), d;
    }
    i.prototype._parseHex = function(u, p, d) {
      this.length = Math.ceil((u.length - p) / 6), this.words = new Array(this.length);
      for (var y = 0; y < this.length; y++) this.words[y] = 0;
      var w = 0, E = 0, M;
      if (d === "be") for (y = u.length - 1; y >= p; y -= 2) M = f(u, p, y) << w, this.words[E] |= M & 67108863, w >= 18 ? (w -= 18, E += 1, this.words[E] |= M >>> 26) : w += 8;
      else {
        var x = u.length - p;
        for (y = x % 2 === 0 ? p + 1 : p; y < u.length; y += 2) M = f(u, p, y) << w, this.words[E] |= M & 67108863, w >= 18 ? (w -= 18, E += 1, this.words[E] |= M >>> 26) : w += 8;
      }
      this.strip();
    };
    function c(B, u, p, d) {
      for (var y = 0, w = Math.min(B.length, p), E = u; E < w; E++) {
        var M = B.charCodeAt(E) - 48;
        y *= d, M >= 49 ? y += M - 49 + 10 : M >= 17 ? y += M - 17 + 10 : y += M;
      }
      return y;
    }
    i.prototype._parseBase = function(u, p, d) {
      this.words = [0], this.length = 1;
      for (var y = 0, w = 1; w <= 67108863; w *= p) y++;
      y--, w = w / p | 0;
      for (var E = u.length - d, M = E % y, x = Math.min(E, E - M) + d, g = 0, k = d; k < x; k += y) g = c(u, k, k + y, p), this.imuln(w), this.words[0] + g < 67108864 ? this.words[0] += g : this._iaddn(g);
      if (M !== 0) {
        var T = 1;
        for (g = c(u, k, u.length, p), k = 0; k < M; k++) T *= p;
        this.imuln(T), this.words[0] + g < 67108864 ? this.words[0] += g : this._iaddn(g);
      }
      this.strip();
    }, i.prototype.copy = function(u) {
      u.words = new Array(this.length);
      for (var p = 0; p < this.length; p++) u.words[p] = this.words[p];
      u.length = this.length, u.negative = this.negative, u.red = this.red;
    }, i.prototype.clone = function() {
      var u = new i(null);
      return this.copy(u), u;
    }, i.prototype._expand = function(u) {
      for (; this.length < u; ) this.words[this.length++] = 0;
      return this;
    }, i.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; ) this.length--;
      return this._normSign();
    }, i.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, i.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var l = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], h = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], m = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    i.prototype.toString = function(u, p) {
      u = u || 10, p = p | 0 || 1;
      var d;
      if (u === 16 || u === "hex") {
        d = "";
        for (var y = 0, w = 0, E = 0; E < this.length; E++) {
          var M = this.words[E], x = ((M << y | w) & 16777215).toString(16);
          w = M >>> 24 - y & 16777215, y += 2, y >= 26 && (y -= 26, E--), w !== 0 || E !== this.length - 1 ? d = l[6 - x.length] + x + d : d = x + d;
        }
        for (w !== 0 && (d = w.toString(16) + d); d.length % p !== 0; ) d = "0" + d;
        return this.negative !== 0 && (d = "-" + d), d;
      }
      if (u === (u | 0) && u >= 2 && u <= 36) {
        var g = h[u], k = m[u];
        d = "";
        var T = this.clone();
        for (T.negative = 0; !T.isZero(); ) {
          var O = T.modn(k).toString(u);
          T = T.idivn(k), T.isZero() ? d = O + d : d = l[g - O.length] + O + d;
        }
        for (this.isZero() && (d = "0" + d); d.length % p !== 0; ) d = "0" + d;
        return this.negative !== 0 && (d = "-" + d), d;
      }
      r(false, "Base should be between 2 and 36");
    }, i.prototype.toNumber = function() {
      var u = this.words[0];
      return this.length === 2 ? u += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? u += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -u : u;
    }, i.prototype.toJSON = function() {
      return this.toString(16);
    }, i.prototype.toBuffer = function(u, p) {
      return r(typeof a < "u"), this.toArrayLike(a, u, p);
    }, i.prototype.toArray = function(u, p) {
      return this.toArrayLike(Array, u, p);
    }, i.prototype.toArrayLike = function(u, p, d) {
      var y = this.byteLength(), w = d || Math.max(1, y);
      r(y <= w, "byte array longer than desired length"), r(w > 0, "Requested array length <= 0"), this.strip();
      var E = p === "le", M = new u(w), x, g, k = this.clone();
      if (E) {
        for (g = 0; !k.isZero(); g++) x = k.andln(255), k.iushrn(8), M[g] = x;
        for (; g < w; g++) M[g] = 0;
      } else {
        for (g = 0; g < w - y; g++) M[g] = 0;
        for (g = 0; !k.isZero(); g++) x = k.andln(255), k.iushrn(8), M[w - g - 1] = x;
      }
      return M;
    }, Math.clz32 ? i.prototype._countBits = function(u) {
      return 32 - Math.clz32(u);
    } : i.prototype._countBits = function(u) {
      var p = u, d = 0;
      return p >= 4096 && (d += 13, p >>>= 13), p >= 64 && (d += 7, p >>>= 7), p >= 8 && (d += 4, p >>>= 4), p >= 2 && (d += 2, p >>>= 2), d + p;
    }, i.prototype._zeroBits = function(u) {
      if (u === 0) return 26;
      var p = u, d = 0;
      return p & 8191 || (d += 13, p >>>= 13), p & 127 || (d += 7, p >>>= 7), p & 15 || (d += 4, p >>>= 4), p & 3 || (d += 2, p >>>= 2), p & 1 || d++, d;
    }, i.prototype.bitLength = function() {
      var u = this.words[this.length - 1], p = this._countBits(u);
      return (this.length - 1) * 26 + p;
    };
    function v(B) {
      for (var u = new Array(B.bitLength()), p = 0; p < u.length; p++) {
        var d = p / 26 | 0, y = p % 26;
        u[p] = (B.words[d] & 1 << y) >>> y;
      }
      return u;
    }
    i.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var u = 0, p = 0; p < this.length; p++) {
        var d = this._zeroBits(this.words[p]);
        if (u += d, d !== 26) break;
      }
      return u;
    }, i.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, i.prototype.toTwos = function(u) {
      return this.negative !== 0 ? this.abs().inotn(u).iaddn(1) : this.clone();
    }, i.prototype.fromTwos = function(u) {
      return this.testn(u - 1) ? this.notn(u).iaddn(1).ineg() : this.clone();
    }, i.prototype.isNeg = function() {
      return this.negative !== 0;
    }, i.prototype.neg = function() {
      return this.clone().ineg();
    }, i.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, i.prototype.iuor = function(u) {
      for (; this.length < u.length; ) this.words[this.length++] = 0;
      for (var p = 0; p < u.length; p++) this.words[p] = this.words[p] | u.words[p];
      return this.strip();
    }, i.prototype.ior = function(u) {
      return r((this.negative | u.negative) === 0), this.iuor(u);
    }, i.prototype.or = function(u) {
      return this.length > u.length ? this.clone().ior(u) : u.clone().ior(this);
    }, i.prototype.uor = function(u) {
      return this.length > u.length ? this.clone().iuor(u) : u.clone().iuor(this);
    }, i.prototype.iuand = function(u) {
      var p;
      this.length > u.length ? p = u : p = this;
      for (var d = 0; d < p.length; d++) this.words[d] = this.words[d] & u.words[d];
      return this.length = p.length, this.strip();
    }, i.prototype.iand = function(u) {
      return r((this.negative | u.negative) === 0), this.iuand(u);
    }, i.prototype.and = function(u) {
      return this.length > u.length ? this.clone().iand(u) : u.clone().iand(this);
    }, i.prototype.uand = function(u) {
      return this.length > u.length ? this.clone().iuand(u) : u.clone().iuand(this);
    }, i.prototype.iuxor = function(u) {
      var p, d;
      this.length > u.length ? (p = this, d = u) : (p = u, d = this);
      for (var y = 0; y < d.length; y++) this.words[y] = p.words[y] ^ d.words[y];
      if (this !== p) for (; y < p.length; y++) this.words[y] = p.words[y];
      return this.length = p.length, this.strip();
    }, i.prototype.ixor = function(u) {
      return r((this.negative | u.negative) === 0), this.iuxor(u);
    }, i.prototype.xor = function(u) {
      return this.length > u.length ? this.clone().ixor(u) : u.clone().ixor(this);
    }, i.prototype.uxor = function(u) {
      return this.length > u.length ? this.clone().iuxor(u) : u.clone().iuxor(this);
    }, i.prototype.inotn = function(u) {
      r(typeof u == "number" && u >= 0);
      var p = Math.ceil(u / 26) | 0, d = u % 26;
      this._expand(p), d > 0 && p--;
      for (var y = 0; y < p; y++) this.words[y] = ~this.words[y] & 67108863;
      return d > 0 && (this.words[y] = ~this.words[y] & 67108863 >> 26 - d), this.strip();
    }, i.prototype.notn = function(u) {
      return this.clone().inotn(u);
    }, i.prototype.setn = function(u, p) {
      r(typeof u == "number" && u >= 0);
      var d = u / 26 | 0, y = u % 26;
      return this._expand(d + 1), p ? this.words[d] = this.words[d] | 1 << y : this.words[d] = this.words[d] & ~(1 << y), this.strip();
    }, i.prototype.iadd = function(u) {
      var p;
      if (this.negative !== 0 && u.negative === 0) return this.negative = 0, p = this.isub(u), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && u.negative !== 0) return u.negative = 0, p = this.isub(u), u.negative = 1, p._normSign();
      var d, y;
      this.length > u.length ? (d = this, y = u) : (d = u, y = this);
      for (var w = 0, E = 0; E < y.length; E++) p = (d.words[E] | 0) + (y.words[E] | 0) + w, this.words[E] = p & 67108863, w = p >>> 26;
      for (; w !== 0 && E < d.length; E++) p = (d.words[E] | 0) + w, this.words[E] = p & 67108863, w = p >>> 26;
      if (this.length = d.length, w !== 0) this.words[this.length] = w, this.length++;
      else if (d !== this) for (; E < d.length; E++) this.words[E] = d.words[E];
      return this;
    }, i.prototype.add = function(u) {
      var p;
      return u.negative !== 0 && this.negative === 0 ? (u.negative = 0, p = this.sub(u), u.negative ^= 1, p) : u.negative === 0 && this.negative !== 0 ? (this.negative = 0, p = u.sub(this), this.negative = 1, p) : this.length > u.length ? this.clone().iadd(u) : u.clone().iadd(this);
    }, i.prototype.isub = function(u) {
      if (u.negative !== 0) {
        u.negative = 0;
        var p = this.iadd(u);
        return u.negative = 1, p._normSign();
      } else if (this.negative !== 0) return this.negative = 0, this.iadd(u), this.negative = 1, this._normSign();
      var d = this.cmp(u);
      if (d === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var y, w;
      d > 0 ? (y = this, w = u) : (y = u, w = this);
      for (var E = 0, M = 0; M < w.length; M++) p = (y.words[M] | 0) - (w.words[M] | 0) + E, E = p >> 26, this.words[M] = p & 67108863;
      for (; E !== 0 && M < y.length; M++) p = (y.words[M] | 0) + E, E = p >> 26, this.words[M] = p & 67108863;
      if (E === 0 && M < y.length && y !== this) for (; M < y.length; M++) this.words[M] = y.words[M];
      return this.length = Math.max(this.length, M), y !== this && (this.negative = 1), this.strip();
    }, i.prototype.sub = function(u) {
      return this.clone().isub(u);
    };
    function b(B, u, p) {
      p.negative = u.negative ^ B.negative;
      var d = B.length + u.length | 0;
      p.length = d, d = d - 1 | 0;
      var y = B.words[0] | 0, w = u.words[0] | 0, E = y * w, M = E & 67108863, x = E / 67108864 | 0;
      p.words[0] = M;
      for (var g = 1; g < d; g++) {
        for (var k = x >>> 26, T = x & 67108863, O = Math.min(g, u.length - 1), K = Math.max(0, g - B.length + 1); K <= O; K++) {
          var Y = g - K | 0;
          y = B.words[Y] | 0, w = u.words[K] | 0, E = y * w + T, k += E / 67108864 | 0, T = E & 67108863;
        }
        p.words[g] = T | 0, x = k | 0;
      }
      return x !== 0 ? p.words[g] = x | 0 : p.length--, p.strip();
    }
    var A = function(u, p, d) {
      var y = u.words, w = p.words, E = d.words, M = 0, x, g, k, T = y[0] | 0, O = T & 8191, K = T >>> 13, Y = y[1] | 0, J = Y & 8191, G = Y >>> 13, X = y[2] | 0, ie = X & 8191, de = X >>> 13, se = y[3] | 0, te = se & 8191, le = se >>> 13, Z = y[4] | 0, ve = Z & 8191, he = Z >>> 13, me = y[5] | 0, ce = me & 8191, ye = me >>> 13, Oe = y[6] | 0, Se = Oe & 8191, Ce = Oe >>> 13, Ne = y[7] | 0, $e = Ne & 8191, Re = Ne >>> 13, Ge = y[8] | 0, Fe = Ge & 8191, Ue = Ge >>> 13, kt = y[9] | 0, pe = kt & 8191, re = kt >>> 13, ue = w[0] | 0, xe = ue & 8191, Me = ue >>> 13, We = w[1] | 0, De = We & 8191, je = We >>> 13, ir = w[2] | 0, Xe = ir & 8191, st = ir >>> 13, Vt = w[3] | 0, at = Vt & 8191, ht = Vt >>> 13, br = w[4] | 0, ot = br & 8191, ct = br >>> 13, _r = w[5] | 0, ft = _r & 8191, pt = _r >>> 13, Cr = w[6] | 0, nt = Cr & 8191, lt = Cr >>> 13, ge = w[7] | 0, be = ge & 8191, Ae = ge >>> 13, ne = w[8] | 0, _e = ne & 8191, Te = ne >>> 13, Ye = w[9] | 0, Pe = Ye & 8191, He = Ye >>> 13;
      d.negative = u.negative ^ p.negative, d.length = 19, x = Math.imul(O, xe), g = Math.imul(O, Me), g = g + Math.imul(K, xe) | 0, k = Math.imul(K, Me);
      var _t = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, x = Math.imul(J, xe), g = Math.imul(J, Me), g = g + Math.imul(G, xe) | 0, k = Math.imul(G, Me), x = x + Math.imul(O, De) | 0, g = g + Math.imul(O, je) | 0, g = g + Math.imul(K, De) | 0, k = k + Math.imul(K, je) | 0;
      var vt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, x = Math.imul(ie, xe), g = Math.imul(ie, Me), g = g + Math.imul(de, xe) | 0, k = Math.imul(de, Me), x = x + Math.imul(J, De) | 0, g = g + Math.imul(J, je) | 0, g = g + Math.imul(G, De) | 0, k = k + Math.imul(G, je) | 0, x = x + Math.imul(O, Xe) | 0, g = g + Math.imul(O, st) | 0, g = g + Math.imul(K, Xe) | 0, k = k + Math.imul(K, st) | 0;
      var cr = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (cr >>> 26) | 0, cr &= 67108863, x = Math.imul(te, xe), g = Math.imul(te, Me), g = g + Math.imul(le, xe) | 0, k = Math.imul(le, Me), x = x + Math.imul(ie, De) | 0, g = g + Math.imul(ie, je) | 0, g = g + Math.imul(de, De) | 0, k = k + Math.imul(de, je) | 0, x = x + Math.imul(J, Xe) | 0, g = g + Math.imul(J, st) | 0, g = g + Math.imul(G, Xe) | 0, k = k + Math.imul(G, st) | 0, x = x + Math.imul(O, at) | 0, g = g + Math.imul(O, ht) | 0, g = g + Math.imul(K, at) | 0, k = k + Math.imul(K, ht) | 0;
      var Tt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, x = Math.imul(ve, xe), g = Math.imul(ve, Me), g = g + Math.imul(he, xe) | 0, k = Math.imul(he, Me), x = x + Math.imul(te, De) | 0, g = g + Math.imul(te, je) | 0, g = g + Math.imul(le, De) | 0, k = k + Math.imul(le, je) | 0, x = x + Math.imul(ie, Xe) | 0, g = g + Math.imul(ie, st) | 0, g = g + Math.imul(de, Xe) | 0, k = k + Math.imul(de, st) | 0, x = x + Math.imul(J, at) | 0, g = g + Math.imul(J, ht) | 0, g = g + Math.imul(G, at) | 0, k = k + Math.imul(G, ht) | 0, x = x + Math.imul(O, ot) | 0, g = g + Math.imul(O, ct) | 0, g = g + Math.imul(K, ot) | 0, k = k + Math.imul(K, ct) | 0;
      var Gt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Gt >>> 26) | 0, Gt &= 67108863, x = Math.imul(ce, xe), g = Math.imul(ce, Me), g = g + Math.imul(ye, xe) | 0, k = Math.imul(ye, Me), x = x + Math.imul(ve, De) | 0, g = g + Math.imul(ve, je) | 0, g = g + Math.imul(he, De) | 0, k = k + Math.imul(he, je) | 0, x = x + Math.imul(te, Xe) | 0, g = g + Math.imul(te, st) | 0, g = g + Math.imul(le, Xe) | 0, k = k + Math.imul(le, st) | 0, x = x + Math.imul(ie, at) | 0, g = g + Math.imul(ie, ht) | 0, g = g + Math.imul(de, at) | 0, k = k + Math.imul(de, ht) | 0, x = x + Math.imul(J, ot) | 0, g = g + Math.imul(J, ct) | 0, g = g + Math.imul(G, ot) | 0, k = k + Math.imul(G, ct) | 0, x = x + Math.imul(O, ft) | 0, g = g + Math.imul(O, pt) | 0, g = g + Math.imul(K, ft) | 0, k = k + Math.imul(K, pt) | 0;
      var Yt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Yt >>> 26) | 0, Yt &= 67108863, x = Math.imul(Se, xe), g = Math.imul(Se, Me), g = g + Math.imul(Ce, xe) | 0, k = Math.imul(Ce, Me), x = x + Math.imul(ce, De) | 0, g = g + Math.imul(ce, je) | 0, g = g + Math.imul(ye, De) | 0, k = k + Math.imul(ye, je) | 0, x = x + Math.imul(ve, Xe) | 0, g = g + Math.imul(ve, st) | 0, g = g + Math.imul(he, Xe) | 0, k = k + Math.imul(he, st) | 0, x = x + Math.imul(te, at) | 0, g = g + Math.imul(te, ht) | 0, g = g + Math.imul(le, at) | 0, k = k + Math.imul(le, ht) | 0, x = x + Math.imul(ie, ot) | 0, g = g + Math.imul(ie, ct) | 0, g = g + Math.imul(de, ot) | 0, k = k + Math.imul(de, ct) | 0, x = x + Math.imul(J, ft) | 0, g = g + Math.imul(J, pt) | 0, g = g + Math.imul(G, ft) | 0, k = k + Math.imul(G, pt) | 0, x = x + Math.imul(O, nt) | 0, g = g + Math.imul(O, lt) | 0, g = g + Math.imul(K, nt) | 0, k = k + Math.imul(K, lt) | 0;
      var or = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (or >>> 26) | 0, or &= 67108863, x = Math.imul($e, xe), g = Math.imul($e, Me), g = g + Math.imul(Re, xe) | 0, k = Math.imul(Re, Me), x = x + Math.imul(Se, De) | 0, g = g + Math.imul(Se, je) | 0, g = g + Math.imul(Ce, De) | 0, k = k + Math.imul(Ce, je) | 0, x = x + Math.imul(ce, Xe) | 0, g = g + Math.imul(ce, st) | 0, g = g + Math.imul(ye, Xe) | 0, k = k + Math.imul(ye, st) | 0, x = x + Math.imul(ve, at) | 0, g = g + Math.imul(ve, ht) | 0, g = g + Math.imul(he, at) | 0, k = k + Math.imul(he, ht) | 0, x = x + Math.imul(te, ot) | 0, g = g + Math.imul(te, ct) | 0, g = g + Math.imul(le, ot) | 0, k = k + Math.imul(le, ct) | 0, x = x + Math.imul(ie, ft) | 0, g = g + Math.imul(ie, pt) | 0, g = g + Math.imul(de, ft) | 0, k = k + Math.imul(de, pt) | 0, x = x + Math.imul(J, nt) | 0, g = g + Math.imul(J, lt) | 0, g = g + Math.imul(G, nt) | 0, k = k + Math.imul(G, lt) | 0, x = x + Math.imul(O, be) | 0, g = g + Math.imul(O, Ae) | 0, g = g + Math.imul(K, be) | 0, k = k + Math.imul(K, Ae) | 0;
      var sr = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (sr >>> 26) | 0, sr &= 67108863, x = Math.imul(Fe, xe), g = Math.imul(Fe, Me), g = g + Math.imul(Ue, xe) | 0, k = Math.imul(Ue, Me), x = x + Math.imul($e, De) | 0, g = g + Math.imul($e, je) | 0, g = g + Math.imul(Re, De) | 0, k = k + Math.imul(Re, je) | 0, x = x + Math.imul(Se, Xe) | 0, g = g + Math.imul(Se, st) | 0, g = g + Math.imul(Ce, Xe) | 0, k = k + Math.imul(Ce, st) | 0, x = x + Math.imul(ce, at) | 0, g = g + Math.imul(ce, ht) | 0, g = g + Math.imul(ye, at) | 0, k = k + Math.imul(ye, ht) | 0, x = x + Math.imul(ve, ot) | 0, g = g + Math.imul(ve, ct) | 0, g = g + Math.imul(he, ot) | 0, k = k + Math.imul(he, ct) | 0, x = x + Math.imul(te, ft) | 0, g = g + Math.imul(te, pt) | 0, g = g + Math.imul(le, ft) | 0, k = k + Math.imul(le, pt) | 0, x = x + Math.imul(ie, nt) | 0, g = g + Math.imul(ie, lt) | 0, g = g + Math.imul(de, nt) | 0, k = k + Math.imul(de, lt) | 0, x = x + Math.imul(J, be) | 0, g = g + Math.imul(J, Ae) | 0, g = g + Math.imul(G, be) | 0, k = k + Math.imul(G, Ae) | 0, x = x + Math.imul(O, _e) | 0, g = g + Math.imul(O, Te) | 0, g = g + Math.imul(K, _e) | 0, k = k + Math.imul(K, Te) | 0;
      var Wt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Wt >>> 26) | 0, Wt &= 67108863, x = Math.imul(pe, xe), g = Math.imul(pe, Me), g = g + Math.imul(re, xe) | 0, k = Math.imul(re, Me), x = x + Math.imul(Fe, De) | 0, g = g + Math.imul(Fe, je) | 0, g = g + Math.imul(Ue, De) | 0, k = k + Math.imul(Ue, je) | 0, x = x + Math.imul($e, Xe) | 0, g = g + Math.imul($e, st) | 0, g = g + Math.imul(Re, Xe) | 0, k = k + Math.imul(Re, st) | 0, x = x + Math.imul(Se, at) | 0, g = g + Math.imul(Se, ht) | 0, g = g + Math.imul(Ce, at) | 0, k = k + Math.imul(Ce, ht) | 0, x = x + Math.imul(ce, ot) | 0, g = g + Math.imul(ce, ct) | 0, g = g + Math.imul(ye, ot) | 0, k = k + Math.imul(ye, ct) | 0, x = x + Math.imul(ve, ft) | 0, g = g + Math.imul(ve, pt) | 0, g = g + Math.imul(he, ft) | 0, k = k + Math.imul(he, pt) | 0, x = x + Math.imul(te, nt) | 0, g = g + Math.imul(te, lt) | 0, g = g + Math.imul(le, nt) | 0, k = k + Math.imul(le, lt) | 0, x = x + Math.imul(ie, be) | 0, g = g + Math.imul(ie, Ae) | 0, g = g + Math.imul(de, be) | 0, k = k + Math.imul(de, Ae) | 0, x = x + Math.imul(J, _e) | 0, g = g + Math.imul(J, Te) | 0, g = g + Math.imul(G, _e) | 0, k = k + Math.imul(G, Te) | 0, x = x + Math.imul(O, Pe) | 0, g = g + Math.imul(O, He) | 0, g = g + Math.imul(K, Pe) | 0, k = k + Math.imul(K, He) | 0;
      var tr = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (tr >>> 26) | 0, tr &= 67108863, x = Math.imul(pe, De), g = Math.imul(pe, je), g = g + Math.imul(re, De) | 0, k = Math.imul(re, je), x = x + Math.imul(Fe, Xe) | 0, g = g + Math.imul(Fe, st) | 0, g = g + Math.imul(Ue, Xe) | 0, k = k + Math.imul(Ue, st) | 0, x = x + Math.imul($e, at) | 0, g = g + Math.imul($e, ht) | 0, g = g + Math.imul(Re, at) | 0, k = k + Math.imul(Re, ht) | 0, x = x + Math.imul(Se, ot) | 0, g = g + Math.imul(Se, ct) | 0, g = g + Math.imul(Ce, ot) | 0, k = k + Math.imul(Ce, ct) | 0, x = x + Math.imul(ce, ft) | 0, g = g + Math.imul(ce, pt) | 0, g = g + Math.imul(ye, ft) | 0, k = k + Math.imul(ye, pt) | 0, x = x + Math.imul(ve, nt) | 0, g = g + Math.imul(ve, lt) | 0, g = g + Math.imul(he, nt) | 0, k = k + Math.imul(he, lt) | 0, x = x + Math.imul(te, be) | 0, g = g + Math.imul(te, Ae) | 0, g = g + Math.imul(le, be) | 0, k = k + Math.imul(le, Ae) | 0, x = x + Math.imul(ie, _e) | 0, g = g + Math.imul(ie, Te) | 0, g = g + Math.imul(de, _e) | 0, k = k + Math.imul(de, Te) | 0, x = x + Math.imul(J, Pe) | 0, g = g + Math.imul(J, He) | 0, g = g + Math.imul(G, Pe) | 0, k = k + Math.imul(G, He) | 0;
      var Jt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Jt >>> 26) | 0, Jt &= 67108863, x = Math.imul(pe, Xe), g = Math.imul(pe, st), g = g + Math.imul(re, Xe) | 0, k = Math.imul(re, st), x = x + Math.imul(Fe, at) | 0, g = g + Math.imul(Fe, ht) | 0, g = g + Math.imul(Ue, at) | 0, k = k + Math.imul(Ue, ht) | 0, x = x + Math.imul($e, ot) | 0, g = g + Math.imul($e, ct) | 0, g = g + Math.imul(Re, ot) | 0, k = k + Math.imul(Re, ct) | 0, x = x + Math.imul(Se, ft) | 0, g = g + Math.imul(Se, pt) | 0, g = g + Math.imul(Ce, ft) | 0, k = k + Math.imul(Ce, pt) | 0, x = x + Math.imul(ce, nt) | 0, g = g + Math.imul(ce, lt) | 0, g = g + Math.imul(ye, nt) | 0, k = k + Math.imul(ye, lt) | 0, x = x + Math.imul(ve, be) | 0, g = g + Math.imul(ve, Ae) | 0, g = g + Math.imul(he, be) | 0, k = k + Math.imul(he, Ae) | 0, x = x + Math.imul(te, _e) | 0, g = g + Math.imul(te, Te) | 0, g = g + Math.imul(le, _e) | 0, k = k + Math.imul(le, Te) | 0, x = x + Math.imul(ie, Pe) | 0, g = g + Math.imul(ie, He) | 0, g = g + Math.imul(de, Pe) | 0, k = k + Math.imul(de, He) | 0;
      var Ft = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Ft >>> 26) | 0, Ft &= 67108863, x = Math.imul(pe, at), g = Math.imul(pe, ht), g = g + Math.imul(re, at) | 0, k = Math.imul(re, ht), x = x + Math.imul(Fe, ot) | 0, g = g + Math.imul(Fe, ct) | 0, g = g + Math.imul(Ue, ot) | 0, k = k + Math.imul(Ue, ct) | 0, x = x + Math.imul($e, ft) | 0, g = g + Math.imul($e, pt) | 0, g = g + Math.imul(Re, ft) | 0, k = k + Math.imul(Re, pt) | 0, x = x + Math.imul(Se, nt) | 0, g = g + Math.imul(Se, lt) | 0, g = g + Math.imul(Ce, nt) | 0, k = k + Math.imul(Ce, lt) | 0, x = x + Math.imul(ce, be) | 0, g = g + Math.imul(ce, Ae) | 0, g = g + Math.imul(ye, be) | 0, k = k + Math.imul(ye, Ae) | 0, x = x + Math.imul(ve, _e) | 0, g = g + Math.imul(ve, Te) | 0, g = g + Math.imul(he, _e) | 0, k = k + Math.imul(he, Te) | 0, x = x + Math.imul(te, Pe) | 0, g = g + Math.imul(te, He) | 0, g = g + Math.imul(le, Pe) | 0, k = k + Math.imul(le, He) | 0;
      var Ut = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, x = Math.imul(pe, ot), g = Math.imul(pe, ct), g = g + Math.imul(re, ot) | 0, k = Math.imul(re, ct), x = x + Math.imul(Fe, ft) | 0, g = g + Math.imul(Fe, pt) | 0, g = g + Math.imul(Ue, ft) | 0, k = k + Math.imul(Ue, pt) | 0, x = x + Math.imul($e, nt) | 0, g = g + Math.imul($e, lt) | 0, g = g + Math.imul(Re, nt) | 0, k = k + Math.imul(Re, lt) | 0, x = x + Math.imul(Se, be) | 0, g = g + Math.imul(Se, Ae) | 0, g = g + Math.imul(Ce, be) | 0, k = k + Math.imul(Ce, Ae) | 0, x = x + Math.imul(ce, _e) | 0, g = g + Math.imul(ce, Te) | 0, g = g + Math.imul(ye, _e) | 0, k = k + Math.imul(ye, Te) | 0, x = x + Math.imul(ve, Pe) | 0, g = g + Math.imul(ve, He) | 0, g = g + Math.imul(he, Pe) | 0, k = k + Math.imul(he, He) | 0;
      var Mt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, x = Math.imul(pe, ft), g = Math.imul(pe, pt), g = g + Math.imul(re, ft) | 0, k = Math.imul(re, pt), x = x + Math.imul(Fe, nt) | 0, g = g + Math.imul(Fe, lt) | 0, g = g + Math.imul(Ue, nt) | 0, k = k + Math.imul(Ue, lt) | 0, x = x + Math.imul($e, be) | 0, g = g + Math.imul($e, Ae) | 0, g = g + Math.imul(Re, be) | 0, k = k + Math.imul(Re, Ae) | 0, x = x + Math.imul(Se, _e) | 0, g = g + Math.imul(Se, Te) | 0, g = g + Math.imul(Ce, _e) | 0, k = k + Math.imul(Ce, Te) | 0, x = x + Math.imul(ce, Pe) | 0, g = g + Math.imul(ce, He) | 0, g = g + Math.imul(ye, Pe) | 0, k = k + Math.imul(ye, He) | 0;
      var Pt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, x = Math.imul(pe, nt), g = Math.imul(pe, lt), g = g + Math.imul(re, nt) | 0, k = Math.imul(re, lt), x = x + Math.imul(Fe, be) | 0, g = g + Math.imul(Fe, Ae) | 0, g = g + Math.imul(Ue, be) | 0, k = k + Math.imul(Ue, Ae) | 0, x = x + Math.imul($e, _e) | 0, g = g + Math.imul($e, Te) | 0, g = g + Math.imul(Re, _e) | 0, k = k + Math.imul(Re, Te) | 0, x = x + Math.imul(Se, Pe) | 0, g = g + Math.imul(Se, He) | 0, g = g + Math.imul(Ce, Pe) | 0, k = k + Math.imul(Ce, He) | 0;
      var Nt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, x = Math.imul(pe, be), g = Math.imul(pe, Ae), g = g + Math.imul(re, be) | 0, k = Math.imul(re, Ae), x = x + Math.imul(Fe, _e) | 0, g = g + Math.imul(Fe, Te) | 0, g = g + Math.imul(Ue, _e) | 0, k = k + Math.imul(Ue, Te) | 0, x = x + Math.imul($e, Pe) | 0, g = g + Math.imul($e, He) | 0, g = g + Math.imul(Re, Pe) | 0, k = k + Math.imul(Re, He) | 0;
      var It = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, x = Math.imul(pe, _e), g = Math.imul(pe, Te), g = g + Math.imul(re, _e) | 0, k = Math.imul(re, Te), x = x + Math.imul(Fe, Pe) | 0, g = g + Math.imul(Fe, He) | 0, g = g + Math.imul(Ue, Pe) | 0, k = k + Math.imul(Ue, He) | 0;
      var tt = (M + x | 0) + ((g & 8191) << 13) | 0;
      M = (k + (g >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, x = Math.imul(pe, Pe), g = Math.imul(pe, He), g = g + Math.imul(re, Pe) | 0, k = Math.imul(re, He);
      var rt = (M + x | 0) + ((g & 8191) << 13) | 0;
      return M = (k + (g >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, E[0] = _t, E[1] = vt, E[2] = cr, E[3] = Tt, E[4] = Gt, E[5] = Yt, E[6] = or, E[7] = sr, E[8] = Wt, E[9] = tr, E[10] = Jt, E[11] = Ft, E[12] = Ut, E[13] = Mt, E[14] = Pt, E[15] = Nt, E[16] = It, E[17] = tt, E[18] = rt, M !== 0 && (E[19] = M, d.length++), d;
    };
    Math.imul || (A = b);
    function _(B, u, p) {
      p.negative = u.negative ^ B.negative, p.length = B.length + u.length;
      for (var d = 0, y = 0, w = 0; w < p.length - 1; w++) {
        var E = y;
        y = 0;
        for (var M = d & 67108863, x = Math.min(w, u.length - 1), g = Math.max(0, w - B.length + 1); g <= x; g++) {
          var k = w - g, T = B.words[k] | 0, O = u.words[g] | 0, K = T * O, Y = K & 67108863;
          E = E + (K / 67108864 | 0) | 0, Y = Y + M | 0, M = Y & 67108863, E = E + (Y >>> 26) | 0, y += E >>> 26, E &= 67108863;
        }
        p.words[w] = M, d = E, E = y;
      }
      return d !== 0 ? p.words[w] = d : p.length--, p.strip();
    }
    function C(B, u, p) {
      var d = new I();
      return d.mulp(B, u, p);
    }
    i.prototype.mulTo = function(u, p) {
      var d, y = this.length + u.length;
      return this.length === 10 && u.length === 10 ? d = A(this, u, p) : y < 63 ? d = b(this, u, p) : y < 1024 ? d = _(this, u, p) : d = C(this, u, p), d;
    };
    function I(B, u) {
      this.x = B, this.y = u;
    }
    I.prototype.makeRBT = function(u) {
      for (var p = new Array(u), d = i.prototype._countBits(u) - 1, y = 0; y < u; y++) p[y] = this.revBin(y, d, u);
      return p;
    }, I.prototype.revBin = function(u, p, d) {
      if (u === 0 || u === d - 1) return u;
      for (var y = 0, w = 0; w < p; w++) y |= (u & 1) << p - w - 1, u >>= 1;
      return y;
    }, I.prototype.permute = function(u, p, d, y, w, E) {
      for (var M = 0; M < E; M++) y[M] = p[u[M]], w[M] = d[u[M]];
    }, I.prototype.transform = function(u, p, d, y, w, E) {
      this.permute(E, u, p, d, y, w);
      for (var M = 1; M < w; M <<= 1) for (var x = M << 1, g = Math.cos(2 * Math.PI / x), k = Math.sin(2 * Math.PI / x), T = 0; T < w; T += x) for (var O = g, K = k, Y = 0; Y < M; Y++) {
        var J = d[T + Y], G = y[T + Y], X = d[T + Y + M], ie = y[T + Y + M], de = O * X - K * ie;
        ie = O * ie + K * X, X = de, d[T + Y] = J + X, y[T + Y] = G + ie, d[T + Y + M] = J - X, y[T + Y + M] = G - ie, Y !== x && (de = g * O - k * K, K = g * K + k * O, O = de);
      }
    }, I.prototype.guessLen13b = function(u, p) {
      var d = Math.max(p, u) | 1, y = d & 1, w = 0;
      for (d = d / 2 | 0; d; d = d >>> 1) w++;
      return 1 << w + 1 + y;
    }, I.prototype.conjugate = function(u, p, d) {
      if (!(d <= 1)) for (var y = 0; y < d / 2; y++) {
        var w = u[y];
        u[y] = u[d - y - 1], u[d - y - 1] = w, w = p[y], p[y] = -p[d - y - 1], p[d - y - 1] = -w;
      }
    }, I.prototype.normalize13b = function(u, p) {
      for (var d = 0, y = 0; y < p / 2; y++) {
        var w = Math.round(u[2 * y + 1] / p) * 8192 + Math.round(u[2 * y] / p) + d;
        u[y] = w & 67108863, w < 67108864 ? d = 0 : d = w / 67108864 | 0;
      }
      return u;
    }, I.prototype.convert13b = function(u, p, d, y) {
      for (var w = 0, E = 0; E < p; E++) w = w + (u[E] | 0), d[2 * E] = w & 8191, w = w >>> 13, d[2 * E + 1] = w & 8191, w = w >>> 13;
      for (E = 2 * p; E < y; ++E) d[E] = 0;
      r(w === 0), r((w & -8192) === 0);
    }, I.prototype.stub = function(u) {
      for (var p = new Array(u), d = 0; d < u; d++) p[d] = 0;
      return p;
    }, I.prototype.mulp = function(u, p, d) {
      var y = 2 * this.guessLen13b(u.length, p.length), w = this.makeRBT(y), E = this.stub(y), M = new Array(y), x = new Array(y), g = new Array(y), k = new Array(y), T = new Array(y), O = new Array(y), K = d.words;
      K.length = y, this.convert13b(u.words, u.length, M, y), this.convert13b(p.words, p.length, k, y), this.transform(M, E, x, g, y, w), this.transform(k, E, T, O, y, w);
      for (var Y = 0; Y < y; Y++) {
        var J = x[Y] * T[Y] - g[Y] * O[Y];
        g[Y] = x[Y] * O[Y] + g[Y] * T[Y], x[Y] = J;
      }
      return this.conjugate(x, g, y), this.transform(x, g, K, E, y, w), this.conjugate(K, E, y), this.normalize13b(K, y), d.negative = u.negative ^ p.negative, d.length = u.length + p.length, d.strip();
    }, i.prototype.mul = function(u) {
      var p = new i(null);
      return p.words = new Array(this.length + u.length), this.mulTo(u, p);
    }, i.prototype.mulf = function(u) {
      var p = new i(null);
      return p.words = new Array(this.length + u.length), C(this, u, p);
    }, i.prototype.imul = function(u) {
      return this.clone().mulTo(u, this);
    }, i.prototype.imuln = function(u) {
      r(typeof u == "number"), r(u < 67108864);
      for (var p = 0, d = 0; d < this.length; d++) {
        var y = (this.words[d] | 0) * u, w = (y & 67108863) + (p & 67108863);
        p >>= 26, p += y / 67108864 | 0, p += w >>> 26, this.words[d] = w & 67108863;
      }
      return p !== 0 && (this.words[d] = p, this.length++), this.length = u === 0 ? 1 : this.length, this;
    }, i.prototype.muln = function(u) {
      return this.clone().imuln(u);
    }, i.prototype.sqr = function() {
      return this.mul(this);
    }, i.prototype.isqr = function() {
      return this.imul(this.clone());
    }, i.prototype.pow = function(u) {
      var p = v(u);
      if (p.length === 0) return new i(1);
      for (var d = this, y = 0; y < p.length && p[y] === 0; y++, d = d.sqr()) ;
      if (++y < p.length) for (var w = d.sqr(); y < p.length; y++, w = w.sqr()) p[y] !== 0 && (d = d.mul(w));
      return d;
    }, i.prototype.iushln = function(u) {
      r(typeof u == "number" && u >= 0);
      var p = u % 26, d = (u - p) / 26, y = 67108863 >>> 26 - p << 26 - p, w;
      if (p !== 0) {
        var E = 0;
        for (w = 0; w < this.length; w++) {
          var M = this.words[w] & y, x = (this.words[w] | 0) - M << p;
          this.words[w] = x | E, E = M >>> 26 - p;
        }
        E && (this.words[w] = E, this.length++);
      }
      if (d !== 0) {
        for (w = this.length - 1; w >= 0; w--) this.words[w + d] = this.words[w];
        for (w = 0; w < d; w++) this.words[w] = 0;
        this.length += d;
      }
      return this.strip();
    }, i.prototype.ishln = function(u) {
      return r(this.negative === 0), this.iushln(u);
    }, i.prototype.iushrn = function(u, p, d) {
      r(typeof u == "number" && u >= 0);
      var y;
      p ? y = (p - p % 26) / 26 : y = 0;
      var w = u % 26, E = Math.min((u - w) / 26, this.length), M = 67108863 ^ 67108863 >>> w << w, x = d;
      if (y -= E, y = Math.max(0, y), x) {
        for (var g = 0; g < E; g++) x.words[g] = this.words[g];
        x.length = E;
      }
      if (E !== 0) if (this.length > E) for (this.length -= E, g = 0; g < this.length; g++) this.words[g] = this.words[g + E];
      else this.words[0] = 0, this.length = 1;
      var k = 0;
      for (g = this.length - 1; g >= 0 && (k !== 0 || g >= y); g--) {
        var T = this.words[g] | 0;
        this.words[g] = k << 26 - w | T >>> w, k = T & M;
      }
      return x && k !== 0 && (x.words[x.length++] = k), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, i.prototype.ishrn = function(u, p, d) {
      return r(this.negative === 0), this.iushrn(u, p, d);
    }, i.prototype.shln = function(u) {
      return this.clone().ishln(u);
    }, i.prototype.ushln = function(u) {
      return this.clone().iushln(u);
    }, i.prototype.shrn = function(u) {
      return this.clone().ishrn(u);
    }, i.prototype.ushrn = function(u) {
      return this.clone().iushrn(u);
    }, i.prototype.testn = function(u) {
      r(typeof u == "number" && u >= 0);
      var p = u % 26, d = (u - p) / 26, y = 1 << p;
      if (this.length <= d) return false;
      var w = this.words[d];
      return !!(w & y);
    }, i.prototype.imaskn = function(u) {
      r(typeof u == "number" && u >= 0);
      var p = u % 26, d = (u - p) / 26;
      if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= d) return this;
      if (p !== 0 && d++, this.length = Math.min(d, this.length), p !== 0) {
        var y = 67108863 ^ 67108863 >>> p << p;
        this.words[this.length - 1] &= y;
      }
      return this.strip();
    }, i.prototype.maskn = function(u) {
      return this.clone().imaskn(u);
    }, i.prototype.iaddn = function(u) {
      return r(typeof u == "number"), r(u < 67108864), u < 0 ? this.isubn(-u) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < u ? (this.words[0] = u - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(u), this.negative = 1, this) : this._iaddn(u);
    }, i.prototype._iaddn = function(u) {
      this.words[0] += u;
      for (var p = 0; p < this.length && this.words[p] >= 67108864; p++) this.words[p] -= 67108864, p === this.length - 1 ? this.words[p + 1] = 1 : this.words[p + 1]++;
      return this.length = Math.max(this.length, p + 1), this;
    }, i.prototype.isubn = function(u) {
      if (r(typeof u == "number"), r(u < 67108864), u < 0) return this.iaddn(-u);
      if (this.negative !== 0) return this.negative = 0, this.iaddn(u), this.negative = 1, this;
      if (this.words[0] -= u, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
      else for (var p = 0; p < this.length && this.words[p] < 0; p++) this.words[p] += 67108864, this.words[p + 1] -= 1;
      return this.strip();
    }, i.prototype.addn = function(u) {
      return this.clone().iaddn(u);
    }, i.prototype.subn = function(u) {
      return this.clone().isubn(u);
    }, i.prototype.iabs = function() {
      return this.negative = 0, this;
    }, i.prototype.abs = function() {
      return this.clone().iabs();
    }, i.prototype._ishlnsubmul = function(u, p, d) {
      var y = u.length + d, w;
      this._expand(y);
      var E, M = 0;
      for (w = 0; w < u.length; w++) {
        E = (this.words[w + d] | 0) + M;
        var x = (u.words[w] | 0) * p;
        E -= x & 67108863, M = (E >> 26) - (x / 67108864 | 0), this.words[w + d] = E & 67108863;
      }
      for (; w < this.length - d; w++) E = (this.words[w + d] | 0) + M, M = E >> 26, this.words[w + d] = E & 67108863;
      if (M === 0) return this.strip();
      for (r(M === -1), M = 0, w = 0; w < this.length; w++) E = -(this.words[w] | 0) + M, M = E >> 26, this.words[w] = E & 67108863;
      return this.negative = 1, this.strip();
    }, i.prototype._wordDiv = function(u, p) {
      var d = this.length - u.length, y = this.clone(), w = u, E = w.words[w.length - 1] | 0, M = this._countBits(E);
      d = 26 - M, d !== 0 && (w = w.ushln(d), y.iushln(d), E = w.words[w.length - 1] | 0);
      var x = y.length - w.length, g;
      if (p !== "mod") {
        g = new i(null), g.length = x + 1, g.words = new Array(g.length);
        for (var k = 0; k < g.length; k++) g.words[k] = 0;
      }
      var T = y.clone()._ishlnsubmul(w, 1, x);
      T.negative === 0 && (y = T, g && (g.words[x] = 1));
      for (var O = x - 1; O >= 0; O--) {
        var K = (y.words[w.length + O] | 0) * 67108864 + (y.words[w.length + O - 1] | 0);
        for (K = Math.min(K / E | 0, 67108863), y._ishlnsubmul(w, K, O); y.negative !== 0; ) K--, y.negative = 0, y._ishlnsubmul(w, 1, O), y.isZero() || (y.negative ^= 1);
        g && (g.words[O] = K);
      }
      return g && g.strip(), y.strip(), p !== "div" && d !== 0 && y.iushrn(d), { div: g || null, mod: y };
    }, i.prototype.divmod = function(u, p, d) {
      if (r(!u.isZero()), this.isZero()) return { div: new i(0), mod: new i(0) };
      var y, w, E;
      return this.negative !== 0 && u.negative === 0 ? (E = this.neg().divmod(u, p), p !== "mod" && (y = E.div.neg()), p !== "div" && (w = E.mod.neg(), d && w.negative !== 0 && w.iadd(u)), { div: y, mod: w }) : this.negative === 0 && u.negative !== 0 ? (E = this.divmod(u.neg(), p), p !== "mod" && (y = E.div.neg()), { div: y, mod: E.mod }) : this.negative & u.negative ? (E = this.neg().divmod(u.neg(), p), p !== "div" && (w = E.mod.neg(), d && w.negative !== 0 && w.isub(u)), { div: E.div, mod: w }) : u.length > this.length || this.cmp(u) < 0 ? { div: new i(0), mod: this } : u.length === 1 ? p === "div" ? { div: this.divn(u.words[0]), mod: null } : p === "mod" ? { div: null, mod: new i(this.modn(u.words[0])) } : { div: this.divn(u.words[0]), mod: new i(this.modn(u.words[0])) } : this._wordDiv(u, p);
    }, i.prototype.div = function(u) {
      return this.divmod(u, "div", false).div;
    }, i.prototype.mod = function(u) {
      return this.divmod(u, "mod", false).mod;
    }, i.prototype.umod = function(u) {
      return this.divmod(u, "mod", true).mod;
    }, i.prototype.divRound = function(u) {
      var p = this.divmod(u);
      if (p.mod.isZero()) return p.div;
      var d = p.div.negative !== 0 ? p.mod.isub(u) : p.mod, y = u.ushrn(1), w = u.andln(1), E = d.cmp(y);
      return E < 0 || w === 1 && E === 0 ? p.div : p.div.negative !== 0 ? p.div.isubn(1) : p.div.iaddn(1);
    }, i.prototype.modn = function(u) {
      r(u <= 67108863);
      for (var p = (1 << 26) % u, d = 0, y = this.length - 1; y >= 0; y--) d = (p * d + (this.words[y] | 0)) % u;
      return d;
    }, i.prototype.idivn = function(u) {
      r(u <= 67108863);
      for (var p = 0, d = this.length - 1; d >= 0; d--) {
        var y = (this.words[d] | 0) + p * 67108864;
        this.words[d] = y / u | 0, p = y % u;
      }
      return this.strip();
    }, i.prototype.divn = function(u) {
      return this.clone().idivn(u);
    }, i.prototype.egcd = function(u) {
      r(u.negative === 0), r(!u.isZero());
      var p = this, d = u.clone();
      p.negative !== 0 ? p = p.umod(u) : p = p.clone();
      for (var y = new i(1), w = new i(0), E = new i(0), M = new i(1), x = 0; p.isEven() && d.isEven(); ) p.iushrn(1), d.iushrn(1), ++x;
      for (var g = d.clone(), k = p.clone(); !p.isZero(); ) {
        for (var T = 0, O = 1; !(p.words[0] & O) && T < 26; ++T, O <<= 1) ;
        if (T > 0) for (p.iushrn(T); T-- > 0; ) (y.isOdd() || w.isOdd()) && (y.iadd(g), w.isub(k)), y.iushrn(1), w.iushrn(1);
        for (var K = 0, Y = 1; !(d.words[0] & Y) && K < 26; ++K, Y <<= 1) ;
        if (K > 0) for (d.iushrn(K); K-- > 0; ) (E.isOdd() || M.isOdd()) && (E.iadd(g), M.isub(k)), E.iushrn(1), M.iushrn(1);
        p.cmp(d) >= 0 ? (p.isub(d), y.isub(E), w.isub(M)) : (d.isub(p), E.isub(y), M.isub(w));
      }
      return { a: E, b: M, gcd: d.iushln(x) };
    }, i.prototype._invmp = function(u) {
      r(u.negative === 0), r(!u.isZero());
      var p = this, d = u.clone();
      p.negative !== 0 ? p = p.umod(u) : p = p.clone();
      for (var y = new i(1), w = new i(0), E = d.clone(); p.cmpn(1) > 0 && d.cmpn(1) > 0; ) {
        for (var M = 0, x = 1; !(p.words[0] & x) && M < 26; ++M, x <<= 1) ;
        if (M > 0) for (p.iushrn(M); M-- > 0; ) y.isOdd() && y.iadd(E), y.iushrn(1);
        for (var g = 0, k = 1; !(d.words[0] & k) && g < 26; ++g, k <<= 1) ;
        if (g > 0) for (d.iushrn(g); g-- > 0; ) w.isOdd() && w.iadd(E), w.iushrn(1);
        p.cmp(d) >= 0 ? (p.isub(d), y.isub(w)) : (d.isub(p), w.isub(y));
      }
      var T;
      return p.cmpn(1) === 0 ? T = y : T = w, T.cmpn(0) < 0 && T.iadd(u), T;
    }, i.prototype.gcd = function(u) {
      if (this.isZero()) return u.abs();
      if (u.isZero()) return this.abs();
      var p = this.clone(), d = u.clone();
      p.negative = 0, d.negative = 0;
      for (var y = 0; p.isEven() && d.isEven(); y++) p.iushrn(1), d.iushrn(1);
      do {
        for (; p.isEven(); ) p.iushrn(1);
        for (; d.isEven(); ) d.iushrn(1);
        var w = p.cmp(d);
        if (w < 0) {
          var E = p;
          p = d, d = E;
        } else if (w === 0 || d.cmpn(1) === 0) break;
        p.isub(d);
      } while (true);
      return d.iushln(y);
    }, i.prototype.invm = function(u) {
      return this.egcd(u).a.umod(u);
    }, i.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, i.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, i.prototype.andln = function(u) {
      return this.words[0] & u;
    }, i.prototype.bincn = function(u) {
      r(typeof u == "number");
      var p = u % 26, d = (u - p) / 26, y = 1 << p;
      if (this.length <= d) return this._expand(d + 1), this.words[d] |= y, this;
      for (var w = y, E = d; w !== 0 && E < this.length; E++) {
        var M = this.words[E] | 0;
        M += w, w = M >>> 26, M &= 67108863, this.words[E] = M;
      }
      return w !== 0 && (this.words[E] = w, this.length++), this;
    }, i.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, i.prototype.cmpn = function(u) {
      var p = u < 0;
      if (this.negative !== 0 && !p) return -1;
      if (this.negative === 0 && p) return 1;
      this.strip();
      var d;
      if (this.length > 1) d = 1;
      else {
        p && (u = -u), r(u <= 67108863, "Number is too big");
        var y = this.words[0] | 0;
        d = y === u ? 0 : y < u ? -1 : 1;
      }
      return this.negative !== 0 ? -d | 0 : d;
    }, i.prototype.cmp = function(u) {
      if (this.negative !== 0 && u.negative === 0) return -1;
      if (this.negative === 0 && u.negative !== 0) return 1;
      var p = this.ucmp(u);
      return this.negative !== 0 ? -p | 0 : p;
    }, i.prototype.ucmp = function(u) {
      if (this.length > u.length) return 1;
      if (this.length < u.length) return -1;
      for (var p = 0, d = this.length - 1; d >= 0; d--) {
        var y = this.words[d] | 0, w = u.words[d] | 0;
        if (y !== w) {
          y < w ? p = -1 : y > w && (p = 1);
          break;
        }
      }
      return p;
    }, i.prototype.gtn = function(u) {
      return this.cmpn(u) === 1;
    }, i.prototype.gt = function(u) {
      return this.cmp(u) === 1;
    }, i.prototype.gten = function(u) {
      return this.cmpn(u) >= 0;
    }, i.prototype.gte = function(u) {
      return this.cmp(u) >= 0;
    }, i.prototype.ltn = function(u) {
      return this.cmpn(u) === -1;
    }, i.prototype.lt = function(u) {
      return this.cmp(u) === -1;
    }, i.prototype.lten = function(u) {
      return this.cmpn(u) <= 0;
    }, i.prototype.lte = function(u) {
      return this.cmp(u) <= 0;
    }, i.prototype.eqn = function(u) {
      return this.cmpn(u) === 0;
    }, i.prototype.eq = function(u) {
      return this.cmp(u) === 0;
    }, i.red = function(u) {
      return new N(u);
    }, i.prototype.toRed = function(u) {
      return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), u.convertTo(this)._forceRed(u);
    }, i.prototype.fromRed = function() {
      return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, i.prototype._forceRed = function(u) {
      return this.red = u, this;
    }, i.prototype.forceRed = function(u) {
      return r(!this.red, "Already a number in reduction context"), this._forceRed(u);
    }, i.prototype.redAdd = function(u) {
      return r(this.red, "redAdd works only with red numbers"), this.red.add(this, u);
    }, i.prototype.redIAdd = function(u) {
      return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, u);
    }, i.prototype.redSub = function(u) {
      return r(this.red, "redSub works only with red numbers"), this.red.sub(this, u);
    }, i.prototype.redISub = function(u) {
      return r(this.red, "redISub works only with red numbers"), this.red.isub(this, u);
    }, i.prototype.redShl = function(u) {
      return r(this.red, "redShl works only with red numbers"), this.red.shl(this, u);
    }, i.prototype.redMul = function(u) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, u), this.red.mul(this, u);
    }, i.prototype.redIMul = function(u) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, u), this.red.imul(this, u);
    }, i.prototype.redSqr = function() {
      return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, i.prototype.redISqr = function() {
      return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, i.prototype.redSqrt = function() {
      return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, i.prototype.redInvm = function() {
      return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, i.prototype.redNeg = function() {
      return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, i.prototype.redPow = function(u) {
      return r(this.red && !u.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, u);
    };
    var S = { k256: null, p224: null, p192: null, p25519: null };
    function $(B, u) {
      this.name = B, this.p = new i(u, 16), this.n = this.p.bitLength(), this.k = new i(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    $.prototype._tmp = function() {
      var u = new i(null);
      return u.words = new Array(Math.ceil(this.n / 13)), u;
    }, $.prototype.ireduce = function(u) {
      var p = u, d;
      do
        this.split(p, this.tmp), p = this.imulK(p), p = p.iadd(this.tmp), d = p.bitLength();
      while (d > this.n);
      var y = d < this.n ? -1 : p.ucmp(this.p);
      return y === 0 ? (p.words[0] = 0, p.length = 1) : y > 0 ? p.isub(this.p) : p.strip !== void 0 ? p.strip() : p._strip(), p;
    }, $.prototype.split = function(u, p) {
      u.iushrn(this.n, 0, p);
    }, $.prototype.imulK = function(u) {
      return u.imul(this.k);
    };
    function F() {
      $.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    s(F, $), F.prototype.split = function(u, p) {
      for (var d = 4194303, y = Math.min(u.length, 9), w = 0; w < y; w++) p.words[w] = u.words[w];
      if (p.length = y, u.length <= 9) {
        u.words[0] = 0, u.length = 1;
        return;
      }
      var E = u.words[9];
      for (p.words[p.length++] = E & d, w = 10; w < u.length; w++) {
        var M = u.words[w] | 0;
        u.words[w - 10] = (M & d) << 4 | E >>> 22, E = M;
      }
      E >>>= 22, u.words[w - 10] = E, E === 0 && u.length > 10 ? u.length -= 10 : u.length -= 9;
    }, F.prototype.imulK = function(u) {
      u.words[u.length] = 0, u.words[u.length + 1] = 0, u.length += 2;
      for (var p = 0, d = 0; d < u.length; d++) {
        var y = u.words[d] | 0;
        p += y * 977, u.words[d] = p & 67108863, p = y * 64 + (p / 67108864 | 0);
      }
      return u.words[u.length - 1] === 0 && (u.length--, u.words[u.length - 1] === 0 && u.length--), u;
    };
    function U() {
      $.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    s(U, $);
    function Q() {
      $.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    s(Q, $);
    function P() {
      $.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    s(P, $), P.prototype.imulK = function(u) {
      for (var p = 0, d = 0; d < u.length; d++) {
        var y = (u.words[d] | 0) * 19 + p, w = y & 67108863;
        y >>>= 26, u.words[d] = w, p = y;
      }
      return p !== 0 && (u.words[u.length++] = p), u;
    }, i._prime = function(u) {
      if (S[u]) return S[u];
      var p;
      if (u === "k256") p = new F();
      else if (u === "p224") p = new U();
      else if (u === "p192") p = new Q();
      else if (u === "p25519") p = new P();
      else throw new Error("Unknown prime " + u);
      return S[u] = p, p;
    };
    function N(B) {
      if (typeof B == "string") {
        var u = i._prime(B);
        this.m = u.p, this.prime = u;
      } else r(B.gtn(1), "modulus must be greater than 1"), this.m = B, this.prime = null;
    }
    N.prototype._verify1 = function(u) {
      r(u.negative === 0, "red works only with positives"), r(u.red, "red works only with red numbers");
    }, N.prototype._verify2 = function(u, p) {
      r((u.negative | p.negative) === 0, "red works only with positives"), r(u.red && u.red === p.red, "red works only with red numbers");
    }, N.prototype.imod = function(u) {
      return this.prime ? this.prime.ireduce(u)._forceRed(this) : u.umod(this.m)._forceRed(this);
    }, N.prototype.neg = function(u) {
      return u.isZero() ? u.clone() : this.m.sub(u)._forceRed(this);
    }, N.prototype.add = function(u, p) {
      this._verify2(u, p);
      var d = u.add(p);
      return d.cmp(this.m) >= 0 && d.isub(this.m), d._forceRed(this);
    }, N.prototype.iadd = function(u, p) {
      this._verify2(u, p);
      var d = u.iadd(p);
      return d.cmp(this.m) >= 0 && d.isub(this.m), d;
    }, N.prototype.sub = function(u, p) {
      this._verify2(u, p);
      var d = u.sub(p);
      return d.cmpn(0) < 0 && d.iadd(this.m), d._forceRed(this);
    }, N.prototype.isub = function(u, p) {
      this._verify2(u, p);
      var d = u.isub(p);
      return d.cmpn(0) < 0 && d.iadd(this.m), d;
    }, N.prototype.shl = function(u, p) {
      return this._verify1(u), this.imod(u.ushln(p));
    }, N.prototype.imul = function(u, p) {
      return this._verify2(u, p), this.imod(u.imul(p));
    }, N.prototype.mul = function(u, p) {
      return this._verify2(u, p), this.imod(u.mul(p));
    }, N.prototype.isqr = function(u) {
      return this.imul(u, u.clone());
    }, N.prototype.sqr = function(u) {
      return this.mul(u, u);
    }, N.prototype.sqrt = function(u) {
      if (u.isZero()) return u.clone();
      var p = this.m.andln(3);
      if (r(p % 2 === 1), p === 3) {
        var d = this.m.add(new i(1)).iushrn(2);
        return this.pow(u, d);
      }
      for (var y = this.m.subn(1), w = 0; !y.isZero() && y.andln(1) === 0; ) w++, y.iushrn(1);
      r(!y.isZero());
      var E = new i(1).toRed(this), M = E.redNeg(), x = this.m.subn(1).iushrn(1), g = this.m.bitLength();
      for (g = new i(2 * g * g).toRed(this); this.pow(g, x).cmp(M) !== 0; ) g.redIAdd(M);
      for (var k = this.pow(g, y), T = this.pow(u, y.addn(1).iushrn(1)), O = this.pow(u, y), K = w; O.cmp(E) !== 0; ) {
        for (var Y = O, J = 0; Y.cmp(E) !== 0; J++) Y = Y.redSqr();
        r(J < K);
        var G = this.pow(k, new i(1).iushln(K - J - 1));
        T = T.redMul(G), k = G.redSqr(), O = O.redMul(k), K = J;
      }
      return T;
    }, N.prototype.invm = function(u) {
      var p = u._invmp(this.m);
      return p.negative !== 0 ? (p.negative = 0, this.imod(p).redNeg()) : this.imod(p);
    }, N.prototype.pow = function(u, p) {
      if (p.isZero()) return new i(1).toRed(this);
      if (p.cmpn(1) === 0) return u.clone();
      var d = 4, y = new Array(1 << d);
      y[0] = new i(1).toRed(this), y[1] = u;
      for (var w = 2; w < y.length; w++) y[w] = this.mul(y[w - 1], u);
      var E = y[0], M = 0, x = 0, g = p.bitLength() % 26;
      for (g === 0 && (g = 26), w = p.length - 1; w >= 0; w--) {
        for (var k = p.words[w], T = g - 1; T >= 0; T--) {
          var O = k >> T & 1;
          if (E !== y[0] && (E = this.sqr(E)), O === 0 && M === 0) {
            x = 0;
            continue;
          }
          M <<= 1, M |= O, x++, !(x !== d && (w !== 0 || T !== 0)) && (E = this.mul(E, y[M]), x = 0, M = 0);
        }
        g = 26;
      }
      return E;
    }, N.prototype.convertTo = function(u) {
      var p = u.umod(this.m);
      return p === u ? p.clone() : p;
    }, N.prototype.convertFrom = function(u) {
      var p = u.clone();
      return p.red = null, p;
    }, i.mont = function(u) {
      return new L(u);
    };
    function L(B) {
      N.call(this, B), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new i(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    s(L, N), L.prototype.convertTo = function(u) {
      return this.imod(u.ushln(this.shift));
    }, L.prototype.convertFrom = function(u) {
      var p = this.imod(u.mul(this.rinv));
      return p.red = null, p;
    }, L.prototype.imul = function(u, p) {
      if (u.isZero() || p.isZero()) return u.words[0] = 0, u.length = 1, u;
      var d = u.imul(p), y = d.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = d.isub(y).iushrn(this.shift), E = w;
      return w.cmp(this.m) >= 0 ? E = w.isub(this.m) : w.cmpn(0) < 0 && (E = w.iadd(this.m)), E._forceRed(this);
    }, L.prototype.mul = function(u, p) {
      if (u.isZero() || p.isZero()) return new i(0)._forceRed(this);
      var d = u.mul(p), y = d.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), w = d.isub(y).iushrn(this.shift), E = w;
      return w.cmp(this.m) >= 0 ? E = w.isub(this.m) : w.cmpn(0) < 0 && (E = w.iadd(this.m)), E._forceRed(this);
    }, L.prototype.invm = function(u) {
      var p = this.imod(u._invmp(this.m).mul(this.r2));
      return p._forceRed(this);
    };
  })(t3, mt);
})(i4);
var s4 = i4.exports, gx = s4, Oj = Tn.Buffer;
function Qj(t3, e) {
  return Oj.from(t3.toRed(gx.mont(e.modulus)).redPow(new gx(e.publicExponent)).fromRed().toArray());
}
var nT = Qj, Kj = fm, tb = Yu, Hj = vd, mx = tT, vx = rT, a4 = s4, qj = nT, zj = YA, ka = Tn.Buffer, Gj = function(e, n, r) {
  var s;
  e.padding ? s = e.padding : r ? s = 1 : s = 4;
  var i = Kj(e), a;
  if (s === 4) a = Vj(i, n);
  else if (s === 1) a = Yj(i, n, r);
  else if (s === 3) {
    if (a = new a4(n), a.cmp(i.modulus) >= 0) throw new Error("data too long for modulus");
  } else throw new Error("unknown padding");
  return r ? zj(a, i) : qj(a, i);
};
function Vj(t3, e) {
  var n = t3.modulus.byteLength(), r = e.length, s = Hj("sha1").update(ka.alloc(0)).digest(), i = s.length, a = 2 * i;
  if (r > n - a - 2) throw new Error("message too long");
  var o = ka.alloc(n - r - a - 2), f = n - i - 1, c = tb(i), l = vx(ka.concat([s, o, ka.alloc(1, 1), e], f), mx(c, f)), h = vx(c, mx(l, i));
  return new a4(ka.concat([ka.alloc(1), h, l], n));
}
function Yj(t3, e, n) {
  var r = e.length, s = t3.modulus.byteLength();
  if (r > s - 11) throw new Error("message too long");
  var i;
  return n ? i = ka.alloc(s - r - 3, 255) : i = Wj(s - r - 3), new a4(ka.concat([ka.from([0, n ? 1 : 2]), i, ka.alloc(1), e], s));
}
function Wj(t3) {
  for (var e = ka.allocUnsafe(t3), n = 0, r = tb(t3 * 2), s = 0, i; n < t3; ) s === r.length && (r = tb(t3 * 2), s = 0), i = r[s++], i && (e[n++] = i);
  return e;
}
var Jj = fm, yx = tT, bx = rT, Ax = s4, Zj = YA, jj = vd, Xj = nT, Nh = Tn.Buffer, eX = function(e, n, r) {
  var s;
  e.padding ? s = e.padding : r ? s = 1 : s = 4;
  var i = Jj(e), a = i.modulus.byteLength();
  if (n.length > a || new Ax(n).cmp(i.modulus) >= 0) throw new Error("decryption error");
  var o;
  r ? o = Xj(new Ax(n), i) : o = Zj(n, i);
  var f = Nh.alloc(a - o.length);
  if (o = Nh.concat([f, o], a), s === 4) return tX(i, o);
  if (s === 1) return rX(i, o, r);
  if (s === 3) return o;
  throw new Error("unknown padding");
};
function tX(t3, e) {
  var n = t3.modulus.byteLength(), r = jj("sha1").update(Nh.alloc(0)).digest(), s = r.length;
  if (e[0] !== 0) throw new Error("decryption error");
  var i = e.slice(1, s + 1), a = e.slice(s + 1), o = bx(i, yx(a, s)), f = bx(a, yx(o, n - s - 1));
  if (nX(r, f.slice(0, s))) throw new Error("decryption error");
  for (var c = s; f[c] === 0; ) c++;
  if (f[c++] !== 1) throw new Error("decryption error");
  return f.slice(c);
}
function rX(t3, e, n) {
  for (var r = e.slice(0, 2), s = 2, i = 0; e[s++] !== 0; ) if (s >= e.length) {
    i++;
    break;
  }
  var a = e.slice(2, s - 1);
  if ((r.toString("hex") !== "0002" && !n || r.toString("hex") !== "0001" && n) && i++, a.length < 8 && i++, i) throw new Error("decryption error");
  return e.slice(s);
}
function nX(t3, e) {
  t3 = Nh.from(t3), e = Nh.from(e);
  var n = 0, r = t3.length;
  t3.length !== e.length && (n++, r = Math.min(t3.length, e.length));
  for (var s = -1; ++s < r; ) n += t3[s] ^ e[s];
  return n;
}
(function(t3) {
  t3.publicEncrypt = Gj, t3.privateDecrypt = eX, t3.privateEncrypt = function(n, r) {
    return t3.publicEncrypt(n, r, true);
  }, t3.publicDecrypt = function(n, r) {
    return t3.privateDecrypt(n, r, true);
  };
})(eT);
var eh = {};
function wx() {
  throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
}
var iT = Tn, xx = Yu, sT = iT.Buffer, aT = iT.kMaxLength, rb = mt.crypto || mt.msCrypto, oT = Math.pow(2, 32) - 1;
function fT(t3, e) {
  if (typeof t3 != "number" || t3 !== t3) throw new TypeError("offset must be a number");
  if (t3 > oT || t3 < 0) throw new TypeError("offset must be a uint32");
  if (t3 > aT || t3 > e) throw new RangeError("offset out of range");
}
function lT(t3, e, n) {
  if (typeof t3 != "number" || t3 !== t3) throw new TypeError("size must be a number");
  if (t3 > oT || t3 < 0) throw new TypeError("size must be a uint32");
  if (t3 + e > n || t3 > aT) throw new RangeError("buffer too small");
}
rb && rb.getRandomValues || !jt.browser ? (eh.randomFill = iX, eh.randomFillSync = sX) : (eh.randomFill = wx, eh.randomFillSync = wx);
function iX(t3, e, n, r) {
  if (!sT.isBuffer(t3) && !(t3 instanceof mt.Uint8Array)) throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  if (typeof e == "function") r = e, e = 0, n = t3.length;
  else if (typeof n == "function") r = n, n = t3.length - e;
  else if (typeof r != "function") throw new TypeError('"cb" argument must be a function');
  return fT(e, t3.length), lT(n, e, t3.length), uT(t3, e, n, r);
}
function uT(t3, e, n, r) {
  if (jt.browser) {
    var s = t3.buffer, i = new Uint8Array(s, e, n);
    if (rb.getRandomValues(i), r) {
      jt.nextTick(function() {
        r(null, t3);
      });
      return;
    }
    return t3;
  }
  if (r) {
    xx(n, function(o, f) {
      if (o) return r(o);
      f.copy(t3, e), r(null, t3);
    });
    return;
  }
  var a = xx(n);
  return a.copy(t3, e), t3;
}
function sX(t3, e, n) {
  if (typeof e > "u" && (e = 0), !sT.isBuffer(t3) && !(t3 instanceof mt.Uint8Array)) throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  return fT(e, t3.length), n === void 0 && (n = t3.length - e), lT(n, e, t3.length), uT(t3, e, n);
}
var _x;
function vl() {
  if (_x) return Tr;
  _x = 1, Tr.randomBytes = Tr.rng = Tr.pseudoRandomBytes = Tr.prng = Yu, Tr.createHash = Tr.Hash = vd, Tr.createHmac = Tr.Hmac = IM;
  var t3 = tY, e = Object.keys(t3), n = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(e);
  Tr.getHashes = function() {
    return n;
  };
  var r = Vg;
  Tr.pbkdf2 = r.pbkdf2, Tr.pbkdf2Sync = r.pbkdf2Sync;
  var s = Ta;
  Tr.Cipher = s.Cipher, Tr.createCipher = s.createCipher, Tr.Cipheriv = s.Cipheriv, Tr.createCipheriv = s.createCipheriv, Tr.Decipher = s.Decipher, Tr.createDecipher = s.createDecipher, Tr.Decipheriv = s.Decipheriv, Tr.createDecipheriv = s.createDecipheriv, Tr.getCiphers = s.getCiphers, Tr.listCiphers = s.listCiphers;
  var i = OW();
  Tr.DiffieHellmanGroup = i.DiffieHellmanGroup, Tr.createDiffieHellmanGroup = i.createDiffieHellmanGroup, Tr.getDiffieHellman = i.getDiffieHellman, Tr.createDiffieHellman = i.createDiffieHellman, Tr.DiffieHellman = i.DiffieHellman;
  var a = Fj();
  Tr.createSign = a.createSign, Tr.Sign = a.Sign, Tr.createVerify = a.createVerify, Tr.Verify = a.Verify, Tr.createECDH = Nj();
  var o = eT;
  Tr.publicEncrypt = o.publicEncrypt, Tr.privateEncrypt = o.privateEncrypt, Tr.publicDecrypt = o.publicDecrypt, Tr.privateDecrypt = o.privateDecrypt;
  var f = eh;
  return Tr.randomFill = f.randomFill, Tr.randomFillSync = f.randomFillSync, Tr.createCredentials = function() {
    throw new Error(`sorry, createCredentials is not implemented yet
we accept pull requests
https://github.com/browserify/crypto-browserify`);
  }, Tr.constants = { DH_CHECK_P_NOT_SAFE_PRIME: 2, DH_CHECK_P_NOT_PRIME: 1, DH_UNABLE_TO_CHECK_GENERATOR: 4, DH_NOT_SUITABLE_GENERATOR: 8, NPN_ENABLED: 1, ALPN_ENABLED: 1, RSA_PKCS1_PADDING: 1, RSA_SSLV23_PADDING: 2, RSA_NO_PADDING: 3, RSA_PKCS1_OAEP_PADDING: 4, RSA_X931_PADDING: 5, RSA_PKCS1_PSS_PADDING: 6, POINT_CONVERSION_COMPRESSED: 2, POINT_CONVERSION_UNCOMPRESSED: 4, POINT_CONVERSION_HYBRID: 6 }, Tr;
}
var os = Ur, aX = os.pkcs5 = os.pkcs5 || {}, Ko;
os.util.isNodejs && !os.options.usePureJavaScript && (Ko = vl());
os.pbkdf2 = aX.pbkdf2 = function(t3, e, n, r, s, i) {
  if (typeof s == "function" && (i = s, s = null), os.util.isNodejs && !os.options.usePureJavaScript && Ko.pbkdf2 && (s === null || typeof s != "object") && (Ko.pbkdf2Sync.length > 4 || !s || s === "sha1")) return typeof s != "string" && (s = "sha1"), t3 = hr.from(t3, "binary"), e = hr.from(e, "binary"), i ? Ko.pbkdf2Sync.length === 4 ? Ko.pbkdf2(t3, e, n, r, function(S, $) {
    if (S) return i(S);
    i(null, $.toString("binary"));
  }) : Ko.pbkdf2(t3, e, n, r, s, function(S, $) {
    if (S) return i(S);
    i(null, $.toString("binary"));
  }) : Ko.pbkdf2Sync.length === 4 ? Ko.pbkdf2Sync(t3, e, n, r).toString("binary") : Ko.pbkdf2Sync(t3, e, n, r, s).toString("binary");
  if ((typeof s > "u" || s === null) && (s = "sha1"), typeof s == "string") {
    if (!(s in os.md.algorithms)) throw new Error("Unknown hash algorithm: " + s);
    s = os.md[s].create();
  }
  var a = s.digestLength;
  if (r > 4294967295 * a) {
    var o = new Error("Derived key is too long.");
    if (i) return i(o);
    throw o;
  }
  var f = Math.ceil(r / a), c = r - (f - 1) * a, l = os.hmac.create();
  l.start(s, t3);
  var h = "", m, v, b;
  if (!i) {
    for (var A = 1; A <= f; ++A) {
      l.start(null, null), l.update(e), l.update(os.util.int32ToBytes(A)), m = b = l.digest().getBytes();
      for (var _ = 2; _ <= n; ++_) l.start(null, null), l.update(b), v = l.digest().getBytes(), m = os.util.xorBytes(m, v, a), b = v;
      h += A < f ? m : m.substr(0, c);
    }
    return h;
  }
  var A = 1, _;
  function C() {
    if (A > f) return i(null, h);
    l.start(null, null), l.update(e), l.update(os.util.int32ToBytes(A)), m = b = l.digest().getBytes(), _ = 2, I();
  }
  function I() {
    if (_ <= n) return l.start(null, null), l.update(b), v = l.digest().getBytes(), m = os.util.xorBytes(m, v, a), b = v, ++_, os.util.setImmediate(I);
    h += A < f ? m : m.substr(0, c), ++A, C();
  }
  C();
};
var so = Ur, cT = so.sha256 = so.sha256 || {};
so.md.sha256 = so.md.algorithms.sha256 = cT;
cT.create = function() {
  hT || oX();
  var t3 = null, e = so.util.createBuffer(), n = new Array(64), r = { algorithm: "sha256", blockLength: 64, digestLength: 32, messageLength: 0, fullMessageLength: null, messageLengthSize: 8 };
  return r.start = function() {
    r.messageLength = 0, r.fullMessageLength = r.messageLength64 = [];
    for (var s = r.messageLengthSize / 4, i = 0; i < s; ++i) r.fullMessageLength.push(0);
    return e = so.util.createBuffer(), t3 = { h0: 1779033703, h1: 3144134277, h2: 1013904242, h3: 2773480762, h4: 1359893119, h5: 2600822924, h6: 528734635, h7: 1541459225 }, r;
  }, r.start(), r.update = function(s, i) {
    i === "utf8" && (s = so.util.encodeUtf8(s));
    var a = s.length;
    r.messageLength += a, a = [a / 4294967296 >>> 0, a >>> 0];
    for (var o = r.fullMessageLength.length - 1; o >= 0; --o) r.fullMessageLength[o] += a[1], a[1] = a[0] + (r.fullMessageLength[o] / 4294967296 >>> 0), r.fullMessageLength[o] = r.fullMessageLength[o] >>> 0, a[0] = a[1] / 4294967296 >>> 0;
    return e.putBytes(s), Ex(t3, n, e), (e.read > 2048 || e.length() === 0) && e.compact(), r;
  }, r.digest = function() {
    var s = so.util.createBuffer();
    s.putBytes(e.bytes());
    var i = r.fullMessageLength[r.fullMessageLength.length - 1] + r.messageLengthSize, a = i & r.blockLength - 1;
    s.putBytes(nb.substr(0, r.blockLength - a));
    for (var o, f, c = r.fullMessageLength[0] * 8, l = 0; l < r.fullMessageLength.length - 1; ++l) o = r.fullMessageLength[l + 1] * 8, f = o / 4294967296 >>> 0, c += f, s.putInt32(c >>> 0), c = o >>> 0;
    s.putInt32(c);
    var h = { h0: t3.h0, h1: t3.h1, h2: t3.h2, h3: t3.h3, h4: t3.h4, h5: t3.h5, h6: t3.h6, h7: t3.h7 };
    Ex(h, n, s);
    var m = so.util.createBuffer();
    return m.putInt32(h.h0), m.putInt32(h.h1), m.putInt32(h.h2), m.putInt32(h.h3), m.putInt32(h.h4), m.putInt32(h.h5), m.putInt32(h.h6), m.putInt32(h.h7), m;
  }, r;
};
var nb = null, hT = false, dT = null;
function oX() {
  nb = "\x80", nb += so.util.fillString("\0", 64), dT = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], hT = true;
}
function Ex(t3, e, n) {
  for (var r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I = n.length(); I >= 64; ) {
    for (c = 0; c < 16; ++c) e[c] = n.getInt32();
    for (; c < 64; ++c) r = e[c - 2], r = (r >>> 17 | r << 15) ^ (r >>> 19 | r << 13) ^ r >>> 10, s = e[c - 15], s = (s >>> 7 | s << 25) ^ (s >>> 18 | s << 14) ^ s >>> 3, e[c] = r + e[c - 7] + s + e[c - 16] | 0;
    for (l = t3.h0, h = t3.h1, m = t3.h2, v = t3.h3, b = t3.h4, A = t3.h5, _ = t3.h6, C = t3.h7, c = 0; c < 64; ++c) a = (b >>> 6 | b << 26) ^ (b >>> 11 | b << 21) ^ (b >>> 25 | b << 7), o = _ ^ b & (A ^ _), i = (l >>> 2 | l << 30) ^ (l >>> 13 | l << 19) ^ (l >>> 22 | l << 10), f = l & h | m & (l ^ h), r = C + a + o + dT[c] + e[c], s = i + f, C = _, _ = A, A = b, b = v + r >>> 0, v = m, m = h, h = l, l = r + s >>> 0;
    t3.h0 = t3.h0 + l | 0, t3.h1 = t3.h1 + h | 0, t3.h2 = t3.h2 + m | 0, t3.h3 = t3.h3 + v | 0, t3.h4 = t3.h4 + b | 0, t3.h5 = t3.h5 + A | 0, t3.h6 = t3.h6 + _ | 0, t3.h7 = t3.h7 + C | 0, I -= 64;
  }
}
var Xa = Ur, zp = null;
Xa.util.isNodejs && !Xa.options.usePureJavaScript && !jt.versions["node-webkit"] && (zp = vl());
var fX = Xa.prng = Xa.prng || {};
fX.create = function(t3) {
  for (var e = { plugin: t3, key: null, seed: null, time: null, reseeds: 0, generated: 0, keyBytes: "" }, n = t3.md, r = new Array(32), s = 0; s < 32; ++s) r[s] = n.create();
  e.pools = r, e.pool = 0, e.generate = function(c, l) {
    if (!l) return e.generateSync(c);
    var h = e.plugin.cipher, m = e.plugin.increment, v = e.plugin.formatKey, b = e.plugin.formatSeed, A = Xa.util.createBuffer();
    e.key = null, _();
    function _(C) {
      if (C) return l(C);
      if (A.length() >= c) return l(null, A.getBytes(c));
      if (e.generated > 1048575 && (e.key = null), e.key === null) return Xa.util.nextTick(function() {
        i(_);
      });
      var I = h(e.key, e.seed);
      e.generated += I.length, A.putBytes(I), e.key = v(h(e.key, m(e.seed))), e.seed = b(h(e.key, e.seed)), Xa.util.setImmediate(_);
    }
  }, e.generateSync = function(c) {
    var l = e.plugin.cipher, h = e.plugin.increment, m = e.plugin.formatKey, v = e.plugin.formatSeed;
    e.key = null;
    for (var b = Xa.util.createBuffer(); b.length() < c; ) {
      e.generated > 1048575 && (e.key = null), e.key === null && a();
      var A = l(e.key, e.seed);
      e.generated += A.length, b.putBytes(A), e.key = m(l(e.key, h(e.seed))), e.seed = v(l(e.key, e.seed));
    }
    return b.getBytes(c);
  };
  function i(c) {
    if (e.pools[0].messageLength >= 32) return o(), c();
    var l = 32 - e.pools[0].messageLength << 5;
    e.seedFile(l, function(h, m) {
      if (h) return c(h);
      e.collect(m), o(), c();
    });
  }
  function a() {
    if (e.pools[0].messageLength >= 32) return o();
    var c = 32 - e.pools[0].messageLength << 5;
    e.collect(e.seedFileSync(c)), o();
  }
  function o() {
    e.reseeds = e.reseeds === 4294967295 ? 0 : e.reseeds + 1;
    var c = e.plugin.md.create();
    c.update(e.keyBytes);
    for (var l = 1, h = 0; h < 32; ++h) e.reseeds % l === 0 && (c.update(e.pools[h].digest().getBytes()), e.pools[h].start()), l = l << 1;
    e.keyBytes = c.digest().getBytes(), c.start(), c.update(e.keyBytes);
    var m = c.digest().getBytes();
    e.key = e.plugin.formatKey(e.keyBytes), e.seed = e.plugin.formatSeed(m), e.generated = 0;
  }
  function f(c) {
    var l = null, h = Xa.util.globalScope, m = h.crypto || h.msCrypto;
    m && m.getRandomValues && (l = function(F) {
      return m.getRandomValues(F);
    });
    var v = Xa.util.createBuffer();
    if (l) for (; v.length() < c; ) {
      var b = Math.max(1, Math.min(c - v.length(), 65536) / 4), A = new Uint32Array(Math.floor(b));
      try {
        l(A);
        for (var _ = 0; _ < A.length; ++_) v.putInt32(A[_]);
      } catch (F) {
        if (!(typeof QuotaExceededError < "u" && F instanceof QuotaExceededError)) throw F;
      }
    }
    if (v.length() < c) for (var C, I, S, $ = Math.floor(Math.random() * 65536); v.length() < c; ) {
      I = 16807 * ($ & 65535), C = 16807 * ($ >> 16), I += (C & 32767) << 16, I += C >> 15, I = (I & 2147483647) + (I >> 31), $ = I & 4294967295;
      for (var _ = 0; _ < 3; ++_) S = $ >>> (_ << 3), S ^= Math.floor(Math.random() * 256), v.putByte(S & 255);
    }
    return v.getBytes(c);
  }
  return zp ? (e.seedFile = function(c, l) {
    zp.randomBytes(c, function(h, m) {
      if (h) return l(h);
      l(null, m.toString());
    });
  }, e.seedFileSync = function(c) {
    return zp.randomBytes(c).toString();
  }) : (e.seedFile = function(c, l) {
    try {
      l(null, f(c));
    } catch (h) {
      l(h);
    }
  }, e.seedFileSync = f), e.collect = function(c) {
    for (var l = c.length, h = 0; h < l; ++h) e.pools[e.pool].update(c.substr(h, 1)), e.pool = e.pool === 31 ? 0 : e.pool + 1;
  }, e.collectInt = function(c, l) {
    for (var h = "", m = 0; m < l; m += 8) h += String.fromCharCode(c >> m & 255);
    e.collect(h);
  }, e.registerWorker = function(c) {
    if (c === self) e.seedFile = function(h, m) {
      function v(b) {
        var A = b.data;
        A.forge && A.forge.prng && (self.removeEventListener("message", v), m(A.forge.prng.err, A.forge.prng.bytes));
      }
      self.addEventListener("message", v), self.postMessage({ forge: { prng: { needed: h } } });
    };
    else {
      var l = function(h) {
        var m = h.data;
        m.forge && m.forge.prng && e.seedFile(m.forge.prng.needed, function(v, b) {
          c.postMessage({ forge: { prng: { err: v, bytes: b } } });
        });
      };
      c.addEventListener("message", l);
    }
  }, e;
};
var gi = Ur;
(function() {
  if (gi.random && gi.random.getBytes) {
    gi.random;
    return;
  }
  (function(t3) {
    var e = {}, n = new Array(4), r = gi.util.createBuffer();
    e.formatKey = function(h) {
      var m = gi.util.createBuffer(h);
      return h = new Array(4), h[0] = m.getInt32(), h[1] = m.getInt32(), h[2] = m.getInt32(), h[3] = m.getInt32(), gi.aes._expandKey(h, false);
    }, e.formatSeed = function(h) {
      var m = gi.util.createBuffer(h);
      return h = new Array(4), h[0] = m.getInt32(), h[1] = m.getInt32(), h[2] = m.getInt32(), h[3] = m.getInt32(), h;
    }, e.cipher = function(h, m) {
      return gi.aes._updateBlock(h, m, n, false), r.putInt32(n[0]), r.putInt32(n[1]), r.putInt32(n[2]), r.putInt32(n[3]), r.getBytes();
    }, e.increment = function(h) {
      return ++h[3], h;
    }, e.md = gi.md.sha256;
    function s() {
      var h = gi.prng.create(e);
      return h.getBytes = function(m, v) {
        return h.generate(m, v);
      }, h.getBytesSync = function(m) {
        return h.generate(m);
      }, h;
    }
    var i = s(), a = null, o = gi.util.globalScope, f = o.crypto || o.msCrypto;
    if (f && f.getRandomValues && (a = function(h) {
      return f.getRandomValues(h);
    }), gi.options.usePureJavaScript || !gi.util.isNodejs && !a) {
      if (i.collectInt(+/* @__PURE__ */ new Date(), 32), typeof navigator < "u") {
        var c = "";
        for (var l in navigator) try {
          typeof navigator[l] == "string" && (c += navigator[l]);
        } catch {
        }
        i.collect(c), c = null;
      }
      t3 && (t3().mousemove(function(h) {
        i.collectInt(h.clientX, 16), i.collectInt(h.clientY, 16);
      }), t3().keypress(function(h) {
        i.collectInt(h.charCode, 8);
      }));
    }
    if (!gi.random) gi.random = i;
    else for (var l in i) gi.random[l] = i[l];
    gi.random.createInstance = s, gi.random;
  })(typeof jQuery < "u" ? jQuery : null);
})();
var Bs = Ur, mv = [217, 120, 249, 196, 25, 221, 181, 237, 40, 233, 253, 121, 74, 160, 216, 157, 198, 126, 55, 131, 43, 118, 83, 142, 98, 76, 100, 136, 68, 139, 251, 162, 23, 154, 89, 245, 135, 179, 79, 19, 97, 69, 109, 141, 9, 129, 125, 50, 189, 143, 64, 235, 134, 183, 123, 11, 240, 149, 33, 34, 92, 107, 78, 130, 84, 214, 101, 147, 206, 96, 178, 28, 115, 86, 192, 20, 167, 140, 241, 220, 18, 117, 202, 31, 59, 190, 228, 209, 66, 61, 212, 48, 163, 60, 182, 38, 111, 191, 14, 218, 70, 105, 7, 87, 39, 242, 29, 155, 188, 148, 67, 3, 248, 17, 199, 246, 144, 239, 62, 231, 6, 195, 213, 47, 200, 102, 30, 215, 8, 232, 234, 222, 128, 82, 238, 247, 132, 170, 114, 172, 53, 77, 106, 42, 150, 26, 210, 113, 90, 21, 73, 116, 75, 159, 208, 94, 4, 24, 164, 236, 194, 224, 65, 110, 15, 81, 203, 204, 36, 145, 175, 80, 161, 244, 112, 57, 153, 124, 58, 133, 35, 184, 180, 122, 252, 2, 54, 91, 37, 85, 151, 49, 45, 93, 250, 152, 227, 138, 146, 174, 5, 223, 41, 16, 103, 108, 186, 201, 211, 0, 230, 207, 225, 158, 168, 44, 99, 22, 1, 63, 88, 226, 137, 169, 13, 56, 52, 27, 171, 51, 255, 176, 187, 72, 12, 95, 185, 177, 205, 46, 197, 243, 219, 71, 229, 165, 156, 119, 10, 166, 32, 104, 254, 127, 193, 173], Bx = [1, 2, 3, 5], lX = function(t3, e) {
  return t3 << e & 65535 | (t3 & 65535) >> 16 - e;
}, uX = function(t3, e) {
  return (t3 & 65535) >> e | t3 << 16 - e & 65535;
};
Bs.rc2 = Bs.rc2 || {};
Bs.rc2.expandKey = function(t3, e) {
  typeof t3 == "string" && (t3 = Bs.util.createBuffer(t3)), e = e || 128;
  var n = t3, r = t3.length(), s = e, i = Math.ceil(s / 8), a = 255 >> (s & 7), o;
  for (o = r; o < 128; o++) n.putByte(mv[n.at(o - 1) + n.at(o - r) & 255]);
  for (n.setAt(128 - i, mv[n.at(128 - i) & a]), o = 127 - i; o >= 0; o--) n.setAt(o, mv[n.at(o + 1) ^ n.at(o + i)]);
  return n;
};
var pT = function(t3, e, n) {
  var r = false, s = null, i = null, a = null, o, f, c, l, h = [];
  for (t3 = Bs.rc2.expandKey(t3, e), c = 0; c < 64; c++) h.push(t3.getInt16Le());
  n ? (o = function(b) {
    for (c = 0; c < 4; c++) b[c] += h[l] + (b[(c + 3) % 4] & b[(c + 2) % 4]) + (~b[(c + 3) % 4] & b[(c + 1) % 4]), b[c] = lX(b[c], Bx[c]), l++;
  }, f = function(b) {
    for (c = 0; c < 4; c++) b[c] += h[b[(c + 3) % 4] & 63];
  }) : (o = function(b) {
    for (c = 3; c >= 0; c--) b[c] = uX(b[c], Bx[c]), b[c] -= h[l] + (b[(c + 3) % 4] & b[(c + 2) % 4]) + (~b[(c + 3) % 4] & b[(c + 1) % 4]), l--;
  }, f = function(b) {
    for (c = 3; c >= 0; c--) b[c] -= h[b[(c + 3) % 4] & 63];
  });
  var m = function(b) {
    var A = [];
    for (c = 0; c < 4; c++) {
      var _ = s.getInt16Le();
      a !== null && (n ? _ ^= a.getInt16Le() : a.putInt16Le(_)), A.push(_ & 65535);
    }
    l = n ? 0 : 63;
    for (var C = 0; C < b.length; C++) for (var I = 0; I < b[C][0]; I++) b[C][1](A);
    for (c = 0; c < 4; c++) a !== null && (n ? a.putInt16Le(A[c]) : A[c] ^= a.getInt16Le()), i.putInt16Le(A[c]);
  }, v = null;
  return v = { start: function(b, A) {
    b && typeof b == "string" && (b = Bs.util.createBuffer(b)), r = false, s = Bs.util.createBuffer(), i = A || new Bs.util.createBuffer(), a = b, v.output = i;
  }, update: function(b) {
    for (r || s.putBuffer(b); s.length() >= 8; ) m([[5, o], [1, f], [6, o], [1, f], [5, o]]);
  }, finish: function(b) {
    var A = true;
    if (n) if (b) A = b(8, s, !n);
    else {
      var _ = s.length() === 8 ? 8 : 8 - s.length();
      s.fillWithByte(_, _);
    }
    if (A && (r = true, v.update()), !n && (A = s.length() === 0, A)) if (b) A = b(8, i, !n);
    else {
      var C = i.length(), I = i.at(C - 1);
      I > C ? A = false : i.truncate(I);
    }
    return A;
  } }, v;
};
Bs.rc2.startEncrypting = function(t3, e, n) {
  var r = Bs.rc2.createEncryptionCipher(t3, 128);
  return r.start(e, n), r;
};
Bs.rc2.createEncryptionCipher = function(t3, e) {
  return pT(t3, e, true);
};
Bs.rc2.startDecrypting = function(t3, e, n) {
  var r = Bs.rc2.createDecryptionCipher(t3, 128);
  return r.start(e, n), r;
};
Bs.rc2.createDecryptionCipher = function(t3, e) {
  return pT(t3, e, false);
};
var ib = Ur;
ib.jsbn = ib.jsbn || {};
var jo;
function Ct(t3, e, n) {
  this.data = [], t3 != null && (typeof t3 == "number" ? this.fromNumber(t3, e, n) : e == null && typeof t3 != "string" ? this.fromString(t3, 256) : this.fromString(t3, e));
}
ib.jsbn.BigInteger = Ct;
function sn() {
  return new Ct(null);
}
function cX(t3, e, n, r, s, i) {
  for (; --i >= 0; ) {
    var a = e * this.data[t3++] + n.data[r] + s;
    s = Math.floor(a / 67108864), n.data[r++] = a & 67108863;
  }
  return s;
}
function hX(t3, e, n, r, s, i) {
  for (var a = e & 32767, o = e >> 15; --i >= 0; ) {
    var f = this.data[t3] & 32767, c = this.data[t3++] >> 15, l = o * f + c * a;
    f = a * f + ((l & 32767) << 15) + n.data[r] + (s & 1073741823), s = (f >>> 30) + (l >>> 15) + o * c + (s >>> 30), n.data[r++] = f & 1073741823;
  }
  return s;
}
function Cx(t3, e, n, r, s, i) {
  for (var a = e & 16383, o = e >> 14; --i >= 0; ) {
    var f = this.data[t3] & 16383, c = this.data[t3++] >> 14, l = o * f + c * a;
    f = a * f + ((l & 16383) << 14) + n.data[r] + s, s = (f >> 28) + (l >> 14) + o * c, n.data[r++] = f & 268435455;
  }
  return s;
}
typeof navigator > "u" ? (Ct.prototype.am = Cx, jo = 28) : navigator.appName == "Microsoft Internet Explorer" ? (Ct.prototype.am = hX, jo = 30) : navigator.appName != "Netscape" ? (Ct.prototype.am = cX, jo = 26) : (Ct.prototype.am = Cx, jo = 28);
Ct.prototype.DB = jo;
Ct.prototype.DM = (1 << jo) - 1;
Ct.prototype.DV = 1 << jo;
var o4 = 52;
Ct.prototype.FV = Math.pow(2, o4);
Ct.prototype.F1 = o4 - jo;
Ct.prototype.F2 = 2 * jo - o4;
var dX = "0123456789abcdefghijklmnopqrstuvwxyz", lm = new Array(), oc, ra;
oc = 48;
for (ra = 0; ra <= 9; ++ra) lm[oc++] = ra;
oc = 97;
for (ra = 10; ra < 36; ++ra) lm[oc++] = ra;
oc = 65;
for (ra = 10; ra < 36; ++ra) lm[oc++] = ra;
function kx(t3) {
  return dX.charAt(t3);
}
function gT(t3, e) {
  var n = lm[t3.charCodeAt(e)];
  return n ?? -1;
}
function pX(t3) {
  for (var e = this.t - 1; e >= 0; --e) t3.data[e] = this.data[e];
  t3.t = this.t, t3.s = this.s;
}
function gX(t3) {
  this.t = 1, this.s = t3 < 0 ? -1 : 0, t3 > 0 ? this.data[0] = t3 : t3 < -1 ? this.data[0] = t3 + this.DV : this.t = 0;
}
function Yf(t3) {
  var e = sn();
  return e.fromInt(t3), e;
}
function mX(t3, e) {
  var n;
  if (e == 16) n = 4;
  else if (e == 8) n = 3;
  else if (e == 256) n = 8;
  else if (e == 2) n = 1;
  else if (e == 32) n = 5;
  else if (e == 4) n = 2;
  else {
    this.fromRadix(t3, e);
    return;
  }
  this.t = 0, this.s = 0;
  for (var r = t3.length, s = false, i = 0; --r >= 0; ) {
    var a = n == 8 ? t3[r] & 255 : gT(t3, r);
    if (a < 0) {
      t3.charAt(r) == "-" && (s = true);
      continue;
    }
    s = false, i == 0 ? this.data[this.t++] = a : i + n > this.DB ? (this.data[this.t - 1] |= (a & (1 << this.DB - i) - 1) << i, this.data[this.t++] = a >> this.DB - i) : this.data[this.t - 1] |= a << i, i += n, i >= this.DB && (i -= this.DB);
  }
  n == 8 && t3[0] & 128 && (this.s = -1, i > 0 && (this.data[this.t - 1] |= (1 << this.DB - i) - 1 << i)), this.clamp(), s && Ct.ZERO.subTo(this, this);
}
function vX() {
  for (var t3 = this.s & this.DM; this.t > 0 && this.data[this.t - 1] == t3; ) --this.t;
}
function yX(t3) {
  if (this.s < 0) return "-" + this.negate().toString(t3);
  var e;
  if (t3 == 16) e = 4;
  else if (t3 == 8) e = 3;
  else if (t3 == 2) e = 1;
  else if (t3 == 32) e = 5;
  else if (t3 == 4) e = 2;
  else return this.toRadix(t3);
  var n = (1 << e) - 1, r, s = false, i = "", a = this.t, o = this.DB - a * this.DB % e;
  if (a-- > 0) for (o < this.DB && (r = this.data[a] >> o) > 0 && (s = true, i = kx(r)); a >= 0; ) o < e ? (r = (this.data[a] & (1 << o) - 1) << e - o, r |= this.data[--a] >> (o += this.DB - e)) : (r = this.data[a] >> (o -= e) & n, o <= 0 && (o += this.DB, --a)), r > 0 && (s = true), s && (i += kx(r));
  return s ? i : "0";
}
function bX() {
  var t3 = sn();
  return Ct.ZERO.subTo(this, t3), t3;
}
function AX() {
  return this.s < 0 ? this.negate() : this;
}
function wX(t3) {
  var e = this.s - t3.s;
  if (e != 0) return e;
  var n = this.t;
  if (e = n - t3.t, e != 0) return this.s < 0 ? -e : e;
  for (; --n >= 0; ) if ((e = this.data[n] - t3.data[n]) != 0) return e;
  return 0;
}
function um(t3) {
  var e = 1, n;
  return (n = t3 >>> 16) != 0 && (t3 = n, e += 16), (n = t3 >> 8) != 0 && (t3 = n, e += 8), (n = t3 >> 4) != 0 && (t3 = n, e += 4), (n = t3 >> 2) != 0 && (t3 = n, e += 2), (n = t3 >> 1) != 0 && (t3 = n, e += 1), e;
}
function xX() {
  return this.t <= 0 ? 0 : this.DB * (this.t - 1) + um(this.data[this.t - 1] ^ this.s & this.DM);
}
function _X(t3, e) {
  var n;
  for (n = this.t - 1; n >= 0; --n) e.data[n + t3] = this.data[n];
  for (n = t3 - 1; n >= 0; --n) e.data[n] = 0;
  e.t = this.t + t3, e.s = this.s;
}
function EX(t3, e) {
  for (var n = t3; n < this.t; ++n) e.data[n - t3] = this.data[n];
  e.t = Math.max(this.t - t3, 0), e.s = this.s;
}
function BX(t3, e) {
  var n = t3 % this.DB, r = this.DB - n, s = (1 << r) - 1, i = Math.floor(t3 / this.DB), a = this.s << n & this.DM, o;
  for (o = this.t - 1; o >= 0; --o) e.data[o + i + 1] = this.data[o] >> r | a, a = (this.data[o] & s) << n;
  for (o = i - 1; o >= 0; --o) e.data[o] = 0;
  e.data[i] = a, e.t = this.t + i + 1, e.s = this.s, e.clamp();
}
function CX(t3, e) {
  e.s = this.s;
  var n = Math.floor(t3 / this.DB);
  if (n >= this.t) {
    e.t = 0;
    return;
  }
  var r = t3 % this.DB, s = this.DB - r, i = (1 << r) - 1;
  e.data[0] = this.data[n] >> r;
  for (var a = n + 1; a < this.t; ++a) e.data[a - n - 1] |= (this.data[a] & i) << s, e.data[a - n] = this.data[a] >> r;
  r > 0 && (e.data[this.t - n - 1] |= (this.s & i) << s), e.t = this.t - n, e.clamp();
}
function kX(t3, e) {
  for (var n = 0, r = 0, s = Math.min(t3.t, this.t); n < s; ) r += this.data[n] - t3.data[n], e.data[n++] = r & this.DM, r >>= this.DB;
  if (t3.t < this.t) {
    for (r -= t3.s; n < this.t; ) r += this.data[n], e.data[n++] = r & this.DM, r >>= this.DB;
    r += this.s;
  } else {
    for (r += this.s; n < t3.t; ) r -= t3.data[n], e.data[n++] = r & this.DM, r >>= this.DB;
    r -= t3.s;
  }
  e.s = r < 0 ? -1 : 0, r < -1 ? e.data[n++] = this.DV + r : r > 0 && (e.data[n++] = r), e.t = n, e.clamp();
}
function IX(t3, e) {
  var n = this.abs(), r = t3.abs(), s = n.t;
  for (e.t = s + r.t; --s >= 0; ) e.data[s] = 0;
  for (s = 0; s < r.t; ++s) e.data[s + n.t] = n.am(0, r.data[s], e, s, 0, n.t);
  e.s = 0, e.clamp(), this.s != t3.s && Ct.ZERO.subTo(e, e);
}
function SX(t3) {
  for (var e = this.abs(), n = t3.t = 2 * e.t; --n >= 0; ) t3.data[n] = 0;
  for (n = 0; n < e.t - 1; ++n) {
    var r = e.am(n, e.data[n], t3, 2 * n, 0, 1);
    (t3.data[n + e.t] += e.am(n + 1, 2 * e.data[n], t3, 2 * n + 1, r, e.t - n - 1)) >= e.DV && (t3.data[n + e.t] -= e.DV, t3.data[n + e.t + 1] = 1);
  }
  t3.t > 0 && (t3.data[t3.t - 1] += e.am(n, e.data[n], t3, 2 * n, 0, 1)), t3.s = 0, t3.clamp();
}
function MX(t3, e, n) {
  var r = t3.abs();
  if (!(r.t <= 0)) {
    var s = this.abs();
    if (s.t < r.t) {
      e == null ? void 0 : e.fromInt(0), n != null && this.copyTo(n);
      return;
    }
    n == null && (n = sn());
    var i = sn(), a = this.s, o = t3.s, f = this.DB - um(r.data[r.t - 1]);
    f > 0 ? (r.lShiftTo(f, i), s.lShiftTo(f, n)) : (r.copyTo(i), s.copyTo(n));
    var c = i.t, l = i.data[c - 1];
    if (l != 0) {
      var h = l * (1 << this.F1) + (c > 1 ? i.data[c - 2] >> this.F2 : 0), m = this.FV / h, v = (1 << this.F1) / h, b = 1 << this.F2, A = n.t, _ = A - c, C = e ?? sn();
      for (i.dlShiftTo(_, C), n.compareTo(C) >= 0 && (n.data[n.t++] = 1, n.subTo(C, n)), Ct.ONE.dlShiftTo(c, C), C.subTo(i, i); i.t < c; ) i.data[i.t++] = 0;
      for (; --_ >= 0; ) {
        var I = n.data[--A] == l ? this.DM : Math.floor(n.data[A] * m + (n.data[A - 1] + b) * v);
        if ((n.data[A] += i.am(0, I, n, _, 0, c)) < I) for (i.dlShiftTo(_, C), n.subTo(C, n); n.data[A] < --I; ) n.subTo(C, n);
      }
      e != null && (n.drShiftTo(c, e), a != o && Ct.ZERO.subTo(e, e)), n.t = c, n.clamp(), f > 0 && n.rShiftTo(f, n), a < 0 && Ct.ZERO.subTo(n, n);
    }
  }
}
function $X(t3) {
  var e = sn();
  return this.abs().divRemTo(t3, null, e), this.s < 0 && e.compareTo(Ct.ZERO) > 0 && t3.subTo(e, e), e;
}
function w0(t3) {
  this.m = t3;
}
function TX(t3) {
  return t3.s < 0 || t3.compareTo(this.m) >= 0 ? t3.mod(this.m) : t3;
}
function DX(t3) {
  return t3;
}
function RX(t3) {
  t3.divRemTo(this.m, null, t3);
}
function FX(t3, e, n) {
  t3.multiplyTo(e, n), this.reduce(n);
}
function PX(t3, e) {
  t3.squareTo(e), this.reduce(e);
}
w0.prototype.convert = TX;
w0.prototype.revert = DX;
w0.prototype.reduce = RX;
w0.prototype.mulTo = FX;
w0.prototype.sqrTo = PX;
function NX() {
  if (this.t < 1) return 0;
  var t3 = this.data[0];
  if (!(t3 & 1)) return 0;
  var e = t3 & 3;
  return e = e * (2 - (t3 & 15) * e) & 15, e = e * (2 - (t3 & 255) * e) & 255, e = e * (2 - ((t3 & 65535) * e & 65535)) & 65535, e = e * (2 - t3 * e % this.DV) % this.DV, e > 0 ? this.DV - e : -e;
}
function x0(t3) {
  this.m = t3, this.mp = t3.invDigit(), this.mpl = this.mp & 32767, this.mph = this.mp >> 15, this.um = (1 << t3.DB - 15) - 1, this.mt2 = 2 * t3.t;
}
function UX(t3) {
  var e = sn();
  return t3.abs().dlShiftTo(this.m.t, e), e.divRemTo(this.m, null, e), t3.s < 0 && e.compareTo(Ct.ZERO) > 0 && this.m.subTo(e, e), e;
}
function LX(t3) {
  var e = sn();
  return t3.copyTo(e), this.reduce(e), e;
}
function OX(t3) {
  for (; t3.t <= this.mt2; ) t3.data[t3.t++] = 0;
  for (var e = 0; e < this.m.t; ++e) {
    var n = t3.data[e] & 32767, r = n * this.mpl + ((n * this.mph + (t3.data[e] >> 15) * this.mpl & this.um) << 15) & t3.DM;
    for (n = e + this.m.t, t3.data[n] += this.m.am(0, r, t3, e, 0, this.m.t); t3.data[n] >= t3.DV; ) t3.data[n] -= t3.DV, t3.data[++n]++;
  }
  t3.clamp(), t3.drShiftTo(this.m.t, t3), t3.compareTo(this.m) >= 0 && t3.subTo(this.m, t3);
}
function QX(t3, e) {
  t3.squareTo(e), this.reduce(e);
}
function KX(t3, e, n) {
  t3.multiplyTo(e, n), this.reduce(n);
}
x0.prototype.convert = UX;
x0.prototype.revert = LX;
x0.prototype.reduce = OX;
x0.prototype.mulTo = KX;
x0.prototype.sqrTo = QX;
function HX() {
  return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
}
function qX(t3, e) {
  if (t3 > 4294967295 || t3 < 1) return Ct.ONE;
  var n = sn(), r = sn(), s = e.convert(this), i = um(t3) - 1;
  for (s.copyTo(n); --i >= 0; ) if (e.sqrTo(n, r), (t3 & 1 << i) > 0) e.mulTo(r, s, n);
  else {
    var a = n;
    n = r, r = a;
  }
  return e.revert(n);
}
function zX(t3, e) {
  var n;
  return t3 < 256 || e.isEven() ? n = new w0(e) : n = new x0(e), this.exp(t3, n);
}
Ct.prototype.copyTo = pX;
Ct.prototype.fromInt = gX;
Ct.prototype.fromString = mX;
Ct.prototype.clamp = vX;
Ct.prototype.dlShiftTo = _X;
Ct.prototype.drShiftTo = EX;
Ct.prototype.lShiftTo = BX;
Ct.prototype.rShiftTo = CX;
Ct.prototype.subTo = kX;
Ct.prototype.multiplyTo = IX;
Ct.prototype.squareTo = SX;
Ct.prototype.divRemTo = MX;
Ct.prototype.invDigit = NX;
Ct.prototype.isEven = HX;
Ct.prototype.exp = qX;
Ct.prototype.toString = yX;
Ct.prototype.negate = bX;
Ct.prototype.abs = AX;
Ct.prototype.compareTo = wX;
Ct.prototype.bitLength = xX;
Ct.prototype.mod = $X;
Ct.prototype.modPowInt = zX;
Ct.ZERO = Yf(0);
Ct.ONE = Yf(1);
function GX() {
  var t3 = sn();
  return this.copyTo(t3), t3;
}
function VX() {
  if (this.s < 0) {
    if (this.t == 1) return this.data[0] - this.DV;
    if (this.t == 0) return -1;
  } else {
    if (this.t == 1) return this.data[0];
    if (this.t == 0) return 0;
  }
  return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
}
function YX() {
  return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
}
function WX() {
  return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
}
function JX(t3) {
  return Math.floor(Math.LN2 * this.DB / Math.log(t3));
}
function ZX() {
  return this.s < 0 ? -1 : this.t <= 0 || this.t == 1 && this.data[0] <= 0 ? 0 : 1;
}
function jX(t3) {
  if (t3 == null && (t3 = 10), this.signum() == 0 || t3 < 2 || t3 > 36) return "0";
  var e = this.chunkSize(t3), n = Math.pow(t3, e), r = Yf(n), s = sn(), i = sn(), a = "";
  for (this.divRemTo(r, s, i); s.signum() > 0; ) a = (n + i.intValue()).toString(t3).substr(1) + a, s.divRemTo(r, s, i);
  return i.intValue().toString(t3) + a;
}
function XX(t3, e) {
  this.fromInt(0), e == null && (e = 10);
  for (var n = this.chunkSize(e), r = Math.pow(e, n), s = false, i = 0, a = 0, o = 0; o < t3.length; ++o) {
    var f = gT(t3, o);
    if (f < 0) {
      t3.charAt(o) == "-" && this.signum() == 0 && (s = true);
      continue;
    }
    a = e * a + f, ++i >= n && (this.dMultiply(r), this.dAddOffset(a, 0), i = 0, a = 0);
  }
  i > 0 && (this.dMultiply(Math.pow(e, i)), this.dAddOffset(a, 0)), s && Ct.ZERO.subTo(this, this);
}
function eee(t3, e, n) {
  if (typeof e == "number") if (t3 < 2) this.fromInt(1);
  else for (this.fromNumber(t3, n), this.testBit(t3 - 1) || this.bitwiseTo(Ct.ONE.shiftLeft(t3 - 1), f4, this), this.isEven() && this.dAddOffset(1, 0); !this.isProbablePrime(e); ) this.dAddOffset(2, 0), this.bitLength() > t3 && this.subTo(Ct.ONE.shiftLeft(t3 - 1), this);
  else {
    var r = new Array(), s = t3 & 7;
    r.length = (t3 >> 3) + 1, e.nextBytes(r), s > 0 ? r[0] &= (1 << s) - 1 : r[0] = 0, this.fromString(r, 256);
  }
}
function tee() {
  var t3 = this.t, e = new Array();
  e[0] = this.s;
  var n = this.DB - t3 * this.DB % 8, r, s = 0;
  if (t3-- > 0) for (n < this.DB && (r = this.data[t3] >> n) != (this.s & this.DM) >> n && (e[s++] = r | this.s << this.DB - n); t3 >= 0; ) n < 8 ? (r = (this.data[t3] & (1 << n) - 1) << 8 - n, r |= this.data[--t3] >> (n += this.DB - 8)) : (r = this.data[t3] >> (n -= 8) & 255, n <= 0 && (n += this.DB, --t3)), r & 128 && (r |= -256), s == 0 && (this.s & 128) != (r & 128) && ++s, (s > 0 || r != this.s) && (e[s++] = r);
  return e;
}
function ree(t3) {
  return this.compareTo(t3) == 0;
}
function nee(t3) {
  return this.compareTo(t3) < 0 ? this : t3;
}
function iee(t3) {
  return this.compareTo(t3) > 0 ? this : t3;
}
function see(t3, e, n) {
  var r, s, i = Math.min(t3.t, this.t);
  for (r = 0; r < i; ++r) n.data[r] = e(this.data[r], t3.data[r]);
  if (t3.t < this.t) {
    for (s = t3.s & this.DM, r = i; r < this.t; ++r) n.data[r] = e(this.data[r], s);
    n.t = this.t;
  } else {
    for (s = this.s & this.DM, r = i; r < t3.t; ++r) n.data[r] = e(s, t3.data[r]);
    n.t = t3.t;
  }
  n.s = e(this.s, t3.s), n.clamp();
}
function aee(t3, e) {
  return t3 & e;
}
function oee(t3) {
  var e = sn();
  return this.bitwiseTo(t3, aee, e), e;
}
function f4(t3, e) {
  return t3 | e;
}
function fee(t3) {
  var e = sn();
  return this.bitwiseTo(t3, f4, e), e;
}
function mT(t3, e) {
  return t3 ^ e;
}
function lee(t3) {
  var e = sn();
  return this.bitwiseTo(t3, mT, e), e;
}
function vT(t3, e) {
  return t3 & ~e;
}
function uee(t3) {
  var e = sn();
  return this.bitwiseTo(t3, vT, e), e;
}
function cee() {
  for (var t3 = sn(), e = 0; e < this.t; ++e) t3.data[e] = this.DM & ~this.data[e];
  return t3.t = this.t, t3.s = ~this.s, t3;
}
function hee(t3) {
  var e = sn();
  return t3 < 0 ? this.rShiftTo(-t3, e) : this.lShiftTo(t3, e), e;
}
function dee(t3) {
  var e = sn();
  return t3 < 0 ? this.lShiftTo(-t3, e) : this.rShiftTo(t3, e), e;
}
function pee(t3) {
  if (t3 == 0) return -1;
  var e = 0;
  return t3 & 65535 || (t3 >>= 16, e += 16), t3 & 255 || (t3 >>= 8, e += 8), t3 & 15 || (t3 >>= 4, e += 4), t3 & 3 || (t3 >>= 2, e += 2), t3 & 1 || ++e, e;
}
function gee() {
  for (var t3 = 0; t3 < this.t; ++t3) if (this.data[t3] != 0) return t3 * this.DB + pee(this.data[t3]);
  return this.s < 0 ? this.t * this.DB : -1;
}
function mee(t3) {
  for (var e = 0; t3 != 0; ) t3 &= t3 - 1, ++e;
  return e;
}
function vee() {
  for (var t3 = 0, e = this.s & this.DM, n = 0; n < this.t; ++n) t3 += mee(this.data[n] ^ e);
  return t3;
}
function yee(t3) {
  var e = Math.floor(t3 / this.DB);
  return e >= this.t ? this.s != 0 : (this.data[e] & 1 << t3 % this.DB) != 0;
}
function bee(t3, e) {
  var n = Ct.ONE.shiftLeft(t3);
  return this.bitwiseTo(n, e, n), n;
}
function Aee(t3) {
  return this.changeBit(t3, f4);
}
function wee(t3) {
  return this.changeBit(t3, vT);
}
function xee(t3) {
  return this.changeBit(t3, mT);
}
function _ee(t3, e) {
  for (var n = 0, r = 0, s = Math.min(t3.t, this.t); n < s; ) r += this.data[n] + t3.data[n], e.data[n++] = r & this.DM, r >>= this.DB;
  if (t3.t < this.t) {
    for (r += t3.s; n < this.t; ) r += this.data[n], e.data[n++] = r & this.DM, r >>= this.DB;
    r += this.s;
  } else {
    for (r += this.s; n < t3.t; ) r += t3.data[n], e.data[n++] = r & this.DM, r >>= this.DB;
    r += t3.s;
  }
  e.s = r < 0 ? -1 : 0, r > 0 ? e.data[n++] = r : r < -1 && (e.data[n++] = this.DV + r), e.t = n, e.clamp();
}
function Eee(t3) {
  var e = sn();
  return this.addTo(t3, e), e;
}
function Bee(t3) {
  var e = sn();
  return this.subTo(t3, e), e;
}
function Cee(t3) {
  var e = sn();
  return this.multiplyTo(t3, e), e;
}
function kee(t3) {
  var e = sn();
  return this.divRemTo(t3, e, null), e;
}
function Iee(t3) {
  var e = sn();
  return this.divRemTo(t3, null, e), e;
}
function See(t3) {
  var e = sn(), n = sn();
  return this.divRemTo(t3, e, n), new Array(e, n);
}
function Mee(t3) {
  this.data[this.t] = this.am(0, t3 - 1, this, 0, 0, this.t), ++this.t, this.clamp();
}
function $ee(t3, e) {
  if (t3 != 0) {
    for (; this.t <= e; ) this.data[this.t++] = 0;
    for (this.data[e] += t3; this.data[e] >= this.DV; ) this.data[e] -= this.DV, ++e >= this.t && (this.data[this.t++] = 0), ++this.data[e];
  }
}
function Cd() {
}
function yT(t3) {
  return t3;
}
function Tee(t3, e, n) {
  t3.multiplyTo(e, n);
}
function Dee(t3, e) {
  t3.squareTo(e);
}
Cd.prototype.convert = yT;
Cd.prototype.revert = yT;
Cd.prototype.mulTo = Tee;
Cd.prototype.sqrTo = Dee;
function Ree(t3) {
  return this.exp(t3, new Cd());
}
function Fee(t3, e, n) {
  var r = Math.min(this.t + t3.t, e);
  for (n.s = 0, n.t = r; r > 0; ) n.data[--r] = 0;
  var s;
  for (s = n.t - this.t; r < s; ++r) n.data[r + this.t] = this.am(0, t3.data[r], n, r, 0, this.t);
  for (s = Math.min(t3.t, e); r < s; ++r) this.am(0, t3.data[r], n, r, 0, e - r);
  n.clamp();
}
function Pee(t3, e, n) {
  --e;
  var r = n.t = this.t + t3.t - e;
  for (n.s = 0; --r >= 0; ) n.data[r] = 0;
  for (r = Math.max(e - this.t, 0); r < t3.t; ++r) n.data[this.t + r - e] = this.am(e - r, t3.data[r], n, 0, 0, this.t + r - e);
  n.clamp(), n.drShiftTo(1, n);
}
function fc(t3) {
  this.r2 = sn(), this.q3 = sn(), Ct.ONE.dlShiftTo(2 * t3.t, this.r2), this.mu = this.r2.divide(t3), this.m = t3;
}
function Nee(t3) {
  if (t3.s < 0 || t3.t > 2 * this.m.t) return t3.mod(this.m);
  if (t3.compareTo(this.m) < 0) return t3;
  var e = sn();
  return t3.copyTo(e), this.reduce(e), e;
}
function Uee(t3) {
  return t3;
}
function Lee(t3) {
  for (t3.drShiftTo(this.m.t - 1, this.r2), t3.t > this.m.t + 1 && (t3.t = this.m.t + 1, t3.clamp()), this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3), this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); t3.compareTo(this.r2) < 0; ) t3.dAddOffset(1, this.m.t + 1);
  for (t3.subTo(this.r2, t3); t3.compareTo(this.m) >= 0; ) t3.subTo(this.m, t3);
}
function Oee(t3, e) {
  t3.squareTo(e), this.reduce(e);
}
function Qee(t3, e, n) {
  t3.multiplyTo(e, n), this.reduce(n);
}
fc.prototype.convert = Nee;
fc.prototype.revert = Uee;
fc.prototype.reduce = Lee;
fc.prototype.mulTo = Qee;
fc.prototype.sqrTo = Oee;
function Kee(t3, e) {
  var n = t3.bitLength(), r, s = Yf(1), i;
  if (n <= 0) return s;
  n < 18 ? r = 1 : n < 48 ? r = 3 : n < 144 ? r = 4 : n < 768 ? r = 5 : r = 6, n < 8 ? i = new w0(e) : e.isEven() ? i = new fc(e) : i = new x0(e);
  var a = new Array(), o = 3, f = r - 1, c = (1 << r) - 1;
  if (a[1] = i.convert(this), r > 1) {
    var l = sn();
    for (i.sqrTo(a[1], l); o <= c; ) a[o] = sn(), i.mulTo(l, a[o - 2], a[o]), o += 2;
  }
  var h = t3.t - 1, m, v = true, b = sn(), A;
  for (n = um(t3.data[h]) - 1; h >= 0; ) {
    for (n >= f ? m = t3.data[h] >> n - f & c : (m = (t3.data[h] & (1 << n + 1) - 1) << f - n, h > 0 && (m |= t3.data[h - 1] >> this.DB + n - f)), o = r; !(m & 1); ) m >>= 1, --o;
    if ((n -= o) < 0 && (n += this.DB, --h), v) a[m].copyTo(s), v = false;
    else {
      for (; o > 1; ) i.sqrTo(s, b), i.sqrTo(b, s), o -= 2;
      o > 0 ? i.sqrTo(s, b) : (A = s, s = b, b = A), i.mulTo(b, a[m], s);
    }
    for (; h >= 0 && !(t3.data[h] & 1 << n); ) i.sqrTo(s, b), A = s, s = b, b = A, --n < 0 && (n = this.DB - 1, --h);
  }
  return i.revert(s);
}
function Hee(t3) {
  var e = this.s < 0 ? this.negate() : this.clone(), n = t3.s < 0 ? t3.negate() : t3.clone();
  if (e.compareTo(n) < 0) {
    var r = e;
    e = n, n = r;
  }
  var s = e.getLowestSetBit(), i = n.getLowestSetBit();
  if (i < 0) return e;
  for (s < i && (i = s), i > 0 && (e.rShiftTo(i, e), n.rShiftTo(i, n)); e.signum() > 0; ) (s = e.getLowestSetBit()) > 0 && e.rShiftTo(s, e), (s = n.getLowestSetBit()) > 0 && n.rShiftTo(s, n), e.compareTo(n) >= 0 ? (e.subTo(n, e), e.rShiftTo(1, e)) : (n.subTo(e, n), n.rShiftTo(1, n));
  return i > 0 && n.lShiftTo(i, n), n;
}
function qee(t3) {
  if (t3 <= 0) return 0;
  var e = this.DV % t3, n = this.s < 0 ? t3 - 1 : 0;
  if (this.t > 0) if (e == 0) n = this.data[0] % t3;
  else for (var r = this.t - 1; r >= 0; --r) n = (e * n + this.data[r]) % t3;
  return n;
}
function zee(t3) {
  var e = t3.isEven();
  if (this.isEven() && e || t3.signum() == 0) return Ct.ZERO;
  for (var n = t3.clone(), r = this.clone(), s = Yf(1), i = Yf(0), a = Yf(0), o = Yf(1); n.signum() != 0; ) {
    for (; n.isEven(); ) n.rShiftTo(1, n), e ? ((!s.isEven() || !i.isEven()) && (s.addTo(this, s), i.subTo(t3, i)), s.rShiftTo(1, s)) : i.isEven() || i.subTo(t3, i), i.rShiftTo(1, i);
    for (; r.isEven(); ) r.rShiftTo(1, r), e ? ((!a.isEven() || !o.isEven()) && (a.addTo(this, a), o.subTo(t3, o)), a.rShiftTo(1, a)) : o.isEven() || o.subTo(t3, o), o.rShiftTo(1, o);
    n.compareTo(r) >= 0 ? (n.subTo(r, n), e && s.subTo(a, s), i.subTo(o, i)) : (r.subTo(n, r), e && a.subTo(s, a), o.subTo(i, o));
  }
  if (r.compareTo(Ct.ONE) != 0) return Ct.ZERO;
  if (o.compareTo(t3) >= 0) return o.subtract(t3);
  if (o.signum() < 0) o.addTo(t3, o);
  else return o;
  return o.signum() < 0 ? o.add(t3) : o;
}
var xa = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509], Gee = (1 << 26) / xa[xa.length - 1];
function Vee(t3) {
  var e, n = this.abs();
  if (n.t == 1 && n.data[0] <= xa[xa.length - 1]) {
    for (e = 0; e < xa.length; ++e) if (n.data[0] == xa[e]) return true;
    return false;
  }
  if (n.isEven()) return false;
  for (e = 1; e < xa.length; ) {
    for (var r = xa[e], s = e + 1; s < xa.length && r < Gee; ) r *= xa[s++];
    for (r = n.modInt(r); e < s; ) if (r % xa[e++] == 0) return false;
  }
  return n.millerRabin(t3);
}
function Yee(t3) {
  var e = this.subtract(Ct.ONE), n = e.getLowestSetBit();
  if (n <= 0) return false;
  for (var r = e.shiftRight(n), s = Wee(), i, a = 0; a < t3; ++a) {
    do
      i = new Ct(this.bitLength(), s);
    while (i.compareTo(Ct.ONE) <= 0 || i.compareTo(e) >= 0);
    var o = i.modPow(r, this);
    if (o.compareTo(Ct.ONE) != 0 && o.compareTo(e) != 0) {
      for (var f = 1; f++ < n && o.compareTo(e) != 0; ) if (o = o.modPowInt(2, this), o.compareTo(Ct.ONE) == 0) return false;
      if (o.compareTo(e) != 0) return false;
    }
  }
  return true;
}
function Wee() {
  return { nextBytes: function(t3) {
    for (var e = 0; e < t3.length; ++e) t3[e] = Math.floor(Math.random() * 256);
  } };
}
Ct.prototype.chunkSize = JX;
Ct.prototype.toRadix = jX;
Ct.prototype.fromRadix = XX;
Ct.prototype.fromNumber = eee;
Ct.prototype.bitwiseTo = see;
Ct.prototype.changeBit = bee;
Ct.prototype.addTo = _ee;
Ct.prototype.dMultiply = Mee;
Ct.prototype.dAddOffset = $ee;
Ct.prototype.multiplyLowerTo = Fee;
Ct.prototype.multiplyUpperTo = Pee;
Ct.prototype.modInt = qee;
Ct.prototype.millerRabin = Yee;
Ct.prototype.clone = GX;
Ct.prototype.intValue = VX;
Ct.prototype.byteValue = YX;
Ct.prototype.shortValue = WX;
Ct.prototype.signum = ZX;
Ct.prototype.toByteArray = tee;
Ct.prototype.equals = ree;
Ct.prototype.min = nee;
Ct.prototype.max = iee;
Ct.prototype.and = oee;
Ct.prototype.or = fee;
Ct.prototype.xor = lee;
Ct.prototype.andNot = uee;
Ct.prototype.not = cee;
Ct.prototype.shiftLeft = hee;
Ct.prototype.shiftRight = dee;
Ct.prototype.getLowestSetBit = gee;
Ct.prototype.bitCount = vee;
Ct.prototype.testBit = yee;
Ct.prototype.setBit = Aee;
Ct.prototype.clearBit = wee;
Ct.prototype.flipBit = xee;
Ct.prototype.add = Eee;
Ct.prototype.subtract = Bee;
Ct.prototype.multiply = Cee;
Ct.prototype.divide = kee;
Ct.prototype.remainder = Iee;
Ct.prototype.divideAndRemainder = See;
Ct.prototype.modPow = Kee;
Ct.prototype.modInverse = zee;
Ct.prototype.pow = Ree;
Ct.prototype.gcd = Hee;
Ct.prototype.isProbablePrime = Vee;
var ao = Ur, bT = ao.sha1 = ao.sha1 || {};
ao.md.sha1 = ao.md.algorithms.sha1 = bT;
bT.create = function() {
  AT || Jee();
  var t3 = null, e = ao.util.createBuffer(), n = new Array(80), r = { algorithm: "sha1", blockLength: 64, digestLength: 20, messageLength: 0, fullMessageLength: null, messageLengthSize: 8 };
  return r.start = function() {
    r.messageLength = 0, r.fullMessageLength = r.messageLength64 = [];
    for (var s = r.messageLengthSize / 4, i = 0; i < s; ++i) r.fullMessageLength.push(0);
    return e = ao.util.createBuffer(), t3 = { h0: 1732584193, h1: 4023233417, h2: 2562383102, h3: 271733878, h4: 3285377520 }, r;
  }, r.start(), r.update = function(s, i) {
    i === "utf8" && (s = ao.util.encodeUtf8(s));
    var a = s.length;
    r.messageLength += a, a = [a / 4294967296 >>> 0, a >>> 0];
    for (var o = r.fullMessageLength.length - 1; o >= 0; --o) r.fullMessageLength[o] += a[1], a[1] = a[0] + (r.fullMessageLength[o] / 4294967296 >>> 0), r.fullMessageLength[o] = r.fullMessageLength[o] >>> 0, a[0] = a[1] / 4294967296 >>> 0;
    return e.putBytes(s), Ix(t3, n, e), (e.read > 2048 || e.length() === 0) && e.compact(), r;
  }, r.digest = function() {
    var s = ao.util.createBuffer();
    s.putBytes(e.bytes());
    var i = r.fullMessageLength[r.fullMessageLength.length - 1] + r.messageLengthSize, a = i & r.blockLength - 1;
    s.putBytes(sb.substr(0, r.blockLength - a));
    for (var o, f, c = r.fullMessageLength[0] * 8, l = 0; l < r.fullMessageLength.length - 1; ++l) o = r.fullMessageLength[l + 1] * 8, f = o / 4294967296 >>> 0, c += f, s.putInt32(c >>> 0), c = o >>> 0;
    s.putInt32(c);
    var h = { h0: t3.h0, h1: t3.h1, h2: t3.h2, h3: t3.h3, h4: t3.h4 };
    Ix(h, n, s);
    var m = ao.util.createBuffer();
    return m.putInt32(h.h0), m.putInt32(h.h1), m.putInt32(h.h2), m.putInt32(h.h3), m.putInt32(h.h4), m;
  }, r;
};
var sb = null, AT = false;
function Jee() {
  sb = "\x80", sb += ao.util.fillString("\0", 64), AT = true;
}
function Ix(t3, e, n) {
  for (var r, s, i, a, o, f, c, l, h = n.length(); h >= 64; ) {
    for (s = t3.h0, i = t3.h1, a = t3.h2, o = t3.h3, f = t3.h4, l = 0; l < 16; ++l) r = n.getInt32(), e[l] = r, c = o ^ i & (a ^ o), r = (s << 5 | s >>> 27) + c + f + 1518500249 + r, f = o, o = a, a = (i << 30 | i >>> 2) >>> 0, i = s, s = r;
    for (; l < 20; ++l) r = e[l - 3] ^ e[l - 8] ^ e[l - 14] ^ e[l - 16], r = r << 1 | r >>> 31, e[l] = r, c = o ^ i & (a ^ o), r = (s << 5 | s >>> 27) + c + f + 1518500249 + r, f = o, o = a, a = (i << 30 | i >>> 2) >>> 0, i = s, s = r;
    for (; l < 32; ++l) r = e[l - 3] ^ e[l - 8] ^ e[l - 14] ^ e[l - 16], r = r << 1 | r >>> 31, e[l] = r, c = i ^ a ^ o, r = (s << 5 | s >>> 27) + c + f + 1859775393 + r, f = o, o = a, a = (i << 30 | i >>> 2) >>> 0, i = s, s = r;
    for (; l < 40; ++l) r = e[l - 6] ^ e[l - 16] ^ e[l - 28] ^ e[l - 32], r = r << 2 | r >>> 30, e[l] = r, c = i ^ a ^ o, r = (s << 5 | s >>> 27) + c + f + 1859775393 + r, f = o, o = a, a = (i << 30 | i >>> 2) >>> 0, i = s, s = r;
    for (; l < 60; ++l) r = e[l - 6] ^ e[l - 16] ^ e[l - 28] ^ e[l - 32], r = r << 2 | r >>> 30, e[l] = r, c = i & a | o & (i ^ a), r = (s << 5 | s >>> 27) + c + f + 2400959708 + r, f = o, o = a, a = (i << 30 | i >>> 2) >>> 0, i = s, s = r;
    for (; l < 80; ++l) r = e[l - 6] ^ e[l - 16] ^ e[l - 28] ^ e[l - 32], r = r << 2 | r >>> 30, e[l] = r, c = i ^ a ^ o, r = (s << 5 | s >>> 27) + c + f + 3395469782 + r, f = o, o = a, a = (i << 30 | i >>> 2) >>> 0, i = s, s = r;
    t3.h0 = t3.h0 + s | 0, t3.h1 = t3.h1 + i | 0, t3.h2 = t3.h2 + a | 0, t3.h3 = t3.h3 + o | 0, t3.h4 = t3.h4 + f | 0, h -= 64;
  }
}
var co = Ur, wT = co.pkcs1 = co.pkcs1 || {};
wT.encode_rsa_oaep = function(t3, e, n) {
  var r, s, i, a;
  typeof n == "string" ? (r = n, s = arguments[3] || void 0, i = arguments[4] || void 0) : n && (r = n.label || void 0, s = n.seed || void 0, i = n.md || void 0, n.mgf1 && n.mgf1.md && (a = n.mgf1.md)), i ? i.start() : i = co.md.sha1.create(), a || (a = i);
  var o = Math.ceil(t3.n.bitLength() / 8), f = o - 2 * i.digestLength - 2;
  if (e.length > f) {
    var c = new Error("RSAES-OAEP input message length is too long.");
    throw c.length = e.length, c.maxLength = f, c;
  }
  r || (r = ""), i.update(r, "raw");
  for (var l = i.digest(), h = "", m = f - e.length, v = 0; v < m; v++) h += "\0";
  var b = l.getBytes() + h + "" + e;
  if (!s) s = co.random.getBytes(i.digestLength);
  else if (s.length !== i.digestLength) {
    var c = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
    throw c.seedLength = s.length, c.digestLength = i.digestLength, c;
  }
  var A = $1(s, o - i.digestLength - 1, a), _ = co.util.xorBytes(b, A, b.length), C = $1(_, i.digestLength, a), I = co.util.xorBytes(s, C, s.length);
  return "\0" + I + _;
};
wT.decode_rsa_oaep = function(t3, e, n) {
  var r, s, i;
  typeof n == "string" ? (r = n, s = arguments[3] || void 0) : n && (r = n.label || void 0, s = n.md || void 0, n.mgf1 && n.mgf1.md && (i = n.mgf1.md));
  var a = Math.ceil(t3.n.bitLength() / 8);
  if (e.length !== a) {
    var _ = new Error("RSAES-OAEP encoded message length is invalid.");
    throw _.length = e.length, _.expectedLength = a, _;
  }
  if (s === void 0 ? s = co.md.sha1.create() : s.start(), i || (i = s), a < 2 * s.digestLength + 2) throw new Error("RSAES-OAEP key is too short for the hash function.");
  r || (r = ""), s.update(r, "raw");
  for (var o = s.digest().getBytes(), f = e.charAt(0), c = e.substring(1, s.digestLength + 1), l = e.substring(1 + s.digestLength), h = $1(l, s.digestLength, i), m = co.util.xorBytes(c, h, c.length), v = $1(m, a - s.digestLength - 1, i), b = co.util.xorBytes(l, v, l.length), A = b.substring(0, s.digestLength), _ = f !== "\0", C = 0; C < s.digestLength; ++C) _ |= o.charAt(C) !== A.charAt(C);
  for (var I = 1, S = s.digestLength, $ = s.digestLength; $ < b.length; $++) {
    var F = b.charCodeAt($), U = F & 1 ^ 1, Q = I ? 65534 : 0;
    _ |= F & Q, I = I & U, S += I;
  }
  if (_ || b.charCodeAt(S) !== 1) throw new Error("Invalid RSAES-OAEP padding.");
  return b.substring(S + 1);
};
function $1(t3, e, n) {
  n || (n = co.md.sha1.create());
  for (var r = "", s = Math.ceil(e / n.digestLength), i = 0; i < s; ++i) {
    var a = String.fromCharCode(i >> 24 & 255, i >> 16 & 255, i >> 8 & 255, i & 255);
    n.start(), n.update(t3 + a), r += n.digest().getBytes();
  }
  return r.substring(0, e);
}
var Cf = Ur;
(function() {
  if (Cf.prime) {
    Cf.prime;
    return;
  }
  var t3 = Cf.prime = Cf.prime || {}, e = Cf.jsbn.BigInteger, n = [6, 4, 2, 4, 2, 4, 6, 2], r = new e(null);
  r.fromInt(30);
  var s = function(h, m) {
    return h | m;
  };
  t3.generateProbablePrime = function(h, m, v) {
    typeof m == "function" && (v = m, m = {}), m = m || {};
    var b = m.algorithm || "PRIMEINC";
    typeof b == "string" && (b = { name: b }), b.options = b.options || {};
    var A = m.prng || Cf.random, _ = { nextBytes: function(C) {
      for (var I = A.getBytesSync(C.length), S = 0; S < C.length; ++S) C[S] = I.charCodeAt(S);
    } };
    if (b.name === "PRIMEINC") return i(h, _, b.options, v);
    throw new Error("Invalid prime generation algorithm: " + b.name);
  };
  function i(h, m, v, b) {
    return "workers" in v ? f(h, m, v, b) : a(h, m, v, b);
  }
  function a(h, m, v, b) {
    var A = c(h, m), _ = 0, C = l(A.bitLength());
    "millerRabinTests" in v && (C = v.millerRabinTests);
    var I = 10;
    "maxBlockTime" in v && (I = v.maxBlockTime), o(A, h, m, _, C, I, b);
  }
  function o(h, m, v, b, A, _, C) {
    var I = +/* @__PURE__ */ new Date();
    do {
      if (h.bitLength() > m && (h = c(m, v)), h.isProbablePrime(A)) return C(null, h);
      h.dAddOffset(n[b++ % 8], 0);
    } while (_ < 0 || +/* @__PURE__ */ new Date() - I < _);
    Cf.util.setImmediate(function() {
      o(h, m, v, b, A, _, C);
    });
  }
  function f(h, m, v, b) {
    if (typeof Worker > "u") return a(h, m, v, b);
    var A = c(h, m), _ = v.workers, C = v.workLoad || 100, I = C * 30 / 8, S = v.workerScript || "forge/prime.worker.js";
    if (_ === -1) return Cf.util.estimateCores(function(F, U) {
      F && (U = 2), _ = U - 1, $();
    });
    $();
    function $() {
      _ = Math.max(1, _);
      for (var F = [], U = 0; U < _; ++U) F[U] = new Worker(S);
      for (var U = 0; U < _; ++U) F[U].addEventListener("message", P);
      var Q = false;
      function P(N) {
        if (!Q) {
          var L = N.data;
          if (L.found) {
            for (var B = 0; B < F.length; ++B) F[B].terminate();
            return Q = true, b(null, new e(L.prime, 16));
          }
          A.bitLength() > h && (A = c(h, m));
          var u = A.toString(16);
          N.target.postMessage({ hex: u, workLoad: C }), A.dAddOffset(I, 0);
        }
      }
    }
  }
  function c(h, m) {
    var v = new e(h, m), b = h - 1;
    return v.testBit(b) || v.bitwiseTo(e.ONE.shiftLeft(b), s, v), v.dAddOffset(31 - v.mod(r).byteValue(), 0), v;
  }
  function l(h) {
    return h <= 100 ? 27 : h <= 150 ? 18 : h <= 200 ? 15 : h <= 250 ? 12 : h <= 300 ? 9 : h <= 350 ? 8 : h <= 400 ? 7 : h <= 500 ? 6 : h <= 600 ? 5 : h <= 800 ? 4 : h <= 1250 ? 3 : 2;
  }
})();
var gr = Ur;
if (typeof nn > "u") var nn = gr.jsbn.BigInteger;
var ab = gr.util.isNodejs ? vl() : null, it = gr.asn1, na = gr.util;
gr.pki = gr.pki || {};
gr.pki.rsa = gr.rsa = gr.rsa || {};
var Br = gr.pki, Zee = [6, 4, 2, 4, 2, 4, 6, 2], jee = { name: "PrivateKeyInfo", tagClass: it.Class.UNIVERSAL, type: it.Type.SEQUENCE, constructed: true, value: [{ name: "PrivateKeyInfo.version", tagClass: it.Class.UNIVERSAL, type: it.Type.INTEGER, constructed: false, capture: "privateKeyVersion" }, { name: "PrivateKeyInfo.privateKeyAlgorithm", tagClass: it.Class.UNIVERSAL, type: it.Type.SEQUENCE, constructed: true, value: [{ name: "AlgorithmIdentifier.algorithm", tagClass: it.Class.UNIVERSAL, type: it.Type.OID, constructed: false, capture: "privateKeyOid" }] }, { name: "PrivateKeyInfo", tagClass: it.Class.UNIVERSAL, type: it.Type.OCTETSTRING, constructed: false, capture: "privateKey" }] }, Xee = { name: "RSAPrivateKey", tagClass: it.Class.UNIVERSAL, type: it.Type.SEQUENCE, constructed: true, value: [{ name: "RSAPrivateKey.version", tagClass: it.Class.UNIVERSAL, type: it.Type.INTEGER, constructed: false, capture: "privateKeyVersion" }, { name: "RSAPrivateKey.modulus", tagClass: it.Class.UNIVERSAL, type: it.Type.INTEGER, constructed: false, capture: "privateKeyModulus" }, { name: "RSAPrivateKey.publicExponent", tagClass: it.Class.UNIVERSAL, type: it.Type.INTEGER, constructed: false, capture: "privateKeyPublicExponent" }, { name: "RSAPrivateKey.privateExponent", tagClass: it.Class.UNIVERSAL, type: it.Type.INTEGER, constructed: false, capture: "privateKeyPrivateExponent" }, { name: "RSAPrivateKey.prime1", tagClass: it.Class.UNIVERSAL, type: it.Type.INTEGER, constructed: false, capture: "privateKeyPrime1" }, { name: "RSAPrivateKey.prime2", tagClass: it.Class.UNIVERSAL, type: it.Type.INTEGER, constructed: false, capture: "privateKeyPrime2" }, { name: "RSAPrivateKey.exponent1", tagClass: it.Class.UNIVERSAL, type: it.Type.INTEGER, constructed: false, capture: "privateKeyExponent1" }, { name: "RSAPrivateKey.exponent2", tagClass: it.Class.UNIVERSAL, type: it.Type.INTEGER, constructed: false, capture: "privateKeyExponent2" }, { name: "RSAPrivateKey.coefficient", tagClass: it.Class.UNIVERSAL, type: it.Type.INTEGER, constructed: false, capture: "privateKeyCoefficient" }] }, ete = { name: "RSAPublicKey", tagClass: it.Class.UNIVERSAL, type: it.Type.SEQUENCE, constructed: true, value: [{ name: "RSAPublicKey.modulus", tagClass: it.Class.UNIVERSAL, type: it.Type.INTEGER, constructed: false, capture: "publicKeyModulus" }, { name: "RSAPublicKey.exponent", tagClass: it.Class.UNIVERSAL, type: it.Type.INTEGER, constructed: false, capture: "publicKeyExponent" }] }, tte = gr.pki.rsa.publicKeyValidator = { name: "SubjectPublicKeyInfo", tagClass: it.Class.UNIVERSAL, type: it.Type.SEQUENCE, constructed: true, captureAsn1: "subjectPublicKeyInfo", value: [{ name: "SubjectPublicKeyInfo.AlgorithmIdentifier", tagClass: it.Class.UNIVERSAL, type: it.Type.SEQUENCE, constructed: true, value: [{ name: "AlgorithmIdentifier.algorithm", tagClass: it.Class.UNIVERSAL, type: it.Type.OID, constructed: false, capture: "publicKeyOid" }] }, { name: "SubjectPublicKeyInfo.subjectPublicKey", tagClass: it.Class.UNIVERSAL, type: it.Type.BITSTRING, constructed: false, value: [{ name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey", tagClass: it.Class.UNIVERSAL, type: it.Type.SEQUENCE, constructed: true, optional: true, captureAsn1: "rsaPublicKey" }] }] }, rte = { name: "DigestInfo", tagClass: it.Class.UNIVERSAL, type: it.Type.SEQUENCE, constructed: true, value: [{ name: "DigestInfo.DigestAlgorithm", tagClass: it.Class.UNIVERSAL, type: it.Type.SEQUENCE, constructed: true, value: [{ name: "DigestInfo.DigestAlgorithm.algorithmIdentifier", tagClass: it.Class.UNIVERSAL, type: it.Type.OID, constructed: false, capture: "algorithmIdentifier" }, { name: "DigestInfo.DigestAlgorithm.parameters", tagClass: it.Class.UNIVERSAL, type: it.Type.NULL, capture: "parameters", optional: true, constructed: false }] }, { name: "DigestInfo.digest", tagClass: it.Class.UNIVERSAL, type: it.Type.OCTETSTRING, constructed: false, capture: "digest" }] }, nte = function(t3) {
  var e;
  if (t3.algorithm in Br.oids) e = Br.oids[t3.algorithm];
  else {
    var n = new Error("Unknown message digest algorithm.");
    throw n.algorithm = t3.algorithm, n;
  }
  var r = it.oidToDer(e).getBytes(), s = it.create(it.Class.UNIVERSAL, it.Type.SEQUENCE, true, []), i = it.create(it.Class.UNIVERSAL, it.Type.SEQUENCE, true, []);
  i.value.push(it.create(it.Class.UNIVERSAL, it.Type.OID, false, r)), i.value.push(it.create(it.Class.UNIVERSAL, it.Type.NULL, false, ""));
  var a = it.create(it.Class.UNIVERSAL, it.Type.OCTETSTRING, false, t3.digest().getBytes());
  return s.value.push(i), s.value.push(a), it.toDer(s).getBytes();
}, xT = function(t3, e, n) {
  if (n) return t3.modPow(e.e, e.n);
  if (!e.p || !e.q) return t3.modPow(e.d, e.n);
  e.dP || (e.dP = e.d.mod(e.p.subtract(nn.ONE))), e.dQ || (e.dQ = e.d.mod(e.q.subtract(nn.ONE))), e.qInv || (e.qInv = e.q.modInverse(e.p));
  var r;
  do
    r = new nn(gr.util.bytesToHex(gr.random.getBytes(e.n.bitLength() / 8)), 16);
  while (r.compareTo(e.n) >= 0 || !r.gcd(e.n).equals(nn.ONE));
  t3 = t3.multiply(r.modPow(e.e, e.n)).mod(e.n);
  for (var s = t3.mod(e.p).modPow(e.dP, e.p), i = t3.mod(e.q).modPow(e.dQ, e.q); s.compareTo(i) < 0; ) s = s.add(e.p);
  var a = s.subtract(i).multiply(e.qInv).mod(e.p).multiply(e.q).add(i);
  return a = a.multiply(r.modInverse(e.n)).mod(e.n), a;
};
Br.rsa.encrypt = function(t3, e, n) {
  var r = n, s, i = Math.ceil(e.n.bitLength() / 8);
  n !== false && n !== true ? (r = n === 2, s = _T(t3, e, n)) : (s = gr.util.createBuffer(), s.putBytes(t3));
  for (var a = new nn(s.toHex(), 16), o = xT(a, e, r), f = o.toString(16), c = gr.util.createBuffer(), l = i - Math.ceil(f.length / 2); l > 0; ) c.putByte(0), --l;
  return c.putBytes(gr.util.hexToBytes(f)), c.getBytes();
};
Br.rsa.decrypt = function(t3, e, n, r) {
  var s = Math.ceil(e.n.bitLength() / 8);
  if (t3.length !== s) {
    var i = new Error("Encrypted message length is invalid.");
    throw i.length = t3.length, i.expected = s, i;
  }
  var a = new nn(gr.util.createBuffer(t3).toHex(), 16);
  if (a.compareTo(e.n) >= 0) throw new Error("Encrypted message is invalid.");
  for (var o = xT(a, e, n), f = o.toString(16), c = gr.util.createBuffer(), l = s - Math.ceil(f.length / 2); l > 0; ) c.putByte(0), --l;
  return c.putBytes(gr.util.hexToBytes(f)), r !== false ? T1(c.getBytes(), e, n) : c.getBytes();
};
Br.rsa.createKeyPairGenerationState = function(t3, e, n) {
  typeof t3 == "string" && (t3 = parseInt(t3, 10)), t3 = t3 || 2048, n = n || {};
  var r = n.prng || gr.random, s = { nextBytes: function(o) {
    for (var f = r.getBytesSync(o.length), c = 0; c < o.length; ++c) o[c] = f.charCodeAt(c);
  } }, i = n.algorithm || "PRIMEINC", a;
  if (i === "PRIMEINC") a = { algorithm: i, state: 0, bits: t3, rng: s, eInt: e || 65537, e: new nn(null), p: null, q: null, qBits: t3 >> 1, pBits: t3 - (t3 >> 1), pqState: 0, num: null, keys: null }, a.e.fromInt(a.eInt);
  else throw new Error("Invalid key generation algorithm: " + i);
  return a;
};
Br.rsa.stepKeyPairGenerationState = function(t3, e) {
  "algorithm" in t3 || (t3.algorithm = "PRIMEINC");
  var n = new nn(null);
  n.fromInt(30);
  for (var r = 0, s = function(h, m) {
    return h | m;
  }, i = +/* @__PURE__ */ new Date(), a, o = 0; t3.keys === null && (e <= 0 || o < e); ) {
    if (t3.state === 0) {
      var f = t3.p === null ? t3.pBits : t3.qBits, c = f - 1;
      t3.pqState === 0 ? (t3.num = new nn(f, t3.rng), t3.num.testBit(c) || t3.num.bitwiseTo(nn.ONE.shiftLeft(c), s, t3.num), t3.num.dAddOffset(31 - t3.num.mod(n).byteValue(), 0), r = 0, ++t3.pqState) : t3.pqState === 1 ? t3.num.bitLength() > f ? t3.pqState = 0 : t3.num.isProbablePrime(ste(t3.num.bitLength())) ? ++t3.pqState : t3.num.dAddOffset(Zee[r++ % 8], 0) : t3.pqState === 2 ? t3.pqState = t3.num.subtract(nn.ONE).gcd(t3.e).compareTo(nn.ONE) === 0 ? 3 : 0 : t3.pqState === 3 && (t3.pqState = 0, t3.p === null ? t3.p = t3.num : t3.q = t3.num, t3.p !== null && t3.q !== null && ++t3.state, t3.num = null);
    } else if (t3.state === 1) t3.p.compareTo(t3.q) < 0 && (t3.num = t3.p, t3.p = t3.q, t3.q = t3.num), ++t3.state;
    else if (t3.state === 2) t3.p1 = t3.p.subtract(nn.ONE), t3.q1 = t3.q.subtract(nn.ONE), t3.phi = t3.p1.multiply(t3.q1), ++t3.state;
    else if (t3.state === 3) t3.phi.gcd(t3.e).compareTo(nn.ONE) === 0 ? ++t3.state : (t3.p = null, t3.q = null, t3.state = 0);
    else if (t3.state === 4) t3.n = t3.p.multiply(t3.q), t3.n.bitLength() === t3.bits ? ++t3.state : (t3.q = null, t3.state = 0);
    else if (t3.state === 5) {
      var l = t3.e.modInverse(t3.phi);
      t3.keys = { privateKey: Br.rsa.setPrivateKey(t3.n, t3.e, l, t3.p, t3.q, l.mod(t3.p1), l.mod(t3.q1), t3.q.modInverse(t3.p)), publicKey: Br.rsa.setPublicKey(t3.n, t3.e) };
    }
    a = +/* @__PURE__ */ new Date(), o += a - i, i = a;
  }
  return t3.keys !== null;
};
Br.rsa.generateKeyPair = function(t3, e, n, r) {
  if (arguments.length === 1 ? typeof t3 == "object" ? (n = t3, t3 = void 0) : typeof t3 == "function" && (r = t3, t3 = void 0) : arguments.length === 2 ? typeof t3 == "number" ? typeof e == "function" ? (r = e, e = void 0) : typeof e != "number" && (n = e, e = void 0) : (n = t3, r = e, t3 = void 0, e = void 0) : arguments.length === 3 && (typeof e == "number" ? typeof n == "function" && (r = n, n = void 0) : (r = n, n = e, e = void 0)), n = n || {}, t3 === void 0 && (t3 = n.bits || 2048), e === void 0 && (e = n.e || 65537), !gr.options.usePureJavaScript && !n.prng && t3 >= 256 && t3 <= 16384 && (e === 65537 || e === 3)) {
    if (r) {
      if (Sx("generateKeyPair")) return ab.generateKeyPair("rsa", { modulusLength: t3, publicExponent: e, publicKeyEncoding: { type: "spki", format: "pem" }, privateKeyEncoding: { type: "pkcs8", format: "pem" } }, function(o, f, c) {
        if (o) return r(o);
        r(null, { privateKey: Br.privateKeyFromPem(c), publicKey: Br.publicKeyFromPem(f) });
      });
      if (Mx("generateKey") && Mx("exportKey")) return na.globalScope.crypto.subtle.generateKey({ name: "RSASSA-PKCS1-v1_5", modulusLength: t3, publicExponent: Tx(e), hash: { name: "SHA-256" } }, true, ["sign", "verify"]).then(function(o) {
        return na.globalScope.crypto.subtle.exportKey("pkcs8", o.privateKey);
      }).then(void 0, function(o) {
        r(o);
      }).then(function(o) {
        if (o) {
          var f = Br.privateKeyFromAsn1(it.fromDer(gr.util.createBuffer(o)));
          r(null, { privateKey: f, publicKey: Br.setRsaPublicKey(f.n, f.e) });
        }
      });
      if ($x("generateKey") && $x("exportKey")) {
        var s = na.globalScope.msCrypto.subtle.generateKey({ name: "RSASSA-PKCS1-v1_5", modulusLength: t3, publicExponent: Tx(e), hash: { name: "SHA-256" } }, true, ["sign", "verify"]);
        s.oncomplete = function(o) {
          var f = o.target.result, c = na.globalScope.msCrypto.subtle.exportKey("pkcs8", f.privateKey);
          c.oncomplete = function(l) {
            var h = l.target.result, m = Br.privateKeyFromAsn1(it.fromDer(gr.util.createBuffer(h)));
            r(null, { privateKey: m, publicKey: Br.setRsaPublicKey(m.n, m.e) });
          }, c.onerror = function(l) {
            r(l);
          };
        }, s.onerror = function(o) {
          r(o);
        };
        return;
      }
    } else if (Sx("generateKeyPairSync")) {
      var i = ab.generateKeyPairSync("rsa", { modulusLength: t3, publicExponent: e, publicKeyEncoding: { type: "spki", format: "pem" }, privateKeyEncoding: { type: "pkcs8", format: "pem" } });
      return { privateKey: Br.privateKeyFromPem(i.privateKey), publicKey: Br.publicKeyFromPem(i.publicKey) };
    }
  }
  var a = Br.rsa.createKeyPairGenerationState(t3, e, n);
  if (!r) return Br.rsa.stepKeyPairGenerationState(a, 0), a.keys;
  ite(a, n, r);
};
Br.setRsaPublicKey = Br.rsa.setPublicKey = function(t3, e) {
  var n = { n: t3, e };
  return n.encrypt = function(r, s, i) {
    if (typeof s == "string" ? s = s.toUpperCase() : s === void 0 && (s = "RSAES-PKCS1-V1_5"), s === "RSAES-PKCS1-V1_5") s = { encode: function(o, f, c) {
      return _T(o, f, 2).getBytes();
    } };
    else if (s === "RSA-OAEP" || s === "RSAES-OAEP") s = { encode: function(o, f) {
      return gr.pkcs1.encode_rsa_oaep(f, o, i);
    } };
    else if (["RAW", "NONE", "NULL", null].indexOf(s) !== -1) s = { encode: function(o) {
      return o;
    } };
    else if (typeof s == "string") throw new Error('Unsupported encryption scheme: "' + s + '".');
    var a = s.encode(r, n, true);
    return Br.rsa.encrypt(a, n, true);
  }, n.verify = function(r, s, i, a) {
    typeof i == "string" ? i = i.toUpperCase() : i === void 0 && (i = "RSASSA-PKCS1-V1_5"), a === void 0 && (a = { _parseAllDigestBytes: true }), "_parseAllDigestBytes" in a || (a._parseAllDigestBytes = true), i === "RSASSA-PKCS1-V1_5" ? i = { verify: function(f, c) {
      c = T1(c, n, true);
      var l = it.fromDer(c, { parseAllBytes: a._parseAllDigestBytes }), h = {}, m = [];
      if (!it.validate(l, rte, h, m)) {
        var v = new Error("ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value.");
        throw v.errors = m, v;
      }
      var b = it.derToOid(h.algorithmIdentifier);
      if (!(b === gr.oids.md2 || b === gr.oids.md5 || b === gr.oids.sha1 || b === gr.oids.sha224 || b === gr.oids.sha256 || b === gr.oids.sha384 || b === gr.oids.sha512 || b === gr.oids["sha512-224"] || b === gr.oids["sha512-256"])) {
        var v = new Error("Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier.");
        throw v.oid = b, v;
      }
      if ((b === gr.oids.md2 || b === gr.oids.md5) && !("parameters" in h)) throw new Error("ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value. Missing algorithm identifier NULL parameters.");
      return f === h.digest;
    } } : (i === "NONE" || i === "NULL" || i === null) && (i = { verify: function(f, c) {
      return c = T1(c, n, true), f === c;
    } });
    var o = Br.rsa.decrypt(s, n, true, false);
    return i.verify(r, o, n.n.bitLength());
  }, n;
};
Br.setRsaPrivateKey = Br.rsa.setPrivateKey = function(t3, e, n, r, s, i, a, o) {
  var f = { n: t3, e, d: n, p: r, q: s, dP: i, dQ: a, qInv: o };
  return f.decrypt = function(c, l, h) {
    typeof l == "string" ? l = l.toUpperCase() : l === void 0 && (l = "RSAES-PKCS1-V1_5");
    var m = Br.rsa.decrypt(c, f, false, false);
    if (l === "RSAES-PKCS1-V1_5") l = { decode: T1 };
    else if (l === "RSA-OAEP" || l === "RSAES-OAEP") l = { decode: function(v, b) {
      return gr.pkcs1.decode_rsa_oaep(b, v, h);
    } };
    else if (["RAW", "NONE", "NULL", null].indexOf(l) !== -1) l = { decode: function(v) {
      return v;
    } };
    else throw new Error('Unsupported encryption scheme: "' + l + '".');
    return l.decode(m, f, false);
  }, f.sign = function(c, l) {
    var h = false;
    typeof l == "string" && (l = l.toUpperCase()), l === void 0 || l === "RSASSA-PKCS1-V1_5" ? (l = { encode: nte }, h = 1) : (l === "NONE" || l === "NULL" || l === null) && (l = { encode: function() {
      return c;
    } }, h = 1);
    var m = l.encode(c, f.n.bitLength());
    return Br.rsa.encrypt(m, f, h);
  }, f;
};
Br.wrapRsaPrivateKey = function(t3) {
  return it.create(it.Class.UNIVERSAL, it.Type.SEQUENCE, true, [it.create(it.Class.UNIVERSAL, it.Type.INTEGER, false, it.integerToDer(0).getBytes()), it.create(it.Class.UNIVERSAL, it.Type.SEQUENCE, true, [it.create(it.Class.UNIVERSAL, it.Type.OID, false, it.oidToDer(Br.oids.rsaEncryption).getBytes()), it.create(it.Class.UNIVERSAL, it.Type.NULL, false, "")]), it.create(it.Class.UNIVERSAL, it.Type.OCTETSTRING, false, it.toDer(t3).getBytes())]);
};
Br.privateKeyFromAsn1 = function(t3) {
  var e = {}, n = [];
  if (it.validate(t3, jee, e, n) && (t3 = it.fromDer(gr.util.createBuffer(e.privateKey))), e = {}, n = [], !it.validate(t3, Xee, e, n)) {
    var r = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
    throw r.errors = n, r;
  }
  var s, i, a, o, f, c, l, h;
  return s = gr.util.createBuffer(e.privateKeyModulus).toHex(), i = gr.util.createBuffer(e.privateKeyPublicExponent).toHex(), a = gr.util.createBuffer(e.privateKeyPrivateExponent).toHex(), o = gr.util.createBuffer(e.privateKeyPrime1).toHex(), f = gr.util.createBuffer(e.privateKeyPrime2).toHex(), c = gr.util.createBuffer(e.privateKeyExponent1).toHex(), l = gr.util.createBuffer(e.privateKeyExponent2).toHex(), h = gr.util.createBuffer(e.privateKeyCoefficient).toHex(), Br.setRsaPrivateKey(new nn(s, 16), new nn(i, 16), new nn(a, 16), new nn(o, 16), new nn(f, 16), new nn(c, 16), new nn(l, 16), new nn(h, 16));
};
Br.privateKeyToAsn1 = Br.privateKeyToRSAPrivateKey = function(t3) {
  return it.create(it.Class.UNIVERSAL, it.Type.SEQUENCE, true, [it.create(it.Class.UNIVERSAL, it.Type.INTEGER, false, it.integerToDer(0).getBytes()), it.create(it.Class.UNIVERSAL, it.Type.INTEGER, false, za(t3.n)), it.create(it.Class.UNIVERSAL, it.Type.INTEGER, false, za(t3.e)), it.create(it.Class.UNIVERSAL, it.Type.INTEGER, false, za(t3.d)), it.create(it.Class.UNIVERSAL, it.Type.INTEGER, false, za(t3.p)), it.create(it.Class.UNIVERSAL, it.Type.INTEGER, false, za(t3.q)), it.create(it.Class.UNIVERSAL, it.Type.INTEGER, false, za(t3.dP)), it.create(it.Class.UNIVERSAL, it.Type.INTEGER, false, za(t3.dQ)), it.create(it.Class.UNIVERSAL, it.Type.INTEGER, false, za(t3.qInv))]);
};
Br.publicKeyFromAsn1 = function(t3) {
  var e = {}, n = [];
  if (it.validate(t3, tte, e, n)) {
    var r = it.derToOid(e.publicKeyOid);
    if (r !== Br.oids.rsaEncryption) {
      var s = new Error("Cannot read public key. Unknown OID.");
      throw s.oid = r, s;
    }
    t3 = e.rsaPublicKey;
  }
  if (n = [], !it.validate(t3, ete, e, n)) {
    var s = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
    throw s.errors = n, s;
  }
  var i = gr.util.createBuffer(e.publicKeyModulus).toHex(), a = gr.util.createBuffer(e.publicKeyExponent).toHex();
  return Br.setRsaPublicKey(new nn(i, 16), new nn(a, 16));
};
Br.publicKeyToAsn1 = Br.publicKeyToSubjectPublicKeyInfo = function(t3) {
  return it.create(it.Class.UNIVERSAL, it.Type.SEQUENCE, true, [it.create(it.Class.UNIVERSAL, it.Type.SEQUENCE, true, [it.create(it.Class.UNIVERSAL, it.Type.OID, false, it.oidToDer(Br.oids.rsaEncryption).getBytes()), it.create(it.Class.UNIVERSAL, it.Type.NULL, false, "")]), it.create(it.Class.UNIVERSAL, it.Type.BITSTRING, false, [Br.publicKeyToRSAPublicKey(t3)])]);
};
Br.publicKeyToRSAPublicKey = function(t3) {
  return it.create(it.Class.UNIVERSAL, it.Type.SEQUENCE, true, [it.create(it.Class.UNIVERSAL, it.Type.INTEGER, false, za(t3.n)), it.create(it.Class.UNIVERSAL, it.Type.INTEGER, false, za(t3.e))]);
};
function _T(t3, e, n) {
  var r = gr.util.createBuffer(), s = Math.ceil(e.n.bitLength() / 8);
  if (t3.length > s - 11) {
    var i = new Error("Message is too long for PKCS#1 v1.5 padding.");
    throw i.length = t3.length, i.max = s - 11, i;
  }
  r.putByte(0), r.putByte(n);
  var a = s - 3 - t3.length, o;
  if (n === 0 || n === 1) {
    o = n === 0 ? 0 : 255;
    for (var f = 0; f < a; ++f) r.putByte(o);
  } else for (; a > 0; ) {
    for (var c = 0, l = gr.random.getBytes(a), f = 0; f < a; ++f) o = l.charCodeAt(f), o === 0 ? ++c : r.putByte(o);
    a = c;
  }
  return r.putByte(0), r.putBytes(t3), r;
}
function T1(t3, e, n, r) {
  var s = Math.ceil(e.n.bitLength() / 8), i = gr.util.createBuffer(t3), a = i.getByte(), o = i.getByte();
  if (a !== 0 || n && o !== 0 && o !== 1 || !n && o != 2 || n && o === 0 && typeof r > "u") throw new Error("Encryption block is invalid.");
  var f = 0;
  if (o === 0) {
    f = s - 3 - r;
    for (var c = 0; c < f; ++c) if (i.getByte() !== 0) throw new Error("Encryption block is invalid.");
  } else if (o === 1) for (f = 0; i.length() > 1; ) {
    if (i.getByte() !== 255) {
      --i.read;
      break;
    }
    ++f;
  }
  else if (o === 2) for (f = 0; i.length() > 1; ) {
    if (i.getByte() === 0) {
      --i.read;
      break;
    }
    ++f;
  }
  var l = i.getByte();
  if (l !== 0 || f !== s - 3 - i.length()) throw new Error("Encryption block is invalid.");
  return i.getBytes();
}
function ite(t3, e, n) {
  typeof e == "function" && (n = e, e = {}), e = e || {};
  var r = { algorithm: { name: e.algorithm || "PRIMEINC", options: { workers: e.workers || 2, workLoad: e.workLoad || 100, workerScript: e.workerScript } } };
  "prng" in e && (r.prng = e.prng), s();
  function s() {
    i(t3.pBits, function(o, f) {
      if (o) return n(o);
      if (t3.p = f, t3.q !== null) return a(o, t3.q);
      i(t3.qBits, a);
    });
  }
  function i(o, f) {
    gr.prime.generateProbablePrime(o, r, f);
  }
  function a(o, f) {
    if (o) return n(o);
    if (t3.q = f, t3.p.compareTo(t3.q) < 0) {
      var c = t3.p;
      t3.p = t3.q, t3.q = c;
    }
    if (t3.p.subtract(nn.ONE).gcd(t3.e).compareTo(nn.ONE) !== 0) {
      t3.p = null, s();
      return;
    }
    if (t3.q.subtract(nn.ONE).gcd(t3.e).compareTo(nn.ONE) !== 0) {
      t3.q = null, i(t3.qBits, a);
      return;
    }
    if (t3.p1 = t3.p.subtract(nn.ONE), t3.q1 = t3.q.subtract(nn.ONE), t3.phi = t3.p1.multiply(t3.q1), t3.phi.gcd(t3.e).compareTo(nn.ONE) !== 0) {
      t3.p = t3.q = null, s();
      return;
    }
    if (t3.n = t3.p.multiply(t3.q), t3.n.bitLength() !== t3.bits) {
      t3.q = null, i(t3.qBits, a);
      return;
    }
    var l = t3.e.modInverse(t3.phi);
    t3.keys = { privateKey: Br.rsa.setPrivateKey(t3.n, t3.e, l, t3.p, t3.q, l.mod(t3.p1), l.mod(t3.q1), t3.q.modInverse(t3.p)), publicKey: Br.rsa.setPublicKey(t3.n, t3.e) }, n(null, t3.keys);
  }
}
function za(t3) {
  var e = t3.toString(16);
  e[0] >= "8" && (e = "00" + e);
  var n = gr.util.hexToBytes(e);
  return n.length > 1 && (n.charCodeAt(0) === 0 && !(n.charCodeAt(1) & 128) || n.charCodeAt(0) === 255 && (n.charCodeAt(1) & 128) === 128) ? n.substr(1) : n;
}
function ste(t3) {
  return t3 <= 100 ? 27 : t3 <= 150 ? 18 : t3 <= 200 ? 15 : t3 <= 250 ? 12 : t3 <= 300 ? 9 : t3 <= 350 ? 8 : t3 <= 400 ? 7 : t3 <= 500 ? 6 : t3 <= 600 ? 5 : t3 <= 800 ? 4 : t3 <= 1250 ? 3 : 2;
}
function Sx(t3) {
  return gr.util.isNodejs && typeof ab[t3] == "function";
}
function Mx(t3) {
  return typeof na.globalScope < "u" && typeof na.globalScope.crypto == "object" && typeof na.globalScope.crypto.subtle == "object" && typeof na.globalScope.crypto.subtle[t3] == "function";
}
function $x(t3) {
  return typeof na.globalScope < "u" && typeof na.globalScope.msCrypto == "object" && typeof na.globalScope.msCrypto.subtle == "object" && typeof na.globalScope.msCrypto.subtle[t3] == "function";
}
function Tx(t3) {
  for (var e = gr.util.hexToBytes(t3.toString(16)), n = new Uint8Array(e.length), r = 0; r < e.length; ++r) n[r] = e.charCodeAt(r);
  return n;
}
var fr = Ur;
if (typeof ate > "u") var ate = fr.jsbn.BigInteger;
var gt = fr.asn1, Dr = fr.pki = fr.pki || {};
Dr.pbe = fr.pbe = fr.pbe || {};
var Dl = Dr.oids, ote = { name: "EncryptedPrivateKeyInfo", tagClass: gt.Class.UNIVERSAL, type: gt.Type.SEQUENCE, constructed: true, value: [{ name: "EncryptedPrivateKeyInfo.encryptionAlgorithm", tagClass: gt.Class.UNIVERSAL, type: gt.Type.SEQUENCE, constructed: true, value: [{ name: "AlgorithmIdentifier.algorithm", tagClass: gt.Class.UNIVERSAL, type: gt.Type.OID, constructed: false, capture: "encryptionOid" }, { name: "AlgorithmIdentifier.parameters", tagClass: gt.Class.UNIVERSAL, type: gt.Type.SEQUENCE, constructed: true, captureAsn1: "encryptionParams" }] }, { name: "EncryptedPrivateKeyInfo.encryptedData", tagClass: gt.Class.UNIVERSAL, type: gt.Type.OCTETSTRING, constructed: false, capture: "encryptedData" }] }, fte = { name: "PBES2Algorithms", tagClass: gt.Class.UNIVERSAL, type: gt.Type.SEQUENCE, constructed: true, value: [{ name: "PBES2Algorithms.keyDerivationFunc", tagClass: gt.Class.UNIVERSAL, type: gt.Type.SEQUENCE, constructed: true, value: [{ name: "PBES2Algorithms.keyDerivationFunc.oid", tagClass: gt.Class.UNIVERSAL, type: gt.Type.OID, constructed: false, capture: "kdfOid" }, { name: "PBES2Algorithms.params", tagClass: gt.Class.UNIVERSAL, type: gt.Type.SEQUENCE, constructed: true, value: [{ name: "PBES2Algorithms.params.salt", tagClass: gt.Class.UNIVERSAL, type: gt.Type.OCTETSTRING, constructed: false, capture: "kdfSalt" }, { name: "PBES2Algorithms.params.iterationCount", tagClass: gt.Class.UNIVERSAL, type: gt.Type.INTEGER, constructed: false, capture: "kdfIterationCount" }, { name: "PBES2Algorithms.params.keyLength", tagClass: gt.Class.UNIVERSAL, type: gt.Type.INTEGER, constructed: false, optional: true, capture: "keyLength" }, { name: "PBES2Algorithms.params.prf", tagClass: gt.Class.UNIVERSAL, type: gt.Type.SEQUENCE, constructed: true, optional: true, value: [{ name: "PBES2Algorithms.params.prf.algorithm", tagClass: gt.Class.UNIVERSAL, type: gt.Type.OID, constructed: false, capture: "prfOid" }] }] }] }, { name: "PBES2Algorithms.encryptionScheme", tagClass: gt.Class.UNIVERSAL, type: gt.Type.SEQUENCE, constructed: true, value: [{ name: "PBES2Algorithms.encryptionScheme.oid", tagClass: gt.Class.UNIVERSAL, type: gt.Type.OID, constructed: false, capture: "encOid" }, { name: "PBES2Algorithms.encryptionScheme.iv", tagClass: gt.Class.UNIVERSAL, type: gt.Type.OCTETSTRING, constructed: false, capture: "encIv" }] }] }, lte = { name: "pkcs-12PbeParams", tagClass: gt.Class.UNIVERSAL, type: gt.Type.SEQUENCE, constructed: true, value: [{ name: "pkcs-12PbeParams.salt", tagClass: gt.Class.UNIVERSAL, type: gt.Type.OCTETSTRING, constructed: false, capture: "salt" }, { name: "pkcs-12PbeParams.iterations", tagClass: gt.Class.UNIVERSAL, type: gt.Type.INTEGER, constructed: false, capture: "iterations" }] };
Dr.encryptPrivateKeyInfo = function(t3, e, n) {
  n = n || {}, n.saltSize = n.saltSize || 8, n.count = n.count || 2048, n.algorithm = n.algorithm || "aes128", n.prfAlgorithm = n.prfAlgorithm || "sha1";
  var r = fr.random.getBytesSync(n.saltSize), s = n.count, i = gt.integerToDer(s), a, o, f;
  if (n.algorithm.indexOf("aes") === 0 || n.algorithm === "des") {
    var c, l, h;
    switch (n.algorithm) {
      case "aes128":
        a = 16, c = 16, l = Dl["aes128-CBC"], h = fr.aes.createEncryptionCipher;
        break;
      case "aes192":
        a = 24, c = 16, l = Dl["aes192-CBC"], h = fr.aes.createEncryptionCipher;
        break;
      case "aes256":
        a = 32, c = 16, l = Dl["aes256-CBC"], h = fr.aes.createEncryptionCipher;
        break;
      case "des":
        a = 8, c = 8, l = Dl.desCBC, h = fr.des.createEncryptionCipher;
        break;
      default:
        var m = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
        throw m.algorithm = n.algorithm, m;
    }
    var v = "hmacWith" + n.prfAlgorithm.toUpperCase(), b = BT(v), A = fr.pkcs5.pbkdf2(e, r, s, a, b), _ = fr.random.getBytesSync(c), C = h(A);
    C.start(_), C.update(gt.toDer(t3)), C.finish(), f = C.output.getBytes();
    var I = ute(r, i, a, v);
    o = gt.create(gt.Class.UNIVERSAL, gt.Type.SEQUENCE, true, [gt.create(gt.Class.UNIVERSAL, gt.Type.OID, false, gt.oidToDer(Dl.pkcs5PBES2).getBytes()), gt.create(gt.Class.UNIVERSAL, gt.Type.SEQUENCE, true, [gt.create(gt.Class.UNIVERSAL, gt.Type.SEQUENCE, true, [gt.create(gt.Class.UNIVERSAL, gt.Type.OID, false, gt.oidToDer(Dl.pkcs5PBKDF2).getBytes()), I]), gt.create(gt.Class.UNIVERSAL, gt.Type.SEQUENCE, true, [gt.create(gt.Class.UNIVERSAL, gt.Type.OID, false, gt.oidToDer(l).getBytes()), gt.create(gt.Class.UNIVERSAL, gt.Type.OCTETSTRING, false, _)])])]);
  } else if (n.algorithm === "3des") {
    a = 24;
    var S = new fr.util.ByteBuffer(r), A = Dr.pbe.generatePkcs12Key(e, S, 1, s, a), _ = Dr.pbe.generatePkcs12Key(e, S, 2, s, a), C = fr.des.createEncryptionCipher(A);
    C.start(_), C.update(gt.toDer(t3)), C.finish(), f = C.output.getBytes(), o = gt.create(gt.Class.UNIVERSAL, gt.Type.SEQUENCE, true, [gt.create(gt.Class.UNIVERSAL, gt.Type.OID, false, gt.oidToDer(Dl["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()), gt.create(gt.Class.UNIVERSAL, gt.Type.SEQUENCE, true, [gt.create(gt.Class.UNIVERSAL, gt.Type.OCTETSTRING, false, r), gt.create(gt.Class.UNIVERSAL, gt.Type.INTEGER, false, i.getBytes())])]);
  } else {
    var m = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
    throw m.algorithm = n.algorithm, m;
  }
  var $ = gt.create(gt.Class.UNIVERSAL, gt.Type.SEQUENCE, true, [o, gt.create(gt.Class.UNIVERSAL, gt.Type.OCTETSTRING, false, f)]);
  return $;
};
Dr.decryptPrivateKeyInfo = function(t3, e) {
  var n = null, r = {}, s = [];
  if (!gt.validate(t3, ote, r, s)) {
    var i = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
    throw i.errors = s, i;
  }
  var a = gt.derToOid(r.encryptionOid), o = Dr.pbe.getCipher(a, r.encryptionParams, e), f = fr.util.createBuffer(r.encryptedData);
  return o.update(f), o.finish() && (n = gt.fromDer(o.output)), n;
};
Dr.encryptedPrivateKeyToPem = function(t3, e) {
  var n = { type: "ENCRYPTED PRIVATE KEY", body: gt.toDer(t3).getBytes() };
  return fr.pem.encode(n, { maxline: e });
};
Dr.encryptedPrivateKeyFromPem = function(t3) {
  var e = fr.pem.decode(t3)[0];
  if (e.type !== "ENCRYPTED PRIVATE KEY") {
    var n = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
    throw n.headerType = e.type, n;
  }
  if (e.procType && e.procType.type === "ENCRYPTED") throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
  return gt.fromDer(e.body);
};
Dr.encryptRsaPrivateKey = function(t3, e, n) {
  if (n = n || {}, !n.legacy) {
    var r = Dr.wrapRsaPrivateKey(Dr.privateKeyToAsn1(t3));
    return r = Dr.encryptPrivateKeyInfo(r, e, n), Dr.encryptedPrivateKeyToPem(r);
  }
  var s, i, a, o;
  switch (n.algorithm) {
    case "aes128":
      s = "AES-128-CBC", a = 16, i = fr.random.getBytesSync(16), o = fr.aes.createEncryptionCipher;
      break;
    case "aes192":
      s = "AES-192-CBC", a = 24, i = fr.random.getBytesSync(16), o = fr.aes.createEncryptionCipher;
      break;
    case "aes256":
      s = "AES-256-CBC", a = 32, i = fr.random.getBytesSync(16), o = fr.aes.createEncryptionCipher;
      break;
    case "3des":
      s = "DES-EDE3-CBC", a = 24, i = fr.random.getBytesSync(8), o = fr.des.createEncryptionCipher;
      break;
    case "des":
      s = "DES-CBC", a = 8, i = fr.random.getBytesSync(8), o = fr.des.createEncryptionCipher;
      break;
    default:
      var f = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + n.algorithm + '".');
      throw f.algorithm = n.algorithm, f;
  }
  var c = fr.pbe.opensslDeriveBytes(e, i.substr(0, 8), a), l = o(c);
  l.start(i), l.update(gt.toDer(Dr.privateKeyToAsn1(t3))), l.finish();
  var h = { type: "RSA PRIVATE KEY", procType: { version: "4", type: "ENCRYPTED" }, dekInfo: { algorithm: s, parameters: fr.util.bytesToHex(i).toUpperCase() }, body: l.output.getBytes() };
  return fr.pem.encode(h);
};
Dr.decryptRsaPrivateKey = function(t3, e) {
  var n = null, r = fr.pem.decode(t3)[0];
  if (r.type !== "ENCRYPTED PRIVATE KEY" && r.type !== "PRIVATE KEY" && r.type !== "RSA PRIVATE KEY") {
    var s = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
    throw s.headerType = s, s;
  }
  if (r.procType && r.procType.type === "ENCRYPTED") {
    var i, a;
    switch (r.dekInfo.algorithm) {
      case "DES-CBC":
        i = 8, a = fr.des.createDecryptionCipher;
        break;
      case "DES-EDE3-CBC":
        i = 24, a = fr.des.createDecryptionCipher;
        break;
      case "AES-128-CBC":
        i = 16, a = fr.aes.createDecryptionCipher;
        break;
      case "AES-192-CBC":
        i = 24, a = fr.aes.createDecryptionCipher;
        break;
      case "AES-256-CBC":
        i = 32, a = fr.aes.createDecryptionCipher;
        break;
      case "RC2-40-CBC":
        i = 5, a = function(h) {
          return fr.rc2.createDecryptionCipher(h, 40);
        };
        break;
      case "RC2-64-CBC":
        i = 8, a = function(h) {
          return fr.rc2.createDecryptionCipher(h, 64);
        };
        break;
      case "RC2-128-CBC":
        i = 16, a = function(h) {
          return fr.rc2.createDecryptionCipher(h, 128);
        };
        break;
      default:
        var s = new Error('Could not decrypt private key; unsupported encryption algorithm "' + r.dekInfo.algorithm + '".');
        throw s.algorithm = r.dekInfo.algorithm, s;
    }
    var o = fr.util.hexToBytes(r.dekInfo.parameters), f = fr.pbe.opensslDeriveBytes(e, o.substr(0, 8), i), c = a(f);
    if (c.start(o), c.update(fr.util.createBuffer(r.body)), c.finish()) n = c.output.getBytes();
    else return n;
  } else n = r.body;
  return r.type === "ENCRYPTED PRIVATE KEY" ? n = Dr.decryptPrivateKeyInfo(gt.fromDer(n), e) : n = gt.fromDer(n), n !== null && (n = Dr.privateKeyFromAsn1(n)), n;
};
Dr.pbe.generatePkcs12Key = function(t3, e, n, r, s, i) {
  var a, o;
  if (typeof i > "u" || i === null) {
    if (!("sha1" in fr.md)) throw new Error('"sha1" hash algorithm unavailable.');
    i = fr.md.sha1.create();
  }
  var f = i.digestLength, c = i.blockLength, l = new fr.util.ByteBuffer(), h = new fr.util.ByteBuffer();
  if (t3 != null) {
    for (o = 0; o < t3.length; o++) h.putInt16(t3.charCodeAt(o));
    h.putInt16(0);
  }
  var m = h.length(), v = e.length(), b = new fr.util.ByteBuffer();
  b.fillWithByte(n, c);
  var A = c * Math.ceil(v / c), _ = new fr.util.ByteBuffer();
  for (o = 0; o < A; o++) _.putByte(e.at(o % v));
  var C = c * Math.ceil(m / c), I = new fr.util.ByteBuffer();
  for (o = 0; o < C; o++) I.putByte(h.at(o % m));
  var S = _;
  S.putBuffer(I);
  for (var $ = Math.ceil(s / f), F = 1; F <= $; F++) {
    var U = new fr.util.ByteBuffer();
    U.putBytes(b.bytes()), U.putBytes(S.bytes());
    for (var Q = 0; Q < r; Q++) i.start(), i.update(U.getBytes()), U = i.digest();
    var P = new fr.util.ByteBuffer();
    for (o = 0; o < c; o++) P.putByte(U.at(o % f));
    var N = Math.ceil(v / c) + Math.ceil(m / c), L = new fr.util.ByteBuffer();
    for (a = 0; a < N; a++) {
      var B = new fr.util.ByteBuffer(S.getBytes(c)), u = 511;
      for (o = P.length() - 1; o >= 0; o--) u = u >> 8, u += P.at(o) + B.at(o), B.setAt(o, u & 255);
      L.putBuffer(B);
    }
    S = L, l.putBuffer(U);
  }
  return l.truncate(l.length() - s), l;
};
Dr.pbe.getCipher = function(t3, e, n) {
  switch (t3) {
    case Dr.oids.pkcs5PBES2:
      return Dr.pbe.getCipherForPBES2(t3, e, n);
    case Dr.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
    case Dr.oids["pbewithSHAAnd40BitRC2-CBC"]:
      return Dr.pbe.getCipherForPKCS12PBE(t3, e, n);
    default:
      var r = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
      throw r.oid = t3, r.supportedOids = ["pkcs5PBES2", "pbeWithSHAAnd3-KeyTripleDES-CBC", "pbewithSHAAnd40BitRC2-CBC"], r;
  }
};
Dr.pbe.getCipherForPBES2 = function(t3, e, n) {
  var r = {}, s = [];
  if (!gt.validate(e, fte, r, s)) {
    var i = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
    throw i.errors = s, i;
  }
  if (t3 = gt.derToOid(r.kdfOid), t3 !== Dr.oids.pkcs5PBKDF2) {
    var i = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
    throw i.oid = t3, i.supportedOids = ["pkcs5PBKDF2"], i;
  }
  if (t3 = gt.derToOid(r.encOid), t3 !== Dr.oids["aes128-CBC"] && t3 !== Dr.oids["aes192-CBC"] && t3 !== Dr.oids["aes256-CBC"] && t3 !== Dr.oids["des-EDE3-CBC"] && t3 !== Dr.oids.desCBC) {
    var i = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
    throw i.oid = t3, i.supportedOids = ["aes128-CBC", "aes192-CBC", "aes256-CBC", "des-EDE3-CBC", "desCBC"], i;
  }
  var a = r.kdfSalt, o = fr.util.createBuffer(r.kdfIterationCount);
  o = o.getInt(o.length() << 3);
  var f, c;
  switch (Dr.oids[t3]) {
    case "aes128-CBC":
      f = 16, c = fr.aes.createDecryptionCipher;
      break;
    case "aes192-CBC":
      f = 24, c = fr.aes.createDecryptionCipher;
      break;
    case "aes256-CBC":
      f = 32, c = fr.aes.createDecryptionCipher;
      break;
    case "des-EDE3-CBC":
      f = 24, c = fr.des.createDecryptionCipher;
      break;
    case "desCBC":
      f = 8, c = fr.des.createDecryptionCipher;
      break;
  }
  var l = ET(r.prfOid), h = fr.pkcs5.pbkdf2(n, a, o, f, l), m = r.encIv, v = c(h);
  return v.start(m), v;
};
Dr.pbe.getCipherForPKCS12PBE = function(t3, e, n) {
  var r = {}, s = [];
  if (!gt.validate(e, lte, r, s)) {
    var i = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
    throw i.errors = s, i;
  }
  var a = fr.util.createBuffer(r.salt), o = fr.util.createBuffer(r.iterations);
  o = o.getInt(o.length() << 3);
  var f, c, l;
  switch (t3) {
    case Dr.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
      f = 24, c = 8, l = fr.des.startDecrypting;
      break;
    case Dr.oids["pbewithSHAAnd40BitRC2-CBC"]:
      f = 5, c = 8, l = function(A, _) {
        var C = fr.rc2.createDecryptionCipher(A, 40);
        return C.start(_, null), C;
      };
      break;
    default:
      var i = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
      throw i.oid = t3, i;
  }
  var h = ET(r.prfOid), m = Dr.pbe.generatePkcs12Key(n, a, 1, o, f, h);
  h.start();
  var v = Dr.pbe.generatePkcs12Key(n, a, 2, o, c, h);
  return l(m, v);
};
Dr.pbe.opensslDeriveBytes = function(t3, e, n, r) {
  if (typeof r > "u" || r === null) {
    if (!("md5" in fr.md)) throw new Error('"md5" hash algorithm unavailable.');
    r = fr.md.md5.create();
  }
  e === null && (e = "");
  for (var s = [Dx(r, t3 + e)], i = 16, a = 1; i < n; ++a, i += 16) s.push(Dx(r, s[a - 1] + t3 + e));
  return s.join("").substr(0, n);
};
function Dx(t3, e) {
  return t3.start().update(e).digest().getBytes();
}
function ET(t3) {
  var e;
  if (!t3) e = "hmacWithSHA1";
  else if (e = Dr.oids[gt.derToOid(t3)], !e) {
    var n = new Error("Unsupported PRF OID.");
    throw n.oid = t3, n.supported = ["hmacWithSHA1", "hmacWithSHA224", "hmacWithSHA256", "hmacWithSHA384", "hmacWithSHA512"], n;
  }
  return BT(e);
}
function BT(t3) {
  var e = fr.md;
  switch (t3) {
    case "hmacWithSHA224":
      e = fr.md.sha512;
    case "hmacWithSHA1":
    case "hmacWithSHA256":
    case "hmacWithSHA384":
    case "hmacWithSHA512":
      t3 = t3.substr(8).toLowerCase();
      break;
    default:
      var n = new Error("Unsupported PRF algorithm.");
      throw n.algorithm = t3, n.supported = ["hmacWithSHA1", "hmacWithSHA224", "hmacWithSHA256", "hmacWithSHA384", "hmacWithSHA512"], n;
  }
  if (!e || !(t3 in e)) throw new Error("Unknown hash algorithm: " + t3);
  return e[t3].create();
}
function ute(t3, e, n, r) {
  var s = gt.create(gt.Class.UNIVERSAL, gt.Type.SEQUENCE, true, [gt.create(gt.Class.UNIVERSAL, gt.Type.OCTETSTRING, false, t3), gt.create(gt.Class.UNIVERSAL, gt.Type.INTEGER, false, e.getBytes())]);
  return r !== "hmacWithSHA1" && s.value.push(gt.create(gt.Class.UNIVERSAL, gt.Type.INTEGER, false, fr.util.hexToBytes(n.toString(16))), gt.create(gt.Class.UNIVERSAL, gt.Type.SEQUENCE, true, [gt.create(gt.Class.UNIVERSAL, gt.Type.OID, false, gt.oidToDer(Dr.oids[r]).getBytes()), gt.create(gt.Class.UNIVERSAL, gt.Type.NULL, false, "")])), s;
}
var Nu = Ur, nr = Nu.asn1, lc = Nu.pkcs7asn1 = Nu.pkcs7asn1 || {};
Nu.pkcs7 = Nu.pkcs7 || {};
Nu.pkcs7.asn1 = lc;
var CT = { name: "ContentInfo", tagClass: nr.Class.UNIVERSAL, type: nr.Type.SEQUENCE, constructed: true, value: [{ name: "ContentInfo.ContentType", tagClass: nr.Class.UNIVERSAL, type: nr.Type.OID, constructed: false, capture: "contentType" }, { name: "ContentInfo.content", tagClass: nr.Class.CONTEXT_SPECIFIC, type: 0, constructed: true, optional: true, captureAsn1: "content" }] };
lc.contentInfoValidator = CT;
var kT = { name: "EncryptedContentInfo", tagClass: nr.Class.UNIVERSAL, type: nr.Type.SEQUENCE, constructed: true, value: [{ name: "EncryptedContentInfo.contentType", tagClass: nr.Class.UNIVERSAL, type: nr.Type.OID, constructed: false, capture: "contentType" }, { name: "EncryptedContentInfo.contentEncryptionAlgorithm", tagClass: nr.Class.UNIVERSAL, type: nr.Type.SEQUENCE, constructed: true, value: [{ name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm", tagClass: nr.Class.UNIVERSAL, type: nr.Type.OID, constructed: false, capture: "encAlgorithm" }, { name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter", tagClass: nr.Class.UNIVERSAL, captureAsn1: "encParameter" }] }, { name: "EncryptedContentInfo.encryptedContent", tagClass: nr.Class.CONTEXT_SPECIFIC, type: 0, capture: "encryptedContent", captureAsn1: "encryptedContentAsn1" }] };
lc.envelopedDataValidator = { name: "EnvelopedData", tagClass: nr.Class.UNIVERSAL, type: nr.Type.SEQUENCE, constructed: true, value: [{ name: "EnvelopedData.Version", tagClass: nr.Class.UNIVERSAL, type: nr.Type.INTEGER, constructed: false, capture: "version" }, { name: "EnvelopedData.RecipientInfos", tagClass: nr.Class.UNIVERSAL, type: nr.Type.SET, constructed: true, captureAsn1: "recipientInfos" }].concat(kT) };
lc.encryptedDataValidator = { name: "EncryptedData", tagClass: nr.Class.UNIVERSAL, type: nr.Type.SEQUENCE, constructed: true, value: [{ name: "EncryptedData.Version", tagClass: nr.Class.UNIVERSAL, type: nr.Type.INTEGER, constructed: false, capture: "version" }].concat(kT) };
var cte = { name: "SignerInfo", tagClass: nr.Class.UNIVERSAL, type: nr.Type.SEQUENCE, constructed: true, value: [{ name: "SignerInfo.version", tagClass: nr.Class.UNIVERSAL, type: nr.Type.INTEGER, constructed: false }, { name: "SignerInfo.issuerAndSerialNumber", tagClass: nr.Class.UNIVERSAL, type: nr.Type.SEQUENCE, constructed: true, value: [{ name: "SignerInfo.issuerAndSerialNumber.issuer", tagClass: nr.Class.UNIVERSAL, type: nr.Type.SEQUENCE, constructed: true, captureAsn1: "issuer" }, { name: "SignerInfo.issuerAndSerialNumber.serialNumber", tagClass: nr.Class.UNIVERSAL, type: nr.Type.INTEGER, constructed: false, capture: "serial" }] }, { name: "SignerInfo.digestAlgorithm", tagClass: nr.Class.UNIVERSAL, type: nr.Type.SEQUENCE, constructed: true, value: [{ name: "SignerInfo.digestAlgorithm.algorithm", tagClass: nr.Class.UNIVERSAL, type: nr.Type.OID, constructed: false, capture: "digestAlgorithm" }, { name: "SignerInfo.digestAlgorithm.parameter", tagClass: nr.Class.UNIVERSAL, constructed: false, captureAsn1: "digestParameter", optional: true }] }, { name: "SignerInfo.authenticatedAttributes", tagClass: nr.Class.CONTEXT_SPECIFIC, type: 0, constructed: true, optional: true, capture: "authenticatedAttributes" }, { name: "SignerInfo.digestEncryptionAlgorithm", tagClass: nr.Class.UNIVERSAL, type: nr.Type.SEQUENCE, constructed: true, capture: "signatureAlgorithm" }, { name: "SignerInfo.encryptedDigest", tagClass: nr.Class.UNIVERSAL, type: nr.Type.OCTETSTRING, constructed: false, capture: "signature" }, { name: "SignerInfo.unauthenticatedAttributes", tagClass: nr.Class.CONTEXT_SPECIFIC, type: 1, constructed: true, optional: true, capture: "unauthenticatedAttributes" }] };
lc.signedDataValidator = { name: "SignedData", tagClass: nr.Class.UNIVERSAL, type: nr.Type.SEQUENCE, constructed: true, value: [{ name: "SignedData.Version", tagClass: nr.Class.UNIVERSAL, type: nr.Type.INTEGER, constructed: false, capture: "version" }, { name: "SignedData.DigestAlgorithms", tagClass: nr.Class.UNIVERSAL, type: nr.Type.SET, constructed: true, captureAsn1: "digestAlgorithms" }, CT, { name: "SignedData.Certificates", tagClass: nr.Class.CONTEXT_SPECIFIC, type: 0, optional: true, captureAsn1: "certificates" }, { name: "SignedData.CertificateRevocationLists", tagClass: nr.Class.CONTEXT_SPECIFIC, type: 1, optional: true, captureAsn1: "crls" }, { name: "SignedData.SignerInfos", tagClass: nr.Class.UNIVERSAL, type: nr.Type.SET, capture: "signerInfos", optional: true, value: [cte] }] };
lc.recipientInfoValidator = { name: "RecipientInfo", tagClass: nr.Class.UNIVERSAL, type: nr.Type.SEQUENCE, constructed: true, value: [{ name: "RecipientInfo.version", tagClass: nr.Class.UNIVERSAL, type: nr.Type.INTEGER, constructed: false, capture: "version" }, { name: "RecipientInfo.issuerAndSerial", tagClass: nr.Class.UNIVERSAL, type: nr.Type.SEQUENCE, constructed: true, value: [{ name: "RecipientInfo.issuerAndSerial.issuer", tagClass: nr.Class.UNIVERSAL, type: nr.Type.SEQUENCE, constructed: true, captureAsn1: "issuer" }, { name: "RecipientInfo.issuerAndSerial.serialNumber", tagClass: nr.Class.UNIVERSAL, type: nr.Type.INTEGER, constructed: false, capture: "serial" }] }, { name: "RecipientInfo.keyEncryptionAlgorithm", tagClass: nr.Class.UNIVERSAL, type: nr.Type.SEQUENCE, constructed: true, value: [{ name: "RecipientInfo.keyEncryptionAlgorithm.algorithm", tagClass: nr.Class.UNIVERSAL, type: nr.Type.OID, constructed: false, capture: "encAlgorithm" }, { name: "RecipientInfo.keyEncryptionAlgorithm.parameter", tagClass: nr.Class.UNIVERSAL, constructed: false, captureAsn1: "encParameter", optional: true }] }, { name: "RecipientInfo.encryptedKey", tagClass: nr.Class.UNIVERSAL, type: nr.Type.OCTETSTRING, constructed: false, capture: "encKey" }] };
var t0 = Ur;
t0.mgf = t0.mgf || {};
var hte = t0.mgf.mgf1 = t0.mgf1 = t0.mgf1 || {};
hte.create = function(t3) {
  var e = { generate: function(n, r) {
    for (var s = new t0.util.ByteBuffer(), i = Math.ceil(r / t3.digestLength), a = 0; a < i; a++) {
      var o = new t0.util.ByteBuffer();
      o.putInt32(a), t3.start(), t3.update(n + o.getBytes()), s.putBuffer(t3.digest());
    }
    return s.truncate(s.length() - r), s.getBytes();
  } };
  return e;
};
var D1 = Ur;
D1.mgf = D1.mgf || {};
D1.mgf.mgf1 = D1.mgf1;
var Nl = Ur, dte = Nl.pss = Nl.pss || {};
dte.create = function(t3) {
  arguments.length === 3 && (t3 = { md: arguments[0], mgf: arguments[1], saltLength: arguments[2] });
  var e = t3.md, n = t3.mgf, r = e.digestLength, s = t3.salt || null;
  typeof s == "string" && (s = Nl.util.createBuffer(s));
  var i;
  if ("saltLength" in t3) i = t3.saltLength;
  else if (s !== null) i = s.length();
  else throw new Error("Salt length not specified or specific salt not given.");
  if (s !== null && s.length() !== i) throw new Error("Given salt length does not match length of given salt.");
  var a = t3.prng || Nl.random, o = {};
  return o.encode = function(f, c) {
    var l, h = c - 1, m = Math.ceil(h / 8), v = f.digest().getBytes();
    if (m < r + i + 2) throw new Error("Message is too long to encrypt.");
    var b;
    s === null ? b = a.getBytesSync(i) : b = s.bytes();
    var A = new Nl.util.ByteBuffer();
    A.fillWithByte(0, 8), A.putBytes(v), A.putBytes(b), e.start(), e.update(A.getBytes());
    var _ = e.digest().getBytes(), C = new Nl.util.ByteBuffer();
    C.fillWithByte(0, m - i - r - 2), C.putByte(1), C.putBytes(b);
    var I = C.getBytes(), S = m - r - 1, $ = n.generate(_, S), F = "";
    for (l = 0; l < S; l++) F += String.fromCharCode(I.charCodeAt(l) ^ $.charCodeAt(l));
    var U = 65280 >> 8 * m - h & 255;
    return F = String.fromCharCode(F.charCodeAt(0) & ~U) + F.substr(1), F + _ + "\xBC";
  }, o.verify = function(f, c, l) {
    var h, m = l - 1, v = Math.ceil(m / 8);
    if (c = c.substr(-v), v < r + i + 2) throw new Error("Inconsistent parameters to PSS signature verification.");
    if (c.charCodeAt(v - 1) !== 188) throw new Error("Encoded message does not end in 0xBC.");
    var b = v - r - 1, A = c.substr(0, b), _ = c.substr(b, r), C = 65280 >> 8 * v - m & 255;
    if (A.charCodeAt(0) & C) throw new Error("Bits beyond keysize not zero as expected.");
    var I = n.generate(_, b), S = "";
    for (h = 0; h < b; h++) S += String.fromCharCode(A.charCodeAt(h) ^ I.charCodeAt(h));
    S = String.fromCharCode(S.charCodeAt(0) & ~C) + S.substr(1);
    var $ = v - r - i - 2;
    for (h = 0; h < $; h++) if (S.charCodeAt(h) !== 0) throw new Error("Leftmost octets not zero as expected");
    if (S.charCodeAt($) !== 1) throw new Error("Inconsistent PSS signature, 0x01 marker not found");
    var F = S.substr(-i), U = new Nl.util.ByteBuffer();
    U.fillWithByte(0, 8), U.putBytes(f), U.putBytes(F), e.start(), e.update(U.getBytes());
    var Q = e.digest().getBytes();
    return _ === Q;
  }, o;
};
var mr = Ur, Be = mr.asn1, Ot = mr.pki = mr.pki || {}, Xr = Ot.oids, Gn = {};
Gn.CN = Xr.commonName;
Gn.commonName = "CN";
Gn.C = Xr.countryName;
Gn.countryName = "C";
Gn.L = Xr.localityName;
Gn.localityName = "L";
Gn.ST = Xr.stateOrProvinceName;
Gn.stateOrProvinceName = "ST";
Gn.O = Xr.organizationName;
Gn.organizationName = "O";
Gn.OU = Xr.organizationalUnitName;
Gn.organizationalUnitName = "OU";
Gn.E = Xr.emailAddress;
Gn.emailAddress = "E";
var IT = mr.pki.rsa.publicKeyValidator, pte = { name: "Certificate", tagClass: Be.Class.UNIVERSAL, type: Be.Type.SEQUENCE, constructed: true, value: [{ name: "Certificate.TBSCertificate", tagClass: Be.Class.UNIVERSAL, type: Be.Type.SEQUENCE, constructed: true, captureAsn1: "tbsCertificate", value: [{ name: "Certificate.TBSCertificate.version", tagClass: Be.Class.CONTEXT_SPECIFIC, type: 0, constructed: true, optional: true, value: [{ name: "Certificate.TBSCertificate.version.integer", tagClass: Be.Class.UNIVERSAL, type: Be.Type.INTEGER, constructed: false, capture: "certVersion" }] }, { name: "Certificate.TBSCertificate.serialNumber", tagClass: Be.Class.UNIVERSAL, type: Be.Type.INTEGER, constructed: false, capture: "certSerialNumber" }, { name: "Certificate.TBSCertificate.signature", tagClass: Be.Class.UNIVERSAL, type: Be.Type.SEQUENCE, constructed: true, value: [{ name: "Certificate.TBSCertificate.signature.algorithm", tagClass: Be.Class.UNIVERSAL, type: Be.Type.OID, constructed: false, capture: "certinfoSignatureOid" }, { name: "Certificate.TBSCertificate.signature.parameters", tagClass: Be.Class.UNIVERSAL, optional: true, captureAsn1: "certinfoSignatureParams" }] }, { name: "Certificate.TBSCertificate.issuer", tagClass: Be.Class.UNIVERSAL, type: Be.Type.SEQUENCE, constructed: true, captureAsn1: "certIssuer" }, { name: "Certificate.TBSCertificate.validity", tagClass: Be.Class.UNIVERSAL, type: Be.Type.SEQUENCE, constructed: true, value: [{ name: "Certificate.TBSCertificate.validity.notBefore (utc)", tagClass: Be.Class.UNIVERSAL, type: Be.Type.UTCTIME, constructed: false, optional: true, capture: "certValidity1UTCTime" }, { name: "Certificate.TBSCertificate.validity.notBefore (generalized)", tagClass: Be.Class.UNIVERSAL, type: Be.Type.GENERALIZEDTIME, constructed: false, optional: true, capture: "certValidity2GeneralizedTime" }, { name: "Certificate.TBSCertificate.validity.notAfter (utc)", tagClass: Be.Class.UNIVERSAL, type: Be.Type.UTCTIME, constructed: false, optional: true, capture: "certValidity3UTCTime" }, { name: "Certificate.TBSCertificate.validity.notAfter (generalized)", tagClass: Be.Class.UNIVERSAL, type: Be.Type.GENERALIZEDTIME, constructed: false, optional: true, capture: "certValidity4GeneralizedTime" }] }, { name: "Certificate.TBSCertificate.subject", tagClass: Be.Class.UNIVERSAL, type: Be.Type.SEQUENCE, constructed: true, captureAsn1: "certSubject" }, IT, { name: "Certificate.TBSCertificate.issuerUniqueID", tagClass: Be.Class.CONTEXT_SPECIFIC, type: 1, constructed: true, optional: true, value: [{ name: "Certificate.TBSCertificate.issuerUniqueID.id", tagClass: Be.Class.UNIVERSAL, type: Be.Type.BITSTRING, constructed: false, captureBitStringValue: "certIssuerUniqueId" }] }, { name: "Certificate.TBSCertificate.subjectUniqueID", tagClass: Be.Class.CONTEXT_SPECIFIC, type: 2, constructed: true, optional: true, value: [{ name: "Certificate.TBSCertificate.subjectUniqueID.id", tagClass: Be.Class.UNIVERSAL, type: Be.Type.BITSTRING, constructed: false, captureBitStringValue: "certSubjectUniqueId" }] }, { name: "Certificate.TBSCertificate.extensions", tagClass: Be.Class.CONTEXT_SPECIFIC, type: 3, constructed: true, captureAsn1: "certExtensions", optional: true }] }, { name: "Certificate.signatureAlgorithm", tagClass: Be.Class.UNIVERSAL, type: Be.Type.SEQUENCE, constructed: true, value: [{ name: "Certificate.signatureAlgorithm.algorithm", tagClass: Be.Class.UNIVERSAL, type: Be.Type.OID, constructed: false, capture: "certSignatureOid" }, { name: "Certificate.TBSCertificate.signature.parameters", tagClass: Be.Class.UNIVERSAL, optional: true, captureAsn1: "certSignatureParams" }] }, { name: "Certificate.signatureValue", tagClass: Be.Class.UNIVERSAL, type: Be.Type.BITSTRING, constructed: false, captureBitStringValue: "certSignature" }] }, gte = { name: "rsapss", tagClass: Be.Class.UNIVERSAL, type: Be.Type.SEQUENCE, constructed: true, value: [{ name: "rsapss.hashAlgorithm", tagClass: Be.Class.CONTEXT_SPECIFIC, type: 0, constructed: true, value: [{ name: "rsapss.hashAlgorithm.AlgorithmIdentifier", tagClass: Be.Class.UNIVERSAL, type: Be.Class.SEQUENCE, constructed: true, optional: true, value: [{ name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm", tagClass: Be.Class.UNIVERSAL, type: Be.Type.OID, constructed: false, capture: "hashOid" }] }] }, { name: "rsapss.maskGenAlgorithm", tagClass: Be.Class.CONTEXT_SPECIFIC, type: 1, constructed: true, value: [{ name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier", tagClass: Be.Class.UNIVERSAL, type: Be.Class.SEQUENCE, constructed: true, optional: true, value: [{ name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm", tagClass: Be.Class.UNIVERSAL, type: Be.Type.OID, constructed: false, capture: "maskGenOid" }, { name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params", tagClass: Be.Class.UNIVERSAL, type: Be.Type.SEQUENCE, constructed: true, value: [{ name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm", tagClass: Be.Class.UNIVERSAL, type: Be.Type.OID, constructed: false, capture: "maskGenHashOid" }] }] }] }, { name: "rsapss.saltLength", tagClass: Be.Class.CONTEXT_SPECIFIC, type: 2, optional: true, value: [{ name: "rsapss.saltLength.saltLength", tagClass: Be.Class.UNIVERSAL, type: Be.Class.INTEGER, constructed: false, capture: "saltLength" }] }, { name: "rsapss.trailerField", tagClass: Be.Class.CONTEXT_SPECIFIC, type: 3, optional: true, value: [{ name: "rsapss.trailer.trailer", tagClass: Be.Class.UNIVERSAL, type: Be.Class.INTEGER, constructed: false, capture: "trailer" }] }] }, mte = { name: "CertificationRequestInfo", tagClass: Be.Class.UNIVERSAL, type: Be.Type.SEQUENCE, constructed: true, captureAsn1: "certificationRequestInfo", value: [{ name: "CertificationRequestInfo.integer", tagClass: Be.Class.UNIVERSAL, type: Be.Type.INTEGER, constructed: false, capture: "certificationRequestInfoVersion" }, { name: "CertificationRequestInfo.subject", tagClass: Be.Class.UNIVERSAL, type: Be.Type.SEQUENCE, constructed: true, captureAsn1: "certificationRequestInfoSubject" }, IT, { name: "CertificationRequestInfo.attributes", tagClass: Be.Class.CONTEXT_SPECIFIC, type: 0, constructed: true, optional: true, capture: "certificationRequestInfoAttributes", value: [{ name: "CertificationRequestInfo.attributes", tagClass: Be.Class.UNIVERSAL, type: Be.Type.SEQUENCE, constructed: true, value: [{ name: "CertificationRequestInfo.attributes.type", tagClass: Be.Class.UNIVERSAL, type: Be.Type.OID, constructed: false }, { name: "CertificationRequestInfo.attributes.value", tagClass: Be.Class.UNIVERSAL, type: Be.Type.SET, constructed: true }] }] }] }, vte = { name: "CertificationRequest", tagClass: Be.Class.UNIVERSAL, type: Be.Type.SEQUENCE, constructed: true, captureAsn1: "csr", value: [mte, { name: "CertificationRequest.signatureAlgorithm", tagClass: Be.Class.UNIVERSAL, type: Be.Type.SEQUENCE, constructed: true, value: [{ name: "CertificationRequest.signatureAlgorithm.algorithm", tagClass: Be.Class.UNIVERSAL, type: Be.Type.OID, constructed: false, capture: "csrSignatureOid" }, { name: "CertificationRequest.signatureAlgorithm.parameters", tagClass: Be.Class.UNIVERSAL, optional: true, captureAsn1: "csrSignatureParams" }] }, { name: "CertificationRequest.signature", tagClass: Be.Class.UNIVERSAL, type: Be.Type.BITSTRING, constructed: false, captureBitStringValue: "csrSignature" }] };
Ot.RDNAttributesAsArray = function(t3, e) {
  for (var n = [], r, s, i, a = 0; a < t3.value.length; ++a) {
    r = t3.value[a];
    for (var o = 0; o < r.value.length; ++o) i = {}, s = r.value[o], i.type = Be.derToOid(s.value[0].value), i.value = s.value[1].value, i.valueTagClass = s.value[1].type, i.type in Xr && (i.name = Xr[i.type], i.name in Gn && (i.shortName = Gn[i.name])), e && (e.update(i.type), e.update(i.value)), n.push(i);
  }
  return n;
};
Ot.CRIAttributesAsArray = function(t3) {
  for (var e = [], n = 0; n < t3.length; ++n) for (var r = t3[n], s = Be.derToOid(r.value[0].value), i = r.value[1].value, a = 0; a < i.length; ++a) {
    var o = {};
    if (o.type = s, o.value = i[a].value, o.valueTagClass = i[a].type, o.type in Xr && (o.name = Xr[o.type], o.name in Gn && (o.shortName = Gn[o.name])), o.type === Xr.extensionRequest) {
      o.extensions = [];
      for (var f = 0; f < o.value.length; ++f) o.extensions.push(Ot.certificateExtensionFromAsn1(o.value[f]));
    }
    e.push(o);
  }
  return e;
};
function ol(t3, e) {
  typeof e == "string" && (e = { shortName: e });
  for (var n = null, r, s = 0; n === null && s < t3.attributes.length; ++s) r = t3.attributes[s], (e.type && e.type === r.type || e.name && e.name === r.name || e.shortName && e.shortName === r.shortName) && (n = r);
  return n;
}
var R1 = function(t3, e, n) {
  var r = {};
  if (t3 !== Xr["RSASSA-PSS"]) return r;
  n && (r = { hash: { algorithmOid: Xr.sha1 }, mgf: { algorithmOid: Xr.mgf1, hash: { algorithmOid: Xr.sha1 } }, saltLength: 20 });
  var s = {}, i = [];
  if (!Be.validate(e, gte, s, i)) {
    var a = new Error("Cannot read RSASSA-PSS parameter block.");
    throw a.errors = i, a;
  }
  return s.hashOid !== void 0 && (r.hash = r.hash || {}, r.hash.algorithmOid = Be.derToOid(s.hashOid)), s.maskGenOid !== void 0 && (r.mgf = r.mgf || {}, r.mgf.algorithmOid = Be.derToOid(s.maskGenOid), r.mgf.hash = r.mgf.hash || {}, r.mgf.hash.algorithmOid = Be.derToOid(s.maskGenHashOid)), s.saltLength !== void 0 && (r.saltLength = s.saltLength.charCodeAt(0)), r;
}, cm = function(t3) {
  switch (Xr[t3.signatureOid]) {
    case "sha1WithRSAEncryption":
    case "sha1WithRSASignature":
      return mr.md.sha1.create();
    case "md5WithRSAEncryption":
      return mr.md.md5.create();
    case "sha256WithRSAEncryption":
      return mr.md.sha256.create();
    case "sha384WithRSAEncryption":
      return mr.md.sha384.create();
    case "sha512WithRSAEncryption":
      return mr.md.sha512.create();
    case "RSASSA-PSS":
      return mr.md.sha256.create();
    default:
      var e = new Error("Could not compute " + t3.type + " digest. Unknown signature OID.");
      throw e.signatureOid = t3.signatureOid, e;
  }
}, ST = function(t3) {
  var e = t3.certificate, n;
  switch (e.signatureOid) {
    case Xr.sha1WithRSAEncryption:
    case Xr.sha1WithRSASignature:
      break;
    case Xr["RSASSA-PSS"]:
      var r, s;
      if (r = Xr[e.signatureParameters.mgf.hash.algorithmOid], r === void 0 || mr.md[r] === void 0) {
        var i = new Error("Unsupported MGF hash function.");
        throw i.oid = e.signatureParameters.mgf.hash.algorithmOid, i.name = r, i;
      }
      if (s = Xr[e.signatureParameters.mgf.algorithmOid], s === void 0 || mr.mgf[s] === void 0) {
        var i = new Error("Unsupported MGF function.");
        throw i.oid = e.signatureParameters.mgf.algorithmOid, i.name = s, i;
      }
      if (s = mr.mgf[s].create(mr.md[r].create()), r = Xr[e.signatureParameters.hash.algorithmOid], r === void 0 || mr.md[r] === void 0) {
        var i = new Error("Unsupported RSASSA-PSS hash function.");
        throw i.oid = e.signatureParameters.hash.algorithmOid, i.name = r, i;
      }
      n = mr.pss.create(mr.md[r].create(), s, e.signatureParameters.saltLength);
      break;
  }
  return e.publicKey.verify(t3.md.digest().getBytes(), t3.signature, n);
};
Ot.certificateFromPem = function(t3, e, n) {
  var r = mr.pem.decode(t3)[0];
  if (r.type !== "CERTIFICATE" && r.type !== "X509 CERTIFICATE" && r.type !== "TRUSTED CERTIFICATE") {
    var s = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
    throw s.headerType = r.type, s;
  }
  if (r.procType && r.procType.type === "ENCRYPTED") throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
  var i = Be.fromDer(r.body, n);
  return Ot.certificateFromAsn1(i, e);
};
Ot.certificateToPem = function(t3, e) {
  var n = { type: "CERTIFICATE", body: Be.toDer(Ot.certificateToAsn1(t3)).getBytes() };
  return mr.pem.encode(n, { maxline: e });
};
Ot.publicKeyFromPem = function(t3) {
  var e = mr.pem.decode(t3)[0];
  if (e.type !== "PUBLIC KEY" && e.type !== "RSA PUBLIC KEY") {
    var n = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
    throw n.headerType = e.type, n;
  }
  if (e.procType && e.procType.type === "ENCRYPTED") throw new Error("Could not convert public key from PEM; PEM is encrypted.");
  var r = Be.fromDer(e.body);
  return Ot.publicKeyFromAsn1(r);
};
Ot.publicKeyToPem = function(t3, e) {
  var n = { type: "PUBLIC KEY", body: Be.toDer(Ot.publicKeyToAsn1(t3)).getBytes() };
  return mr.pem.encode(n, { maxline: e });
};
Ot.publicKeyToRSAPublicKeyPem = function(t3, e) {
  var n = { type: "RSA PUBLIC KEY", body: Be.toDer(Ot.publicKeyToRSAPublicKey(t3)).getBytes() };
  return mr.pem.encode(n, { maxline: e });
};
Ot.getPublicKeyFingerprint = function(t3, e) {
  e = e || {};
  var n = e.md || mr.md.sha1.create(), r = e.type || "RSAPublicKey", s;
  switch (r) {
    case "RSAPublicKey":
      s = Be.toDer(Ot.publicKeyToRSAPublicKey(t3)).getBytes();
      break;
    case "SubjectPublicKeyInfo":
      s = Be.toDer(Ot.publicKeyToAsn1(t3)).getBytes();
      break;
    default:
      throw new Error('Unknown fingerprint type "' + e.type + '".');
  }
  n.start(), n.update(s);
  var i = n.digest();
  if (e.encoding === "hex") {
    var a = i.toHex();
    return e.delimiter ? a.match(/.{2}/g).join(e.delimiter) : a;
  } else {
    if (e.encoding === "binary") return i.getBytes();
    if (e.encoding) throw new Error('Unknown encoding "' + e.encoding + '".');
  }
  return i;
};
Ot.certificationRequestFromPem = function(t3, e, n) {
  var r = mr.pem.decode(t3)[0];
  if (r.type !== "CERTIFICATE REQUEST") {
    var s = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
    throw s.headerType = r.type, s;
  }
  if (r.procType && r.procType.type === "ENCRYPTED") throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
  var i = Be.fromDer(r.body, n);
  return Ot.certificationRequestFromAsn1(i, e);
};
Ot.certificationRequestToPem = function(t3, e) {
  var n = { type: "CERTIFICATE REQUEST", body: Be.toDer(Ot.certificationRequestToAsn1(t3)).getBytes() };
  return mr.pem.encode(n, { maxline: e });
};
Ot.createCertificate = function() {
  var t3 = {};
  return t3.version = 2, t3.serialNumber = "00", t3.signatureOid = null, t3.signature = null, t3.siginfo = {}, t3.siginfo.algorithmOid = null, t3.validity = {}, t3.validity.notBefore = /* @__PURE__ */ new Date(), t3.validity.notAfter = /* @__PURE__ */ new Date(), t3.issuer = {}, t3.issuer.getField = function(e) {
    return ol(t3.issuer, e);
  }, t3.issuer.addField = function(e) {
    ia([e]), t3.issuer.attributes.push(e);
  }, t3.issuer.attributes = [], t3.issuer.hash = null, t3.subject = {}, t3.subject.getField = function(e) {
    return ol(t3.subject, e);
  }, t3.subject.addField = function(e) {
    ia([e]), t3.subject.attributes.push(e);
  }, t3.subject.attributes = [], t3.subject.hash = null, t3.extensions = [], t3.publicKey = null, t3.md = null, t3.setSubject = function(e, n) {
    ia(e), t3.subject.attributes = e, delete t3.subject.uniqueId, n && (t3.subject.uniqueId = n), t3.subject.hash = null;
  }, t3.setIssuer = function(e, n) {
    ia(e), t3.issuer.attributes = e, delete t3.issuer.uniqueId, n && (t3.issuer.uniqueId = n), t3.issuer.hash = null;
  }, t3.setExtensions = function(e) {
    for (var n = 0; n < e.length; ++n) MT(e[n], { cert: t3 });
    t3.extensions = e;
  }, t3.getExtension = function(e) {
    typeof e == "string" && (e = { name: e });
    for (var n = null, r, s = 0; n === null && s < t3.extensions.length; ++s) r = t3.extensions[s], (e.id && r.id === e.id || e.name && r.name === e.name) && (n = r);
    return n;
  }, t3.sign = function(e, n) {
    t3.md = n || mr.md.sha1.create();
    var r = Xr[t3.md.algorithm + "WithRSAEncryption"];
    if (!r) {
      var s = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
      throw s.algorithm = t3.md.algorithm, s;
    }
    t3.signatureOid = t3.siginfo.algorithmOid = r, t3.tbsCertificate = Ot.getTBSCertificate(t3);
    var i = Be.toDer(t3.tbsCertificate);
    t3.md.update(i.getBytes()), t3.signature = e.sign(t3.md);
  }, t3.verify = function(e) {
    var n = false;
    if (!t3.issued(e)) {
      var r = e.issuer, s = t3.subject, i = new Error("The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject.");
      throw i.expectedIssuer = s.attributes, i.actualIssuer = r.attributes, i;
    }
    var a = e.md;
    if (a === null) {
      a = cm({ signatureOid: e.signatureOid, type: "certificate" });
      var o = e.tbsCertificate || Ot.getTBSCertificate(e), f = Be.toDer(o);
      a.update(f.getBytes());
    }
    return a !== null && (n = ST({ certificate: t3, md: a, signature: e.signature })), n;
  }, t3.isIssuer = function(e) {
    var n = false, r = t3.issuer, s = e.subject;
    if (r.hash && s.hash) n = r.hash === s.hash;
    else if (r.attributes.length === s.attributes.length) {
      n = true;
      for (var i, a, o = 0; n && o < r.attributes.length; ++o) i = r.attributes[o], a = s.attributes[o], (i.type !== a.type || i.value !== a.value) && (n = false);
    }
    return n;
  }, t3.issued = function(e) {
    return e.isIssuer(t3);
  }, t3.generateSubjectKeyIdentifier = function() {
    return Ot.getPublicKeyFingerprint(t3.publicKey, { type: "RSAPublicKey" });
  }, t3.verifySubjectKeyIdentifier = function() {
    for (var e = Xr.subjectKeyIdentifier, n = 0; n < t3.extensions.length; ++n) {
      var r = t3.extensions[n];
      if (r.id === e) {
        var s = t3.generateSubjectKeyIdentifier().getBytes();
        return mr.util.hexToBytes(r.subjectKeyIdentifier) === s;
      }
    }
    return false;
  }, t3;
};
Ot.certificateFromAsn1 = function(t3, e) {
  var n = {}, r = [];
  if (!Be.validate(t3, pte, n, r)) {
    var s = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");
    throw s.errors = r, s;
  }
  var i = Be.derToOid(n.publicKeyOid);
  if (i !== Ot.oids.rsaEncryption) throw new Error("Cannot read public key. OID is not RSA.");
  var a = Ot.createCertificate();
  a.version = n.certVersion ? n.certVersion.charCodeAt(0) : 0;
  var o = mr.util.createBuffer(n.certSerialNumber);
  a.serialNumber = o.toHex(), a.signatureOid = mr.asn1.derToOid(n.certSignatureOid), a.signatureParameters = R1(a.signatureOid, n.certSignatureParams, true), a.siginfo.algorithmOid = mr.asn1.derToOid(n.certinfoSignatureOid), a.siginfo.parameters = R1(a.siginfo.algorithmOid, n.certinfoSignatureParams, false), a.signature = n.certSignature;
  var f = [];
  if (n.certValidity1UTCTime !== void 0 && f.push(Be.utcTimeToDate(n.certValidity1UTCTime)), n.certValidity2GeneralizedTime !== void 0 && f.push(Be.generalizedTimeToDate(n.certValidity2GeneralizedTime)), n.certValidity3UTCTime !== void 0 && f.push(Be.utcTimeToDate(n.certValidity3UTCTime)), n.certValidity4GeneralizedTime !== void 0 && f.push(Be.generalizedTimeToDate(n.certValidity4GeneralizedTime)), f.length > 2) throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
  if (f.length < 2) throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
  if (a.validity.notBefore = f[0], a.validity.notAfter = f[1], a.tbsCertificate = n.tbsCertificate, e) {
    a.md = cm({ signatureOid: a.signatureOid, type: "certificate" });
    var c = Be.toDer(a.tbsCertificate);
    a.md.update(c.getBytes());
  }
  var l = mr.md.sha1.create(), h = Be.toDer(n.certIssuer);
  l.update(h.getBytes()), a.issuer.getField = function(b) {
    return ol(a.issuer, b);
  }, a.issuer.addField = function(b) {
    ia([b]), a.issuer.attributes.push(b);
  }, a.issuer.attributes = Ot.RDNAttributesAsArray(n.certIssuer), n.certIssuerUniqueId && (a.issuer.uniqueId = n.certIssuerUniqueId), a.issuer.hash = l.digest().toHex();
  var m = mr.md.sha1.create(), v = Be.toDer(n.certSubject);
  return m.update(v.getBytes()), a.subject.getField = function(b) {
    return ol(a.subject, b);
  }, a.subject.addField = function(b) {
    ia([b]), a.subject.attributes.push(b);
  }, a.subject.attributes = Ot.RDNAttributesAsArray(n.certSubject), n.certSubjectUniqueId && (a.subject.uniqueId = n.certSubjectUniqueId), a.subject.hash = m.digest().toHex(), n.certExtensions ? a.extensions = Ot.certificateExtensionsFromAsn1(n.certExtensions) : a.extensions = [], a.publicKey = Ot.publicKeyFromAsn1(n.subjectPublicKeyInfo), a;
};
Ot.certificateExtensionsFromAsn1 = function(t3) {
  for (var e = [], n = 0; n < t3.value.length; ++n) for (var r = t3.value[n], s = 0; s < r.value.length; ++s) e.push(Ot.certificateExtensionFromAsn1(r.value[s]));
  return e;
};
Ot.certificateExtensionFromAsn1 = function(t3) {
  var e = {};
  if (e.id = Be.derToOid(t3.value[0].value), e.critical = false, t3.value[1].type === Be.Type.BOOLEAN ? (e.critical = t3.value[1].value.charCodeAt(0) !== 0, e.value = t3.value[2].value) : e.value = t3.value[1].value, e.id in Xr) {
    if (e.name = Xr[e.id], e.name === "keyUsage") {
      var n = Be.fromDer(e.value), r = 0, s = 0;
      n.value.length > 1 && (r = n.value.charCodeAt(1), s = n.value.length > 2 ? n.value.charCodeAt(2) : 0), e.digitalSignature = (r & 128) === 128, e.nonRepudiation = (r & 64) === 64, e.keyEncipherment = (r & 32) === 32, e.dataEncipherment = (r & 16) === 16, e.keyAgreement = (r & 8) === 8, e.keyCertSign = (r & 4) === 4, e.cRLSign = (r & 2) === 2, e.encipherOnly = (r & 1) === 1, e.decipherOnly = (s & 128) === 128;
    } else if (e.name === "basicConstraints") {
      var n = Be.fromDer(e.value);
      n.value.length > 0 && n.value[0].type === Be.Type.BOOLEAN ? e.cA = n.value[0].value.charCodeAt(0) !== 0 : e.cA = false;
      var i = null;
      n.value.length > 0 && n.value[0].type === Be.Type.INTEGER ? i = n.value[0].value : n.value.length > 1 && (i = n.value[1].value), i !== null && (e.pathLenConstraint = Be.derToInteger(i));
    } else if (e.name === "extKeyUsage") for (var n = Be.fromDer(e.value), a = 0; a < n.value.length; ++a) {
      var o = Be.derToOid(n.value[a].value);
      o in Xr ? e[Xr[o]] = true : e[o] = true;
    }
    else if (e.name === "nsCertType") {
      var n = Be.fromDer(e.value), r = 0;
      n.value.length > 1 && (r = n.value.charCodeAt(1)), e.client = (r & 128) === 128, e.server = (r & 64) === 64, e.email = (r & 32) === 32, e.objsign = (r & 16) === 16, e.reserved = (r & 8) === 8, e.sslCA = (r & 4) === 4, e.emailCA = (r & 2) === 2, e.objCA = (r & 1) === 1;
    } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
      e.altNames = [];
      for (var f, n = Be.fromDer(e.value), c = 0; c < n.value.length; ++c) {
        f = n.value[c];
        var l = { type: f.type, value: f.value };
        switch (e.altNames.push(l), f.type) {
          case 1:
          case 2:
          case 6:
            break;
          case 7:
            l.ip = mr.util.bytesToIP(f.value);
            break;
          case 8:
            l.oid = Be.derToOid(f.value);
            break;
        }
      }
    } else if (e.name === "subjectKeyIdentifier") {
      var n = Be.fromDer(e.value);
      e.subjectKeyIdentifier = mr.util.bytesToHex(n.value);
    }
  }
  return e;
};
Ot.certificationRequestFromAsn1 = function(t3, e) {
  var n = {}, r = [];
  if (!Be.validate(t3, vte, n, r)) {
    var s = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");
    throw s.errors = r, s;
  }
  var i = Be.derToOid(n.publicKeyOid);
  if (i !== Ot.oids.rsaEncryption) throw new Error("Cannot read public key. OID is not RSA.");
  var a = Ot.createCertificationRequest();
  if (a.version = n.csrVersion ? n.csrVersion.charCodeAt(0) : 0, a.signatureOid = mr.asn1.derToOid(n.csrSignatureOid), a.signatureParameters = R1(a.signatureOid, n.csrSignatureParams, true), a.siginfo.algorithmOid = mr.asn1.derToOid(n.csrSignatureOid), a.siginfo.parameters = R1(a.siginfo.algorithmOid, n.csrSignatureParams, false), a.signature = n.csrSignature, a.certificationRequestInfo = n.certificationRequestInfo, e) {
    a.md = cm({ signatureOid: a.signatureOid, type: "certification request" });
    var o = Be.toDer(a.certificationRequestInfo);
    a.md.update(o.getBytes());
  }
  var f = mr.md.sha1.create();
  return a.subject.getField = function(c) {
    return ol(a.subject, c);
  }, a.subject.addField = function(c) {
    ia([c]), a.subject.attributes.push(c);
  }, a.subject.attributes = Ot.RDNAttributesAsArray(n.certificationRequestInfoSubject, f), a.subject.hash = f.digest().toHex(), a.publicKey = Ot.publicKeyFromAsn1(n.subjectPublicKeyInfo), a.getAttribute = function(c) {
    return ol(a, c);
  }, a.addAttribute = function(c) {
    ia([c]), a.attributes.push(c);
  }, a.attributes = Ot.CRIAttributesAsArray(n.certificationRequestInfoAttributes || []), a;
};
Ot.createCertificationRequest = function() {
  var t3 = {};
  return t3.version = 0, t3.signatureOid = null, t3.signature = null, t3.siginfo = {}, t3.siginfo.algorithmOid = null, t3.subject = {}, t3.subject.getField = function(e) {
    return ol(t3.subject, e);
  }, t3.subject.addField = function(e) {
    ia([e]), t3.subject.attributes.push(e);
  }, t3.subject.attributes = [], t3.subject.hash = null, t3.publicKey = null, t3.attributes = [], t3.getAttribute = function(e) {
    return ol(t3, e);
  }, t3.addAttribute = function(e) {
    ia([e]), t3.attributes.push(e);
  }, t3.md = null, t3.setSubject = function(e) {
    ia(e), t3.subject.attributes = e, t3.subject.hash = null;
  }, t3.setAttributes = function(e) {
    ia(e), t3.attributes = e;
  }, t3.sign = function(e, n) {
    t3.md = n || mr.md.sha1.create();
    var r = Xr[t3.md.algorithm + "WithRSAEncryption"];
    if (!r) {
      var s = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
      throw s.algorithm = t3.md.algorithm, s;
    }
    t3.signatureOid = t3.siginfo.algorithmOid = r, t3.certificationRequestInfo = Ot.getCertificationRequestInfo(t3);
    var i = Be.toDer(t3.certificationRequestInfo);
    t3.md.update(i.getBytes()), t3.signature = e.sign(t3.md);
  }, t3.verify = function() {
    var e = false, n = t3.md;
    if (n === null) {
      n = cm({ signatureOid: t3.signatureOid, type: "certification request" });
      var r = t3.certificationRequestInfo || Ot.getCertificationRequestInfo(t3), s = Be.toDer(r);
      n.update(s.getBytes());
    }
    return n !== null && (e = ST({ certificate: t3, md: n, signature: t3.signature })), e;
  }, t3;
};
function Uu(t3) {
  for (var e = Be.create(Be.Class.UNIVERSAL, Be.Type.SEQUENCE, true, []), n, r, s = t3.attributes, i = 0; i < s.length; ++i) {
    n = s[i];
    var a = n.value, o = Be.Type.PRINTABLESTRING;
    "valueTagClass" in n && (o = n.valueTagClass, o === Be.Type.UTF8 && (a = mr.util.encodeUtf8(a))), r = Be.create(Be.Class.UNIVERSAL, Be.Type.SET, true, [Be.create(Be.Class.UNIVERSAL, Be.Type.SEQUENCE, true, [Be.create(Be.Class.UNIVERSAL, Be.Type.OID, false, Be.oidToDer(n.type).getBytes()), Be.create(Be.Class.UNIVERSAL, o, false, a)])]), e.value.push(r);
  }
  return e;
}
function ia(t3) {
  for (var e, n = 0; n < t3.length; ++n) {
    if (e = t3[n], typeof e.name > "u" && (e.type && e.type in Ot.oids ? e.name = Ot.oids[e.type] : e.shortName && e.shortName in Gn && (e.name = Ot.oids[Gn[e.shortName]])), typeof e.type > "u") if (e.name && e.name in Ot.oids) e.type = Ot.oids[e.name];
    else {
      var r = new Error("Attribute type not specified.");
      throw r.attribute = e, r;
    }
    if (typeof e.shortName > "u" && e.name && e.name in Gn && (e.shortName = Gn[e.name]), e.type === Xr.extensionRequest && (e.valueConstructed = true, e.valueTagClass = Be.Type.SEQUENCE, !e.value && e.extensions)) {
      e.value = [];
      for (var s = 0; s < e.extensions.length; ++s) e.value.push(Ot.certificateExtensionToAsn1(MT(e.extensions[s])));
    }
    if (typeof e.value > "u") {
      var r = new Error("Attribute value not specified.");
      throw r.attribute = e, r;
    }
  }
}
function MT(t3, e) {
  if (e = e || {}, typeof t3.name > "u" && t3.id && t3.id in Ot.oids && (t3.name = Ot.oids[t3.id]), typeof t3.id > "u") if (t3.name && t3.name in Ot.oids) t3.id = Ot.oids[t3.name];
  else {
    var n = new Error("Extension ID not specified.");
    throw n.extension = t3, n;
  }
  if (typeof t3.value < "u") return t3;
  if (t3.name === "keyUsage") {
    var r = 0, s = 0, i = 0;
    t3.digitalSignature && (s |= 128, r = 7), t3.nonRepudiation && (s |= 64, r = 6), t3.keyEncipherment && (s |= 32, r = 5), t3.dataEncipherment && (s |= 16, r = 4), t3.keyAgreement && (s |= 8, r = 3), t3.keyCertSign && (s |= 4, r = 2), t3.cRLSign && (s |= 2, r = 1), t3.encipherOnly && (s |= 1, r = 0), t3.decipherOnly && (i |= 128, r = 7);
    var a = String.fromCharCode(r);
    i !== 0 ? a += String.fromCharCode(s) + String.fromCharCode(i) : s !== 0 && (a += String.fromCharCode(s)), t3.value = Be.create(Be.Class.UNIVERSAL, Be.Type.BITSTRING, false, a);
  } else if (t3.name === "basicConstraints") t3.value = Be.create(Be.Class.UNIVERSAL, Be.Type.SEQUENCE, true, []), t3.cA && t3.value.value.push(Be.create(Be.Class.UNIVERSAL, Be.Type.BOOLEAN, false, "\xFF")), "pathLenConstraint" in t3 && t3.value.value.push(Be.create(Be.Class.UNIVERSAL, Be.Type.INTEGER, false, Be.integerToDer(t3.pathLenConstraint).getBytes()));
  else if (t3.name === "extKeyUsage") {
    t3.value = Be.create(Be.Class.UNIVERSAL, Be.Type.SEQUENCE, true, []);
    var o = t3.value.value;
    for (var f in t3) t3[f] === true && (f in Xr ? o.push(Be.create(Be.Class.UNIVERSAL, Be.Type.OID, false, Be.oidToDer(Xr[f]).getBytes())) : f.indexOf(".") !== -1 && o.push(Be.create(Be.Class.UNIVERSAL, Be.Type.OID, false, Be.oidToDer(f).getBytes())));
  } else if (t3.name === "nsCertType") {
    var r = 0, s = 0;
    t3.client && (s |= 128, r = 7), t3.server && (s |= 64, r = 6), t3.email && (s |= 32, r = 5), t3.objsign && (s |= 16, r = 4), t3.reserved && (s |= 8, r = 3), t3.sslCA && (s |= 4, r = 2), t3.emailCA && (s |= 2, r = 1), t3.objCA && (s |= 1, r = 0);
    var a = String.fromCharCode(r);
    s !== 0 && (a += String.fromCharCode(s)), t3.value = Be.create(Be.Class.UNIVERSAL, Be.Type.BITSTRING, false, a);
  } else if (t3.name === "subjectAltName" || t3.name === "issuerAltName") {
    t3.value = Be.create(Be.Class.UNIVERSAL, Be.Type.SEQUENCE, true, []);
    for (var c, l = 0; l < t3.altNames.length; ++l) {
      c = t3.altNames[l];
      var a = c.value;
      if (c.type === 7 && c.ip) {
        if (a = mr.util.bytesFromIP(c.ip), a === null) {
          var n = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');
          throw n.extension = t3, n;
        }
      } else c.type === 8 && (c.oid ? a = Be.oidToDer(Be.oidToDer(c.oid)) : a = Be.oidToDer(a));
      t3.value.value.push(Be.create(Be.Class.CONTEXT_SPECIFIC, c.type, false, a));
    }
  } else if (t3.name === "nsComment" && e.cert) {
    if (!/^[\x00-\x7F]*$/.test(t3.comment) || t3.comment.length < 1 || t3.comment.length > 128) throw new Error('Invalid "nsComment" content.');
    t3.value = Be.create(Be.Class.UNIVERSAL, Be.Type.IA5STRING, false, t3.comment);
  } else if (t3.name === "subjectKeyIdentifier" && e.cert) {
    var h = e.cert.generateSubjectKeyIdentifier();
    t3.subjectKeyIdentifier = h.toHex(), t3.value = Be.create(Be.Class.UNIVERSAL, Be.Type.OCTETSTRING, false, h.getBytes());
  } else if (t3.name === "authorityKeyIdentifier" && e.cert) {
    t3.value = Be.create(Be.Class.UNIVERSAL, Be.Type.SEQUENCE, true, []);
    var o = t3.value.value;
    if (t3.keyIdentifier) {
      var m = t3.keyIdentifier === true ? e.cert.generateSubjectKeyIdentifier().getBytes() : t3.keyIdentifier;
      o.push(Be.create(Be.Class.CONTEXT_SPECIFIC, 0, false, m));
    }
    if (t3.authorityCertIssuer) {
      var v = [Be.create(Be.Class.CONTEXT_SPECIFIC, 4, true, [Uu(t3.authorityCertIssuer === true ? e.cert.issuer : t3.authorityCertIssuer)])];
      o.push(Be.create(Be.Class.CONTEXT_SPECIFIC, 1, true, v));
    }
    if (t3.serialNumber) {
      var b = mr.util.hexToBytes(t3.serialNumber === true ? e.cert.serialNumber : t3.serialNumber);
      o.push(Be.create(Be.Class.CONTEXT_SPECIFIC, 2, false, b));
    }
  } else if (t3.name === "cRLDistributionPoints") {
    t3.value = Be.create(Be.Class.UNIVERSAL, Be.Type.SEQUENCE, true, []);
    for (var o = t3.value.value, A = Be.create(Be.Class.UNIVERSAL, Be.Type.SEQUENCE, true, []), _ = Be.create(Be.Class.CONTEXT_SPECIFIC, 0, true, []), c, l = 0; l < t3.altNames.length; ++l) {
      c = t3.altNames[l];
      var a = c.value;
      if (c.type === 7 && c.ip) {
        if (a = mr.util.bytesFromIP(c.ip), a === null) {
          var n = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');
          throw n.extension = t3, n;
        }
      } else c.type === 8 && (c.oid ? a = Be.oidToDer(Be.oidToDer(c.oid)) : a = Be.oidToDer(a));
      _.value.push(Be.create(Be.Class.CONTEXT_SPECIFIC, c.type, false, a));
    }
    A.value.push(Be.create(Be.Class.CONTEXT_SPECIFIC, 0, true, [_])), o.push(A);
  }
  if (typeof t3.value > "u") {
    var n = new Error("Extension value not specified.");
    throw n.extension = t3, n;
  }
  return t3;
}
function l4(t3, e) {
  switch (t3) {
    case Xr["RSASSA-PSS"]:
      var n = [];
      return e.hash.algorithmOid !== void 0 && n.push(Be.create(Be.Class.CONTEXT_SPECIFIC, 0, true, [Be.create(Be.Class.UNIVERSAL, Be.Type.SEQUENCE, true, [Be.create(Be.Class.UNIVERSAL, Be.Type.OID, false, Be.oidToDer(e.hash.algorithmOid).getBytes()), Be.create(Be.Class.UNIVERSAL, Be.Type.NULL, false, "")])])), e.mgf.algorithmOid !== void 0 && n.push(Be.create(Be.Class.CONTEXT_SPECIFIC, 1, true, [Be.create(Be.Class.UNIVERSAL, Be.Type.SEQUENCE, true, [Be.create(Be.Class.UNIVERSAL, Be.Type.OID, false, Be.oidToDer(e.mgf.algorithmOid).getBytes()), Be.create(Be.Class.UNIVERSAL, Be.Type.SEQUENCE, true, [Be.create(Be.Class.UNIVERSAL, Be.Type.OID, false, Be.oidToDer(e.mgf.hash.algorithmOid).getBytes()), Be.create(Be.Class.UNIVERSAL, Be.Type.NULL, false, "")])])])), e.saltLength !== void 0 && n.push(Be.create(Be.Class.CONTEXT_SPECIFIC, 2, true, [Be.create(Be.Class.UNIVERSAL, Be.Type.INTEGER, false, Be.integerToDer(e.saltLength).getBytes())])), Be.create(Be.Class.UNIVERSAL, Be.Type.SEQUENCE, true, n);
    default:
      return Be.create(Be.Class.UNIVERSAL, Be.Type.NULL, false, "");
  }
}
function yte(t3) {
  var e = Be.create(Be.Class.CONTEXT_SPECIFIC, 0, true, []);
  if (t3.attributes.length === 0) return e;
  for (var n = t3.attributes, r = 0; r < n.length; ++r) {
    var s = n[r], i = s.value, a = Be.Type.UTF8;
    "valueTagClass" in s && (a = s.valueTagClass), a === Be.Type.UTF8 && (i = mr.util.encodeUtf8(i));
    var o = false;
    "valueConstructed" in s && (o = s.valueConstructed);
    var f = Be.create(Be.Class.UNIVERSAL, Be.Type.SEQUENCE, true, [Be.create(Be.Class.UNIVERSAL, Be.Type.OID, false, Be.oidToDer(s.type).getBytes()), Be.create(Be.Class.UNIVERSAL, Be.Type.SET, true, [Be.create(Be.Class.UNIVERSAL, a, o, i)])]);
    e.value.push(f);
  }
  return e;
}
var bte = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z"), Ate = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z");
function Rx(t3) {
  return t3 >= bte && t3 < Ate ? Be.create(Be.Class.UNIVERSAL, Be.Type.UTCTIME, false, Be.dateToUtcTime(t3)) : Be.create(Be.Class.UNIVERSAL, Be.Type.GENERALIZEDTIME, false, Be.dateToGeneralizedTime(t3));
}
Ot.getTBSCertificate = function(t3) {
  var e = Rx(t3.validity.notBefore), n = Rx(t3.validity.notAfter), r = Be.create(Be.Class.UNIVERSAL, Be.Type.SEQUENCE, true, [Be.create(Be.Class.CONTEXT_SPECIFIC, 0, true, [Be.create(Be.Class.UNIVERSAL, Be.Type.INTEGER, false, Be.integerToDer(t3.version).getBytes())]), Be.create(Be.Class.UNIVERSAL, Be.Type.INTEGER, false, mr.util.hexToBytes(t3.serialNumber)), Be.create(Be.Class.UNIVERSAL, Be.Type.SEQUENCE, true, [Be.create(Be.Class.UNIVERSAL, Be.Type.OID, false, Be.oidToDer(t3.siginfo.algorithmOid).getBytes()), l4(t3.siginfo.algorithmOid, t3.siginfo.parameters)]), Uu(t3.issuer), Be.create(Be.Class.UNIVERSAL, Be.Type.SEQUENCE, true, [e, n]), Uu(t3.subject), Ot.publicKeyToAsn1(t3.publicKey)]);
  return t3.issuer.uniqueId && r.value.push(Be.create(Be.Class.CONTEXT_SPECIFIC, 1, true, [Be.create(Be.Class.UNIVERSAL, Be.Type.BITSTRING, false, "\0" + t3.issuer.uniqueId)])), t3.subject.uniqueId && r.value.push(Be.create(Be.Class.CONTEXT_SPECIFIC, 2, true, [Be.create(Be.Class.UNIVERSAL, Be.Type.BITSTRING, false, "\0" + t3.subject.uniqueId)])), t3.extensions.length > 0 && r.value.push(Ot.certificateExtensionsToAsn1(t3.extensions)), r;
};
Ot.getCertificationRequestInfo = function(t3) {
  var e = Be.create(Be.Class.UNIVERSAL, Be.Type.SEQUENCE, true, [Be.create(Be.Class.UNIVERSAL, Be.Type.INTEGER, false, Be.integerToDer(t3.version).getBytes()), Uu(t3.subject), Ot.publicKeyToAsn1(t3.publicKey), yte(t3)]);
  return e;
};
Ot.distinguishedNameToAsn1 = function(t3) {
  return Uu(t3);
};
Ot.certificateToAsn1 = function(t3) {
  var e = t3.tbsCertificate || Ot.getTBSCertificate(t3);
  return Be.create(Be.Class.UNIVERSAL, Be.Type.SEQUENCE, true, [e, Be.create(Be.Class.UNIVERSAL, Be.Type.SEQUENCE, true, [Be.create(Be.Class.UNIVERSAL, Be.Type.OID, false, Be.oidToDer(t3.signatureOid).getBytes()), l4(t3.signatureOid, t3.signatureParameters)]), Be.create(Be.Class.UNIVERSAL, Be.Type.BITSTRING, false, "\0" + t3.signature)]);
};
Ot.certificateExtensionsToAsn1 = function(t3) {
  var e = Be.create(Be.Class.CONTEXT_SPECIFIC, 3, true, []), n = Be.create(Be.Class.UNIVERSAL, Be.Type.SEQUENCE, true, []);
  e.value.push(n);
  for (var r = 0; r < t3.length; ++r) n.value.push(Ot.certificateExtensionToAsn1(t3[r]));
  return e;
};
Ot.certificateExtensionToAsn1 = function(t3) {
  var e = Be.create(Be.Class.UNIVERSAL, Be.Type.SEQUENCE, true, []);
  e.value.push(Be.create(Be.Class.UNIVERSAL, Be.Type.OID, false, Be.oidToDer(t3.id).getBytes())), t3.critical && e.value.push(Be.create(Be.Class.UNIVERSAL, Be.Type.BOOLEAN, false, "\xFF"));
  var n = t3.value;
  return typeof t3.value != "string" && (n = Be.toDer(n).getBytes()), e.value.push(Be.create(Be.Class.UNIVERSAL, Be.Type.OCTETSTRING, false, n)), e;
};
Ot.certificationRequestToAsn1 = function(t3) {
  var e = t3.certificationRequestInfo || Ot.getCertificationRequestInfo(t3);
  return Be.create(Be.Class.UNIVERSAL, Be.Type.SEQUENCE, true, [e, Be.create(Be.Class.UNIVERSAL, Be.Type.SEQUENCE, true, [Be.create(Be.Class.UNIVERSAL, Be.Type.OID, false, Be.oidToDer(t3.signatureOid).getBytes()), l4(t3.signatureOid, t3.signatureParameters)]), Be.create(Be.Class.UNIVERSAL, Be.Type.BITSTRING, false, "\0" + t3.signature)]);
};
Ot.createCaStore = function(t3) {
  var e = { certs: {} };
  e.getIssuer = function(a) {
    var o = n(a.issuer);
    return o;
  }, e.addCertificate = function(a) {
    if (typeof a == "string" && (a = mr.pki.certificateFromPem(a)), r(a.subject), !e.hasCertificate(a)) if (a.subject.hash in e.certs) {
      var o = e.certs[a.subject.hash];
      mr.util.isArray(o) || (o = [o]), o.push(a), e.certs[a.subject.hash] = o;
    } else e.certs[a.subject.hash] = a;
  }, e.hasCertificate = function(a) {
    typeof a == "string" && (a = mr.pki.certificateFromPem(a));
    var o = n(a.subject);
    if (!o) return false;
    mr.util.isArray(o) || (o = [o]);
    for (var f = Be.toDer(Ot.certificateToAsn1(a)).getBytes(), c = 0; c < o.length; ++c) {
      var l = Be.toDer(Ot.certificateToAsn1(o[c])).getBytes();
      if (f === l) return true;
    }
    return false;
  }, e.listAllCertificates = function() {
    var a = [];
    for (var o in e.certs) if (e.certs.hasOwnProperty(o)) {
      var f = e.certs[o];
      if (!mr.util.isArray(f)) a.push(f);
      else for (var c = 0; c < f.length; ++c) a.push(f[c]);
    }
    return a;
  }, e.removeCertificate = function(a) {
    var o;
    if (typeof a == "string" && (a = mr.pki.certificateFromPem(a)), r(a.subject), !e.hasCertificate(a)) return null;
    var f = n(a.subject);
    if (!mr.util.isArray(f)) return o = e.certs[a.subject.hash], delete e.certs[a.subject.hash], o;
    for (var c = Be.toDer(Ot.certificateToAsn1(a)).getBytes(), l = 0; l < f.length; ++l) {
      var h = Be.toDer(Ot.certificateToAsn1(f[l])).getBytes();
      c === h && (o = f[l], f.splice(l, 1));
    }
    return f.length === 0 && delete e.certs[a.subject.hash], o;
  };
  function n(a) {
    return r(a), e.certs[a.hash] || null;
  }
  function r(a) {
    if (!a.hash) {
      var o = mr.md.sha1.create();
      a.attributes = Ot.RDNAttributesAsArray(Uu(a), o), a.hash = o.digest().toHex();
    }
  }
  if (t3) for (var s = 0; s < t3.length; ++s) {
    var i = t3[s];
    e.addCertificate(i);
  }
  return e;
};
Ot.certificateError = { bad_certificate: "forge.pki.BadCertificate", unsupported_certificate: "forge.pki.UnsupportedCertificate", certificate_revoked: "forge.pki.CertificateRevoked", certificate_expired: "forge.pki.CertificateExpired", certificate_unknown: "forge.pki.CertificateUnknown", unknown_ca: "forge.pki.UnknownCertificateAuthority" };
Ot.verifyCertificateChain = function(t3, e, n) {
  typeof n == "function" && (n = { verify: n }), n = n || {}, e = e.slice(0);
  var r = e.slice(0), s = n.validityCheckDate;
  typeof s > "u" && (s = /* @__PURE__ */ new Date());
  var i = true, a = null, o = 0;
  do {
    var f = e.shift(), c = null, l = false;
    if (s && (s < f.validity.notBefore || s > f.validity.notAfter) && (a = { message: "Certificate is not valid yet or has expired.", error: Ot.certificateError.certificate_expired, notBefore: f.validity.notBefore, notAfter: f.validity.notAfter, now: s }), a === null) {
      if (c = e[0] || t3.getIssuer(f), c === null && f.isIssuer(f) && (l = true, c = f), c) {
        var h = c;
        mr.util.isArray(h) || (h = [h]);
        for (var m = false; !m && h.length > 0; ) {
          c = h.shift();
          try {
            m = c.verify(f);
          } catch {
          }
        }
        m || (a = { message: "Certificate signature is invalid.", error: Ot.certificateError.bad_certificate });
      }
      a === null && (!c || l) && !t3.hasCertificate(f) && (a = { message: "Certificate is not trusted.", error: Ot.certificateError.unknown_ca });
    }
    if (a === null && c && !f.isIssuer(c) && (a = { message: "Certificate issuer is invalid.", error: Ot.certificateError.bad_certificate }), a === null) for (var v = { keyUsage: true, basicConstraints: true }, b = 0; a === null && b < f.extensions.length; ++b) {
      var A = f.extensions[b];
      A.critical && !(A.name in v) && (a = { message: "Certificate has an unsupported critical extension.", error: Ot.certificateError.unsupported_certificate });
    }
    if (a === null && (!i || e.length === 0 && (!c || l))) {
      var _ = f.getExtension("basicConstraints"), C = f.getExtension("keyUsage");
      if (C !== null && (!C.keyCertSign || _ === null) && (a = { message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.", error: Ot.certificateError.bad_certificate }), a === null && _ !== null && !_.cA && (a = { message: "Certificate basicConstraints indicates the certificate is not a CA.", error: Ot.certificateError.bad_certificate }), a === null && C !== null && "pathLenConstraint" in _) {
        var I = o - 1;
        I > _.pathLenConstraint && (a = { message: "Certificate basicConstraints pathLenConstraint violated.", error: Ot.certificateError.bad_certificate });
      }
    }
    var S = a === null ? true : a.error, $ = n.verify ? n.verify(S, o, r) : S;
    if ($ === true) a = null;
    else throw S === true && (a = { message: "The application rejected the certificate.", error: Ot.certificateError.bad_certificate }), ($ || $ === 0) && (typeof $ == "object" && !mr.util.isArray($) ? ($.message && (a.message = $.message), $.error && (a.error = $.error)) : typeof $ == "string" && (a.error = $)), a;
    i = false, ++o;
  } while (e.length > 0);
  return true;
};
var bn = Ur, Ke = bn.asn1, Qr = bn.pki, Uh = bn.pkcs12 = bn.pkcs12 || {}, $T = { name: "ContentInfo", tagClass: Ke.Class.UNIVERSAL, type: Ke.Type.SEQUENCE, constructed: true, value: [{ name: "ContentInfo.contentType", tagClass: Ke.Class.UNIVERSAL, type: Ke.Type.OID, constructed: false, capture: "contentType" }, { name: "ContentInfo.content", tagClass: Ke.Class.CONTEXT_SPECIFIC, constructed: true, captureAsn1: "content" }] }, wte = { name: "PFX", tagClass: Ke.Class.UNIVERSAL, type: Ke.Type.SEQUENCE, constructed: true, value: [{ name: "PFX.version", tagClass: Ke.Class.UNIVERSAL, type: Ke.Type.INTEGER, constructed: false, capture: "version" }, $T, { name: "PFX.macData", tagClass: Ke.Class.UNIVERSAL, type: Ke.Type.SEQUENCE, constructed: true, optional: true, captureAsn1: "mac", value: [{ name: "PFX.macData.mac", tagClass: Ke.Class.UNIVERSAL, type: Ke.Type.SEQUENCE, constructed: true, value: [{ name: "PFX.macData.mac.digestAlgorithm", tagClass: Ke.Class.UNIVERSAL, type: Ke.Type.SEQUENCE, constructed: true, value: [{ name: "PFX.macData.mac.digestAlgorithm.algorithm", tagClass: Ke.Class.UNIVERSAL, type: Ke.Type.OID, constructed: false, capture: "macAlgorithm" }, { name: "PFX.macData.mac.digestAlgorithm.parameters", optional: true, tagClass: Ke.Class.UNIVERSAL, captureAsn1: "macAlgorithmParameters" }] }, { name: "PFX.macData.mac.digest", tagClass: Ke.Class.UNIVERSAL, type: Ke.Type.OCTETSTRING, constructed: false, capture: "macDigest" }] }, { name: "PFX.macData.macSalt", tagClass: Ke.Class.UNIVERSAL, type: Ke.Type.OCTETSTRING, constructed: false, capture: "macSalt" }, { name: "PFX.macData.iterations", tagClass: Ke.Class.UNIVERSAL, type: Ke.Type.INTEGER, constructed: false, optional: true, capture: "macIterations" }] }] }, xte = { name: "SafeBag", tagClass: Ke.Class.UNIVERSAL, type: Ke.Type.SEQUENCE, constructed: true, value: [{ name: "SafeBag.bagId", tagClass: Ke.Class.UNIVERSAL, type: Ke.Type.OID, constructed: false, capture: "bagId" }, { name: "SafeBag.bagValue", tagClass: Ke.Class.CONTEXT_SPECIFIC, constructed: true, captureAsn1: "bagValue" }, { name: "SafeBag.bagAttributes", tagClass: Ke.Class.UNIVERSAL, type: Ke.Type.SET, constructed: true, optional: true, capture: "bagAttributes" }] }, _te = { name: "Attribute", tagClass: Ke.Class.UNIVERSAL, type: Ke.Type.SEQUENCE, constructed: true, value: [{ name: "Attribute.attrId", tagClass: Ke.Class.UNIVERSAL, type: Ke.Type.OID, constructed: false, capture: "oid" }, { name: "Attribute.attrValues", tagClass: Ke.Class.UNIVERSAL, type: Ke.Type.SET, constructed: true, capture: "values" }] }, Ete = { name: "CertBag", tagClass: Ke.Class.UNIVERSAL, type: Ke.Type.SEQUENCE, constructed: true, value: [{ name: "CertBag.certId", tagClass: Ke.Class.UNIVERSAL, type: Ke.Type.OID, constructed: false, capture: "certId" }, { name: "CertBag.certValue", tagClass: Ke.Class.CONTEXT_SPECIFIC, constructed: true, value: [{ name: "CertBag.certValue[0]", tagClass: Ke.Class.UNIVERSAL, type: Ke.Class.OCTETSTRING, constructed: false, capture: "cert" }] }] };
function Rc(t3, e, n, r) {
  for (var s = [], i = 0; i < t3.length; i++) for (var a = 0; a < t3[i].safeBags.length; a++) {
    var o = t3[i].safeBags[a];
    if (!(r !== void 0 && o.type !== r)) {
      if (e === null) {
        s.push(o);
        continue;
      }
      o.attributes[e] !== void 0 && o.attributes[e].indexOf(n) >= 0 && s.push(o);
    }
  }
  return s;
}
Uh.pkcs12FromAsn1 = function(t3, e, n) {
  typeof e == "string" ? (n = e, e = true) : e === void 0 && (e = true);
  var r = {}, s = [];
  if (!Ke.validate(t3, wte, r, s)) {
    var i = new Error("Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.");
    throw i.errors = i, i;
  }
  var a = { version: r.version.charCodeAt(0), safeContents: [], getBags: function(_) {
    var C = {}, I;
    return "localKeyId" in _ ? I = _.localKeyId : "localKeyIdHex" in _ && (I = bn.util.hexToBytes(_.localKeyIdHex)), I === void 0 && !("friendlyName" in _) && "bagType" in _ && (C[_.bagType] = Rc(a.safeContents, null, null, _.bagType)), I !== void 0 && (C.localKeyId = Rc(a.safeContents, "localKeyId", I, _.bagType)), "friendlyName" in _ && (C.friendlyName = Rc(a.safeContents, "friendlyName", _.friendlyName, _.bagType)), C;
  }, getBagsByFriendlyName: function(_, C) {
    return Rc(a.safeContents, "friendlyName", _, C);
  }, getBagsByLocalKeyId: function(_, C) {
    return Rc(a.safeContents, "localKeyId", _, C);
  } };
  if (r.version.charCodeAt(0) !== 3) {
    var i = new Error("PKCS#12 PFX of version other than 3 not supported.");
    throw i.version = r.version.charCodeAt(0), i;
  }
  if (Ke.derToOid(r.contentType) !== Qr.oids.data) {
    var i = new Error("Only PKCS#12 PFX in password integrity mode supported.");
    throw i.oid = Ke.derToOid(r.contentType), i;
  }
  var o = r.content.value[0];
  if (o.tagClass !== Ke.Class.UNIVERSAL || o.type !== Ke.Type.OCTETSTRING) throw new Error("PKCS#12 authSafe content data is not an OCTET STRING.");
  if (o = u4(o), r.mac) {
    var f = null, c = 0, l = Ke.derToOid(r.macAlgorithm);
    switch (l) {
      case Qr.oids.sha1:
        f = bn.md.sha1.create(), c = 20;
        break;
      case Qr.oids.sha256:
        f = bn.md.sha256.create(), c = 32;
        break;
      case Qr.oids.sha384:
        f = bn.md.sha384.create(), c = 48;
        break;
      case Qr.oids.sha512:
        f = bn.md.sha512.create(), c = 64;
        break;
      case Qr.oids.md5:
        f = bn.md.md5.create(), c = 16;
        break;
    }
    if (f === null) throw new Error("PKCS#12 uses unsupported MAC algorithm: " + l);
    var h = new bn.util.ByteBuffer(r.macSalt), m = "macIterations" in r ? parseInt(bn.util.bytesToHex(r.macIterations), 16) : 1, v = Uh.generateKey(n, h, 3, m, c, f), b = bn.hmac.create();
    b.start(f, v), b.update(o.value);
    var A = b.getMac();
    if (A.getBytes() !== r.macDigest) throw new Error("PKCS#12 MAC could not be verified. Invalid password?");
  } else if (Array.isArray(t3.value) && t3.value.length > 2) throw new Error("Invalid PKCS#12. macData field present but MAC was not validated.");
  return Bte(a, o.value, e, n), a;
};
function u4(t3) {
  if (t3.composed || t3.constructed) {
    for (var e = bn.util.createBuffer(), n = 0; n < t3.value.length; ++n) e.putBytes(t3.value[n].value);
    t3.composed = t3.constructed = false, t3.value = e.getBytes();
  }
  return t3;
}
function Bte(t3, e, n, r) {
  if (e = Ke.fromDer(e, n), e.tagClass !== Ke.Class.UNIVERSAL || e.type !== Ke.Type.SEQUENCE || e.constructed !== true) throw new Error("PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo");
  for (var s = 0; s < e.value.length; s++) {
    var i = e.value[s], a = {}, o = [];
    if (!Ke.validate(i, $T, a, o)) {
      var f = new Error("Cannot read ContentInfo.");
      throw f.errors = o, f;
    }
    var c = { encrypted: false }, l = null, h = a.content.value[0];
    switch (Ke.derToOid(a.contentType)) {
      case Qr.oids.data:
        if (h.tagClass !== Ke.Class.UNIVERSAL || h.type !== Ke.Type.OCTETSTRING) throw new Error("PKCS#12 SafeContents Data is not an OCTET STRING.");
        l = u4(h).value;
        break;
      case Qr.oids.encryptedData:
        l = Cte(h, r), c.encrypted = true;
        break;
      default:
        var f = new Error("Unsupported PKCS#12 contentType.");
        throw f.contentType = Ke.derToOid(a.contentType), f;
    }
    c.safeBags = kte(l, n, r), t3.safeContents.push(c);
  }
}
function Cte(t3, e) {
  var n = {}, r = [];
  if (!Ke.validate(t3, bn.pkcs7.asn1.encryptedDataValidator, n, r)) {
    var s = new Error("Cannot read EncryptedContentInfo.");
    throw s.errors = r, s;
  }
  var i = Ke.derToOid(n.contentType);
  if (i !== Qr.oids.data) {
    var s = new Error("PKCS#12 EncryptedContentInfo ContentType is not Data.");
    throw s.oid = i, s;
  }
  i = Ke.derToOid(n.encAlgorithm);
  var a = Qr.pbe.getCipher(i, n.encParameter, e), o = u4(n.encryptedContentAsn1), f = bn.util.createBuffer(o.value);
  if (a.update(f), !a.finish()) throw new Error("Failed to decrypt PKCS#12 SafeContents.");
  return a.output.getBytes();
}
function kte(t3, e, n) {
  if (!e && t3.length === 0) return [];
  if (t3 = Ke.fromDer(t3, e), t3.tagClass !== Ke.Class.UNIVERSAL || t3.type !== Ke.Type.SEQUENCE || t3.constructed !== true) throw new Error("PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.");
  for (var r = [], s = 0; s < t3.value.length; s++) {
    var i = t3.value[s], a = {}, o = [];
    if (!Ke.validate(i, xte, a, o)) {
      var f = new Error("Cannot read SafeBag.");
      throw f.errors = o, f;
    }
    var c = { type: Ke.derToOid(a.bagId), attributes: Ite(a.bagAttributes) };
    r.push(c);
    var l, h, m = a.bagValue.value[0];
    switch (c.type) {
      case Qr.oids.pkcs8ShroudedKeyBag:
        if (m = Qr.decryptPrivateKeyInfo(m, n), m === null) throw new Error("Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?");
      case Qr.oids.keyBag:
        try {
          c.key = Qr.privateKeyFromAsn1(m);
        } catch {
          c.key = null, c.asn1 = m;
        }
        continue;
      case Qr.oids.certBag:
        l = Ete, h = function() {
          if (Ke.derToOid(a.certId) !== Qr.oids.x509Certificate) {
            var b = new Error("Unsupported certificate type, only X.509 supported.");
            throw b.oid = Ke.derToOid(a.certId), b;
          }
          var A = Ke.fromDer(a.cert, e);
          try {
            c.cert = Qr.certificateFromAsn1(A, true);
          } catch {
            c.cert = null, c.asn1 = A;
          }
        };
        break;
      default:
        var f = new Error("Unsupported PKCS#12 SafeBag type.");
        throw f.oid = c.type, f;
    }
    if (l !== void 0 && !Ke.validate(m, l, a, o)) {
      var f = new Error("Cannot read PKCS#12 " + l.name);
      throw f.errors = o, f;
    }
    h();
  }
  return r;
}
function Ite(t3) {
  var e = {};
  if (t3 !== void 0) for (var n = 0; n < t3.length; ++n) {
    var r = {}, s = [];
    if (!Ke.validate(t3[n], _te, r, s)) {
      var i = new Error("Cannot read PKCS#12 BagAttribute.");
      throw i.errors = s, i;
    }
    var a = Ke.derToOid(r.oid);
    if (Qr.oids[a] !== void 0) {
      e[Qr.oids[a]] = [];
      for (var o = 0; o < r.values.length; ++o) e[Qr.oids[a]].push(r.values[o].value);
    }
  }
  return e;
}
Uh.toPkcs12Asn1 = function(t3, e, n, r) {
  r = r || {}, r.saltSize = r.saltSize || 8, r.count = r.count || 2048, r.algorithm = r.algorithm || r.encAlgorithm || "aes128", "useMac" in r || (r.useMac = true), "localKeyId" in r || (r.localKeyId = null), "generateLocalKeyId" in r || (r.generateLocalKeyId = true);
  var s = r.localKeyId, i;
  if (s !== null) s = bn.util.hexToBytes(s);
  else if (r.generateLocalKeyId) if (e) {
    var a = bn.util.isArray(e) ? e[0] : e;
    typeof a == "string" && (a = Qr.certificateFromPem(a));
    var o = bn.md.sha1.create();
    o.update(Ke.toDer(Qr.certificateToAsn1(a)).getBytes()), s = o.digest().getBytes();
  } else s = bn.random.getBytes(20);
  var f = [];
  s !== null && f.push(Ke.create(Ke.Class.UNIVERSAL, Ke.Type.SEQUENCE, true, [Ke.create(Ke.Class.UNIVERSAL, Ke.Type.OID, false, Ke.oidToDer(Qr.oids.localKeyId).getBytes()), Ke.create(Ke.Class.UNIVERSAL, Ke.Type.SET, true, [Ke.create(Ke.Class.UNIVERSAL, Ke.Type.OCTETSTRING, false, s)])])), "friendlyName" in r && f.push(Ke.create(Ke.Class.UNIVERSAL, Ke.Type.SEQUENCE, true, [Ke.create(Ke.Class.UNIVERSAL, Ke.Type.OID, false, Ke.oidToDer(Qr.oids.friendlyName).getBytes()), Ke.create(Ke.Class.UNIVERSAL, Ke.Type.SET, true, [Ke.create(Ke.Class.UNIVERSAL, Ke.Type.BMPSTRING, false, r.friendlyName)])])), f.length > 0 && (i = Ke.create(Ke.Class.UNIVERSAL, Ke.Type.SET, true, f));
  var c = [], l = [];
  e !== null && (bn.util.isArray(e) ? l = e : l = [e]);
  for (var h = [], m = 0; m < l.length; ++m) {
    e = l[m], typeof e == "string" && (e = Qr.certificateFromPem(e));
    var v = m === 0 ? i : void 0, b = Qr.certificateToAsn1(e), A = Ke.create(Ke.Class.UNIVERSAL, Ke.Type.SEQUENCE, true, [Ke.create(Ke.Class.UNIVERSAL, Ke.Type.OID, false, Ke.oidToDer(Qr.oids.certBag).getBytes()), Ke.create(Ke.Class.CONTEXT_SPECIFIC, 0, true, [Ke.create(Ke.Class.UNIVERSAL, Ke.Type.SEQUENCE, true, [Ke.create(Ke.Class.UNIVERSAL, Ke.Type.OID, false, Ke.oidToDer(Qr.oids.x509Certificate).getBytes()), Ke.create(Ke.Class.CONTEXT_SPECIFIC, 0, true, [Ke.create(Ke.Class.UNIVERSAL, Ke.Type.OCTETSTRING, false, Ke.toDer(b).getBytes())])])]), v]);
    h.push(A);
  }
  if (h.length > 0) {
    var _ = Ke.create(Ke.Class.UNIVERSAL, Ke.Type.SEQUENCE, true, h), C = Ke.create(Ke.Class.UNIVERSAL, Ke.Type.SEQUENCE, true, [Ke.create(Ke.Class.UNIVERSAL, Ke.Type.OID, false, Ke.oidToDer(Qr.oids.data).getBytes()), Ke.create(Ke.Class.CONTEXT_SPECIFIC, 0, true, [Ke.create(Ke.Class.UNIVERSAL, Ke.Type.OCTETSTRING, false, Ke.toDer(_).getBytes())])]);
    c.push(C);
  }
  var I = null;
  if (t3 !== null) {
    var S = Qr.wrapRsaPrivateKey(Qr.privateKeyToAsn1(t3));
    n === null ? I = Ke.create(Ke.Class.UNIVERSAL, Ke.Type.SEQUENCE, true, [Ke.create(Ke.Class.UNIVERSAL, Ke.Type.OID, false, Ke.oidToDer(Qr.oids.keyBag).getBytes()), Ke.create(Ke.Class.CONTEXT_SPECIFIC, 0, true, [S]), i]) : I = Ke.create(Ke.Class.UNIVERSAL, Ke.Type.SEQUENCE, true, [Ke.create(Ke.Class.UNIVERSAL, Ke.Type.OID, false, Ke.oidToDer(Qr.oids.pkcs8ShroudedKeyBag).getBytes()), Ke.create(Ke.Class.CONTEXT_SPECIFIC, 0, true, [Qr.encryptPrivateKeyInfo(S, n, r)]), i]);
    var $ = Ke.create(Ke.Class.UNIVERSAL, Ke.Type.SEQUENCE, true, [I]), F = Ke.create(Ke.Class.UNIVERSAL, Ke.Type.SEQUENCE, true, [Ke.create(Ke.Class.UNIVERSAL, Ke.Type.OID, false, Ke.oidToDer(Qr.oids.data).getBytes()), Ke.create(Ke.Class.CONTEXT_SPECIFIC, 0, true, [Ke.create(Ke.Class.UNIVERSAL, Ke.Type.OCTETSTRING, false, Ke.toDer($).getBytes())])]);
    c.push(F);
  }
  var U = Ke.create(Ke.Class.UNIVERSAL, Ke.Type.SEQUENCE, true, c), Q;
  if (r.useMac) {
    var o = bn.md.sha1.create(), P = new bn.util.ByteBuffer(bn.random.getBytes(r.saltSize)), N = r.count, t3 = Uh.generateKey(n, P, 3, N, 20), L = bn.hmac.create();
    L.start(o, t3), L.update(Ke.toDer(U).getBytes());
    var B = L.getMac();
    Q = Ke.create(Ke.Class.UNIVERSAL, Ke.Type.SEQUENCE, true, [Ke.create(Ke.Class.UNIVERSAL, Ke.Type.SEQUENCE, true, [Ke.create(Ke.Class.UNIVERSAL, Ke.Type.SEQUENCE, true, [Ke.create(Ke.Class.UNIVERSAL, Ke.Type.OID, false, Ke.oidToDer(Qr.oids.sha1).getBytes()), Ke.create(Ke.Class.UNIVERSAL, Ke.Type.NULL, false, "")]), Ke.create(Ke.Class.UNIVERSAL, Ke.Type.OCTETSTRING, false, B.getBytes())]), Ke.create(Ke.Class.UNIVERSAL, Ke.Type.OCTETSTRING, false, P.getBytes()), Ke.create(Ke.Class.UNIVERSAL, Ke.Type.INTEGER, false, Ke.integerToDer(N).getBytes())]);
  }
  return Ke.create(Ke.Class.UNIVERSAL, Ke.Type.SEQUENCE, true, [Ke.create(Ke.Class.UNIVERSAL, Ke.Type.INTEGER, false, Ke.integerToDer(3).getBytes()), Ke.create(Ke.Class.UNIVERSAL, Ke.Type.SEQUENCE, true, [Ke.create(Ke.Class.UNIVERSAL, Ke.Type.OID, false, Ke.oidToDer(Qr.oids.data).getBytes()), Ke.create(Ke.Class.CONTEXT_SPECIFIC, 0, true, [Ke.create(Ke.Class.UNIVERSAL, Ke.Type.OCTETSTRING, false, Ke.toDer(U).getBytes())])]), Q]);
};
Uh.generateKey = bn.pbe.generatePkcs12Key;
var fl = Ur, c4 = fl.asn1, Lu = fl.pki = fl.pki || {};
Lu.pemToDer = function(t3) {
  var e = fl.pem.decode(t3)[0];
  if (e.procType && e.procType.type === "ENCRYPTED") throw new Error("Could not convert PEM to DER; PEM is encrypted.");
  return fl.util.createBuffer(e.body);
};
Lu.privateKeyFromPem = function(t3) {
  var e = fl.pem.decode(t3)[0];
  if (e.type !== "PRIVATE KEY" && e.type !== "RSA PRIVATE KEY") {
    var n = new Error('Could not convert private key from PEM; PEM header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".');
    throw n.headerType = e.type, n;
  }
  if (e.procType && e.procType.type === "ENCRYPTED") throw new Error("Could not convert private key from PEM; PEM is encrypted.");
  var r = c4.fromDer(e.body);
  return Lu.privateKeyFromAsn1(r);
};
Lu.privateKeyToPem = function(t3, e) {
  var n = { type: "RSA PRIVATE KEY", body: c4.toDer(Lu.privateKeyToAsn1(t3)).getBytes() };
  return fl.pem.encode(n, { maxline: e });
};
Lu.privateKeyInfoToPem = function(t3, e) {
  var n = { type: "PRIVATE KEY", body: c4.toDer(t3).getBytes() };
  return fl.pem.encode(n, { maxline: e });
};
var Bt = Ur, hm = function(t3, e, n, r) {
  var s = Bt.util.createBuffer(), i = t3.length >> 1, a = i + (t3.length & 1), o = t3.substr(0, a), f = t3.substr(i, a), c = Bt.util.createBuffer(), l = Bt.hmac.create();
  n = e + n;
  var h = Math.ceil(r / 16), m = Math.ceil(r / 20);
  l.start("MD5", o);
  var v = Bt.util.createBuffer();
  c.putBytes(n);
  for (var b = 0; b < h; ++b) l.start(null, null), l.update(c.getBytes()), c.putBuffer(l.digest()), l.start(null, null), l.update(c.bytes() + n), v.putBuffer(l.digest());
  l.start("SHA1", f);
  var A = Bt.util.createBuffer();
  c.clear(), c.putBytes(n);
  for (var b = 0; b < m; ++b) l.start(null, null), l.update(c.getBytes()), c.putBuffer(l.digest()), l.start(null, null), l.update(c.bytes() + n), A.putBuffer(l.digest());
  return s.putBytes(Bt.util.xorBytes(v.getBytes(), A.getBytes(), r)), s;
}, Ste = function(t3, e, n) {
  var r = Bt.hmac.create();
  r.start("SHA1", t3);
  var s = Bt.util.createBuffer();
  return s.putInt32(e[0]), s.putInt32(e[1]), s.putByte(n.type), s.putByte(n.version.major), s.putByte(n.version.minor), s.putInt16(n.length), s.putBytes(n.fragment.bytes()), r.update(s.getBytes()), r.digest().getBytes();
}, Mte = function(t3, e, n) {
  var r = false;
  try {
    var s = t3.deflate(e.fragment.getBytes());
    e.fragment = Bt.util.createBuffer(s), e.length = s.length, r = true;
  } catch {
  }
  return r;
}, $te = function(t3, e, n) {
  var r = false;
  try {
    var s = t3.inflate(e.fragment.getBytes());
    e.fragment = Bt.util.createBuffer(s), e.length = s.length, r = true;
  } catch {
  }
  return r;
}, Ls = function(t3, e) {
  var n = 0;
  switch (e) {
    case 1:
      n = t3.getByte();
      break;
    case 2:
      n = t3.getInt16();
      break;
    case 3:
      n = t3.getInt24();
      break;
    case 4:
      n = t3.getInt32();
      break;
  }
  return Bt.util.createBuffer(t3.getBytes(n));
}, Xs = function(t3, e, n) {
  t3.putInt(n.length(), e << 3), t3.putBuffer(n);
}, Ie = {};
Ie.Versions = { TLS_1_0: { major: 3, minor: 1 }, TLS_1_1: { major: 3, minor: 2 }, TLS_1_2: { major: 3, minor: 3 } };
Ie.SupportedVersions = [Ie.Versions.TLS_1_1, Ie.Versions.TLS_1_0];
Ie.Version = Ie.SupportedVersions[0];
Ie.MaxFragment = 15360;
Ie.ConnectionEnd = { server: 0, client: 1 };
Ie.PRFAlgorithm = { tls_prf_sha256: 0 };
Ie.BulkCipherAlgorithm = { none: null, rc4: 0, des3: 1, aes: 2 };
Ie.CipherType = { stream: 0, block: 1, aead: 2 };
Ie.MACAlgorithm = { none: null, hmac_md5: 0, hmac_sha1: 1, hmac_sha256: 2, hmac_sha384: 3, hmac_sha512: 4 };
Ie.CompressionMethod = { none: 0, deflate: 1 };
Ie.ContentType = { change_cipher_spec: 20, alert: 21, handshake: 22, application_data: 23, heartbeat: 24 };
Ie.HandshakeType = { hello_request: 0, client_hello: 1, server_hello: 2, certificate: 11, server_key_exchange: 12, certificate_request: 13, server_hello_done: 14, certificate_verify: 15, client_key_exchange: 16, finished: 20 };
Ie.Alert = {};
Ie.Alert.Level = { warning: 1, fatal: 2 };
Ie.Alert.Description = { close_notify: 0, unexpected_message: 10, bad_record_mac: 20, decryption_failed: 21, record_overflow: 22, decompression_failure: 30, handshake_failure: 40, bad_certificate: 42, unsupported_certificate: 43, certificate_revoked: 44, certificate_expired: 45, certificate_unknown: 46, illegal_parameter: 47, unknown_ca: 48, access_denied: 49, decode_error: 50, decrypt_error: 51, export_restriction: 60, protocol_version: 70, insufficient_security: 71, internal_error: 80, user_canceled: 90, no_renegotiation: 100 };
Ie.HeartbeatMessageType = { heartbeat_request: 1, heartbeat_response: 2 };
Ie.CipherSuites = {};
Ie.getCipherSuite = function(t3) {
  var e = null;
  for (var n in Ie.CipherSuites) {
    var r = Ie.CipherSuites[n];
    if (r.id[0] === t3.charCodeAt(0) && r.id[1] === t3.charCodeAt(1)) {
      e = r;
      break;
    }
  }
  return e;
};
Ie.handleUnexpected = function(t3, e) {
  var n = !t3.open && t3.entity === Ie.ConnectionEnd.client;
  n || t3.error(t3, { message: "Unexpected message. Received TLS record out of order.", send: true, alert: { level: Ie.Alert.Level.fatal, description: Ie.Alert.Description.unexpected_message } });
};
Ie.handleHelloRequest = function(t3, e, n) {
  !t3.handshaking && t3.handshakes > 0 && (Ie.queue(t3, Ie.createAlert(t3, { level: Ie.Alert.Level.warning, description: Ie.Alert.Description.no_renegotiation })), Ie.flush(t3)), t3.process();
};
Ie.parseHelloMessage = function(t3, e, n) {
  var r = null, s = t3.entity === Ie.ConnectionEnd.client;
  if (n < 38) t3.error(t3, { message: s ? "Invalid ServerHello message. Message too short." : "Invalid ClientHello message. Message too short.", send: true, alert: { level: Ie.Alert.Level.fatal, description: Ie.Alert.Description.illegal_parameter } });
  else {
    var i = e.fragment, a = i.length();
    if (r = { version: { major: i.getByte(), minor: i.getByte() }, random: Bt.util.createBuffer(i.getBytes(32)), session_id: Ls(i, 1), extensions: [] }, s ? (r.cipher_suite = i.getBytes(2), r.compression_method = i.getByte()) : (r.cipher_suites = Ls(i, 2), r.compression_methods = Ls(i, 1)), a = n - (a - i.length()), a > 0) {
      for (var o = Ls(i, 2); o.length() > 0; ) r.extensions.push({ type: [o.getByte(), o.getByte()], data: Ls(o, 2) });
      if (!s) for (var f = 0; f < r.extensions.length; ++f) {
        var c = r.extensions[f];
        if (c.type[0] === 0 && c.type[1] === 0) for (var l = Ls(c.data, 2); l.length() > 0; ) {
          var h = l.getByte();
          if (h !== 0) break;
          t3.session.extensions.server_name.serverNameList.push(Ls(l, 2).getBytes());
        }
      }
    }
    if (t3.session.version && (r.version.major !== t3.session.version.major || r.version.minor !== t3.session.version.minor)) return t3.error(t3, { message: "TLS version change is disallowed during renegotiation.", send: true, alert: { level: Ie.Alert.Level.fatal, description: Ie.Alert.Description.protocol_version } });
    if (s) t3.session.cipherSuite = Ie.getCipherSuite(r.cipher_suite);
    else for (var m = Bt.util.createBuffer(r.cipher_suites.bytes()); m.length() > 0 && (t3.session.cipherSuite = Ie.getCipherSuite(m.getBytes(2)), t3.session.cipherSuite === null); ) ;
    if (t3.session.cipherSuite === null) return t3.error(t3, { message: "No cipher suites in common.", send: true, alert: { level: Ie.Alert.Level.fatal, description: Ie.Alert.Description.handshake_failure }, cipherSuite: Bt.util.bytesToHex(r.cipher_suite) });
    s ? t3.session.compressionMethod = r.compression_method : t3.session.compressionMethod = Ie.CompressionMethod.none;
  }
  return r;
};
Ie.createSecurityParameters = function(t3, e) {
  var n = t3.entity === Ie.ConnectionEnd.client, r = e.random.bytes(), s = n ? t3.session.sp.client_random : r, i = n ? r : Ie.createRandom().getBytes();
  t3.session.sp = { entity: t3.entity, prf_algorithm: Ie.PRFAlgorithm.tls_prf_sha256, bulk_cipher_algorithm: null, cipher_type: null, enc_key_length: null, block_length: null, fixed_iv_length: null, record_iv_length: null, mac_algorithm: null, mac_length: null, mac_key_length: null, compression_algorithm: t3.session.compressionMethod, pre_master_secret: null, master_secret: null, client_random: s, server_random: i };
};
Ie.handleServerHello = function(t3, e, n) {
  var r = Ie.parseHelloMessage(t3, e, n);
  if (!t3.fail) {
    if (r.version.minor <= t3.version.minor) t3.version.minor = r.version.minor;
    else return t3.error(t3, { message: "Incompatible TLS version.", send: true, alert: { level: Ie.Alert.Level.fatal, description: Ie.Alert.Description.protocol_version } });
    t3.session.version = t3.version;
    var s = r.session_id.bytes();
    s.length > 0 && s === t3.session.id ? (t3.expect = TT, t3.session.resuming = true, t3.session.sp.server_random = r.random.bytes()) : (t3.expect = Dte, t3.session.resuming = false, Ie.createSecurityParameters(t3, r)), t3.session.id = s, t3.process();
  }
};
Ie.handleClientHello = function(t3, e, n) {
  var r = Ie.parseHelloMessage(t3, e, n);
  if (!t3.fail) {
    var s = r.session_id.bytes(), i = null;
    if (t3.sessionCache && (i = t3.sessionCache.getSession(s), i === null ? s = "" : (i.version.major !== r.version.major || i.version.minor > r.version.minor) && (i = null, s = "")), s.length === 0 && (s = Bt.random.getBytes(32)), t3.session.id = s, t3.session.clientHelloVersion = r.version, t3.session.sp = {}, i) t3.version = t3.session.version = i.version, t3.session.sp = i.sp;
    else {
      for (var a, o = 1; o < Ie.SupportedVersions.length && (a = Ie.SupportedVersions[o], !(a.minor <= r.version.minor)); ++o) ;
      t3.version = { major: a.major, minor: a.minor }, t3.session.version = t3.version;
    }
    i !== null ? (t3.expect = h4, t3.session.resuming = true, t3.session.sp.client_random = r.random.bytes()) : (t3.expect = t3.verifyClient !== false ? Ote : ob, t3.session.resuming = false, Ie.createSecurityParameters(t3, r)), t3.open = true, Ie.queue(t3, Ie.createRecord(t3, { type: Ie.ContentType.handshake, data: Ie.createServerHello(t3) })), t3.session.resuming ? (Ie.queue(t3, Ie.createRecord(t3, { type: Ie.ContentType.change_cipher_spec, data: Ie.createChangeCipherSpec() })), t3.state.pending = Ie.createConnectionState(t3), t3.state.current.write = t3.state.pending.write, Ie.queue(t3, Ie.createRecord(t3, { type: Ie.ContentType.handshake, data: Ie.createFinished(t3) }))) : (Ie.queue(t3, Ie.createRecord(t3, { type: Ie.ContentType.handshake, data: Ie.createCertificate(t3) })), t3.fail || (Ie.queue(t3, Ie.createRecord(t3, { type: Ie.ContentType.handshake, data: Ie.createServerKeyExchange(t3) })), t3.verifyClient !== false && Ie.queue(t3, Ie.createRecord(t3, { type: Ie.ContentType.handshake, data: Ie.createCertificateRequest(t3) })), Ie.queue(t3, Ie.createRecord(t3, { type: Ie.ContentType.handshake, data: Ie.createServerHelloDone(t3) })))), Ie.flush(t3), t3.process();
  }
};
Ie.handleCertificate = function(t3, e, n) {
  if (n < 3) return t3.error(t3, { message: "Invalid Certificate message. Message too short.", send: true, alert: { level: Ie.Alert.Level.fatal, description: Ie.Alert.Description.illegal_parameter } });
  var r = e.fragment, s = { certificate_list: Ls(r, 3) }, i, a, o = [];
  try {
    for (; s.certificate_list.length() > 0; ) i = Ls(s.certificate_list, 3), a = Bt.asn1.fromDer(i), i = Bt.pki.certificateFromAsn1(a, true), o.push(i);
  } catch (c) {
    return t3.error(t3, { message: "Could not parse certificate list.", cause: c, send: true, alert: { level: Ie.Alert.Level.fatal, description: Ie.Alert.Description.bad_certificate } });
  }
  var f = t3.entity === Ie.ConnectionEnd.client;
  (f || t3.verifyClient === true) && o.length === 0 ? t3.error(t3, { message: f ? "No server certificate provided." : "No client certificate provided.", send: true, alert: { level: Ie.Alert.Level.fatal, description: Ie.Alert.Description.illegal_parameter } }) : o.length === 0 ? t3.expect = f ? Fx : ob : (f ? t3.session.serverCertificate = o[0] : t3.session.clientCertificate = o[0], Ie.verifyCertificateChain(t3, o) && (t3.expect = f ? Fx : ob)), t3.process();
};
Ie.handleServerKeyExchange = function(t3, e, n) {
  if (n > 0) return t3.error(t3, { message: "Invalid key parameters. Only RSA is supported.", send: true, alert: { level: Ie.Alert.Level.fatal, description: Ie.Alert.Description.unsupported_certificate } });
  t3.expect = Rte, t3.process();
};
Ie.handleClientKeyExchange = function(t3, e, n) {
  if (n < 48) return t3.error(t3, { message: "Invalid key parameters. Only RSA is supported.", send: true, alert: { level: Ie.Alert.Level.fatal, description: Ie.Alert.Description.unsupported_certificate } });
  var r = e.fragment, s = { enc_pre_master_secret: Ls(r, 2).getBytes() }, i = null;
  if (t3.getPrivateKey) try {
    i = t3.getPrivateKey(t3, t3.session.serverCertificate), i = Bt.pki.privateKeyFromPem(i);
  } catch (f) {
    t3.error(t3, { message: "Could not get private key.", cause: f, send: true, alert: { level: Ie.Alert.Level.fatal, description: Ie.Alert.Description.internal_error } });
  }
  if (i === null) return t3.error(t3, { message: "No private key set.", send: true, alert: { level: Ie.Alert.Level.fatal, description: Ie.Alert.Description.internal_error } });
  try {
    var a = t3.session.sp;
    a.pre_master_secret = i.decrypt(s.enc_pre_master_secret);
    var o = t3.session.clientHelloVersion;
    if (o.major !== a.pre_master_secret.charCodeAt(0) || o.minor !== a.pre_master_secret.charCodeAt(1)) throw new Error("TLS version rollback attack detected.");
  } catch {
    a.pre_master_secret = Bt.random.getBytes(48);
  }
  t3.expect = h4, t3.session.clientCertificate !== null && (t3.expect = Qte), t3.process();
};
Ie.handleCertificateRequest = function(t3, e, n) {
  if (n < 3) return t3.error(t3, { message: "Invalid CertificateRequest. Message too short.", send: true, alert: { level: Ie.Alert.Level.fatal, description: Ie.Alert.Description.illegal_parameter } });
  var r = e.fragment, s = { certificate_types: Ls(r, 1), certificate_authorities: Ls(r, 2) };
  t3.session.certificateRequest = s, t3.expect = Fte, t3.process();
};
Ie.handleCertificateVerify = function(t3, e, n) {
  if (n < 2) return t3.error(t3, { message: "Invalid CertificateVerify. Message too short.", send: true, alert: { level: Ie.Alert.Level.fatal, description: Ie.Alert.Description.illegal_parameter } });
  var r = e.fragment;
  r.read -= 4;
  var s = r.bytes();
  r.read += 4;
  var i = { signature: Ls(r, 2).getBytes() }, a = Bt.util.createBuffer();
  a.putBuffer(t3.session.md5.digest()), a.putBuffer(t3.session.sha1.digest()), a = a.getBytes();
  try {
    var o = t3.session.clientCertificate;
    if (!o.publicKey.verify(a, i.signature, "NONE")) throw new Error("CertificateVerify signature does not match.");
    t3.session.md5.update(s), t3.session.sha1.update(s);
  } catch {
    return t3.error(t3, { message: "Bad signature in CertificateVerify.", send: true, alert: { level: Ie.Alert.Level.fatal, description: Ie.Alert.Description.handshake_failure } });
  }
  t3.expect = h4, t3.process();
};
Ie.handleServerHelloDone = function(t3, e, n) {
  if (n > 0) return t3.error(t3, { message: "Invalid ServerHelloDone message. Invalid length.", send: true, alert: { level: Ie.Alert.Level.fatal, description: Ie.Alert.Description.record_overflow } });
  if (t3.serverCertificate === null) {
    var r = { message: "No server certificate provided. Not enough security.", send: true, alert: { level: Ie.Alert.Level.fatal, description: Ie.Alert.Description.insufficient_security } }, s = 0, i = t3.verify(t3, r.alert.description, s, []);
    if (i !== true) return (i || i === 0) && (typeof i == "object" && !Bt.util.isArray(i) ? (i.message && (r.message = i.message), i.alert && (r.alert.description = i.alert)) : typeof i == "number" && (r.alert.description = i)), t3.error(t3, r);
  }
  t3.session.certificateRequest !== null && (e = Ie.createRecord(t3, { type: Ie.ContentType.handshake, data: Ie.createCertificate(t3) }), Ie.queue(t3, e)), e = Ie.createRecord(t3, { type: Ie.ContentType.handshake, data: Ie.createClientKeyExchange(t3) }), Ie.queue(t3, e), t3.expect = Ute;
  var a = function(o, f) {
    o.session.certificateRequest !== null && o.session.clientCertificate !== null && Ie.queue(o, Ie.createRecord(o, { type: Ie.ContentType.handshake, data: Ie.createCertificateVerify(o, f) })), Ie.queue(o, Ie.createRecord(o, { type: Ie.ContentType.change_cipher_spec, data: Ie.createChangeCipherSpec() })), o.state.pending = Ie.createConnectionState(o), o.state.current.write = o.state.pending.write, Ie.queue(o, Ie.createRecord(o, { type: Ie.ContentType.handshake, data: Ie.createFinished(o) })), o.expect = TT, Ie.flush(o), o.process();
  };
  if (t3.session.certificateRequest === null || t3.session.clientCertificate === null) return a(t3, null);
  Ie.getClientSignature(t3, a);
};
Ie.handleChangeCipherSpec = function(t3, e) {
  if (e.fragment.getByte() !== 1) return t3.error(t3, { message: "Invalid ChangeCipherSpec message received.", send: true, alert: { level: Ie.Alert.Level.fatal, description: Ie.Alert.Description.illegal_parameter } });
  var n = t3.entity === Ie.ConnectionEnd.client;
  (t3.session.resuming && n || !t3.session.resuming && !n) && (t3.state.pending = Ie.createConnectionState(t3)), t3.state.current.read = t3.state.pending.read, (!t3.session.resuming && n || t3.session.resuming && !n) && (t3.state.pending = null), t3.expect = n ? Pte : Kte, t3.process();
};
Ie.handleFinished = function(t3, e, n) {
  var r = e.fragment;
  r.read -= 4;
  var s = r.bytes();
  r.read += 4;
  var i = e.fragment.getBytes();
  r = Bt.util.createBuffer(), r.putBuffer(t3.session.md5.digest()), r.putBuffer(t3.session.sha1.digest());
  var a = t3.entity === Ie.ConnectionEnd.client, o = a ? "server finished" : "client finished", f = t3.session.sp, c = 12, l = hm;
  if (r = l(f.master_secret, o, r.getBytes(), c), r.getBytes() !== i) return t3.error(t3, { message: "Invalid verify_data in Finished message.", send: true, alert: { level: Ie.Alert.Level.fatal, description: Ie.Alert.Description.decrypt_error } });
  t3.session.md5.update(s), t3.session.sha1.update(s), (t3.session.resuming && a || !t3.session.resuming && !a) && (Ie.queue(t3, Ie.createRecord(t3, { type: Ie.ContentType.change_cipher_spec, data: Ie.createChangeCipherSpec() })), t3.state.current.write = t3.state.pending.write, t3.state.pending = null, Ie.queue(t3, Ie.createRecord(t3, { type: Ie.ContentType.handshake, data: Ie.createFinished(t3) }))), t3.expect = a ? Nte : Hte, t3.handshaking = false, ++t3.handshakes, t3.peerCertificate = a ? t3.session.serverCertificate : t3.session.clientCertificate, Ie.flush(t3), t3.isConnected = true, t3.connected(t3), t3.process();
};
Ie.handleAlert = function(t3, e) {
  var n = e.fragment, r = { level: n.getByte(), description: n.getByte() }, s;
  switch (r.description) {
    case Ie.Alert.Description.close_notify:
      s = "Connection closed.";
      break;
    case Ie.Alert.Description.unexpected_message:
      s = "Unexpected message.";
      break;
    case Ie.Alert.Description.bad_record_mac:
      s = "Bad record MAC.";
      break;
    case Ie.Alert.Description.decryption_failed:
      s = "Decryption failed.";
      break;
    case Ie.Alert.Description.record_overflow:
      s = "Record overflow.";
      break;
    case Ie.Alert.Description.decompression_failure:
      s = "Decompression failed.";
      break;
    case Ie.Alert.Description.handshake_failure:
      s = "Handshake failure.";
      break;
    case Ie.Alert.Description.bad_certificate:
      s = "Bad certificate.";
      break;
    case Ie.Alert.Description.unsupported_certificate:
      s = "Unsupported certificate.";
      break;
    case Ie.Alert.Description.certificate_revoked:
      s = "Certificate revoked.";
      break;
    case Ie.Alert.Description.certificate_expired:
      s = "Certificate expired.";
      break;
    case Ie.Alert.Description.certificate_unknown:
      s = "Certificate unknown.";
      break;
    case Ie.Alert.Description.illegal_parameter:
      s = "Illegal parameter.";
      break;
    case Ie.Alert.Description.unknown_ca:
      s = "Unknown certificate authority.";
      break;
    case Ie.Alert.Description.access_denied:
      s = "Access denied.";
      break;
    case Ie.Alert.Description.decode_error:
      s = "Decode error.";
      break;
    case Ie.Alert.Description.decrypt_error:
      s = "Decrypt error.";
      break;
    case Ie.Alert.Description.export_restriction:
      s = "Export restriction.";
      break;
    case Ie.Alert.Description.protocol_version:
      s = "Unsupported protocol version.";
      break;
    case Ie.Alert.Description.insufficient_security:
      s = "Insufficient security.";
      break;
    case Ie.Alert.Description.internal_error:
      s = "Internal error.";
      break;
    case Ie.Alert.Description.user_canceled:
      s = "User canceled.";
      break;
    case Ie.Alert.Description.no_renegotiation:
      s = "Renegotiation not supported.";
      break;
    default:
      s = "Unknown error.";
      break;
  }
  if (r.description === Ie.Alert.Description.close_notify) return t3.close();
  t3.error(t3, { message: s, send: false, origin: t3.entity === Ie.ConnectionEnd.client ? "server" : "client", alert: r }), t3.process();
};
Ie.handleHandshake = function(t3, e) {
  var n = e.fragment, r = n.getByte(), s = n.getInt24();
  if (s > n.length()) return t3.fragmented = e, e.fragment = Bt.util.createBuffer(), n.read -= 4, t3.process();
  t3.fragmented = null, n.read -= 4;
  var i = n.bytes(s + 4);
  n.read += 4, r in F1[t3.entity][t3.expect] ? (t3.entity === Ie.ConnectionEnd.server && !t3.open && !t3.fail && (t3.handshaking = true, t3.session = { version: null, extensions: { server_name: { serverNameList: [] } }, cipherSuite: null, compressionMethod: null, serverCertificate: null, clientCertificate: null, md5: Bt.md.md5.create(), sha1: Bt.md.sha1.create() }), r !== Ie.HandshakeType.hello_request && r !== Ie.HandshakeType.certificate_verify && r !== Ie.HandshakeType.finished && (t3.session.md5.update(i), t3.session.sha1.update(i)), F1[t3.entity][t3.expect][r](t3, e, s)) : Ie.handleUnexpected(t3, e);
};
Ie.handleApplicationData = function(t3, e) {
  t3.data.putBuffer(e.fragment), t3.dataReady(t3), t3.process();
};
Ie.handleHeartbeat = function(t3, e) {
  var n = e.fragment, r = n.getByte(), s = n.getInt16(), i = n.getBytes(s);
  if (r === Ie.HeartbeatMessageType.heartbeat_request) {
    if (t3.handshaking || s > i.length) return t3.process();
    Ie.queue(t3, Ie.createRecord(t3, { type: Ie.ContentType.heartbeat, data: Ie.createHeartbeat(Ie.HeartbeatMessageType.heartbeat_response, i) })), Ie.flush(t3);
  } else if (r === Ie.HeartbeatMessageType.heartbeat_response) {
    if (i !== t3.expectedHeartbeatPayload) return t3.process();
    t3.heartbeatReceived && t3.heartbeatReceived(t3, Bt.util.createBuffer(i));
  }
  t3.process();
};
var Tte = 0, Dte = 1, Fx = 2, Rte = 3, Fte = 4, TT = 5, Pte = 6, Nte = 7, Ute = 8, Lte = 0, Ote = 1, ob = 2, Qte = 3, h4 = 4, Kte = 5, Hte = 6, ke = Ie.handleUnexpected, DT = Ie.handleChangeCipherSpec, Ti = Ie.handleAlert, fs = Ie.handleHandshake, RT = Ie.handleApplicationData, Di = Ie.handleHeartbeat, d4 = [];
d4[Ie.ConnectionEnd.client] = [[ke, Ti, fs, ke, Di], [ke, Ti, fs, ke, Di], [ke, Ti, fs, ke, Di], [ke, Ti, fs, ke, Di], [ke, Ti, fs, ke, Di], [DT, Ti, ke, ke, Di], [ke, Ti, fs, ke, Di], [ke, Ti, fs, RT, Di], [ke, Ti, fs, ke, Di]];
d4[Ie.ConnectionEnd.server] = [[ke, Ti, fs, ke, Di], [ke, Ti, fs, ke, Di], [ke, Ti, fs, ke, Di], [ke, Ti, fs, ke, Di], [DT, Ti, ke, ke, Di], [ke, Ti, fs, ke, Di], [ke, Ti, fs, RT, Di], [ke, Ti, fs, ke, Di]];
var kf = Ie.handleHelloRequest, qte = Ie.handleServerHello, FT = Ie.handleCertificate, Px = Ie.handleServerKeyExchange, vv = Ie.handleCertificateRequest, sp = Ie.handleServerHelloDone, PT = Ie.handleFinished, F1 = [];
F1[Ie.ConnectionEnd.client] = [[ke, ke, qte, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke], [kf, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, FT, Px, vv, sp, ke, ke, ke, ke, ke, ke], [kf, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, Px, vv, sp, ke, ke, ke, ke, ke, ke], [kf, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, vv, sp, ke, ke, ke, ke, ke, ke], [kf, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, sp, ke, ke, ke, ke, ke, ke], [kf, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke], [kf, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, PT], [kf, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke], [kf, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke]];
var zte = Ie.handleClientHello, Gte = Ie.handleClientKeyExchange, Vte = Ie.handleCertificateVerify;
F1[Ie.ConnectionEnd.server] = [[ke, zte, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke], [ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, FT, ke, ke, ke, ke, ke, ke, ke, ke, ke], [ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, Gte, ke, ke, ke, ke], [ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, Vte, ke, ke, ke, ke, ke], [ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke], [ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, PT], [ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke], [ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke, ke]];
Ie.generateKeys = function(t3, e) {
  var n = hm, r = e.client_random + e.server_random;
  t3.session.resuming || (e.master_secret = n(e.pre_master_secret, "master secret", r, 48).bytes(), e.pre_master_secret = null), r = e.server_random + e.client_random;
  var s = 2 * e.mac_key_length + 2 * e.enc_key_length, i = t3.version.major === Ie.Versions.TLS_1_0.major && t3.version.minor === Ie.Versions.TLS_1_0.minor;
  i && (s += 2 * e.fixed_iv_length);
  var a = n(e.master_secret, "key expansion", r, s), o = { client_write_MAC_key: a.getBytes(e.mac_key_length), server_write_MAC_key: a.getBytes(e.mac_key_length), client_write_key: a.getBytes(e.enc_key_length), server_write_key: a.getBytes(e.enc_key_length) };
  return i && (o.client_write_IV = a.getBytes(e.fixed_iv_length), o.server_write_IV = a.getBytes(e.fixed_iv_length)), o;
};
Ie.createConnectionState = function(t3) {
  var e = t3.entity === Ie.ConnectionEnd.client, n = function() {
    var i = { sequenceNumber: [0, 0], macKey: null, macLength: 0, macFunction: null, cipherState: null, cipherFunction: function(a) {
      return true;
    }, compressionState: null, compressFunction: function(a) {
      return true;
    }, updateSequenceNumber: function() {
      i.sequenceNumber[1] === 4294967295 ? (i.sequenceNumber[1] = 0, ++i.sequenceNumber[0]) : ++i.sequenceNumber[1];
    } };
    return i;
  }, r = { read: n(), write: n() };
  if (r.read.update = function(i, a) {
    return r.read.cipherFunction(a, r.read) ? r.read.compressFunction(i, a, r.read) || i.error(i, { message: "Could not decompress record.", send: true, alert: { level: Ie.Alert.Level.fatal, description: Ie.Alert.Description.decompression_failure } }) : i.error(i, { message: "Could not decrypt record or bad MAC.", send: true, alert: { level: Ie.Alert.Level.fatal, description: Ie.Alert.Description.bad_record_mac } }), !i.fail;
  }, r.write.update = function(i, a) {
    return r.write.compressFunction(i, a, r.write) ? r.write.cipherFunction(a, r.write) || i.error(i, { message: "Could not encrypt record.", send: false, alert: { level: Ie.Alert.Level.fatal, description: Ie.Alert.Description.internal_error } }) : i.error(i, { message: "Could not compress record.", send: false, alert: { level: Ie.Alert.Level.fatal, description: Ie.Alert.Description.internal_error } }), !i.fail;
  }, t3.session) {
    var s = t3.session.sp;
    switch (t3.session.cipherSuite.initSecurityParameters(s), s.keys = Ie.generateKeys(t3, s), r.read.macKey = e ? s.keys.server_write_MAC_key : s.keys.client_write_MAC_key, r.write.macKey = e ? s.keys.client_write_MAC_key : s.keys.server_write_MAC_key, t3.session.cipherSuite.initConnectionState(r, t3, s), s.compression_algorithm) {
      case Ie.CompressionMethod.none:
        break;
      case Ie.CompressionMethod.deflate:
        r.read.compressFunction = $te, r.write.compressFunction = Mte;
        break;
      default:
        throw new Error("Unsupported compression algorithm.");
    }
  }
  return r;
};
Ie.createRandom = function() {
  var t3 = /* @__PURE__ */ new Date(), e = +t3 + t3.getTimezoneOffset() * 6e4, n = Bt.util.createBuffer();
  return n.putInt32(e), n.putBytes(Bt.random.getBytes(28)), n;
};
Ie.createRecord = function(t3, e) {
  if (!e.data) return null;
  var n = { type: e.type, version: { major: t3.version.major, minor: t3.version.minor }, length: e.data.length(), fragment: e.data };
  return n;
};
Ie.createAlert = function(t3, e) {
  var n = Bt.util.createBuffer();
  return n.putByte(e.level), n.putByte(e.description), Ie.createRecord(t3, { type: Ie.ContentType.alert, data: n });
};
Ie.createClientHello = function(t3) {
  t3.session.clientHelloVersion = { major: t3.version.major, minor: t3.version.minor };
  for (var e = Bt.util.createBuffer(), n = 0; n < t3.cipherSuites.length; ++n) {
    var r = t3.cipherSuites[n];
    e.putByte(r.id[0]), e.putByte(r.id[1]);
  }
  var s = e.length(), i = Bt.util.createBuffer();
  i.putByte(Ie.CompressionMethod.none);
  var a = i.length(), o = Bt.util.createBuffer();
  if (t3.virtualHost) {
    var f = Bt.util.createBuffer();
    f.putByte(0), f.putByte(0);
    var c = Bt.util.createBuffer();
    c.putByte(0), Xs(c, 2, Bt.util.createBuffer(t3.virtualHost));
    var l = Bt.util.createBuffer();
    Xs(l, 2, c), Xs(f, 2, l), o.putBuffer(f);
  }
  var h = o.length();
  h > 0 && (h += 2);
  var m = t3.session.id, v = m.length + 1 + 2 + 4 + 28 + 2 + s + 1 + a + h, b = Bt.util.createBuffer();
  return b.putByte(Ie.HandshakeType.client_hello), b.putInt24(v), b.putByte(t3.version.major), b.putByte(t3.version.minor), b.putBytes(t3.session.sp.client_random), Xs(b, 1, Bt.util.createBuffer(m)), Xs(b, 2, e), Xs(b, 1, i), h > 0 && Xs(b, 2, o), b;
};
Ie.createServerHello = function(t3) {
  var e = t3.session.id, n = e.length + 1 + 2 + 4 + 28 + 2 + 1, r = Bt.util.createBuffer();
  return r.putByte(Ie.HandshakeType.server_hello), r.putInt24(n), r.putByte(t3.version.major), r.putByte(t3.version.minor), r.putBytes(t3.session.sp.server_random), Xs(r, 1, Bt.util.createBuffer(e)), r.putByte(t3.session.cipherSuite.id[0]), r.putByte(t3.session.cipherSuite.id[1]), r.putByte(t3.session.compressionMethod), r;
};
Ie.createCertificate = function(t3) {
  var e = t3.entity === Ie.ConnectionEnd.client, n = null;
  if (t3.getCertificate) {
    var r;
    e ? r = t3.session.certificateRequest : r = t3.session.extensions.server_name.serverNameList, n = t3.getCertificate(t3, r);
  }
  var s = Bt.util.createBuffer();
  if (n !== null) try {
    Bt.util.isArray(n) || (n = [n]);
    for (var i = null, a = 0; a < n.length; ++a) {
      var o = Bt.pem.decode(n[a])[0];
      if (o.type !== "CERTIFICATE" && o.type !== "X509 CERTIFICATE" && o.type !== "TRUSTED CERTIFICATE") {
        var f = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
        throw f.headerType = o.type, f;
      }
      if (o.procType && o.procType.type === "ENCRYPTED") throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
      var c = Bt.util.createBuffer(o.body);
      i === null && (i = Bt.asn1.fromDer(c.bytes(), false));
      var l = Bt.util.createBuffer();
      Xs(l, 3, c), s.putBuffer(l);
    }
    n = Bt.pki.certificateFromAsn1(i), e ? t3.session.clientCertificate = n : t3.session.serverCertificate = n;
  } catch (v) {
    return t3.error(t3, { message: "Could not send certificate list.", cause: v, send: true, alert: { level: Ie.Alert.Level.fatal, description: Ie.Alert.Description.bad_certificate } });
  }
  var h = 3 + s.length(), m = Bt.util.createBuffer();
  return m.putByte(Ie.HandshakeType.certificate), m.putInt24(h), Xs(m, 3, s), m;
};
Ie.createClientKeyExchange = function(t3) {
  var e = Bt.util.createBuffer();
  e.putByte(t3.session.clientHelloVersion.major), e.putByte(t3.session.clientHelloVersion.minor), e.putBytes(Bt.random.getBytes(46));
  var n = t3.session.sp;
  n.pre_master_secret = e.getBytes();
  var r = t3.session.serverCertificate.publicKey;
  e = r.encrypt(n.pre_master_secret);
  var s = e.length + 2, i = Bt.util.createBuffer();
  return i.putByte(Ie.HandshakeType.client_key_exchange), i.putInt24(s), i.putInt16(e.length), i.putBytes(e), i;
};
Ie.createServerKeyExchange = function(t3) {
  var e = Bt.util.createBuffer();
  return e;
};
Ie.getClientSignature = function(t3, e) {
  var n = Bt.util.createBuffer();
  n.putBuffer(t3.session.md5.digest()), n.putBuffer(t3.session.sha1.digest()), n = n.getBytes(), t3.getSignature = t3.getSignature || function(r, s, i) {
    var a = null;
    if (r.getPrivateKey) try {
      a = r.getPrivateKey(r, r.session.clientCertificate), a = Bt.pki.privateKeyFromPem(a);
    } catch (o) {
      r.error(r, { message: "Could not get private key.", cause: o, send: true, alert: { level: Ie.Alert.Level.fatal, description: Ie.Alert.Description.internal_error } });
    }
    a === null ? r.error(r, { message: "No private key set.", send: true, alert: { level: Ie.Alert.Level.fatal, description: Ie.Alert.Description.internal_error } }) : s = a.sign(s, null), i(r, s);
  }, t3.getSignature(t3, n, e);
};
Ie.createCertificateVerify = function(t3, e) {
  var n = e.length + 2, r = Bt.util.createBuffer();
  return r.putByte(Ie.HandshakeType.certificate_verify), r.putInt24(n), r.putInt16(e.length), r.putBytes(e), r;
};
Ie.createCertificateRequest = function(t3) {
  var e = Bt.util.createBuffer();
  e.putByte(1);
  var n = Bt.util.createBuffer();
  for (var r in t3.caStore.certs) {
    var s = t3.caStore.certs[r], i = Bt.pki.distinguishedNameToAsn1(s.subject), a = Bt.asn1.toDer(i);
    n.putInt16(a.length()), n.putBuffer(a);
  }
  var o = 1 + e.length() + 2 + n.length(), f = Bt.util.createBuffer();
  return f.putByte(Ie.HandshakeType.certificate_request), f.putInt24(o), Xs(f, 1, e), Xs(f, 2, n), f;
};
Ie.createServerHelloDone = function(t3) {
  var e = Bt.util.createBuffer();
  return e.putByte(Ie.HandshakeType.server_hello_done), e.putInt24(0), e;
};
Ie.createChangeCipherSpec = function() {
  var t3 = Bt.util.createBuffer();
  return t3.putByte(1), t3;
};
Ie.createFinished = function(t3) {
  var e = Bt.util.createBuffer();
  e.putBuffer(t3.session.md5.digest()), e.putBuffer(t3.session.sha1.digest());
  var n = t3.entity === Ie.ConnectionEnd.client, r = t3.session.sp, s = 12, i = hm, a = n ? "client finished" : "server finished";
  e = i(r.master_secret, a, e.getBytes(), s);
  var o = Bt.util.createBuffer();
  return o.putByte(Ie.HandshakeType.finished), o.putInt24(e.length()), o.putBuffer(e), o;
};
Ie.createHeartbeat = function(t3, e, n) {
  typeof n > "u" && (n = e.length);
  var r = Bt.util.createBuffer();
  r.putByte(t3), r.putInt16(n), r.putBytes(e);
  var s = r.length(), i = Math.max(16, s - n - 3);
  return r.putBytes(Bt.random.getBytes(i)), r;
};
Ie.queue = function(t3, e) {
  if (e && !(e.fragment.length() === 0 && (e.type === Ie.ContentType.handshake || e.type === Ie.ContentType.alert || e.type === Ie.ContentType.change_cipher_spec))) {
    if (e.type === Ie.ContentType.handshake) {
      var n = e.fragment.bytes();
      t3.session.md5.update(n), t3.session.sha1.update(n), n = null;
    }
    var r;
    if (e.fragment.length() <= Ie.MaxFragment) r = [e];
    else {
      r = [];
      for (var s = e.fragment.bytes(); s.length > Ie.MaxFragment; ) r.push(Ie.createRecord(t3, { type: e.type, data: Bt.util.createBuffer(s.slice(0, Ie.MaxFragment)) })), s = s.slice(Ie.MaxFragment);
      s.length > 0 && r.push(Ie.createRecord(t3, { type: e.type, data: Bt.util.createBuffer(s) }));
    }
    for (var i = 0; i < r.length && !t3.fail; ++i) {
      var a = r[i], o = t3.state.current.write;
      o.update(t3, a) && t3.records.push(a);
    }
  }
};
Ie.flush = function(t3) {
  for (var e = 0; e < t3.records.length; ++e) {
    var n = t3.records[e];
    t3.tlsData.putByte(n.type), t3.tlsData.putByte(n.version.major), t3.tlsData.putByte(n.version.minor), t3.tlsData.putInt16(n.fragment.length()), t3.tlsData.putBuffer(t3.records[e].fragment);
  }
  return t3.records = [], t3.tlsDataReady(t3);
};
var yv = function(t3) {
  switch (t3) {
    case true:
      return true;
    case Bt.pki.certificateError.bad_certificate:
      return Ie.Alert.Description.bad_certificate;
    case Bt.pki.certificateError.unsupported_certificate:
      return Ie.Alert.Description.unsupported_certificate;
    case Bt.pki.certificateError.certificate_revoked:
      return Ie.Alert.Description.certificate_revoked;
    case Bt.pki.certificateError.certificate_expired:
      return Ie.Alert.Description.certificate_expired;
    case Bt.pki.certificateError.certificate_unknown:
      return Ie.Alert.Description.certificate_unknown;
    case Bt.pki.certificateError.unknown_ca:
      return Ie.Alert.Description.unknown_ca;
    default:
      return Ie.Alert.Description.bad_certificate;
  }
}, Yte = function(t3) {
  switch (t3) {
    case true:
      return true;
    case Ie.Alert.Description.bad_certificate:
      return Bt.pki.certificateError.bad_certificate;
    case Ie.Alert.Description.unsupported_certificate:
      return Bt.pki.certificateError.unsupported_certificate;
    case Ie.Alert.Description.certificate_revoked:
      return Bt.pki.certificateError.certificate_revoked;
    case Ie.Alert.Description.certificate_expired:
      return Bt.pki.certificateError.certificate_expired;
    case Ie.Alert.Description.certificate_unknown:
      return Bt.pki.certificateError.certificate_unknown;
    case Ie.Alert.Description.unknown_ca:
      return Bt.pki.certificateError.unknown_ca;
    default:
      return Bt.pki.certificateError.bad_certificate;
  }
};
Ie.verifyCertificateChain = function(t3, e) {
  try {
    var n = {};
    for (var r in t3.verifyOptions) n[r] = t3.verifyOptions[r];
    n.verify = function(i, a, o) {
      var f = yv(i), c = t3.verify(t3, i, a, o);
      if (c !== true) {
        if (typeof c == "object" && !Bt.util.isArray(c)) {
          var l = new Error("The application rejected the certificate.");
          throw l.send = true, l.alert = { level: Ie.Alert.Level.fatal, description: Ie.Alert.Description.bad_certificate }, c.message && (l.message = c.message), c.alert && (l.alert.description = c.alert), l;
        }
        c !== i && (c = Yte(c));
      }
      return c;
    }, Bt.pki.verifyCertificateChain(t3.caStore, e, n);
  } catch (i) {
    var s = i;
    (typeof s != "object" || Bt.util.isArray(s)) && (s = { send: true, alert: { level: Ie.Alert.Level.fatal, description: yv(i) } }), "send" in s || (s.send = true), "alert" in s || (s.alert = { level: Ie.Alert.Level.fatal, description: yv(s.error) }), t3.error(t3, s);
  }
  return !t3.fail;
};
Ie.createSessionCache = function(t3, e) {
  var n = null;
  if (t3 && t3.getSession && t3.setSession && t3.order) n = t3;
  else {
    n = {}, n.cache = t3 || {}, n.capacity = Math.max(e || 100, 1), n.order = [];
    for (var r in t3) n.order.length <= e ? n.order.push(r) : delete t3[r];
    n.getSession = function(s) {
      var i = null, a = null;
      if (s ? a = Bt.util.bytesToHex(s) : n.order.length > 0 && (a = n.order[0]), a !== null && a in n.cache) {
        i = n.cache[a], delete n.cache[a];
        for (var o in n.order) if (n.order[o] === a) {
          n.order.splice(o, 1);
          break;
        }
      }
      return i;
    }, n.setSession = function(s, i) {
      if (n.order.length === n.capacity) {
        var a = n.order.shift();
        delete n.cache[a];
      }
      var a = Bt.util.bytesToHex(s);
      n.order.push(a), n.cache[a] = i;
    };
  }
  return n;
};
Ie.createConnection = function(t3) {
  var e = null;
  t3.caStore ? Bt.util.isArray(t3.caStore) ? e = Bt.pki.createCaStore(t3.caStore) : e = t3.caStore : e = Bt.pki.createCaStore();
  var n = t3.cipherSuites || null;
  if (n === null) {
    n = [];
    for (var r in Ie.CipherSuites) n.push(Ie.CipherSuites[r]);
  }
  var s = t3.server ? Ie.ConnectionEnd.server : Ie.ConnectionEnd.client, i = t3.sessionCache ? Ie.createSessionCache(t3.sessionCache) : null, a = { version: { major: Ie.Version.major, minor: Ie.Version.minor }, entity: s, sessionId: t3.sessionId, caStore: e, sessionCache: i, cipherSuites: n, connected: t3.connected, virtualHost: t3.virtualHost || null, verifyClient: t3.verifyClient || false, verify: t3.verify || function(l, h, m, v) {
    return h;
  }, verifyOptions: t3.verifyOptions || {}, getCertificate: t3.getCertificate || null, getPrivateKey: t3.getPrivateKey || null, getSignature: t3.getSignature || null, input: Bt.util.createBuffer(), tlsData: Bt.util.createBuffer(), data: Bt.util.createBuffer(), tlsDataReady: t3.tlsDataReady, dataReady: t3.dataReady, heartbeatReceived: t3.heartbeatReceived, closed: t3.closed, error: function(l, h) {
    h.origin = h.origin || (l.entity === Ie.ConnectionEnd.client ? "client" : "server"), h.send && (Ie.queue(l, Ie.createAlert(l, h.alert)), Ie.flush(l));
    var m = h.fatal !== false;
    m && (l.fail = true), t3.error(l, h), m && l.close(false);
  }, deflate: t3.deflate || null, inflate: t3.inflate || null };
  a.reset = function(l) {
    a.version = { major: Ie.Version.major, minor: Ie.Version.minor }, a.record = null, a.session = null, a.peerCertificate = null, a.state = { pending: null, current: null }, a.expect = a.entity === Ie.ConnectionEnd.client ? Tte : Lte, a.fragmented = null, a.records = [], a.open = false, a.handshakes = 0, a.handshaking = false, a.isConnected = false, a.fail = !(l || typeof l > "u"), a.input.clear(), a.tlsData.clear(), a.data.clear(), a.state.current = Ie.createConnectionState(a);
  }, a.reset();
  var o = function(l, h) {
    var m = h.type - Ie.ContentType.change_cipher_spec, v = d4[l.entity][l.expect];
    m in v ? v[m](l, h) : Ie.handleUnexpected(l, h);
  }, f = function(l) {
    var h = 0, m = l.input, v = m.length();
    if (v < 5) h = 5 - v;
    else {
      l.record = { type: m.getByte(), version: { major: m.getByte(), minor: m.getByte() }, length: m.getInt16(), fragment: Bt.util.createBuffer(), ready: false };
      var b = l.record.version.major === l.version.major;
      b && l.session && l.session.version && (b = l.record.version.minor === l.version.minor), b || l.error(l, { message: "Incompatible TLS version.", send: true, alert: { level: Ie.Alert.Level.fatal, description: Ie.Alert.Description.protocol_version } });
    }
    return h;
  }, c = function(l) {
    var h = 0, m = l.input, v = m.length();
    if (v < l.record.length) h = l.record.length - v;
    else {
      l.record.fragment.putBytes(m.getBytes(l.record.length)), m.compact();
      var b = l.state.current.read;
      b.update(l, l.record) && (l.fragmented !== null && (l.fragmented.type === l.record.type ? (l.fragmented.fragment.putBuffer(l.record.fragment), l.record = l.fragmented) : l.error(l, { message: "Invalid fragmented record.", send: true, alert: { level: Ie.Alert.Level.fatal, description: Ie.Alert.Description.unexpected_message } })), l.record.ready = true);
    }
    return h;
  };
  return a.handshake = function(l) {
    if (a.entity !== Ie.ConnectionEnd.client) a.error(a, { message: "Cannot initiate handshake as a server.", fatal: false });
    else if (a.handshaking) a.error(a, { message: "Handshake already in progress.", fatal: false });
    else {
      a.fail && !a.open && a.handshakes === 0 && (a.fail = false), a.handshaking = true, l = l || "";
      var h = null;
      l.length > 0 && (a.sessionCache && (h = a.sessionCache.getSession(l)), h === null && (l = "")), l.length === 0 && a.sessionCache && (h = a.sessionCache.getSession(), h !== null && (l = h.id)), a.session = { id: l, version: null, cipherSuite: null, compressionMethod: null, serverCertificate: null, certificateRequest: null, clientCertificate: null, sp: {}, md5: Bt.md.md5.create(), sha1: Bt.md.sha1.create() }, h && (a.version = h.version, a.session.sp = h.sp), a.session.sp.client_random = Ie.createRandom().getBytes(), a.open = true, Ie.queue(a, Ie.createRecord(a, { type: Ie.ContentType.handshake, data: Ie.createClientHello(a) })), Ie.flush(a);
    }
  }, a.process = function(l) {
    var h = 0;
    return l && a.input.putBytes(l), a.fail || (a.record !== null && a.record.ready && a.record.fragment.isEmpty() && (a.record = null), a.record === null && (h = f(a)), !a.fail && a.record !== null && !a.record.ready && (h = c(a)), !a.fail && a.record !== null && a.record.ready && o(a, a.record)), h;
  }, a.prepare = function(l) {
    return Ie.queue(a, Ie.createRecord(a, { type: Ie.ContentType.application_data, data: Bt.util.createBuffer(l) })), Ie.flush(a);
  }, a.prepareHeartbeatRequest = function(l, h) {
    return l instanceof Bt.util.ByteBuffer && (l = l.bytes()), typeof h > "u" && (h = l.length), a.expectedHeartbeatPayload = l, Ie.queue(a, Ie.createRecord(a, { type: Ie.ContentType.heartbeat, data: Ie.createHeartbeat(Ie.HeartbeatMessageType.heartbeat_request, l, h) })), Ie.flush(a);
  }, a.close = function(l) {
    if (!a.fail && a.sessionCache && a.session) {
      var h = { id: a.session.id, version: a.session.version, sp: a.session.sp };
      h.sp.keys = null, a.sessionCache.setSession(h.id, h);
    }
    a.open && (a.open = false, a.input.clear(), (a.isConnected || a.handshaking) && (a.isConnected = a.handshaking = false, Ie.queue(a, Ie.createAlert(a, { level: Ie.Alert.Level.warning, description: Ie.Alert.Description.close_notify })), Ie.flush(a)), a.closed(a)), a.reset(l);
  }, a;
};
Bt.tls = Bt.tls || {};
for (var bv in Ie) typeof Ie[bv] != "function" && (Bt.tls[bv] = Ie[bv]);
Bt.tls.prf_tls1 = hm;
Bt.tls.hmac_sha1 = Ste;
Bt.tls.createSessionCache = Ie.createSessionCache;
Bt.tls.createConnection = Ie.createConnection;
var tl = Ur, sa = tl.tls;
sa.CipherSuites.TLS_RSA_WITH_AES_128_CBC_SHA = { id: [0, 47], name: "TLS_RSA_WITH_AES_128_CBC_SHA", initSecurityParameters: function(t3) {
  t3.bulk_cipher_algorithm = sa.BulkCipherAlgorithm.aes, t3.cipher_type = sa.CipherType.block, t3.enc_key_length = 16, t3.block_length = 16, t3.fixed_iv_length = 16, t3.record_iv_length = 16, t3.mac_algorithm = sa.MACAlgorithm.hmac_sha1, t3.mac_length = 20, t3.mac_key_length = 20;
}, initConnectionState: NT };
sa.CipherSuites.TLS_RSA_WITH_AES_256_CBC_SHA = { id: [0, 53], name: "TLS_RSA_WITH_AES_256_CBC_SHA", initSecurityParameters: function(t3) {
  t3.bulk_cipher_algorithm = sa.BulkCipherAlgorithm.aes, t3.cipher_type = sa.CipherType.block, t3.enc_key_length = 32, t3.block_length = 16, t3.fixed_iv_length = 16, t3.record_iv_length = 16, t3.mac_algorithm = sa.MACAlgorithm.hmac_sha1, t3.mac_length = 20, t3.mac_key_length = 20;
}, initConnectionState: NT };
function NT(t3, e, n) {
  var r = e.entity === tl.tls.ConnectionEnd.client;
  t3.read.cipherState = { init: false, cipher: tl.cipher.createDecipher("AES-CBC", r ? n.keys.server_write_key : n.keys.client_write_key), iv: r ? n.keys.server_write_IV : n.keys.client_write_IV }, t3.write.cipherState = { init: false, cipher: tl.cipher.createCipher("AES-CBC", r ? n.keys.client_write_key : n.keys.server_write_key), iv: r ? n.keys.client_write_IV : n.keys.server_write_IV }, t3.read.cipherFunction = jte, t3.write.cipherFunction = Wte, t3.read.macLength = t3.write.macLength = n.mac_length, t3.read.macFunction = t3.write.macFunction = sa.hmac_sha1;
}
function Wte(t3, e) {
  var n = false, r = e.macFunction(e.macKey, e.sequenceNumber, t3);
  t3.fragment.putBytes(r), e.updateSequenceNumber();
  var s;
  t3.version.minor === sa.Versions.TLS_1_0.minor ? s = e.cipherState.init ? null : e.cipherState.iv : s = tl.random.getBytesSync(16), e.cipherState.init = true;
  var i = e.cipherState.cipher;
  return i.start({ iv: s }), t3.version.minor >= sa.Versions.TLS_1_1.minor && i.output.putBytes(s), i.update(t3.fragment), i.finish(Jte) && (t3.fragment = i.output, t3.length = t3.fragment.length(), n = true), n;
}
function Jte(t3, e, n) {
  if (!n) {
    var r = t3 - e.length() % t3;
    e.fillWithByte(r - 1, r);
  }
  return true;
}
function Zte(t3, e, n) {
  var r = true;
  if (n) {
    for (var s = e.length(), i = e.last(), a = s - 1 - i; a < s - 1; ++a) r = r && e.at(a) == i;
    r && e.truncate(i + 1);
  }
  return r;
}
function jte(t3, e) {
  var n = false, r;
  t3.version.minor === sa.Versions.TLS_1_0.minor ? r = e.cipherState.init ? null : e.cipherState.iv : r = t3.fragment.getBytes(16), e.cipherState.init = true;
  var s = e.cipherState.cipher;
  s.start({ iv: r }), s.update(t3.fragment), n = s.finish(Zte);
  var i = e.macLength, a = tl.random.getBytesSync(i), o = s.output.length();
  o >= i ? (t3.fragment = s.output.getBytes(o - i), a = s.output.getBytes(i)) : t3.fragment = s.output.getBytes(), t3.fragment = tl.util.createBuffer(t3.fragment), t3.length = t3.fragment.length();
  var f = e.macFunction(e.macKey, e.sequenceNumber, t3);
  return e.updateSequenceNumber(), n = Xte(e.macKey, a, f) && n, n;
}
function Xte(t3, e, n) {
  var r = tl.hmac.create();
  return r.start("SHA1", t3), r.update(e), e = r.digest().getBytes(), r.start(null, null), r.update(n), n = r.digest().getBytes(), e === n;
}
var Sn = Ur, kd = Sn.sha512 = Sn.sha512 || {};
Sn.md.sha512 = Sn.md.algorithms.sha512 = kd;
var UT = Sn.sha384 = Sn.sha512.sha384 = Sn.sha512.sha384 || {};
UT.create = function() {
  return kd.create("SHA-384");
};
Sn.md.sha384 = Sn.md.algorithms.sha384 = UT;
Sn.sha512.sha256 = Sn.sha512.sha256 || { create: function() {
  return kd.create("SHA-512/256");
} };
Sn.md["sha512/256"] = Sn.md.algorithms["sha512/256"] = Sn.sha512.sha256;
Sn.sha512.sha224 = Sn.sha512.sha224 || { create: function() {
  return kd.create("SHA-512/224");
} };
Sn.md["sha512/224"] = Sn.md.algorithms["sha512/224"] = Sn.sha512.sha224;
kd.create = function(t3) {
  if (LT || ere(), typeof t3 > "u" && (t3 = "SHA-512"), !(t3 in Ul)) throw new Error("Invalid SHA-512 algorithm: " + t3);
  for (var e = Ul[t3], n = null, r = Sn.util.createBuffer(), s = new Array(80), i = 0; i < 80; ++i) s[i] = new Array(2);
  var a = 64;
  switch (t3) {
    case "SHA-384":
      a = 48;
      break;
    case "SHA-512/256":
      a = 32;
      break;
    case "SHA-512/224":
      a = 28;
      break;
  }
  var o = { algorithm: t3.replace("-", "").toLowerCase(), blockLength: 128, digestLength: a, messageLength: 0, fullMessageLength: null, messageLengthSize: 16 };
  return o.start = function() {
    o.messageLength = 0, o.fullMessageLength = o.messageLength128 = [];
    for (var f = o.messageLengthSize / 4, c = 0; c < f; ++c) o.fullMessageLength.push(0);
    r = Sn.util.createBuffer(), n = new Array(e.length);
    for (var c = 0; c < e.length; ++c) n[c] = e[c].slice(0);
    return o;
  }, o.start(), o.update = function(f, c) {
    c === "utf8" && (f = Sn.util.encodeUtf8(f));
    var l = f.length;
    o.messageLength += l, l = [l / 4294967296 >>> 0, l >>> 0];
    for (var h = o.fullMessageLength.length - 1; h >= 0; --h) o.fullMessageLength[h] += l[1], l[1] = l[0] + (o.fullMessageLength[h] / 4294967296 >>> 0), o.fullMessageLength[h] = o.fullMessageLength[h] >>> 0, l[0] = l[1] / 4294967296 >>> 0;
    return r.putBytes(f), Nx(n, s, r), (r.read > 2048 || r.length() === 0) && r.compact(), o;
  }, o.digest = function() {
    var f = Sn.util.createBuffer();
    f.putBytes(r.bytes());
    var c = o.fullMessageLength[o.fullMessageLength.length - 1] + o.messageLengthSize, l = c & o.blockLength - 1;
    f.putBytes(fb.substr(0, o.blockLength - l));
    for (var h, m, v = o.fullMessageLength[0] * 8, b = 0; b < o.fullMessageLength.length - 1; ++b) h = o.fullMessageLength[b + 1] * 8, m = h / 4294967296 >>> 0, v += m, f.putInt32(v >>> 0), v = h >>> 0;
    f.putInt32(v);
    for (var A = new Array(n.length), b = 0; b < n.length; ++b) A[b] = n[b].slice(0);
    Nx(A, s, f);
    var _ = Sn.util.createBuffer(), C;
    t3 === "SHA-512" ? C = A.length : t3 === "SHA-384" ? C = A.length - 2 : C = A.length - 4;
    for (var b = 0; b < C; ++b) _.putInt32(A[b][0]), (b !== C - 1 || t3 !== "SHA-512/224") && _.putInt32(A[b][1]);
    return _;
  }, o;
};
var fb = null, LT = false, lb = null, Ul = null;
function ere() {
  fb = "\x80", fb += Sn.util.fillString("\0", 128), lb = [[1116352408, 3609767458], [1899447441, 602891725], [3049323471, 3964484399], [3921009573, 2173295548], [961987163, 4081628472], [1508970993, 3053834265], [2453635748, 2937671579], [2870763221, 3664609560], [3624381080, 2734883394], [310598401, 1164996542], [607225278, 1323610764], [1426881987, 3590304994], [1925078388, 4068182383], [2162078206, 991336113], [2614888103, 633803317], [3248222580, 3479774868], [3835390401, 2666613458], [4022224774, 944711139], [264347078, 2341262773], [604807628, 2007800933], [770255983, 1495990901], [1249150122, 1856431235], [1555081692, 3175218132], [1996064986, 2198950837], [2554220882, 3999719339], [2821834349, 766784016], [2952996808, 2566594879], [3210313671, 3203337956], [3336571891, 1034457026], [3584528711, 2466948901], [113926993, 3758326383], [338241895, 168717936], [666307205, 1188179964], [773529912, 1546045734], [1294757372, 1522805485], [1396182291, 2643833823], [1695183700, 2343527390], [1986661051, 1014477480], [2177026350, 1206759142], [2456956037, 344077627], [2730485921, 1290863460], [2820302411, 3158454273], [3259730800, 3505952657], [3345764771, 106217008], [3516065817, 3606008344], [3600352804, 1432725776], [4094571909, 1467031594], [275423344, 851169720], [430227734, 3100823752], [506948616, 1363258195], [659060556, 3750685593], [883997877, 3785050280], [958139571, 3318307427], [1322822218, 3812723403], [1537002063, 2003034995], [1747873779, 3602036899], [1955562222, 1575990012], [2024104815, 1125592928], [2227730452, 2716904306], [2361852424, 442776044], [2428436474, 593698344], [2756734187, 3733110249], [3204031479, 2999351573], [3329325298, 3815920427], [3391569614, 3928383900], [3515267271, 566280711], [3940187606, 3454069534], [4118630271, 4000239992], [116418474, 1914138554], [174292421, 2731055270], [289380356, 3203993006], [460393269, 320620315], [685471733, 587496836], [852142971, 1086792851], [1017036298, 365543100], [1126000580, 2618297676], [1288033470, 3409855158], [1501505948, 4234509866], [1607167915, 987167468], [1816402316, 1246189591]], Ul = {}, Ul["SHA-512"] = [[1779033703, 4089235720], [3144134277, 2227873595], [1013904242, 4271175723], [2773480762, 1595750129], [1359893119, 2917565137], [2600822924, 725511199], [528734635, 4215389547], [1541459225, 327033209]], Ul["SHA-384"] = [[3418070365, 3238371032], [1654270250, 914150663], [2438529370, 812702999], [355462360, 4144912697], [1731405415, 4290775857], [2394180231, 1750603025], [3675008525, 1694076839], [1203062813, 3204075428]], Ul["SHA-512/256"] = [[573645204, 4230739756], [2673172387, 3360449730], [596883563, 1867755857], [2520282905, 1497426621], [2519219938, 2827943907], [3193839141, 1401305490], [721525244, 746961066], [246885852, 2177182882]], Ul["SHA-512/224"] = [[2352822216, 424955298], [1944164710, 2312950998], [502970286, 855612546], [1738396948, 1479516111], [258812777, 2077511080], [2011393907, 79989058], [1067287976, 1780299464], [286451373, 2446758561]], LT = true;
}
function Nx(t3, e, n) {
  for (var r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U, Q, P, N, L, B, u, p, d, y, w, E, M, x, g, k, T = n.length(); T >= 128; ) {
    for (y = 0; y < 16; ++y) e[y][0] = n.getInt32() >>> 0, e[y][1] = n.getInt32() >>> 0;
    for (; y < 80; ++y) M = e[y - 2], w = M[0], E = M[1], r = ((w >>> 19 | E << 13) ^ (E >>> 29 | w << 3) ^ w >>> 6) >>> 0, s = ((w << 13 | E >>> 19) ^ (E << 3 | w >>> 29) ^ (w << 26 | E >>> 6)) >>> 0, g = e[y - 15], w = g[0], E = g[1], i = ((w >>> 1 | E << 31) ^ (w >>> 8 | E << 24) ^ w >>> 7) >>> 0, a = ((w << 31 | E >>> 1) ^ (w << 24 | E >>> 8) ^ (w << 25 | E >>> 7)) >>> 0, x = e[y - 7], k = e[y - 16], E = s + x[1] + a + k[1], e[y][0] = r + x[0] + i + k[0] + (E / 4294967296 >>> 0) >>> 0, e[y][1] = E >>> 0;
    for (A = t3[0][0], _ = t3[0][1], C = t3[1][0], I = t3[1][1], S = t3[2][0], $ = t3[2][1], F = t3[3][0], U = t3[3][1], Q = t3[4][0], P = t3[4][1], N = t3[5][0], L = t3[5][1], B = t3[6][0], u = t3[6][1], p = t3[7][0], d = t3[7][1], y = 0; y < 80; ++y) c = ((Q >>> 14 | P << 18) ^ (Q >>> 18 | P << 14) ^ (P >>> 9 | Q << 23)) >>> 0, l = ((Q << 18 | P >>> 14) ^ (Q << 14 | P >>> 18) ^ (P << 23 | Q >>> 9)) >>> 0, h = (B ^ Q & (N ^ B)) >>> 0, m = (u ^ P & (L ^ u)) >>> 0, o = ((A >>> 28 | _ << 4) ^ (_ >>> 2 | A << 30) ^ (_ >>> 7 | A << 25)) >>> 0, f = ((A << 4 | _ >>> 28) ^ (_ << 30 | A >>> 2) ^ (_ << 25 | A >>> 7)) >>> 0, v = (A & C | S & (A ^ C)) >>> 0, b = (_ & I | $ & (_ ^ I)) >>> 0, E = d + l + m + lb[y][1] + e[y][1], r = p + c + h + lb[y][0] + e[y][0] + (E / 4294967296 >>> 0) >>> 0, s = E >>> 0, E = f + b, i = o + v + (E / 4294967296 >>> 0) >>> 0, a = E >>> 0, p = B, d = u, B = N, u = L, N = Q, L = P, E = U + s, Q = F + r + (E / 4294967296 >>> 0) >>> 0, P = E >>> 0, F = S, U = $, S = C, $ = I, C = A, I = _, E = s + a, A = r + i + (E / 4294967296 >>> 0) >>> 0, _ = E >>> 0;
    E = t3[0][1] + _, t3[0][0] = t3[0][0] + A + (E / 4294967296 >>> 0) >>> 0, t3[0][1] = E >>> 0, E = t3[1][1] + I, t3[1][0] = t3[1][0] + C + (E / 4294967296 >>> 0) >>> 0, t3[1][1] = E >>> 0, E = t3[2][1] + $, t3[2][0] = t3[2][0] + S + (E / 4294967296 >>> 0) >>> 0, t3[2][1] = E >>> 0, E = t3[3][1] + U, t3[3][0] = t3[3][0] + F + (E / 4294967296 >>> 0) >>> 0, t3[3][1] = E >>> 0, E = t3[4][1] + P, t3[4][0] = t3[4][0] + Q + (E / 4294967296 >>> 0) >>> 0, t3[4][1] = E >>> 0, E = t3[5][1] + L, t3[5][0] = t3[5][0] + N + (E / 4294967296 >>> 0) >>> 0, t3[5][1] = E >>> 0, E = t3[6][1] + u, t3[6][0] = t3[6][0] + B + (E / 4294967296 >>> 0) >>> 0, t3[6][1] = E >>> 0, E = t3[7][1] + d, t3[7][0] = t3[7][0] + p + (E / 4294967296 >>> 0) >>> 0, t3[7][1] = E >>> 0, T -= 128;
  }
}
var p4 = {}, tre = Ur, bi = tre.asn1;
p4.privateKeyValidator = { name: "PrivateKeyInfo", tagClass: bi.Class.UNIVERSAL, type: bi.Type.SEQUENCE, constructed: true, value: [{ name: "PrivateKeyInfo.version", tagClass: bi.Class.UNIVERSAL, type: bi.Type.INTEGER, constructed: false, capture: "privateKeyVersion" }, { name: "PrivateKeyInfo.privateKeyAlgorithm", tagClass: bi.Class.UNIVERSAL, type: bi.Type.SEQUENCE, constructed: true, value: [{ name: "AlgorithmIdentifier.algorithm", tagClass: bi.Class.UNIVERSAL, type: bi.Type.OID, constructed: false, capture: "privateKeyOid" }] }, { name: "PrivateKeyInfo", tagClass: bi.Class.UNIVERSAL, type: bi.Type.OCTETSTRING, constructed: false, capture: "privateKey" }] };
p4.publicKeyValidator = { name: "SubjectPublicKeyInfo", tagClass: bi.Class.UNIVERSAL, type: bi.Type.SEQUENCE, constructed: true, captureAsn1: "subjectPublicKeyInfo", value: [{ name: "SubjectPublicKeyInfo.AlgorithmIdentifier", tagClass: bi.Class.UNIVERSAL, type: bi.Type.SEQUENCE, constructed: true, value: [{ name: "AlgorithmIdentifier.algorithm", tagClass: bi.Class.UNIVERSAL, type: bi.Type.OID, constructed: false, capture: "publicKeyOid" }] }, { tagClass: bi.Class.UNIVERSAL, type: bi.Type.BITSTRING, constructed: false, composed: true, captureBitStringValue: "ed25519PublicKey" }] };
var Pi = Ur, OT = p4, rre = OT.publicKeyValidator, nre = OT.privateKeyValidator;
if (typeof ire > "u") var ire = Pi.jsbn.BigInteger;
var ub = Pi.util.ByteBuffer, Ms = typeof hr > "u" ? Uint8Array : hr;
Pi.pki = Pi.pki || {};
Pi.pki.ed25519 = Pi.ed25519 = Pi.ed25519 || {};
var Hr = Pi.ed25519;
Hr.constants = {};
Hr.constants.PUBLIC_KEY_BYTE_LENGTH = 32;
Hr.constants.PRIVATE_KEY_BYTE_LENGTH = 64;
Hr.constants.SEED_BYTE_LENGTH = 32;
Hr.constants.SIGN_BYTE_LENGTH = 64;
Hr.constants.HASH_BYTE_LENGTH = 64;
Hr.generateKeyPair = function(t3) {
  t3 = t3 || {};
  var e = t3.seed;
  if (e === void 0) e = Pi.random.getBytesSync(Hr.constants.SEED_BYTE_LENGTH);
  else if (typeof e == "string") {
    if (e.length !== Hr.constants.SEED_BYTE_LENGTH) throw new TypeError('"seed" must be ' + Hr.constants.SEED_BYTE_LENGTH + " bytes in length.");
  } else if (!(e instanceof Uint8Array)) throw new TypeError('"seed" must be a node.js Buffer, Uint8Array, or a binary string.');
  e = nf({ message: e, encoding: "binary" });
  for (var n = new Ms(Hr.constants.PUBLIC_KEY_BYTE_LENGTH), r = new Ms(Hr.constants.PRIVATE_KEY_BYTE_LENGTH), s = 0; s < 32; ++s) r[s] = e[s];
  return fre(n, r), { publicKey: n, privateKey: r };
};
Hr.privateKeyFromAsn1 = function(t3) {
  var e = {}, n = [], r = Pi.asn1.validate(t3, nre, e, n);
  if (!r) {
    var s = new Error("Invalid Key.");
    throw s.errors = n, s;
  }
  var i = Pi.asn1.derToOid(e.privateKeyOid), a = Pi.oids.EdDSA25519;
  if (i !== a) throw new Error('Invalid OID "' + i + '"; OID must be "' + a + '".');
  var o = e.privateKey, f = nf({ message: Pi.asn1.fromDer(o).value, encoding: "binary" });
  return { privateKeyBytes: f };
};
Hr.publicKeyFromAsn1 = function(t3) {
  var e = {}, n = [], r = Pi.asn1.validate(t3, rre, e, n);
  if (!r) {
    var s = new Error("Invalid Key.");
    throw s.errors = n, s;
  }
  var i = Pi.asn1.derToOid(e.publicKeyOid), a = Pi.oids.EdDSA25519;
  if (i !== a) throw new Error('Invalid OID "' + i + '"; OID must be "' + a + '".');
  var o = e.ed25519PublicKey;
  if (o.length !== Hr.constants.PUBLIC_KEY_BYTE_LENGTH) throw new Error("Key length is invalid.");
  return nf({ message: o, encoding: "binary" });
};
Hr.publicKeyFromPrivateKey = function(t3) {
  t3 = t3 || {};
  var e = nf({ message: t3.privateKey, encoding: "binary" });
  if (e.length !== Hr.constants.PRIVATE_KEY_BYTE_LENGTH) throw new TypeError('"options.privateKey" must have a byte length of ' + Hr.constants.PRIVATE_KEY_BYTE_LENGTH);
  for (var n = new Ms(Hr.constants.PUBLIC_KEY_BYTE_LENGTH), r = 0; r < n.length; ++r) n[r] = e[32 + r];
  return n;
};
Hr.sign = function(t3) {
  t3 = t3 || {};
  var e = nf(t3), n = nf({ message: t3.privateKey, encoding: "binary" });
  if (n.length === Hr.constants.SEED_BYTE_LENGTH) {
    var r = Hr.generateKeyPair({ seed: n });
    n = r.privateKey;
  } else if (n.length !== Hr.constants.PRIVATE_KEY_BYTE_LENGTH) throw new TypeError('"options.privateKey" must have a byte length of ' + Hr.constants.SEED_BYTE_LENGTH + " or " + Hr.constants.PRIVATE_KEY_BYTE_LENGTH);
  var s = new Ms(Hr.constants.SIGN_BYTE_LENGTH + e.length);
  lre(s, e, e.length, n);
  for (var i = new Ms(Hr.constants.SIGN_BYTE_LENGTH), a = 0; a < i.length; ++a) i[a] = s[a];
  return i;
};
Hr.verify = function(t3) {
  t3 = t3 || {};
  var e = nf(t3);
  if (t3.signature === void 0) throw new TypeError('"options.signature" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.');
  var n = nf({ message: t3.signature, encoding: "binary" });
  if (n.length !== Hr.constants.SIGN_BYTE_LENGTH) throw new TypeError('"options.signature" must have a byte length of ' + Hr.constants.SIGN_BYTE_LENGTH);
  var r = nf({ message: t3.publicKey, encoding: "binary" });
  if (r.length !== Hr.constants.PUBLIC_KEY_BYTE_LENGTH) throw new TypeError('"options.publicKey" must have a byte length of ' + Hr.constants.PUBLIC_KEY_BYTE_LENGTH);
  var s = new Ms(Hr.constants.SIGN_BYTE_LENGTH + e.length), i = new Ms(Hr.constants.SIGN_BYTE_LENGTH + e.length), a;
  for (a = 0; a < Hr.constants.SIGN_BYTE_LENGTH; ++a) s[a] = n[a];
  for (a = 0; a < e.length; ++a) s[a + Hr.constants.SIGN_BYTE_LENGTH] = e[a];
  return ure(i, s, s.length, r) >= 0;
};
function nf(t3) {
  var e = t3.message;
  if (e instanceof Uint8Array || e instanceof Ms) return e;
  var n = t3.encoding;
  if (e === void 0) if (t3.md) e = t3.md.digest().getBytes(), n = "binary";
  else throw new TypeError('"options.message" or "options.md" not specified.');
  if (typeof e == "string" && !n) throw new TypeError('"options.encoding" must be "binary" or "utf8".');
  if (typeof e == "string") {
    if (typeof hr < "u") return hr.from(e, n);
    e = new ub(e, n);
  } else if (!(e instanceof ub)) throw new TypeError('"options.message" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with "options.encoding" specifying its encoding.');
  for (var r = new Ms(e.length()), s = 0; s < r.length; ++s) r[s] = e.at(s);
  return r;
}
var cb = Ar(), P1 = Ar([1]), sre = Ar([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), are = Ar([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), Ux = Ar([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Lx = Ar([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), Av = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]), ore = Ar([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
function uh(t3, e) {
  var n = Pi.md.sha512.create(), r = new ub(t3);
  n.update(r.getBytes(e), "binary");
  var s = n.digest().getBytes();
  if (typeof hr < "u") return hr.from(s, "binary");
  for (var i = new Ms(Hr.constants.HASH_BYTE_LENGTH), a = 0; a < 64; ++a) i[a] = s.charCodeAt(a);
  return i;
}
function fre(t3, e) {
  var n = [Ar(), Ar(), Ar(), Ar()], r, s = uh(e, 32);
  for (s[0] &= 248, s[31] &= 127, s[31] |= 64, m4(n, s), g4(t3, n), r = 0; r < 32; ++r) e[r + 32] = t3[r];
  return 0;
}
function lre(t3, e, n, r) {
  var s, i, a = new Float64Array(64), o = [Ar(), Ar(), Ar(), Ar()], f = uh(r, 32);
  f[0] &= 248, f[31] &= 127, f[31] |= 64;
  var c = n + 64;
  for (s = 0; s < n; ++s) t3[64 + s] = e[s];
  for (s = 0; s < 32; ++s) t3[32 + s] = f[32 + s];
  var l = uh(t3.subarray(32), n + 32);
  for (hb(l), m4(o, l), g4(t3, o), s = 32; s < 64; ++s) t3[s] = r[s];
  var h = uh(t3, n + 64);
  for (hb(h), s = 32; s < 64; ++s) a[s] = 0;
  for (s = 0; s < 32; ++s) a[s] = l[s];
  for (s = 0; s < 32; ++s) for (i = 0; i < 32; i++) a[s + i] += h[s] * f[i];
  return QT(t3.subarray(32), a), c;
}
function ure(t3, e, n, r) {
  var s, i, a = new Ms(32), o = [Ar(), Ar(), Ar(), Ar()], f = [Ar(), Ar(), Ar(), Ar()];
  if (i = -1, n < 64 || cre(f, r)) return -1;
  for (s = 0; s < n; ++s) t3[s] = e[s];
  for (s = 0; s < 32; ++s) t3[s + 32] = r[s];
  var c = uh(t3, n);
  if (hb(c), qT(o, f, c), m4(f, e.subarray(32)), db(o, f), g4(a, o), n -= 64, KT(e, 0, a, 0)) {
    for (s = 0; s < n; ++s) t3[s] = 0;
    return -1;
  }
  for (s = 0; s < n; ++s) t3[s] = e[s + 64];
  return i = n, i;
}
function QT(t3, e) {
  var n, r, s, i;
  for (r = 63; r >= 32; --r) {
    for (n = 0, s = r - 32, i = r - 12; s < i; ++s) e[s] += n - 16 * e[r] * Av[s - (r - 32)], n = e[s] + 128 >> 8, e[s] -= n * 256;
    e[s] += n, e[r] = 0;
  }
  for (n = 0, s = 0; s < 32; ++s) e[s] += n - (e[31] >> 4) * Av[s], n = e[s] >> 8, e[s] &= 255;
  for (s = 0; s < 32; ++s) e[s] -= n * Av[s];
  for (r = 0; r < 32; ++r) e[r + 1] += e[r] >> 8, t3[r] = e[r] & 255;
}
function hb(t3) {
  for (var e = new Float64Array(64), n = 0; n < 64; ++n) e[n] = t3[n], t3[n] = 0;
  QT(t3, e);
}
function db(t3, e) {
  var n = Ar(), r = Ar(), s = Ar(), i = Ar(), a = Ar(), o = Ar(), f = Ar(), c = Ar(), l = Ar();
  nu(n, t3[1], t3[0]), nu(l, e[1], e[0]), gn(n, n, l), q0(r, t3[0], t3[1]), q0(l, e[0], e[1]), gn(r, r, l), gn(s, t3[3], e[3]), gn(s, s, are), gn(i, t3[2], e[2]), q0(i, i, i), nu(a, r, n), nu(o, i, s), q0(f, i, s), q0(c, r, n), gn(t3[0], a, o), gn(t3[1], c, f), gn(t3[2], f, o), gn(t3[3], a, c);
}
function Ox(t3, e, n) {
  for (var r = 0; r < 4; ++r) zT(t3[r], e[r], n);
}
function g4(t3, e) {
  var n = Ar(), r = Ar(), s = Ar();
  gre(s, e[2]), gn(n, e[0], s), gn(r, e[1], s), N1(t3, r), t3[31] ^= HT(n) << 7;
}
function N1(t3, e) {
  var n, r, s, i = Ar(), a = Ar();
  for (n = 0; n < 16; ++n) a[n] = e[n];
  for (wv(a), wv(a), wv(a), r = 0; r < 2; ++r) {
    for (i[0] = a[0] - 65517, n = 1; n < 15; ++n) i[n] = a[n] - 65535 - (i[n - 1] >> 16 & 1), i[n - 1] &= 65535;
    i[15] = a[15] - 32767 - (i[14] >> 16 & 1), s = i[15] >> 16 & 1, i[14] &= 65535, zT(a, i, 1 - s);
  }
  for (n = 0; n < 16; n++) t3[2 * n] = a[n] & 255, t3[2 * n + 1] = a[n] >> 8;
}
function cre(t3, e) {
  var n = Ar(), r = Ar(), s = Ar(), i = Ar(), a = Ar(), o = Ar(), f = Ar();
  return Wf(t3[2], P1), hre(t3[1], e), Ll(s, t3[1]), gn(i, s, sre), nu(s, s, t3[2]), q0(i, t3[2], i), Ll(a, i), Ll(o, a), gn(f, o, a), gn(n, f, s), gn(n, n, i), dre(n, n), gn(n, n, s), gn(n, n, i), gn(n, n, i), gn(t3[0], n, i), Ll(r, t3[0]), gn(r, r, i), Qx(r, s) && gn(t3[0], t3[0], ore), Ll(r, t3[0]), gn(r, r, i), Qx(r, s) ? -1 : (HT(t3[0]) === e[31] >> 7 && nu(t3[0], cb, t3[0]), gn(t3[3], t3[0], t3[1]), 0);
}
function hre(t3, e) {
  var n;
  for (n = 0; n < 16; ++n) t3[n] = e[2 * n] + (e[2 * n + 1] << 8);
  t3[15] &= 32767;
}
function dre(t3, e) {
  var n = Ar(), r;
  for (r = 0; r < 16; ++r) n[r] = e[r];
  for (r = 250; r >= 0; --r) Ll(n, n), r !== 1 && gn(n, n, e);
  for (r = 0; r < 16; ++r) t3[r] = n[r];
}
function Qx(t3, e) {
  var n = new Ms(32), r = new Ms(32);
  return N1(n, t3), N1(r, e), KT(n, 0, r, 0);
}
function KT(t3, e, n, r) {
  return pre(t3, e, n, r, 32);
}
function pre(t3, e, n, r, s) {
  var i, a = 0;
  for (i = 0; i < s; ++i) a |= t3[e + i] ^ n[r + i];
  return (1 & a - 1 >>> 8) - 1;
}
function HT(t3) {
  var e = new Ms(32);
  return N1(e, t3), e[0] & 1;
}
function qT(t3, e, n) {
  var r, s;
  for (Wf(t3[0], cb), Wf(t3[1], P1), Wf(t3[2], P1), Wf(t3[3], cb), s = 255; s >= 0; --s) r = n[s / 8 | 0] >> (s & 7) & 1, Ox(t3, e, r), db(e, t3), db(t3, t3), Ox(t3, e, r);
}
function m4(t3, e) {
  var n = [Ar(), Ar(), Ar(), Ar()];
  Wf(n[0], Ux), Wf(n[1], Lx), Wf(n[2], P1), gn(n[3], Ux, Lx), qT(t3, n, e);
}
function Wf(t3, e) {
  var n;
  for (n = 0; n < 16; n++) t3[n] = e[n] | 0;
}
function gre(t3, e) {
  var n = Ar(), r;
  for (r = 0; r < 16; ++r) n[r] = e[r];
  for (r = 253; r >= 0; --r) Ll(n, n), r !== 2 && r !== 4 && gn(n, n, e);
  for (r = 0; r < 16; ++r) t3[r] = n[r];
}
function wv(t3) {
  var e, n, r = 1;
  for (e = 0; e < 16; ++e) n = t3[e] + r + 65535, r = Math.floor(n / 65536), t3[e] = n - r * 65536;
  t3[0] += r - 1 + 37 * (r - 1);
}
function zT(t3, e, n) {
  for (var r, s = ~(n - 1), i = 0; i < 16; ++i) r = s & (t3[i] ^ e[i]), t3[i] ^= r, e[i] ^= r;
}
function Ar(t3) {
  var e, n = new Float64Array(16);
  if (t3) for (e = 0; e < t3.length; ++e) n[e] = t3[e];
  return n;
}
function q0(t3, e, n) {
  for (var r = 0; r < 16; ++r) t3[r] = e[r] + n[r];
}
function nu(t3, e, n) {
  for (var r = 0; r < 16; ++r) t3[r] = e[r] - n[r];
}
function Ll(t3, e) {
  gn(t3, e, e);
}
function gn(t3, e, n) {
  var r, s, i = 0, a = 0, o = 0, f = 0, c = 0, l = 0, h = 0, m = 0, v = 0, b = 0, A = 0, _ = 0, C = 0, I = 0, S = 0, $ = 0, F = 0, U = 0, Q = 0, P = 0, N = 0, L = 0, B = 0, u = 0, p = 0, d = 0, y = 0, w = 0, E = 0, M = 0, x = 0, g = n[0], k = n[1], T = n[2], O = n[3], K = n[4], Y = n[5], J = n[6], G = n[7], X = n[8], ie = n[9], de = n[10], se = n[11], te = n[12], le = n[13], Z = n[14], ve = n[15];
  r = e[0], i += r * g, a += r * k, o += r * T, f += r * O, c += r * K, l += r * Y, h += r * J, m += r * G, v += r * X, b += r * ie, A += r * de, _ += r * se, C += r * te, I += r * le, S += r * Z, $ += r * ve, r = e[1], a += r * g, o += r * k, f += r * T, c += r * O, l += r * K, h += r * Y, m += r * J, v += r * G, b += r * X, A += r * ie, _ += r * de, C += r * se, I += r * te, S += r * le, $ += r * Z, F += r * ve, r = e[2], o += r * g, f += r * k, c += r * T, l += r * O, h += r * K, m += r * Y, v += r * J, b += r * G, A += r * X, _ += r * ie, C += r * de, I += r * se, S += r * te, $ += r * le, F += r * Z, U += r * ve, r = e[3], f += r * g, c += r * k, l += r * T, h += r * O, m += r * K, v += r * Y, b += r * J, A += r * G, _ += r * X, C += r * ie, I += r * de, S += r * se, $ += r * te, F += r * le, U += r * Z, Q += r * ve, r = e[4], c += r * g, l += r * k, h += r * T, m += r * O, v += r * K, b += r * Y, A += r * J, _ += r * G, C += r * X, I += r * ie, S += r * de, $ += r * se, F += r * te, U += r * le, Q += r * Z, P += r * ve, r = e[5], l += r * g, h += r * k, m += r * T, v += r * O, b += r * K, A += r * Y, _ += r * J, C += r * G, I += r * X, S += r * ie, $ += r * de, F += r * se, U += r * te, Q += r * le, P += r * Z, N += r * ve, r = e[6], h += r * g, m += r * k, v += r * T, b += r * O, A += r * K, _ += r * Y, C += r * J, I += r * G, S += r * X, $ += r * ie, F += r * de, U += r * se, Q += r * te, P += r * le, N += r * Z, L += r * ve, r = e[7], m += r * g, v += r * k, b += r * T, A += r * O, _ += r * K, C += r * Y, I += r * J, S += r * G, $ += r * X, F += r * ie, U += r * de, Q += r * se, P += r * te, N += r * le, L += r * Z, B += r * ve, r = e[8], v += r * g, b += r * k, A += r * T, _ += r * O, C += r * K, I += r * Y, S += r * J, $ += r * G, F += r * X, U += r * ie, Q += r * de, P += r * se, N += r * te, L += r * le, B += r * Z, u += r * ve, r = e[9], b += r * g, A += r * k, _ += r * T, C += r * O, I += r * K, S += r * Y, $ += r * J, F += r * G, U += r * X, Q += r * ie, P += r * de, N += r * se, L += r * te, B += r * le, u += r * Z, p += r * ve, r = e[10], A += r * g, _ += r * k, C += r * T, I += r * O, S += r * K, $ += r * Y, F += r * J, U += r * G, Q += r * X, P += r * ie, N += r * de, L += r * se, B += r * te, u += r * le, p += r * Z, d += r * ve, r = e[11], _ += r * g, C += r * k, I += r * T, S += r * O, $ += r * K, F += r * Y, U += r * J, Q += r * G, P += r * X, N += r * ie, L += r * de, B += r * se, u += r * te, p += r * le, d += r * Z, y += r * ve, r = e[12], C += r * g, I += r * k, S += r * T, $ += r * O, F += r * K, U += r * Y, Q += r * J, P += r * G, N += r * X, L += r * ie, B += r * de, u += r * se, p += r * te, d += r * le, y += r * Z, w += r * ve, r = e[13], I += r * g, S += r * k, $ += r * T, F += r * O, U += r * K, Q += r * Y, P += r * J, N += r * G, L += r * X, B += r * ie, u += r * de, p += r * se, d += r * te, y += r * le, w += r * Z, E += r * ve, r = e[14], S += r * g, $ += r * k, F += r * T, U += r * O, Q += r * K, P += r * Y, N += r * J, L += r * G, B += r * X, u += r * ie, p += r * de, d += r * se, y += r * te, w += r * le, E += r * Z, M += r * ve, r = e[15], $ += r * g, F += r * k, U += r * T, Q += r * O, P += r * K, N += r * Y, L += r * J, B += r * G, u += r * X, p += r * ie, d += r * de, y += r * se, w += r * te, E += r * le, M += r * Z, x += r * ve, i += 38 * F, a += 38 * U, o += 38 * Q, f += 38 * P, c += 38 * N, l += 38 * L, h += 38 * B, m += 38 * u, v += 38 * p, b += 38 * d, A += 38 * y, _ += 38 * w, C += 38 * E, I += 38 * M, S += 38 * x, s = 1, r = i + s + 65535, s = Math.floor(r / 65536), i = r - s * 65536, r = a + s + 65535, s = Math.floor(r / 65536), a = r - s * 65536, r = o + s + 65535, s = Math.floor(r / 65536), o = r - s * 65536, r = f + s + 65535, s = Math.floor(r / 65536), f = r - s * 65536, r = c + s + 65535, s = Math.floor(r / 65536), c = r - s * 65536, r = l + s + 65535, s = Math.floor(r / 65536), l = r - s * 65536, r = h + s + 65535, s = Math.floor(r / 65536), h = r - s * 65536, r = m + s + 65535, s = Math.floor(r / 65536), m = r - s * 65536, r = v + s + 65535, s = Math.floor(r / 65536), v = r - s * 65536, r = b + s + 65535, s = Math.floor(r / 65536), b = r - s * 65536, r = A + s + 65535, s = Math.floor(r / 65536), A = r - s * 65536, r = _ + s + 65535, s = Math.floor(r / 65536), _ = r - s * 65536, r = C + s + 65535, s = Math.floor(r / 65536), C = r - s * 65536, r = I + s + 65535, s = Math.floor(r / 65536), I = r - s * 65536, r = S + s + 65535, s = Math.floor(r / 65536), S = r - s * 65536, r = $ + s + 65535, s = Math.floor(r / 65536), $ = r - s * 65536, i += s - 1 + 37 * (s - 1), s = 1, r = i + s + 65535, s = Math.floor(r / 65536), i = r - s * 65536, r = a + s + 65535, s = Math.floor(r / 65536), a = r - s * 65536, r = o + s + 65535, s = Math.floor(r / 65536), o = r - s * 65536, r = f + s + 65535, s = Math.floor(r / 65536), f = r - s * 65536, r = c + s + 65535, s = Math.floor(r / 65536), c = r - s * 65536, r = l + s + 65535, s = Math.floor(r / 65536), l = r - s * 65536, r = h + s + 65535, s = Math.floor(r / 65536), h = r - s * 65536, r = m + s + 65535, s = Math.floor(r / 65536), m = r - s * 65536, r = v + s + 65535, s = Math.floor(r / 65536), v = r - s * 65536, r = b + s + 65535, s = Math.floor(r / 65536), b = r - s * 65536, r = A + s + 65535, s = Math.floor(r / 65536), A = r - s * 65536, r = _ + s + 65535, s = Math.floor(r / 65536), _ = r - s * 65536, r = C + s + 65535, s = Math.floor(r / 65536), C = r - s * 65536, r = I + s + 65535, s = Math.floor(r / 65536), I = r - s * 65536, r = S + s + 65535, s = Math.floor(r / 65536), S = r - s * 65536, r = $ + s + 65535, s = Math.floor(r / 65536), $ = r - s * 65536, i += s - 1 + 37 * (s - 1), t3[0] = i, t3[1] = a, t3[2] = o, t3[3] = f, t3[4] = c, t3[5] = l, t3[6] = h, t3[7] = m, t3[8] = v, t3[9] = b, t3[10] = A, t3[11] = _, t3[12] = C, t3[13] = I, t3[14] = S, t3[15] = $;
}
var Os = Ur;
Os.kem = Os.kem || {};
var Kx = Os.jsbn.BigInteger;
Os.kem.rsa = {};
Os.kem.rsa.create = function(t3, e) {
  e = e || {};
  var n = e.prng || Os.random, r = {};
  return r.encrypt = function(s, i) {
    var a = Math.ceil(s.n.bitLength() / 8), o;
    do
      o = new Kx(Os.util.bytesToHex(n.getBytesSync(a)), 16).mod(s.n);
    while (o.compareTo(Kx.ONE) <= 0);
    o = Os.util.hexToBytes(o.toString(16));
    var f = a - o.length;
    f > 0 && (o = Os.util.fillString("\0", f) + o);
    var c = s.encrypt(o, "NONE"), l = t3.generate(o, i);
    return { encapsulation: c, key: l };
  }, r.decrypt = function(s, i, a) {
    var o = s.decrypt(i, "NONE");
    return t3.generate(o, a);
  }, r;
};
Os.kem.kdf1 = function(t3, e) {
  GT(this, t3, 0, e || t3.digestLength);
};
Os.kem.kdf2 = function(t3, e) {
  GT(this, t3, 1, e || t3.digestLength);
};
function GT(t3, e, n, r) {
  t3.generate = function(s, i) {
    for (var a = new Os.util.ByteBuffer(), o = Math.ceil(i / r) + n, f = new Os.util.ByteBuffer(), c = n; c < o; ++c) {
      f.putInt32(c), e.start(), e.update(s + f.getBytes());
      var l = e.digest();
      a.putBytes(l.getBytes(r));
    }
    return a.truncate(a.length() - i), a.getBytes();
  };
}
var zr = Ur;
zr.log = zr.log || {};
zr.log.levels = ["none", "error", "warning", "info", "debug", "verbose", "max"];
var U1 = {}, pb = [], ch = null;
zr.log.LEVEL_LOCKED = 2;
zr.log.NO_LEVEL_CHECK = 4;
zr.log.INTERPOLATE = 8;
for (var Jf = 0; Jf < zr.log.levels.length; ++Jf) {
  var Hx = zr.log.levels[Jf];
  U1[Hx] = { index: Jf, name: Hx.toUpperCase() };
}
zr.log.logMessage = function(t3) {
  for (var e = U1[t3.level].index, n = 0; n < pb.length; ++n) {
    var r = pb[n];
    if (r.flags & zr.log.NO_LEVEL_CHECK) r.f(t3);
    else {
      var s = U1[r.level].index;
      e <= s && r.f(r, t3);
    }
  }
};
zr.log.prepareStandard = function(t3) {
  "standard" in t3 || (t3.standard = U1[t3.level].name + " [" + t3.category + "] " + t3.message);
};
zr.log.prepareFull = function(t3) {
  if (!("full" in t3)) {
    var e = [t3.message];
    e = e.concat([]), t3.full = zr.util.format.apply(this, e);
  }
};
zr.log.prepareStandardFull = function(t3) {
  "standardFull" in t3 || (zr.log.prepareStandard(t3), t3.standardFull = t3.standard);
};
for (var qx = ["error", "warning", "info", "debug", "verbose"], Jf = 0; Jf < qx.length; ++Jf) (function(e) {
  zr.log[e] = function(n, r) {
    var s = Array.prototype.slice.call(arguments).slice(2), i = { timestamp: /* @__PURE__ */ new Date(), level: e, category: n, message: r, arguments: s };
    zr.log.logMessage(i);
  };
})(qx[Jf]);
zr.log.makeLogger = function(t3) {
  var e = { flags: 0, f: t3 };
  return zr.log.setLevel(e, "none"), e;
};
zr.log.setLevel = function(t3, e) {
  var n = false;
  if (t3 && !(t3.flags & zr.log.LEVEL_LOCKED)) for (var r = 0; r < zr.log.levels.length; ++r) {
    var s = zr.log.levels[r];
    if (e == s) {
      t3.level = e, n = true;
      break;
    }
  }
  return n;
};
zr.log.lock = function(t3, e) {
  typeof e > "u" || e ? t3.flags |= zr.log.LEVEL_LOCKED : t3.flags &= ~zr.log.LEVEL_LOCKED;
};
zr.log.addLogger = function(t3) {
  pb.push(t3);
};
if (typeof console < "u" && "log" in console) {
  var Fc;
  if (console.error && console.warn && console.info && console.debug) {
    var mre = { error: console.error, warning: console.warn, info: console.info, debug: console.debug, verbose: console.debug }, v4 = function(t3, e) {
      zr.log.prepareStandard(e);
      var n = mre[e.level], r = [e.standard];
      r = r.concat(e.arguments.slice()), n.apply(console, r);
    };
    Fc = zr.log.makeLogger(v4);
  } else {
    var v4 = function(e, n) {
      zr.log.prepareStandardFull(n), console.log(n.standardFull);
    };
    Fc = zr.log.makeLogger(v4);
  }
  zr.log.setLevel(Fc, "debug"), zr.log.addLogger(Fc), ch = Fc;
} else console = { log: function() {
} };
if (ch !== null && typeof window < "u" && window.location) {
  var ap = new URL(window.location.href).searchParams;
  if (ap.has("console.level") && zr.log.setLevel(ch, ap.get("console.level").slice(-1)[0]), ap.has("console.lock")) {
    var vre = ap.get("console.lock").slice(-1)[0];
    vre == "true" && zr.log.lock(ch);
  }
}
zr.log.consoleLogger = ch;
var qt = Ur, Ve = qt.asn1, ds = qt.pkcs7 = qt.pkcs7 || {};
ds.messageFromPem = function(t3) {
  var e = qt.pem.decode(t3)[0];
  if (e.type !== "PKCS7") {
    var n = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".');
    throw n.headerType = e.type, n;
  }
  if (e.procType && e.procType.type === "ENCRYPTED") throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");
  var r = Ve.fromDer(e.body);
  return ds.messageFromAsn1(r);
};
ds.messageToPem = function(t3, e) {
  var n = { type: "PKCS7", body: Ve.toDer(t3.toAsn1()).getBytes() };
  return qt.pem.encode(n, { maxline: e });
};
ds.messageFromAsn1 = function(t3) {
  var e = {}, n = [];
  if (!Ve.validate(t3, ds.asn1.contentInfoValidator, e, n)) {
    var r = new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");
    throw r.errors = n, r;
  }
  var s = Ve.derToOid(e.contentType), i;
  switch (s) {
    case qt.pki.oids.envelopedData:
      i = ds.createEnvelopedData();
      break;
    case qt.pki.oids.encryptedData:
      i = ds.createEncryptedData();
      break;
    case qt.pki.oids.signedData:
      i = ds.createSignedData();
      break;
    default:
      throw new Error("Cannot read PKCS#7 message. ContentType with OID " + s + " is not (yet) supported.");
  }
  return i.fromAsn1(e.content.value[0]), i;
};
ds.createSignedData = function() {
  var t3 = null;
  return t3 = { type: qt.pki.oids.signedData, version: 1, certificates: [], crls: [], signers: [], digestAlgorithmIdentifiers: [], contentInfo: null, signerInfos: [], fromAsn1: function(r) {
    if (y4(t3, r, ds.asn1.signedDataValidator), t3.certificates = [], t3.crls = [], t3.digestAlgorithmIdentifiers = [], t3.contentInfo = null, t3.signerInfos = [], t3.rawCapture.certificates) for (var s = t3.rawCapture.certificates.value, i = 0; i < s.length; ++i) t3.certificates.push(qt.pki.certificateFromAsn1(s[i]));
  }, toAsn1: function() {
    t3.contentInfo || t3.sign();
    for (var r = [], s = 0; s < t3.certificates.length; ++s) r.push(qt.pki.certificateToAsn1(t3.certificates[s]));
    var i = [], a = Ve.create(Ve.Class.CONTEXT_SPECIFIC, 0, true, [Ve.create(Ve.Class.UNIVERSAL, Ve.Type.SEQUENCE, true, [Ve.create(Ve.Class.UNIVERSAL, Ve.Type.INTEGER, false, Ve.integerToDer(t3.version).getBytes()), Ve.create(Ve.Class.UNIVERSAL, Ve.Type.SET, true, t3.digestAlgorithmIdentifiers), t3.contentInfo])]);
    return r.length > 0 && a.value[0].value.push(Ve.create(Ve.Class.CONTEXT_SPECIFIC, 0, true, r)), i.length > 0 && a.value[0].value.push(Ve.create(Ve.Class.CONTEXT_SPECIFIC, 1, true, i)), a.value[0].value.push(Ve.create(Ve.Class.UNIVERSAL, Ve.Type.SET, true, t3.signerInfos)), Ve.create(Ve.Class.UNIVERSAL, Ve.Type.SEQUENCE, true, [Ve.create(Ve.Class.UNIVERSAL, Ve.Type.OID, false, Ve.oidToDer(t3.type).getBytes()), a]);
  }, addSigner: function(r) {
    var s = r.issuer, i = r.serialNumber;
    if (r.certificate) {
      var a = r.certificate;
      typeof a == "string" && (a = qt.pki.certificateFromPem(a)), s = a.issuer.attributes, i = a.serialNumber;
    }
    var o = r.key;
    if (!o) throw new Error("Could not add PKCS#7 signer; no private key specified.");
    typeof o == "string" && (o = qt.pki.privateKeyFromPem(o));
    var f = r.digestAlgorithm || qt.pki.oids.sha1;
    switch (f) {
      case qt.pki.oids.sha1:
      case qt.pki.oids.sha256:
      case qt.pki.oids.sha384:
      case qt.pki.oids.sha512:
      case qt.pki.oids.md5:
        break;
      default:
        throw new Error("Could not add PKCS#7 signer; unknown message digest algorithm: " + f);
    }
    var c = r.authenticatedAttributes || [];
    if (c.length > 0) {
      for (var l = false, h = false, m = 0; m < c.length; ++m) {
        var v = c[m];
        if (!l && v.type === qt.pki.oids.contentType) {
          if (l = true, h) break;
          continue;
        }
        if (!h && v.type === qt.pki.oids.messageDigest) {
          if (h = true, l) break;
          continue;
        }
      }
      if (!l || !h) throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.");
    }
    t3.signers.push({ key: o, version: 1, issuer: s, serialNumber: i, digestAlgorithm: f, signatureAlgorithm: qt.pki.oids.rsaEncryption, signature: null, authenticatedAttributes: c, unauthenticatedAttributes: [] });
  }, sign: function(r) {
    if (r = r || {}, (typeof t3.content != "object" || t3.contentInfo === null) && (t3.contentInfo = Ve.create(Ve.Class.UNIVERSAL, Ve.Type.SEQUENCE, true, [Ve.create(Ve.Class.UNIVERSAL, Ve.Type.OID, false, Ve.oidToDer(qt.pki.oids.data).getBytes())]), "content" in t3)) {
      var s;
      t3.content instanceof qt.util.ByteBuffer ? s = t3.content.bytes() : typeof t3.content == "string" && (s = qt.util.encodeUtf8(t3.content)), r.detached ? t3.detachedContent = Ve.create(Ve.Class.UNIVERSAL, Ve.Type.OCTETSTRING, false, s) : t3.contentInfo.value.push(Ve.create(Ve.Class.CONTEXT_SPECIFIC, 0, true, [Ve.create(Ve.Class.UNIVERSAL, Ve.Type.OCTETSTRING, false, s)]));
    }
    if (t3.signers.length !== 0) {
      var i = e();
      n(i);
    }
  }, verify: function() {
    throw new Error("PKCS#7 signature verification not yet implemented.");
  }, addCertificate: function(r) {
    typeof r == "string" && (r = qt.pki.certificateFromPem(r)), t3.certificates.push(r);
  }, addCertificateRevokationList: function(r) {
    throw new Error("PKCS#7 CRL support not yet implemented.");
  } }, t3;
  function e() {
    for (var r = {}, s = 0; s < t3.signers.length; ++s) {
      var i = t3.signers[s], a = i.digestAlgorithm;
      a in r || (r[a] = qt.md[qt.pki.oids[a]].create()), i.authenticatedAttributes.length === 0 ? i.md = r[a] : i.md = qt.md[qt.pki.oids[a]].create();
    }
    t3.digestAlgorithmIdentifiers = [];
    for (var a in r) t3.digestAlgorithmIdentifiers.push(Ve.create(Ve.Class.UNIVERSAL, Ve.Type.SEQUENCE, true, [Ve.create(Ve.Class.UNIVERSAL, Ve.Type.OID, false, Ve.oidToDer(a).getBytes()), Ve.create(Ve.Class.UNIVERSAL, Ve.Type.NULL, false, "")]));
    return r;
  }
  function n(r) {
    var s;
    if (t3.detachedContent ? s = t3.detachedContent : (s = t3.contentInfo.value[1], s = s.value[0]), !s) throw new Error("Could not sign PKCS#7 message; there is no content to sign.");
    var i = Ve.derToOid(t3.contentInfo.value[0].value), a = Ve.toDer(s);
    a.getByte(), Ve.getBerValueLength(a), a = a.getBytes();
    for (var o in r) r[o].start().update(a);
    for (var f = /* @__PURE__ */ new Date(), c = 0; c < t3.signers.length; ++c) {
      var l = t3.signers[c];
      if (l.authenticatedAttributes.length === 0) {
        if (i !== qt.pki.oids.data) throw new Error("Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data.");
      } else {
        l.authenticatedAttributesAsn1 = Ve.create(Ve.Class.CONTEXT_SPECIFIC, 0, true, []);
        for (var h = Ve.create(Ve.Class.UNIVERSAL, Ve.Type.SET, true, []), m = 0; m < l.authenticatedAttributes.length; ++m) {
          var v = l.authenticatedAttributes[m];
          v.type === qt.pki.oids.messageDigest ? v.value = r[l.digestAlgorithm].digest() : v.type === qt.pki.oids.signingTime && (v.value || (v.value = f)), h.value.push(gb(v)), l.authenticatedAttributesAsn1.value.push(gb(v));
        }
        a = Ve.toDer(h).getBytes(), l.md.start().update(a);
      }
      l.signature = l.key.sign(l.md, "RSASSA-PKCS1-V1_5");
    }
    t3.signerInfos = _re(t3.signers);
  }
};
ds.createEncryptedData = function() {
  var t3 = null;
  return t3 = { type: qt.pki.oids.encryptedData, version: 0, encryptedContent: { algorithm: qt.pki.oids["aes256-CBC"] }, fromAsn1: function(e) {
    y4(t3, e, ds.asn1.encryptedDataValidator);
  }, decrypt: function(e) {
    e !== void 0 && (t3.encryptedContent.key = e), VT(t3);
  } }, t3;
};
ds.createEnvelopedData = function() {
  var t3 = null;
  return t3 = { type: qt.pki.oids.envelopedData, version: 0, recipients: [], encryptedContent: { algorithm: qt.pki.oids["aes256-CBC"] }, fromAsn1: function(e) {
    var n = y4(t3, e, ds.asn1.envelopedDataValidator);
    t3.recipients = Are(n.recipientInfos.value);
  }, toAsn1: function() {
    return Ve.create(Ve.Class.UNIVERSAL, Ve.Type.SEQUENCE, true, [Ve.create(Ve.Class.UNIVERSAL, Ve.Type.OID, false, Ve.oidToDer(t3.type).getBytes()), Ve.create(Ve.Class.CONTEXT_SPECIFIC, 0, true, [Ve.create(Ve.Class.UNIVERSAL, Ve.Type.SEQUENCE, true, [Ve.create(Ve.Class.UNIVERSAL, Ve.Type.INTEGER, false, Ve.integerToDer(t3.version).getBytes()), Ve.create(Ve.Class.UNIVERSAL, Ve.Type.SET, true, wre(t3.recipients)), Ve.create(Ve.Class.UNIVERSAL, Ve.Type.SEQUENCE, true, Ere(t3.encryptedContent))])])]);
  }, findRecipient: function(e) {
    for (var n = e.issuer.attributes, r = 0; r < t3.recipients.length; ++r) {
      var s = t3.recipients[r], i = s.issuer;
      if (s.serialNumber === e.serialNumber && i.length === n.length) {
        for (var a = true, o = 0; o < n.length; ++o) if (i[o].type !== n[o].type || i[o].value !== n[o].value) {
          a = false;
          break;
        }
        if (a) return s;
      }
    }
    return null;
  }, decrypt: function(e, n) {
    if (t3.encryptedContent.key === void 0 && e !== void 0 && n !== void 0) switch (e.encryptedContent.algorithm) {
      case qt.pki.oids.rsaEncryption:
      case qt.pki.oids.desCBC:
        var r = n.decrypt(e.encryptedContent.content);
        t3.encryptedContent.key = qt.util.createBuffer(r);
        break;
      default:
        throw new Error("Unsupported asymmetric cipher, OID " + e.encryptedContent.algorithm);
    }
    VT(t3);
  }, addRecipient: function(e) {
    t3.recipients.push({ version: 0, issuer: e.issuer.attributes, serialNumber: e.serialNumber, encryptedContent: { algorithm: qt.pki.oids.rsaEncryption, key: e.publicKey } });
  }, encrypt: function(e, n) {
    if (t3.encryptedContent.content === void 0) {
      n = n || t3.encryptedContent.algorithm, e = e || t3.encryptedContent.key;
      var r, s, i;
      switch (n) {
        case qt.pki.oids["aes128-CBC"]:
          r = 16, s = 16, i = qt.aes.createEncryptionCipher;
          break;
        case qt.pki.oids["aes192-CBC"]:
          r = 24, s = 16, i = qt.aes.createEncryptionCipher;
          break;
        case qt.pki.oids["aes256-CBC"]:
          r = 32, s = 16, i = qt.aes.createEncryptionCipher;
          break;
        case qt.pki.oids["des-EDE3-CBC"]:
          r = 24, s = 8, i = qt.des.createEncryptionCipher;
          break;
        default:
          throw new Error("Unsupported symmetric cipher, OID " + n);
      }
      if (e === void 0) e = qt.util.createBuffer(qt.random.getBytes(r));
      else if (e.length() != r) throw new Error("Symmetric key has wrong length; got " + e.length() + " bytes, expected " + r + ".");
      t3.encryptedContent.algorithm = n, t3.encryptedContent.key = e, t3.encryptedContent.parameter = qt.util.createBuffer(qt.random.getBytes(s));
      var a = i(e);
      if (a.start(t3.encryptedContent.parameter.copy()), a.update(t3.content), !a.finish()) throw new Error("Symmetric encryption failed.");
      t3.encryptedContent.content = a.output;
    }
    for (var o = 0; o < t3.recipients.length; ++o) {
      var f = t3.recipients[o];
      if (f.encryptedContent.content === void 0) switch (f.encryptedContent.algorithm) {
        case qt.pki.oids.rsaEncryption:
          f.encryptedContent.content = f.encryptedContent.key.encrypt(t3.encryptedContent.key.data);
          break;
        default:
          throw new Error("Unsupported asymmetric cipher, OID " + f.encryptedContent.algorithm);
      }
    }
  } }, t3;
};
function yre(t3) {
  var e = {}, n = [];
  if (!Ve.validate(t3, ds.asn1.recipientInfoValidator, e, n)) {
    var r = new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");
    throw r.errors = n, r;
  }
  return { version: e.version.charCodeAt(0), issuer: qt.pki.RDNAttributesAsArray(e.issuer), serialNumber: qt.util.createBuffer(e.serial).toHex(), encryptedContent: { algorithm: Ve.derToOid(e.encAlgorithm), parameter: e.encParameter ? e.encParameter.value : void 0, content: e.encKey } };
}
function bre(t3) {
  return Ve.create(Ve.Class.UNIVERSAL, Ve.Type.SEQUENCE, true, [Ve.create(Ve.Class.UNIVERSAL, Ve.Type.INTEGER, false, Ve.integerToDer(t3.version).getBytes()), Ve.create(Ve.Class.UNIVERSAL, Ve.Type.SEQUENCE, true, [qt.pki.distinguishedNameToAsn1({ attributes: t3.issuer }), Ve.create(Ve.Class.UNIVERSAL, Ve.Type.INTEGER, false, qt.util.hexToBytes(t3.serialNumber))]), Ve.create(Ve.Class.UNIVERSAL, Ve.Type.SEQUENCE, true, [Ve.create(Ve.Class.UNIVERSAL, Ve.Type.OID, false, Ve.oidToDer(t3.encryptedContent.algorithm).getBytes()), Ve.create(Ve.Class.UNIVERSAL, Ve.Type.NULL, false, "")]), Ve.create(Ve.Class.UNIVERSAL, Ve.Type.OCTETSTRING, false, t3.encryptedContent.content)]);
}
function Are(t3) {
  for (var e = [], n = 0; n < t3.length; ++n) e.push(yre(t3[n]));
  return e;
}
function wre(t3) {
  for (var e = [], n = 0; n < t3.length; ++n) e.push(bre(t3[n]));
  return e;
}
function xre(t3) {
  var e = Ve.create(Ve.Class.UNIVERSAL, Ve.Type.SEQUENCE, true, [Ve.create(Ve.Class.UNIVERSAL, Ve.Type.INTEGER, false, Ve.integerToDer(t3.version).getBytes()), Ve.create(Ve.Class.UNIVERSAL, Ve.Type.SEQUENCE, true, [qt.pki.distinguishedNameToAsn1({ attributes: t3.issuer }), Ve.create(Ve.Class.UNIVERSAL, Ve.Type.INTEGER, false, qt.util.hexToBytes(t3.serialNumber))]), Ve.create(Ve.Class.UNIVERSAL, Ve.Type.SEQUENCE, true, [Ve.create(Ve.Class.UNIVERSAL, Ve.Type.OID, false, Ve.oidToDer(t3.digestAlgorithm).getBytes()), Ve.create(Ve.Class.UNIVERSAL, Ve.Type.NULL, false, "")])]);
  if (t3.authenticatedAttributesAsn1 && e.value.push(t3.authenticatedAttributesAsn1), e.value.push(Ve.create(Ve.Class.UNIVERSAL, Ve.Type.SEQUENCE, true, [Ve.create(Ve.Class.UNIVERSAL, Ve.Type.OID, false, Ve.oidToDer(t3.signatureAlgorithm).getBytes()), Ve.create(Ve.Class.UNIVERSAL, Ve.Type.NULL, false, "")])), e.value.push(Ve.create(Ve.Class.UNIVERSAL, Ve.Type.OCTETSTRING, false, t3.signature)), t3.unauthenticatedAttributes.length > 0) {
    for (var n = Ve.create(Ve.Class.CONTEXT_SPECIFIC, 1, true, []), r = 0; r < t3.unauthenticatedAttributes.length; ++r) {
      var s = t3.unauthenticatedAttributes[r];
      n.values.push(gb(s));
    }
    e.value.push(n);
  }
  return e;
}
function _re(t3) {
  for (var e = [], n = 0; n < t3.length; ++n) e.push(xre(t3[n]));
  return e;
}
function gb(t3) {
  var e;
  if (t3.type === qt.pki.oids.contentType) e = Ve.create(Ve.Class.UNIVERSAL, Ve.Type.OID, false, Ve.oidToDer(t3.value).getBytes());
  else if (t3.type === qt.pki.oids.messageDigest) e = Ve.create(Ve.Class.UNIVERSAL, Ve.Type.OCTETSTRING, false, t3.value.bytes());
  else if (t3.type === qt.pki.oids.signingTime) {
    var n = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z"), r = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z"), s = t3.value;
    if (typeof s == "string") {
      var i = Date.parse(s);
      isNaN(i) ? s.length === 13 ? s = Ve.utcTimeToDate(s) : s = Ve.generalizedTimeToDate(s) : s = new Date(i);
    }
    s >= n && s < r ? e = Ve.create(Ve.Class.UNIVERSAL, Ve.Type.UTCTIME, false, Ve.dateToUtcTime(s)) : e = Ve.create(Ve.Class.UNIVERSAL, Ve.Type.GENERALIZEDTIME, false, Ve.dateToGeneralizedTime(s));
  }
  return Ve.create(Ve.Class.UNIVERSAL, Ve.Type.SEQUENCE, true, [Ve.create(Ve.Class.UNIVERSAL, Ve.Type.OID, false, Ve.oidToDer(t3.type).getBytes()), Ve.create(Ve.Class.UNIVERSAL, Ve.Type.SET, true, [e])]);
}
function Ere(t3) {
  return [Ve.create(Ve.Class.UNIVERSAL, Ve.Type.OID, false, Ve.oidToDer(qt.pki.oids.data).getBytes()), Ve.create(Ve.Class.UNIVERSAL, Ve.Type.SEQUENCE, true, [Ve.create(Ve.Class.UNIVERSAL, Ve.Type.OID, false, Ve.oidToDer(t3.algorithm).getBytes()), t3.parameter ? Ve.create(Ve.Class.UNIVERSAL, Ve.Type.OCTETSTRING, false, t3.parameter.getBytes()) : void 0]), Ve.create(Ve.Class.CONTEXT_SPECIFIC, 0, true, [Ve.create(Ve.Class.UNIVERSAL, Ve.Type.OCTETSTRING, false, t3.content.getBytes())])];
}
function y4(t3, e, n) {
  var r = {}, s = [];
  if (!Ve.validate(e, n, r, s)) {
    var i = new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");
    throw i.errors = i, i;
  }
  var a = Ve.derToOid(r.contentType);
  if (a !== qt.pki.oids.data) throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");
  if (r.encryptedContent) {
    var o = "";
    if (qt.util.isArray(r.encryptedContent)) for (var f = 0; f < r.encryptedContent.length; ++f) {
      if (r.encryptedContent[f].type !== Ve.Type.OCTETSTRING) throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");
      o += r.encryptedContent[f].value;
    }
    else o = r.encryptedContent;
    t3.encryptedContent = { algorithm: Ve.derToOid(r.encAlgorithm), parameter: qt.util.createBuffer(r.encParameter.value), content: qt.util.createBuffer(o) };
  }
  if (r.content) {
    var o = "";
    if (qt.util.isArray(r.content)) for (var f = 0; f < r.content.length; ++f) {
      if (r.content[f].type !== Ve.Type.OCTETSTRING) throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");
      o += r.content[f].value;
    }
    else o = r.content;
    t3.content = qt.util.createBuffer(o);
  }
  return t3.version = r.version.charCodeAt(0), t3.rawCapture = r, r;
}
function VT(t3) {
  if (t3.encryptedContent.key === void 0) throw new Error("Symmetric key not available.");
  if (t3.content === void 0) {
    var e;
    switch (t3.encryptedContent.algorithm) {
      case qt.pki.oids["aes128-CBC"]:
      case qt.pki.oids["aes192-CBC"]:
      case qt.pki.oids["aes256-CBC"]:
        e = qt.aes.createDecryptionCipher(t3.encryptedContent.key);
        break;
      case qt.pki.oids.desCBC:
      case qt.pki.oids["des-EDE3-CBC"]:
        e = qt.des.createDecryptionCipher(t3.encryptedContent.key);
        break;
      default:
        throw new Error("Unsupported symmetric cipher, OID " + t3.encryptedContent.algorithm);
    }
    if (e.start(t3.encryptedContent.parameter), e.update(t3.encryptedContent.content), !e.finish()) throw new Error("Symmetric decryption failed.");
    t3.content = e.output;
  }
}
var ti = Ur, dm = ti.ssh = ti.ssh || {};
dm.privateKeyToPutty = function(t3, e, n) {
  n = n || "", e = e || "";
  var r = "ssh-rsa", s = e === "" ? "none" : "aes256-cbc", i = "PuTTY-User-Key-File-2: " + r + `\r
`;
  i += "Encryption: " + s + `\r
`, i += "Comment: " + n + `\r
`;
  var a = ti.util.createBuffer();
  iu(a, r), eo(a, t3.e), eo(a, t3.n);
  var o = ti.util.encode64(a.bytes(), 64), f = Math.floor(o.length / 66) + 1;
  i += "Public-Lines: " + f + `\r
`, i += o;
  var c = ti.util.createBuffer();
  eo(c, t3.d), eo(c, t3.p), eo(c, t3.q), eo(c, t3.qInv);
  var l;
  if (!e) l = ti.util.encode64(c.bytes(), 64);
  else {
    var h = c.length() + 16 - 1;
    h -= h % 16;
    var m = op(c.bytes());
    m.truncate(m.length() - h + c.length()), c.putBuffer(m);
    var v = ti.util.createBuffer();
    v.putBuffer(op("\0\0\0\0", e)), v.putBuffer(op("\0\0\0", e));
    var b = ti.aes.createEncryptionCipher(v.truncate(8), "CBC");
    b.start(ti.util.createBuffer().fillWithByte(0, 16)), b.update(c.copy()), b.finish();
    var A = b.output;
    A.truncate(16), l = ti.util.encode64(A.bytes(), 64);
  }
  f = Math.floor(l.length / 66) + 1, i += `\r
Private-Lines: ` + f + `\r
`, i += l;
  var _ = op("putty-private-key-file-mac-key", e), C = ti.util.createBuffer();
  iu(C, r), iu(C, s), iu(C, n), C.putInt32(a.length()), C.putBuffer(a), C.putInt32(c.length()), C.putBuffer(c);
  var I = ti.hmac.create();
  return I.start("sha1", _), I.update(C.bytes()), i += `\r
Private-MAC: ` + I.digest().toHex() + `\r
`, i;
};
dm.publicKeyToOpenSSH = function(t3, e) {
  var n = "ssh-rsa";
  e = e || "";
  var r = ti.util.createBuffer();
  return iu(r, n), eo(r, t3.e), eo(r, t3.n), n + " " + ti.util.encode64(r.bytes()) + " " + e;
};
dm.privateKeyToOpenSSH = function(t3, e) {
  return e ? ti.pki.encryptRsaPrivateKey(t3, e, { legacy: true, algorithm: "aes128" }) : ti.pki.privateKeyToPem(t3);
};
dm.getPublicKeyFingerprint = function(t3, e) {
  e = e || {};
  var n = e.md || ti.md.md5.create(), r = "ssh-rsa", s = ti.util.createBuffer();
  iu(s, r), eo(s, t3.e), eo(s, t3.n), n.start(), n.update(s.getBytes());
  var i = n.digest();
  if (e.encoding === "hex") {
    var a = i.toHex();
    return e.delimiter ? a.match(/.{2}/g).join(e.delimiter) : a;
  } else {
    if (e.encoding === "binary") return i.getBytes();
    if (e.encoding) throw new Error('Unknown encoding "' + e.encoding + '".');
  }
  return i;
};
function eo(t3, e) {
  var n = e.toString(16);
  n[0] >= "8" && (n = "00" + n);
  var r = ti.util.hexToBytes(n);
  t3.putInt32(r.length), t3.putBytes(r);
}
function iu(t3, e) {
  t3.putInt32(e.length), t3.putString(e);
}
function op() {
  for (var t3 = ti.md.sha1.create(), e = arguments.length, n = 0; n < e; ++n) t3.update(arguments[n]);
  return t3.digest();
}
var Bre = Ur;
const on = Fa(Bre);
async function Cre(t3) {
  return new Promise((e, n) => {
    try {
      const r = on.pki.rsa.generateKeyPair(2048), s = on.pki.createCertificationRequest();
      s.publicKey = r.publicKey, s.setSubject([{ name: "commonName", value: t3.commonName }, { name: "countryName", value: t3.country }, { name: "stateOrProvinceName", value: t3.state }, { name: "localityName", value: t3.locality }, { name: "organizationName", value: t3.organization }, { name: "organizationalUnitName", value: t3.orgUnit }]), s.sign(r.privateKey, on.md.sha256.create());
      let i;
      t3.passphrase ? i = on.pki.encryptRsaPrivateKey(r.privateKey, t3.passphrase, { algorithm: "aes256" }) : i = on.pki.privateKeyToPem(r.privateKey);
      const a = on.pki.certificationRequestToPem(s);
      e({ privateKey: i, csr: a });
    } catch (r) {
      n(new Error("Error: " + r.message));
    }
  });
}
function kre(t3) {
  let e;
  return { c() {
    e = we("Generate CSR");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function Ire(t3) {
  let e;
  return { c() {
    e = we("Generating Keys...");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function Sre(t3) {
  let e;
  function n(i, a) {
    return i[4] ? Ire : kre;
  }
  let r = n(t3), s = r(t3);
  return { c() {
    s.c(), e = Lt();
  }, m(i, a) {
    s.m(i, a), R(i, e, a);
  }, p(i, a) {
    r !== (r = n(i)) && (s.d(1), s = r(i), s && (s.c(), s.m(e.parentNode, e)));
  }, d(i) {
    i && D(e), s.d(i);
  } };
}
function Mre(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function zx(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[3]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 8 && Ze(n, r[3]);
  }, d(r) {
    r && D(e);
  } };
}
function Gx(t3) {
  let e, n, r, s, i, a, o, f, c, l;
  return n = new et({ props: { label: "Certificate Signing Request (CSR):", value: t3[1], readonly: true, rows: 6, withCopy: true, withDownload: true, downloadName: "request.csr", expandable: true } }), s = new et({ props: { label: "Private Key:", value: t3[0], readonly: true, rows: 6, withCopy: true, withDownload: true, downloadName: "private.key", expandable: true } }), o = new sd({ props: { data: t3[5], zipName: "csr_bundle.zip", label: "Download All as ZIP" } }), { c() {
    e = H("div"), fe(n.$$.fragment), r = z(), fe(s.$$.fragment), i = z(), a = H("div"), fe(o.$$.fragment), f = z(), c = H("div"), c.innerHTML = "", St(a, "display", "flex"), St(a, "justify-content", "center"), St(a, "margin-bottom", "1rem"), V(c, "class", "result-block"), V(e, "class", "results-area svelte-ji7bkx");
  }, m(h, m) {
    R(h, e, m), ae(n, e, null), q(e, r), ae(s, e, null), q(e, i), q(e, a), ae(o, a, null), q(e, f), q(e, c), l = true;
  }, p(h, m) {
    const v = {};
    m & 2 && (v.value = h[1]), n.$set(v);
    const b = {};
    m & 1 && (b.value = h[0]), s.$set(b);
    const A = {};
    m & 32 && (A.data = h[5]), o.$set(A);
  }, i(h) {
    l || (W(n.$$.fragment, h), W(s.$$.fragment, h), W(o.$$.fragment, h), l = true);
  }, o(h) {
    j(n.$$.fragment, h), j(s.$$.fragment, h), j(o.$$.fragment, h), l = false;
  }, d(h) {
    h && D(e), oe(n), oe(s), oe(o);
  } };
}
function $re(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U, Q, P, N, L, B, u, p, d, y;
  function w(te) {
    t3[9](te);
  }
  let E = { label: "Common Name (Domain Name):", placeholder: "e.g. www.example.com" };
  t3[2].commonName !== void 0 && (E.value = t3[2].commonName), r = new et({ props: E }), Qe.push(() => ze(r, "value", w));
  function M(te) {
    t3[10](te);
  }
  let x = { label: "Organization (O):", placeholder: "e.g. My Company Ltd" };
  t3[2].organization !== void 0 && (x.value = t3[2].organization), a = new et({ props: x }), Qe.push(() => ze(a, "value", M));
  function g(te) {
    t3[11](te);
  }
  let k = { label: "Department (OU):", placeholder: "e.g. IT" };
  t3[2].orgUnit !== void 0 && (k.value = t3[2].orgUnit), c = new et({ props: k }), Qe.push(() => ze(c, "value", g));
  function T(te) {
    t3[12](te);
  }
  let O = { label: "City / Locality (L):", placeholder: "e.g. New York" };
  t3[2].locality !== void 0 && (O.value = t3[2].locality), m = new et({ props: O }), Qe.push(() => ze(m, "value", T));
  function K(te) {
    t3[13](te);
  }
  let Y = { label: "State / Province (ST):", placeholder: "e.g. California" };
  t3[2].state !== void 0 && (Y.value = t3[2].state), A = new et({ props: Y }), Qe.push(() => ze(A, "value", K));
  function J(te) {
    t3[14](te);
  }
  let G = { label: "Country (C):", options: t3[6] };
  t3[2].country !== void 0 && (G.value = t3[2].country), I = new Ht({ props: G }), Qe.push(() => ze(I, "value", J));
  function X(te) {
    t3[15](te);
  }
  let ie = { label: "Private Key Passphrase (Optional):", placeholder: "Leave empty for no encryption", type: "password" };
  t3[2].passphrase !== void 0 && (ie.value = t3[2].passphrase), F = new et({ props: ie }), Qe.push(() => ze(F, "value", X)), N = new ut({ props: { disabled: t3[4], $$slots: { default: [Sre] }, $$scope: { ctx: t3 } } }), N.$on("click", t3[7]), B = new ut({ props: { variant: "secondary", $$slots: { default: [Mre] }, $$scope: { ctx: t3 } } }), B.$on("click", t3[16]);
  let de = t3[3] && zx(t3), se = t3[1] && Gx(t3);
  return { c() {
    e = H("div"), n = H("div"), fe(r.$$.fragment), i = z(), fe(a.$$.fragment), f = z(), fe(c.$$.fragment), h = z(), fe(m.$$.fragment), b = z(), fe(A.$$.fragment), C = z(), fe(I.$$.fragment), $ = z(), fe(F.$$.fragment), Q = z(), P = H("div"), fe(N.$$.fragment), L = z(), fe(B.$$.fragment), u = z(), de && de.c(), p = z(), se && se.c(), d = Lt(), V(n, "class", "full-width svelte-ji7bkx"), V(e, "class", "form-grid svelte-ji7bkx"), V(P, "class", "button-row"), St(P, "margin-top", "1.5rem");
  }, m(te, le) {
    R(te, e, le), q(e, n), ae(r, n, null), q(e, i), ae(a, e, null), q(e, f), ae(c, e, null), q(e, h), ae(m, e, null), q(e, b), ae(A, e, null), q(e, C), ae(I, e, null), q(e, $), ae(F, e, null), R(te, Q, le), R(te, P, le), ae(N, P, null), q(P, L), ae(B, P, null), R(te, u, le), de && de.m(te, le), R(te, p, le), se && se.m(te, le), R(te, d, le), y = true;
  }, p(te, le) {
    const Z = {};
    !s && le & 4 && (s = true, Z.value = te[2].commonName, qe(() => s = false)), r.$set(Z);
    const ve = {};
    !o && le & 4 && (o = true, ve.value = te[2].organization, qe(() => o = false)), a.$set(ve);
    const he = {};
    !l && le & 4 && (l = true, he.value = te[2].orgUnit, qe(() => l = false)), c.$set(he);
    const me = {};
    !v && le & 4 && (v = true, me.value = te[2].locality, qe(() => v = false)), m.$set(me);
    const ce = {};
    !_ && le & 4 && (_ = true, ce.value = te[2].state, qe(() => _ = false)), A.$set(ce);
    const ye = {};
    !S && le & 4 && (S = true, ye.value = te[2].country, qe(() => S = false)), I.$set(ye);
    const Oe = {};
    !U && le & 4 && (U = true, Oe.value = te[2].passphrase, qe(() => U = false)), F.$set(Oe);
    const Se = {};
    le & 16 && (Se.disabled = te[4]), le & 131088 && (Se.$$scope = { dirty: le, ctx: te }), N.$set(Se);
    const Ce = {};
    le & 131072 && (Ce.$$scope = { dirty: le, ctx: te }), B.$set(Ce), te[3] ? de ? de.p(te, le) : (de = zx(te), de.c(), de.m(p.parentNode, p)) : de && (de.d(1), de = null), te[1] ? se ? (se.p(te, le), le & 2 && W(se, 1)) : (se = Gx(te), se.c(), W(se, 1), se.m(d.parentNode, d)) : se && (Xt(), j(se, 1, 1, () => {
      se = null;
    }), er());
  }, i(te) {
    y || (W(r.$$.fragment, te), W(a.$$.fragment, te), W(c.$$.fragment, te), W(m.$$.fragment, te), W(A.$$.fragment, te), W(I.$$.fragment, te), W(F.$$.fragment, te), W(N.$$.fragment, te), W(B.$$.fragment, te), W(se), y = true);
  }, o(te) {
    j(r.$$.fragment, te), j(a.$$.fragment, te), j(c.$$.fragment, te), j(m.$$.fragment, te), j(A.$$.fragment, te), j(I.$$.fragment, te), j(F.$$.fragment, te), j(N.$$.fragment, te), j(B.$$.fragment, te), j(se), y = false;
  }, d(te) {
    te && (D(e), D(Q), D(P), D(u), D(p), D(d)), oe(r), oe(a), oe(c), oe(m), oe(A), oe(I), oe(F), oe(N), oe(B), de && de.d(te), se && se.d(te);
  } };
}
function Tre(t3) {
  let e, n, r, s, i, a, o;
  return { c() {
    e = H("p"), e.innerHTML = `A <strong>Certificate Signing Request (CSR)</strong> is the first step to getting an SSL/TLS certificate for your website.
    It is a block of encoded text that an individual
    or organization submits to a Certificate Authority (CA) when applying for a digital
    certificate, like an SSL/TLS certificate. The CSR contains essential information
    that helps the CA generate and authenticate the certificate. The CSR includes
    the public key that corresponds to the private key generated on the applicant\u2019s server.
    This public key will be part of the issued certificate. A CSR is generated and sent
    to a CA to apply for an SSL certificate or other types of digital certificates. The CA
    verifies the details provided in the CSR to ensure they match the organization 
    requesting the certificate. Once the verification process is completed, the CA issues 
    a certificate that the organization can use to secure its communications. 
    CSRs are encoded in PEM or DER format, with PEM being the more common format in practice.`, n = z(), r = H("p"), r.innerHTML = "<strong>How it works:</strong>", s = z(), i = H("ol"), i.innerHTML = "<li>You generate a <strong>Private Key</strong> (which stays on your server) and a <strong>CSR</strong>.</li> <li>You send the CSR to a Certificate Authority (like Sectigo, DigiCert, or Let&#39;s Encrypt).</li> <li>They verify your details and send back a signed <strong>Certificate</strong>.</li> <li>You install the Certificate and Private Key on your web server.</li>", a = z(), o = H("p"), o.innerHTML = "<em><b>Note:</b> This tool generates keys locally in your browser. Nothing is sent to any server.</em>";
  }, m(f, c) {
    R(f, e, c), R(f, n, c), R(f, r, c), R(f, s, c), R(f, i, c), R(f, a, c), R(f, o, c);
  }, p: dt, d(f) {
    f && (D(e), D(n), D(r), D(s), D(i), D(a), D(o));
  } };
}
function Dre(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Certificate Signing Request (CSR) Generator", $$slots: { default: [$re] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About CSR", links: t3[8], $$slots: { default: [Tre] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 131135 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 131072 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function Rre(t3, e, n) {
  let r, s = { commonName: "", organization: "", orgUnit: "", locality: "", state: "", country: "US", passphrase: "" }, i = "", a = "", o = "", f = false;
  const c = [{ value: "US", label: "United States (US)" }, { value: "GB", label: "United Kingdom (GB)" }, { value: "CA", label: "Canada (CA)" }, { value: "DE", label: "Germany (DE)" }, { value: "FR", label: "France (FR)" }, { value: "IN", label: "India (IN)" }, { value: "JP", label: "Japan (JP)" }, { value: "CN", label: "China (CN)" }, { value: "BR", label: "Brazil (BR)" }, { value: "AU", label: "Australia (AU)" }];
  async function l() {
    if (!s.commonName || !s.organization || !s.country) {
      n(3, o = "Please fill in all required fields (Common Name, Organization, Country).");
      return;
    }
    n(3, o = ""), n(4, f = true), n(0, i = ""), n(1, a = ""), setTimeout(async () => {
      try {
        const $ = await Cre(s);
        n(0, i = $.privateKey), n(1, a = $.csr);
      } catch ($) {
        n(3, o = $.message);
      } finally {
        n(4, f = false);
      }
    }, 50);
  }
  const h = [{ text: "CSR - Wikipedia", url: "https://en.wikipedia.org/wiki/Certificate_signing_request" }, { text: "Sectigo", url: "https://www.sectigo.com/resource-library/what-is-a-certificate-signing-request-csr" }, { text: "node-forge", url: "https://www.npmjs.com/package/node-forge?activeTab=readme" }];
  function m($) {
    t3.$$.not_equal(s.commonName, $) && (s.commonName = $, n(2, s));
  }
  function v($) {
    t3.$$.not_equal(s.organization, $) && (s.organization = $, n(2, s));
  }
  function b($) {
    t3.$$.not_equal(s.orgUnit, $) && (s.orgUnit = $, n(2, s));
  }
  function A($) {
    t3.$$.not_equal(s.locality, $) && (s.locality = $, n(2, s));
  }
  function _($) {
    t3.$$.not_equal(s.state, $) && (s.state = $, n(2, s));
  }
  function C($) {
    t3.$$.not_equal(s.country, $) && (s.country = $, n(2, s));
  }
  function I($) {
    t3.$$.not_equal(s.passphrase, $) && (s.passphrase = $, n(2, s));
  }
  const S = () => {
    n(2, s = { ...s, commonName: "", organization: "" }), result = "";
  };
  return t3.$$.update = () => {
    t3.$$.dirty & 3 && n(5, r = [{ name: "private.key", content: i }, { name: "request.csr", content: a }]);
  }, [i, a, s, o, f, r, c, l, h, m, v, b, A, _, C, I, S];
}
class Fre extends xt {
  constructor(e) {
    super(), wt(this, e, Rre, Dre, At, {});
  }
}
function fp(t3, e, n) {
  let r = 1n, s = t3 % n, i = e;
  for (; i > 0n; ) i % 2n === 1n && (r = r * s % n), s = s * s % n, i /= 2n;
  return r;
}
function Pre(t3, e, n, r) {
  if (!t3 || !e || !n || !r) throw new Error("Please fill in all fields (Base, Modulus, Exponent A, Exponent B).");
  try {
    const s = BigInt(t3), i = BigInt(e), a = BigInt(n), o = BigInt(r), f = fp(s, a, i), c = fp(s, o, i), l = fp(c, a, i), h = fp(f, o, i), m = l === h;
    return { alicePublic: f.toString(), bobPublic: c.toString(), sharedSecret: l.toString(), match: m };
  } catch (s) {
    throw s instanceof SyntaxError ? new Error("Inputs must be valid integers.") : s;
  }
}
function Nre(t3) {
  let e;
  return { c() {
    e = we("Calculate Shared Secret");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function Ure(t3) {
  let e;
  return { c() {
    e = we("Load Example");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function Lre(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function Vx(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[5]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 32 && Ze(n, r[5]);
  }, d(r) {
    r && D(e);
  } };
}
function Yx(t3) {
  let e, n, r, s, i, a, o = t3[4].alicePublic + "", f, c, l, h, m, v, b = t3[4].bobPublic + "", A, _, C, I, S, $, F, U = t3[4].sharedSecret + "", Q, P;
  function N(u, p) {
    return u[4].match ? Qre : Ore;
  }
  let L = N(t3), B = L(t3);
  return { c() {
    e = H("div"), n = H("div"), r = H("div"), s = H("span"), s.textContent = "Alice sends Public Key ($A = g^a \\mod p$):", i = z(), a = H("span"), f = we(o), c = z(), l = H("div"), h = H("span"), h.textContent = "Bob sends Public Key ($B = g^b \\mod p$):", m = z(), v = H("span"), A = we(b), _ = z(), C = H("div"), I = H("div"), S = H("span"), S.textContent = "Calculated Shared Secret:", $ = z(), F = H("span"), Q = we(U), P = z(), B.c(), V(s, "class", "label svelte-1mjnclj"), V(a, "class", "value svelte-1mjnclj"), V(r, "class", "step svelte-1mjnclj"), V(h, "class", "label svelte-1mjnclj"), V(v, "class", "value svelte-1mjnclj"), V(l, "class", "step svelte-1mjnclj"), V(n, "class", "step-row svelte-1mjnclj"), V(S, "class", "label svelte-1mjnclj"), V(F, "class", "value big svelte-1mjnclj"), V(I, "class", "secret-box svelte-1mjnclj"), V(C, "class", "final-result svelte-1mjnclj"), Zt(C, "success", t3[4].match), V(e, "class", "results-area svelte-1mjnclj");
  }, m(u, p) {
    R(u, e, p), q(e, n), q(n, r), q(r, s), q(r, i), q(r, a), q(a, f), q(n, c), q(n, l), q(l, h), q(l, m), q(l, v), q(v, A), q(e, _), q(e, C), q(C, I), q(I, S), q(I, $), q(I, F), q(F, Q), q(C, P), B.m(C, null);
  }, p(u, p) {
    p & 16 && o !== (o = u[4].alicePublic + "") && Ze(f, o), p & 16 && b !== (b = u[4].bobPublic + "") && Ze(A, b), p & 16 && U !== (U = u[4].sharedSecret + "") && Ze(Q, U), L !== (L = N(u)) && (B.d(1), B = L(u), B && (B.c(), B.m(C, null))), p & 16 && Zt(C, "success", u[4].match);
  }, d(u) {
    u && D(e), B.d();
  } };
}
function Ore(t3) {
  let e;
  return { c() {
    e = H("div"), e.textContent = "\u2717 Error: Keys do not match.", V(e, "class", "status error svelte-1mjnclj");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function Qre(t3) {
  let e;
  return { c() {
    e = H("div"), e.textContent = "\u2713 Keys Match! Secure Connection Established.", V(e, "class", "status svelte-1mjnclj");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function Kre(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U, Q, P, N, L, B, u, p, d, y, w, E, M;
  function x(ie) {
    t3[9](ie);
  }
  let g = { label: "Generator / Base (g):", placeholder: "e.g. 5" };
  t3[0] !== void 0 && (g.value = t3[0]), a = new et({ props: g }), Qe.push(() => ze(a, "value", x));
  function k(ie) {
    t3[10](ie);
  }
  let T = { label: "Prime Modulus (p):", placeholder: "e.g. 23" };
  t3[1] !== void 0 && (T.value = t3[1]), c = new et({ props: T }), Qe.push(() => ze(c, "value", k));
  function O(ie) {
    t3[11](ie);
  }
  let K = { label: "Private Key (a):", placeholder: "e.g. 6" };
  t3[2] !== void 0 && (K.value = t3[2]), _ = new et({ props: K }), Qe.push(() => ze(_, "value", O));
  function Y(ie) {
    t3[12](ie);
  }
  let J = { label: "Private Key (b):", placeholder: "e.g. 15" };
  t3[3] !== void 0 && (J.value = t3[3]), U = new et({ props: J }), Qe.push(() => ze(U, "value", Y)), L = new ut({ props: { $$slots: { default: [Nre] }, $$scope: { ctx: t3 } } }), L.$on("click", t3[6]), u = new ut({ props: { variant: "secondary", $$slots: { default: [Ure] }, $$scope: { ctx: t3 } } }), u.$on("click", t3[7]), d = new ut({ props: { variant: "secondary", $$slots: { default: [Lre] }, $$scope: { ctx: t3 } } }), d.$on("click", t3[13]);
  let G = t3[5] && Vx(t3), X = t3[4] && Yx(t3);
  return { c() {
    e = H("div"), n = H("div"), r = H("h4"), r.textContent = "Public Parameters (Known to everyone)", s = z(), i = H("div"), fe(a.$$.fragment), f = z(), fe(c.$$.fragment), h = z(), m = H("div"), v = H("div"), b = H("h4"), b.textContent = "Alice", A = z(), fe(_.$$.fragment), I = z(), S = H("div"), $ = H("h4"), $.textContent = "Bob", F = z(), fe(U.$$.fragment), P = z(), N = H("div"), fe(L.$$.fragment), B = z(), fe(u.$$.fragment), p = z(), fe(d.$$.fragment), y = z(), G && G.c(), w = z(), X && X.c(), E = Lt(), V(r, "class", "svelte-1mjnclj"), V(i, "class", "row svelte-1mjnclj"), V(n, "class", "section-box svelte-1mjnclj"), V(b, "class", "svelte-1mjnclj"), V(v, "class", "section-box alice svelte-1mjnclj"), V($, "class", "svelte-1mjnclj"), V(S, "class", "section-box bob svelte-1mjnclj"), V(m, "class", "split-row svelte-1mjnclj"), V(e, "class", "grid-layout svelte-1mjnclj"), V(N, "class", "button-row svelte-1mjnclj");
  }, m(ie, de) {
    R(ie, e, de), q(e, n), q(n, r), q(n, s), q(n, i), ae(a, i, null), q(i, f), ae(c, i, null), q(e, h), q(e, m), q(m, v), q(v, b), q(v, A), ae(_, v, null), q(m, I), q(m, S), q(S, $), q(S, F), ae(U, S, null), R(ie, P, de), R(ie, N, de), ae(L, N, null), q(N, B), ae(u, N, null), q(N, p), ae(d, N, null), R(ie, y, de), G && G.m(ie, de), R(ie, w, de), X && X.m(ie, de), R(ie, E, de), M = true;
  }, p(ie, de) {
    const se = {};
    !o && de & 1 && (o = true, se.value = ie[0], qe(() => o = false)), a.$set(se);
    const te = {};
    !l && de & 2 && (l = true, te.value = ie[1], qe(() => l = false)), c.$set(te);
    const le = {};
    !C && de & 4 && (C = true, le.value = ie[2], qe(() => C = false)), _.$set(le);
    const Z = {};
    !Q && de & 8 && (Q = true, Z.value = ie[3], qe(() => Q = false)), U.$set(Z);
    const ve = {};
    de & 16384 && (ve.$$scope = { dirty: de, ctx: ie }), L.$set(ve);
    const he = {};
    de & 16384 && (he.$$scope = { dirty: de, ctx: ie }), u.$set(he);
    const me = {};
    de & 16384 && (me.$$scope = { dirty: de, ctx: ie }), d.$set(me), ie[5] ? G ? G.p(ie, de) : (G = Vx(ie), G.c(), G.m(w.parentNode, w)) : G && (G.d(1), G = null), ie[4] ? X ? X.p(ie, de) : (X = Yx(ie), X.c(), X.m(E.parentNode, E)) : X && (X.d(1), X = null);
  }, i(ie) {
    M || (W(a.$$.fragment, ie), W(c.$$.fragment, ie), W(_.$$.fragment, ie), W(U.$$.fragment, ie), W(L.$$.fragment, ie), W(u.$$.fragment, ie), W(d.$$.fragment, ie), M = true);
  }, o(ie) {
    j(a.$$.fragment, ie), j(c.$$.fragment, ie), j(_.$$.fragment, ie), j(U.$$.fragment, ie), j(L.$$.fragment, ie), j(u.$$.fragment, ie), j(d.$$.fragment, ie), M = false;
  }, d(ie) {
    ie && (D(e), D(P), D(N), D(y), D(w), D(E)), oe(a), oe(c), oe(_), oe(U), oe(L), oe(u), oe(d), G && G.d(ie), X && X.d(ie);
  } };
}
function Hre(t3) {
  let e, n, r, s, i, a, o;
  return { c() {
    e = H("p"), e.textContent = `The Diffie-Hellman Key Exchange Algorithm, developed by Whitfield Diffie 
    and Martin Hellman in 1976, is a method for securely exchanging cryptographic 
    keys over a public channel. It's one of the earliest and most widely used 
    public-key protocols and is foundational in securing communications on the internet.`, n = z(), r = H("p"), r.innerHTML = "<strong>How it works:</strong>", s = z(), i = H("ol"), i.innerHTML = "<li>Both parties agree on a large prime p and a generator g (public values).</li> <li>Party A (Alice) chooses a private key a and calculates her public key as A=g^a mod p.</li> <li>Party B (Bob) chooses a private key b and calculates his public key as B=g^b mod p.</li> <li>Alice and Bob then exchange their public keys.</li> <li>Using the received public key, each party can compute the shared secret.</li> <li>Alice computes: S= B^a mod p</li> <li>Bob computes: S= A^b mod p</li> <li>Both values will be the same because of the mathematical property g^ab mod p == g^ba mod p</li>", a = z(), o = H("p"), o.textContent = `Diffie-Hellman is widely used in secure protocols such as TLS/SSL, SSH and IPsec. 
    It remains a core technique for key exchange in cryptography, especially 
    when paired with authentication methods to prevent interception and tampering.`;
  }, m(f, c) {
    R(f, e, c), R(f, n, c), R(f, r, c), R(f, s, c), R(f, i, c), R(f, a, c), R(f, o, c);
  }, p: dt, d(f) {
    f && (D(e), D(n), D(r), D(s), D(i), D(a), D(o));
  } };
}
function qre(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Diffie-Hellman Key Exchange", $$slots: { default: [Kre] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Diffie-Hellman", links: t3[8], $$slots: { default: [Hre] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 16447 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 16384 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function zre(t3, e, n) {
  let r = "", s = "", i = "", a = "", o = null, f = "";
  function c() {
    n(5, f = ""), n(4, o = null);
    try {
      n(4, o = Pre(r, s, i, a));
    } catch (C) {
      n(5, f = C.message);
    }
  }
  function l() {
    n(0, r = "5"), n(1, s = "23"), n(2, i = "6"), n(3, a = "15"), c();
  }
  const h = [{ text: "Wikipedia", url: "https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange" }, { text: "Geeks for Geeks", url: "https://www.geeksforgeeks.org/implementation-diffie-hellman-algorithm" }];
  function m(C) {
    r = C, n(0, r);
  }
  function v(C) {
    s = C, n(1, s);
  }
  function b(C) {
    i = C, n(2, i);
  }
  function A(C) {
    a = C, n(3, a);
  }
  return [r, s, i, a, o, f, c, l, h, m, v, b, A, () => {
    n(0, r = ""), n(1, s = ""), n(2, i = ""), n(3, a = ""), n(4, o = null);
  }];
}
class Gre extends xt {
  constructor(e) {
    super(), wt(this, e, zre, qre, At, {});
  }
}
function Vre(t3) {
  let e, n, r, s, i;
  return { c() {
    e = H("div"), n = H("span"), n.textContent = "\u21C5", r = z(), s = H("span"), i = we(t3[0]), V(n, "class", "icon svelte-196egah"), Zt(n, "spin", t3[1]), V(e, "class", "content-wrapper svelte-196egah");
  }, m(a, o) {
    R(a, e, o), q(e, n), q(e, r), q(e, s), q(s, i);
  }, p(a, o) {
    o & 2 && Zt(n, "spin", a[1]), o & 1 && Ze(i, a[0]);
  }, d(a) {
    a && D(e);
  } };
}
function Yre(t3) {
  let e, n;
  const r = [{ variant: "secondary" }, t3[3]];
  let s = { $$slots: { default: [Vre] }, $$scope: { ctx: t3 } };
  for (let i = 0; i < r.length; i += 1) s = jp(s, r[i]);
  return e = new ut({ props: s }), e.$on("click", t3[2]), { c() {
    fe(e.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), n = true;
  }, p(i, [a]) {
    const o = a & 8 ? UP(r, [r[0], LP(i[3])]) : {};
    a & 35 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
  }, i(i) {
    n || (W(e.$$.fragment, i), n = true);
  }, o(i) {
    j(e.$$.fragment, i), n = false;
  }, d(i) {
    oe(e, i);
  } };
}
function Wre(t3, e, n) {
  const r = ["label"];
  let s = n6(e, r), { label: i = "Swap" } = e;
  const a = Vh();
  let o = false;
  function f() {
    n(1, o = true), setTimeout(() => n(1, o = false), 400), a("click");
  }
  return t3.$$set = (c) => {
    e = jp(jp({}, e), TP(c)), n(3, s = n6(e, r)), "label" in c && n(0, i = c.label);
  }, [i, o, f, s];
}
class hn extends xt {
  constructor(e) {
    super(), wt(this, e, Wre, Yre, At, { label: 0 });
  }
}
const YT = { "P-256": "P-256", "P-384": "P-384", "P-521": "P-521" };
async function Jre(t3, e, n, r) {
  const s = WT(t3), i = await window.crypto.subtle.importKey("pkcs8", s, { name: "ECDSA", namedCurve: YT[n] }, false, ["sign"]), o = new TextEncoder().encode(e), f = await window.crypto.subtle.sign({ name: "ECDSA", hash: { name: r } }, i, o);
  return jre(f);
}
async function Zre(t3, e, n, r, s) {
  const i = WT(t3), a = await window.crypto.subtle.importKey("spki", i, { name: "ECDSA", namedCurve: YT[r] }, false, ["verify"]), f = new TextEncoder().encode(n), c = Xre(e);
  return await window.crypto.subtle.verify({ name: "ECDSA", hash: { name: s } }, a, c, f);
}
function WT(t3) {
  const e = t3.replace(/-----BEGIN [^-]+-----/, "").replace(/-----END [^-]+-----/, "").replace(/\s/g, ""), n = window.atob(e), r = new Uint8Array(n.length);
  for (let s = 0; s < n.length; s++) r[s] = n.charCodeAt(s);
  return r.buffer;
}
function jre(t3) {
  return Array.from(new Uint8Array(t3)).map((e) => e.toString(16).padStart(2, "0")).join("");
}
function Xre(t3) {
  const e = t3.replace(/\s/g, "");
  if (e.length % 2 !== 0) throw new Error("Invalid Hex length");
  const n = new Uint8Array(e.length / 2);
  for (let r = 0; r < e.length; r += 2) n[r / 2] = parseInt(e.substr(r, 2), 16);
  return n.buffer;
}
function Wx(t3) {
  let e, n, r;
  function s(a) {
    t3[21](a);
  }
  let i = { label: "Signature to Verify (Hex):", placeholder: "e.g. 30450221...", expandable: true };
  return t3[3] !== void 0 && (i.value = t3[3]), e = new et({ props: i }), Qe.push(() => ze(e, "value", s)), { c() {
    fe(e.$$.fragment);
  }, m(a, o) {
    ae(e, a, o), r = true;
  }, p(a, o) {
    const f = {};
    !n && o & 8 && (n = true, f.value = a[3], qe(() => n = false)), e.$set(f);
  }, i(a) {
    r || (W(e.$$.fragment, a), r = true);
  }, o(a) {
    j(e.$$.fragment, a), r = false;
  }, d(a) {
    oe(e, a);
  } };
}
function ene(t3) {
  let e = t3[0] === "sign" ? "Sign Message" : "Verify Signature", n;
  return { c() {
    n = we(e);
  }, m(r, s) {
    R(r, n, s);
  }, p(r, s) {
    s & 1 && e !== (e = r[0] === "sign" ? "Sign Message" : "Verify Signature") && Ze(n, e);
  }, d(r) {
    r && D(n);
  } };
}
function tne(t3) {
  let e;
  return { c() {
    e = we("Processing...");
  }, m(n, r) {
    R(n, e, r);
  }, p: dt, d(n) {
    n && D(e);
  } };
}
function rne(t3) {
  let e;
  function n(i, a) {
    return i[9] ? tne : ene;
  }
  let r = n(t3), s = r(t3);
  return { c() {
    s.c(), e = Lt();
  }, m(i, a) {
    s.m(i, a), R(i, e, a);
  }, p(i, a) {
    r === (r = n(i)) && s ? s.p(i, a) : (s.d(1), s = r(i), s && (s.c(), s.m(e.parentNode, e)));
  }, d(i) {
    i && D(e), s.d(i);
  } };
}
function nne(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function Jx(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[8]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 256 && Ze(n, r[8]);
  }, d(r) {
    r && D(e);
  } };
}
function Zx(t3) {
  let e, n;
  return e = new et({ props: { label: "Generated Signature (Hex):", value: t3[6], readonly: true, expandable: true, withCopy: true } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, s) {
    const i = {};
    s & 64 && (i.value = r[6]), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function jx(t3) {
  let e, n, r, s, i, a = t3[7] ? "VALID SIGNATURE" : "INVALID SIGNATURE", o, f;
  function c(m, v) {
    return m[7] ? sne : ine;
  }
  let l = c(t3), h = l(t3);
  return { c() {
    e = H("div"), n = H("div"), r = H("span"), r.textContent = "Verification Result:", s = z(), i = H("strong"), o = we(a), f = z(), h.c(), V(n, "class", "status-bar svelte-zmi5as"), Zt(n, "valid", t3[7]), V(e, "class", "result-box svelte-zmi5as");
  }, m(m, v) {
    R(m, e, v), q(e, n), q(n, r), q(n, s), q(n, i), q(i, o), q(e, f), h.m(e, null);
  }, p(m, v) {
    v & 128 && a !== (a = m[7] ? "VALID SIGNATURE" : "INVALID SIGNATURE") && Ze(o, a), v & 128 && Zt(n, "valid", m[7]), l !== (l = c(m)) && (h.d(1), h = l(m), h && (h.c(), h.m(e, null)));
  }, d(m) {
    m && D(e), h.d();
  } };
}
function ine(t3) {
  let e;
  return { c() {
    e = H("p"), e.textContent = "The signature does not match this message or key.", V(e, "class", "status-text invalid svelte-zmi5as");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function sne(t3) {
  let e;
  return { c() {
    e = H("p"), e.textContent = "The message content matches the signature.", V(e, "class", "status-text valid svelte-zmi5as");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function ane(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U, Q, P, N, L, B, u;
  function p(G) {
    t3[16](G);
  }
  let d = { label: "Operation:", options: t3[10] };
  t3[0] !== void 0 && (d.value = t3[0]), n = new Ht({ props: d }), Qe.push(() => ze(n, "value", p));
  function y(G) {
    t3[17](G);
  }
  let w = { label: "Curve:", options: t3[11] };
  t3[4] !== void 0 && (w.value = t3[4]), i = new Ht({ props: w }), Qe.push(() => ze(i, "value", y));
  function E(G) {
    t3[18](G);
  }
  let M = { label: "Hash Algorithm:", options: t3[12] };
  t3[5] !== void 0 && (M.value = t3[5]), f = new Ht({ props: M }), Qe.push(() => ze(f, "value", E));
  function x(G) {
    t3[19](G);
  }
  let g = { label: "Message:", placeholder: "Enter the text content here...", expandable: true, rows: 2 };
  t3[1] !== void 0 && (g.value = t3[1]), h = new et({ props: g }), Qe.push(() => ze(h, "value", x));
  function k(G) {
    t3[20](G);
  }
  let T = { label: t3[0] === "sign" ? "Private Key (PEM):" : "Public Key (PEM):", placeholder: t3[0] === "sign" ? "-----BEGIN PRIVATE KEY-----..." : "-----BEGIN PUBLIC KEY-----...", expandable: true, rows: 4 };
  t3[2] !== void 0 && (T.value = t3[2]), b = new et({ props: T }), Qe.push(() => ze(b, "value", k));
  let O = t3[0] === "verify" && Wx(t3);
  S = new ut({ props: { disabled: t3[9], $$slots: { default: [rne] }, $$scope: { ctx: t3 } } }), S.$on("click", t3[13]), F = new ut({ props: { variant: "secondary", $$slots: { default: [nne] }, $$scope: { ctx: t3 } } }), F.$on("click", t3[22]), Q = new hn({}), Q.$on("click", t3[14]);
  let K = t3[8] && Jx(t3), Y = t3[0] === "sign" && t3[6] && Zx(t3), J = t3[0] === "verify" && t3[7] !== null && jx(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), fe(i.$$.fragment), o = z(), fe(f.$$.fragment), l = z(), fe(h.$$.fragment), v = z(), fe(b.$$.fragment), _ = z(), O && O.c(), C = z(), I = H("div"), fe(S.$$.fragment), $ = z(), fe(F.$$.fragment), U = z(), fe(Q.$$.fragment), P = z(), K && K.c(), N = z(), Y && Y.c(), L = z(), J && J.c(), B = Lt(), V(e, "class", "controls-row svelte-zmi5as"), V(I, "class", "button-row");
  }, m(G, X) {
    R(G, e, X), ae(n, e, null), q(e, s), ae(i, e, null), q(e, o), ae(f, e, null), R(G, l, X), ae(h, G, X), R(G, v, X), ae(b, G, X), R(G, _, X), O && O.m(G, X), R(G, C, X), R(G, I, X), ae(S, I, null), q(I, $), ae(F, I, null), q(I, U), ae(Q, I, null), R(G, P, X), K && K.m(G, X), R(G, N, X), Y && Y.m(G, X), R(G, L, X), J && J.m(G, X), R(G, B, X), u = true;
  }, p(G, X) {
    const ie = {};
    !r && X & 1 && (r = true, ie.value = G[0], qe(() => r = false)), n.$set(ie);
    const de = {};
    !a && X & 16 && (a = true, de.value = G[4], qe(() => a = false)), i.$set(de);
    const se = {};
    !c && X & 32 && (c = true, se.value = G[5], qe(() => c = false)), f.$set(se);
    const te = {};
    !m && X & 2 && (m = true, te.value = G[1], qe(() => m = false)), h.$set(te);
    const le = {};
    X & 1 && (le.label = G[0] === "sign" ? "Private Key (PEM):" : "Public Key (PEM):"), X & 1 && (le.placeholder = G[0] === "sign" ? "-----BEGIN PRIVATE KEY-----..." : "-----BEGIN PUBLIC KEY-----..."), !A && X & 4 && (A = true, le.value = G[2], qe(() => A = false)), b.$set(le), G[0] === "verify" ? O ? (O.p(G, X), X & 1 && W(O, 1)) : (O = Wx(G), O.c(), W(O, 1), O.m(C.parentNode, C)) : O && (Xt(), j(O, 1, 1, () => {
      O = null;
    }), er());
    const Z = {};
    X & 512 && (Z.disabled = G[9]), X & 8389121 && (Z.$$scope = { dirty: X, ctx: G }), S.$set(Z);
    const ve = {};
    X & 8388608 && (ve.$$scope = { dirty: X, ctx: G }), F.$set(ve), G[8] ? K ? K.p(G, X) : (K = Jx(G), K.c(), K.m(N.parentNode, N)) : K && (K.d(1), K = null), G[0] === "sign" && G[6] ? Y ? (Y.p(G, X), X & 65 && W(Y, 1)) : (Y = Zx(G), Y.c(), W(Y, 1), Y.m(L.parentNode, L)) : Y && (Xt(), j(Y, 1, 1, () => {
      Y = null;
    }), er()), G[0] === "verify" && G[7] !== null ? J ? J.p(G, X) : (J = jx(G), J.c(), J.m(B.parentNode, B)) : J && (J.d(1), J = null);
  }, i(G) {
    u || (W(n.$$.fragment, G), W(i.$$.fragment, G), W(f.$$.fragment, G), W(h.$$.fragment, G), W(b.$$.fragment, G), W(O), W(S.$$.fragment, G), W(F.$$.fragment, G), W(Q.$$.fragment, G), W(Y), u = true);
  }, o(G) {
    j(n.$$.fragment, G), j(i.$$.fragment, G), j(f.$$.fragment, G), j(h.$$.fragment, G), j(b.$$.fragment, G), j(O), j(S.$$.fragment, G), j(F.$$.fragment, G), j(Q.$$.fragment, G), j(Y), u = false;
  }, d(G) {
    G && (D(e), D(l), D(v), D(_), D(C), D(I), D(P), D(N), D(L), D(B)), oe(n), oe(i), oe(f), oe(h, G), oe(b, G), O && O.d(G), oe(S), oe(F), oe(Q), K && K.d(G), Y && Y.d(G), J && J.d(G);
  } };
}
function one(t3) {
  let e, n, r, s, i;
  return { c() {
    e = H("p"), e.innerHTML = `The <b>Elliptic Curve Digital Signature Algorithm (ECDSA)</b> is a cryptographic algorithm 
  used to create and verify digital signatures. ECDSA allows you to prove authenticity without revealing your private key.
  It&#39;s based on elliptic curve cryptography (ECC), which offers a high level of security with smaller key sizes compared to 
  traditional algorithms like RSA. ECDSA\u2019s compact and secure design has made it a 
  fundamental part of modern cryptography, particularly where performance, security 
  and small data size are essential.`, n = z(), r = H("ul"), r.innerHTML = "<li><strong>Sign (Alice):</strong> Uses a <em>Private Key</em> to generate a signature for a specific message.</li> <li><strong>Verify (Bob):</strong> Uses Alice&#39;s <em>Public Key</em> to check if the signature is valid for that message.</li>", s = z(), i = H("p"), i.innerHTML = "<em><b>Note:</b> Ensure you select the correct Curve and Hash algorithm used during key generation.</em>";
  }, m(a, o) {
    R(a, e, o), R(a, n, o), R(a, r, o), R(a, s, o), R(a, i, o);
  }, p: dt, d(a) {
    a && (D(e), D(n), D(r), D(s), D(i));
  } };
}
function fne(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "ECDSA Sign & Verify", $$slots: { default: [ane] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About ECDSA", links: t3[15], $$slots: { default: [one] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 8389631 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 8388608 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function lne(t3, e, n) {
  let r = "sign", s = "", i = "", a = "", o = "P-256", f = "SHA-256", c = "", l = null, h = "", m = false;
  const v = [{ value: "sign", label: "Sign Message" }, { value: "verify", label: "Verify Signature" }], b = [{ value: "P-256", label: "P-256 (Standard)" }, { value: "P-384", label: "P-384 (High Security)" }, { value: "P-521", label: "P-521 (Ultra High)" }], A = [{ value: "SHA-256", label: "SHA-256" }, { value: "SHA-384", label: "SHA-384" }, { value: "SHA-512", label: "SHA-512" }];
  async function _() {
    n(8, h = ""), n(6, c = ""), n(7, l = null), n(9, m = true);
    try {
      if (r === "sign") {
        if (!i) throw new Error("Please provide a Private Key (PEM).");
        n(6, c = await Jre(i, s, o, f));
      } else {
        if (!i) throw new Error("Please provide a Public Key (PEM).");
        if (!a) throw new Error("Please provide a Signature (Hex).");
        n(7, l = await Zre(i, a, s, o, f));
      }
    } catch (L) {
      n(8, h = "Operation Failed: " + L.message), console.error(L);
    } finally {
      n(9, m = false);
    }
  }
  function C() {
    n(0, r = r === "sign" ? "verify" : "sign"), n(8, h = ""), n(6, c = ""), n(7, l = null);
  }
  const I = [{ text: "ECDSA - Wikipedia", url: "https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm" }, { text: "RFC 6090 - ECDSA", url: "https://datatracker.ietf.org/doc/html/rfc6090" }, { text: "NIST FIPS 186-4", url: "https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf" }];
  function S(L) {
    r = L, n(0, r);
  }
  function $(L) {
    o = L, n(4, o);
  }
  function F(L) {
    f = L, n(5, f);
  }
  function U(L) {
    s = L, n(1, s);
  }
  function Q(L) {
    i = L, n(2, i);
  }
  function P(L) {
    a = L, n(3, a);
  }
  return [r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U, Q, P, () => {
    n(1, s = ""), n(2, i = ""), n(3, a = ""), n(6, c = ""), n(7, l = null);
  }];
}
class une extends xt {
  constructor(e) {
    super(), wt(this, e, lne, fne, At, {});
  }
}
const cne = { "P-256": "P-256", "P-384": "P-384", "P-521": "P-521" };
async function hne(t3) {
  const e = cne[t3], n = await window.crypto.subtle.generateKey({ name: "ECDSA", namedCurve: e }, true, ["sign", "verify"]), r = await window.crypto.subtle.exportKey("pkcs8", n.privateKey), s = await window.crypto.subtle.exportKey("spki", n.publicKey), i = Xx(r, "PRIVATE KEY"), a = Xx(s, "PUBLIC KEY");
  return { privateKey: i, publicKey: a };
}
function dne(t3) {
  let e = "";
  const n = new Uint8Array(t3);
  for (let r = 0; r < n.byteLength; r++) e += String.fromCharCode(n[r]);
  return window.btoa(e);
}
function Xx(t3, e) {
  const r = dne(t3).match(/.{1,64}/g).join(`
`);
  return `-----BEGIN ${e}-----
${r}
-----END ${e}-----`;
}
function pne(t3) {
  let e;
  return { c() {
    e = we("Generate New Key Pair");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function gne(t3) {
  let e;
  return { c() {
    e = we("Generating...");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function mne(t3) {
  let e;
  function n(i, a) {
    return i[4] ? gne : pne;
  }
  let r = n(t3), s = r(t3);
  return { c() {
    s.c(), e = Lt();
  }, m(i, a) {
    s.m(i, a), R(i, e, a);
  }, p(i, a) {
    r !== (r = n(i)) && (s.d(1), s = r(i), s && (s.c(), s.m(e.parentNode, e)));
  }, d(i) {
    i && D(e), s.d(i);
  } };
}
function e_(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[3]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 8 && Ze(n, r[3]);
  }, d(r) {
    r && D(e);
  } };
}
function t_(t3) {
  let e, n, r, s, i, a, o, f;
  return n = new et({ props: { label: "Private Key (Keep Secret):", value: t3[0], readonly: true, expandable: true, withCopy: true, withDownload: true, downloadName: "private_key.pem", rows: 5 } }), s = new et({ props: { label: "Public Key (Share Freely):", value: t3[1], readonly: true, expandable: true, withCopy: true, withDownload: true, downloadName: "public_key.pem", rows: 5 } }), o = new sd({ props: { data: t3[5], zipName: "ecdsa_keys.zip", label: "Download Key Pair (.zip)" } }), { c() {
    e = H("div"), fe(n.$$.fragment), r = z(), fe(s.$$.fragment), i = z(), a = H("div"), fe(o.$$.fragment), V(a, "class", "download-container svelte-1pbjmu5"), V(e, "class", "results-area svelte-1pbjmu5");
  }, m(c, l) {
    R(c, e, l), ae(n, e, null), q(e, r), ae(s, e, null), q(e, i), q(e, a), ae(o, a, null), f = true;
  }, p(c, l) {
    const h = {};
    l & 1 && (h.value = c[0]), n.$set(h);
    const m = {};
    l & 2 && (m.value = c[1]), s.$set(m);
    const v = {};
    l & 32 && (v.data = c[5]), o.$set(v);
  }, i(c) {
    f || (W(n.$$.fragment, c), W(s.$$.fragment, c), W(o.$$.fragment, c), f = true);
  }, o(c) {
    j(n.$$.fragment, c), j(s.$$.fragment, c), j(o.$$.fragment, c), f = false;
  }, d(c) {
    c && D(e), oe(n), oe(s), oe(o);
  } };
}
function vne(t3) {
  let e, n, r, s, i, a, o, f, c, l;
  function h(A) {
    t3[8](A);
  }
  let m = { label: "Elliptic Curve:", options: t3[6] };
  t3[2] !== void 0 && (m.value = t3[2]), n = new Ht({ props: m }), Qe.push(() => ze(n, "value", h)), a = new ut({ props: { disabled: t3[4], $$slots: { default: [mne] }, $$scope: { ctx: t3 } } }), a.$on("click", t3[7]);
  let v = t3[3] && e_(t3), b = t3[0] && t_(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), i = H("div"), fe(a.$$.fragment), o = z(), v && v.c(), f = z(), b && b.c(), c = Lt(), St(i, "align-self", "flex-end"), St(i, "margin-bottom", "20px"), V(e, "class", "controls-row svelte-1pbjmu5");
  }, m(A, _) {
    R(A, e, _), ae(n, e, null), q(e, s), q(e, i), ae(a, i, null), R(A, o, _), v && v.m(A, _), R(A, f, _), b && b.m(A, _), R(A, c, _), l = true;
  }, p(A, _) {
    const C = {};
    !r && _ & 4 && (r = true, C.value = A[2], qe(() => r = false)), n.$set(C);
    const I = {};
    _ & 16 && (I.disabled = A[4]), _ & 528 && (I.$$scope = { dirty: _, ctx: A }), a.$set(I), A[3] ? v ? v.p(A, _) : (v = e_(A), v.c(), v.m(f.parentNode, f)) : v && (v.d(1), v = null), A[0] ? b ? (b.p(A, _), _ & 1 && W(b, 1)) : (b = t_(A), b.c(), W(b, 1), b.m(c.parentNode, c)) : b && (Xt(), j(b, 1, 1, () => {
      b = null;
    }), er());
  }, i(A) {
    l || (W(n.$$.fragment, A), W(a.$$.fragment, A), W(b), l = true);
  }, o(A) {
    j(n.$$.fragment, A), j(a.$$.fragment, A), j(b), l = false;
  }, d(A) {
    A && (D(e), D(o), D(f), D(c)), oe(n), oe(a), v && v.d(A), b && b.d(A);
  } };
}
function yne(t3) {
  let e, n, r, s, i;
  return { c() {
    e = H("p"), e.innerHTML = "<strong>Elliptic Curve Digital Signature Algorithm (ECDSA)</strong> keys are used to sign data and verify authenticity.", n = z(), r = H("ul"), r.innerHTML = "<li><strong>Private Key:</strong> Used to create signatures. Must never be shared.</li> <li><strong>Public Key:</strong> Distributed to others so they can verify your signatures.</li>", s = z(), i = H("p"), i.innerHTML = "<strong>Which Curve?</strong><br/> <em>P-256</em> is the standard for most web applications (SSL, JWT). <em>P-384</em> is used for higher security requirements (Top Secret classification).";
  }, m(a, o) {
    R(a, e, o), R(a, n, o), R(a, r, o), R(a, s, o), R(a, i, o);
  }, p: dt, d(a) {
    a && (D(e), D(n), D(r), D(s), D(i));
  } };
}
function bne(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "ECDSA Key Generator", $$slots: { default: [vne] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About ECDSA Keys", $$slots: { default: [yne] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 575 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 512 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function Ane(t3, e, n) {
  let r, s = "P-256", i = "", a = "", o = "", f = false;
  const c = [{ value: "P-256", label: "P-256 (Standard - 256 bits)" }, { value: "P-384", label: "P-384 (High Security - 384 bits)" }, { value: "P-521", label: "P-521 (Ultra High - 521 bits)" }];
  async function l() {
    n(3, o = ""), n(4, f = true), n(0, i = ""), n(1, a = "");
    try {
      const m = await hne(s);
      n(0, i = m.privateKey), n(1, a = m.publicKey);
    } catch (m) {
      n(3, o = "Generation Failed: " + m.message);
    } finally {
      n(4, f = false);
    }
  }
  function h(m) {
    s = m, n(2, s);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 3 && n(5, r = i ? [{ name: "private_key.pem", content: i }, { name: "public_key.pem", content: a }] : []);
  }, [i, a, s, o, f, r, c, l, h];
}
class wne extends xt {
  constructor(e) {
    super(), wt(this, e, Ane, bne, At, {});
  }
}
async function xne(t3, e) {
  return new Promise((n, r) => {
    try {
      const s = on.pki.publicKeyFromPem(t3), i = on.util.createBuffer(e, "utf8"), a = s.encrypt(i.getBytes(), "RSA-OAEP", { md: on.md.sha256.create(), mgf1: { md: on.md.sha256.create() } });
      n(on.util.encode64(a));
    } catch (s) {
      r(new Error("Encryption Failed: " + s.message));
    }
  });
}
async function _ne(t3, e) {
  return new Promise((n, r) => {
    try {
      const s = on.pki.privateKeyFromPem(t3), i = on.util.decode64(e), a = s.decrypt(i, "RSA-OAEP", { md: on.md.sha256.create(), mgf1: { md: on.md.sha256.create() } });
      n(a);
    } catch {
      r(new Error("Decryption Failed: Check your Private Key or Ciphertext."));
    }
  });
}
async function Ene(t3, e) {
  return new Promise((n, r) => {
    try {
      const s = on.pki.privateKeyFromPem(t3), i = on.md.sha256.create();
      i.update(e, "utf8");
      const a = s.sign(i);
      n(on.util.encode64(a));
    } catch (s) {
      r(new Error("Signing Failed: " + s.message));
    }
  });
}
async function Bne(t3, e, n) {
  return new Promise((r, s) => {
    try {
      const i = on.pki.publicKeyFromPem(t3), a = on.md.sha256.create();
      a.update(n, "utf8");
      const o = on.util.decode64(e), f = i.verify(a.digest().bytes(), o);
      r(f);
    } catch (i) {
      s(new Error("Verification Error: " + i.message));
    }
  });
}
function r_(t3) {
  let e, n, r;
  function s(a) {
    t3[17](a);
  }
  let i = { label: "Message / Plaintext:", placeholder: "Enter text...", expandable: true, rows: 2 };
  return t3[1] !== void 0 && (i.value = t3[1]), e = new et({ props: i }), Qe.push(() => ze(e, "value", s)), { c() {
    fe(e.$$.fragment);
  }, m(a, o) {
    ae(e, a, o), r = true;
  }, p(a, o) {
    const f = {};
    !n && o & 2 && (n = true, f.value = a[1], qe(() => n = false)), e.$set(f);
  }, i(a) {
    r || (W(e.$$.fragment, a), r = true);
  }, o(a) {
    j(e.$$.fragment, a), r = false;
  }, d(a) {
    oe(e, a);
  } };
}
function n_(t3) {
  let e, n, r;
  function s(a) {
    t3[18](a);
  }
  let i = { label: "Ciphertext (Base64):", placeholder: "Enter encrypted data...", expandable: true, rows: 3 };
  return t3[3] !== void 0 && (i.value = t3[3]), e = new et({ props: i }), Qe.push(() => ze(e, "value", s)), { c() {
    fe(e.$$.fragment);
  }, m(a, o) {
    ae(e, a, o), r = true;
  }, p(a, o) {
    const f = {};
    !n && o & 8 && (n = true, f.value = a[3], qe(() => n = false)), e.$set(f);
  }, i(a) {
    r || (W(e.$$.fragment, a), r = true);
  }, o(a) {
    j(e.$$.fragment, a), r = false;
  }, d(a) {
    oe(e, a);
  } };
}
function i_(t3) {
  let e, n, r;
  function s(a) {
    t3[19](a);
  }
  let i = { label: "Signature (Base64):", placeholder: "Enter signature...", expandable: true, rows: 3 };
  return t3[3] !== void 0 && (i.value = t3[3]), e = new et({ props: i }), Qe.push(() => ze(e, "value", s)), { c() {
    fe(e.$$.fragment);
  }, m(a, o) {
    ae(e, a, o), r = true;
  }, p(a, o) {
    const f = {};
    !n && o & 8 && (n = true, f.value = a[3], qe(() => n = false)), e.$set(f);
  }, i(a) {
    r || (W(e.$$.fragment, a), r = true);
  }, o(a) {
    j(e.$$.fragment, a), r = false;
  }, d(a) {
    oe(e, a);
  } };
}
function Cne(t3) {
  let e = t3[10].find(t3[20]).label + "", n;
  return { c() {
    n = we(e);
  }, m(r, s) {
    R(r, n, s);
  }, p(r, s) {
    s & 1 && e !== (e = r[10].find(r[20]).label + "") && Ze(n, e);
  }, d(r) {
    r && D(n);
  } };
}
function kne(t3) {
  let e;
  return { c() {
    e = we("Processing...");
  }, m(n, r) {
    R(n, e, r);
  }, p: dt, d(n) {
    n && D(e);
  } };
}
function Ine(t3) {
  let e;
  function n(i, a) {
    return i[7] ? kne : Cne;
  }
  let r = n(t3), s = r(t3);
  return { c() {
    s.c(), e = Lt();
  }, m(i, a) {
    s.m(i, a), R(i, e, a);
  }, p(i, a) {
    r === (r = n(i)) && s ? s.p(i, a) : (s.d(1), s = r(i), s && (s.c(), s.m(e.parentNode, e)));
  }, d(i) {
    i && D(e), s.d(i);
  } };
}
function Sne(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function s_(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[6]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 64 && Ze(n, r[6]);
  }, d(r) {
    r && D(e);
  } };
}
function a_(t3) {
  let e, n;
  return e = new et({ props: { label: t3[0] === "encrypt" ? "Encrypted Output (Base64):" : t3[0] === "sign" ? "Generated Signature (Base64):" : "Decrypted Message:", value: t3[4], readonly: true, expandable: true, withCopy: true, rows: 4 } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, s) {
    const i = {};
    s & 1 && (i.label = r[0] === "encrypt" ? "Encrypted Output (Base64):" : r[0] === "sign" ? "Generated Signature (Base64):" : "Decrypted Message:"), s & 16 && (i.value = r[4]), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function o_(t3) {
  let e, n, r, s, i, a = t3[5] ? "VALID" : "INVALID", o, f, c, l = t3[5] ? "The signature matches the message and key." : "Verification failed.", h;
  return { c() {
    e = H("div"), n = H("div"), r = H("span"), r.textContent = "Verification Result:", s = z(), i = H("strong"), o = we(a), f = z(), c = H("p"), h = we(l), V(n, "class", "status-bar svelte-knn8m"), Zt(n, "valid", t3[5]), V(c, "class", "status-text svelte-knn8m"), V(e, "class", "result-box svelte-knn8m");
  }, m(m, v) {
    R(m, e, v), q(e, n), q(n, r), q(n, s), q(n, i), q(i, o), q(e, f), q(e, c), q(c, h);
  }, p(m, v) {
    v & 32 && a !== (a = m[5] ? "VALID" : "INVALID") && Ze(o, a), v & 32 && Zt(n, "valid", m[5]), v & 32 && l !== (l = m[5] ? "The signature matches the message and key." : "Verification failed.") && Ze(h, l);
  }, d(m) {
    m && D(e);
  } };
}
function Mne(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S;
  function $(d) {
    t3[15](d);
  }
  let F = { label: "Operation:", options: t3[10] };
  t3[0] !== void 0 && (F.value = t3[0]), n = new Ht({ props: F }), Qe.push(() => ze(n, "value", $));
  function U(d) {
    t3[16](d);
  }
  let Q = { label: t3[9], placeholder: t3[8], expandable: true, rows: 4 };
  t3[2] !== void 0 && (Q.value = t3[2]), i = new et({ props: Q }), Qe.push(() => ze(i, "value", U));
  let P = t3[0] !== "decrypt" && r_(t3), N = t3[0] === "decrypt" && n_(t3), L = t3[0] === "verify" && i_(t3);
  m = new ut({ props: { disabled: t3[7], $$slots: { default: [Ine] }, $$scope: { ctx: t3 } } }), m.$on("click", t3[11]), b = new ut({ props: { variant: "secondary", $$slots: { default: [Sne] }, $$scope: { ctx: t3 } } }), b.$on("click", t3[12]);
  let B = t3[6] && s_(t3), u = t3[4] && a_(t3), p = t3[0] === "verify" && t3[5] !== null && o_(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), fe(i.$$.fragment), o = z(), P && P.c(), f = z(), N && N.c(), c = z(), L && L.c(), l = z(), h = H("div"), fe(m.$$.fragment), v = z(), fe(b.$$.fragment), A = z(), B && B.c(), _ = z(), u && u.c(), C = z(), p && p.c(), I = Lt(), V(e, "class", "controls-row"), V(h, "class", "button-row");
  }, m(d, y) {
    R(d, e, y), ae(n, e, null), R(d, s, y), ae(i, d, y), R(d, o, y), P && P.m(d, y), R(d, f, y), N && N.m(d, y), R(d, c, y), L && L.m(d, y), R(d, l, y), R(d, h, y), ae(m, h, null), q(h, v), ae(b, h, null), R(d, A, y), B && B.m(d, y), R(d, _, y), u && u.m(d, y), R(d, C, y), p && p.m(d, y), R(d, I, y), S = true;
  }, p(d, y) {
    const w = {};
    !r && y & 1 && (r = true, w.value = d[0], qe(() => r = false)), n.$set(w);
    const E = {};
    y & 512 && (E.label = d[9]), y & 256 && (E.placeholder = d[8]), !a && y & 4 && (a = true, E.value = d[2], qe(() => a = false)), i.$set(E), d[0] !== "decrypt" ? P ? (P.p(d, y), y & 1 && W(P, 1)) : (P = r_(d), P.c(), W(P, 1), P.m(f.parentNode, f)) : P && (Xt(), j(P, 1, 1, () => {
      P = null;
    }), er()), d[0] === "decrypt" ? N ? (N.p(d, y), y & 1 && W(N, 1)) : (N = n_(d), N.c(), W(N, 1), N.m(c.parentNode, c)) : N && (Xt(), j(N, 1, 1, () => {
      N = null;
    }), er()), d[0] === "verify" ? L ? (L.p(d, y), y & 1 && W(L, 1)) : (L = i_(d), L.c(), W(L, 1), L.m(l.parentNode, l)) : L && (Xt(), j(L, 1, 1, () => {
      L = null;
    }), er());
    const M = {};
    y & 128 && (M.disabled = d[7]), y & 2097281 && (M.$$scope = { dirty: y, ctx: d }), m.$set(M);
    const x = {};
    y & 2097152 && (x.$$scope = { dirty: y, ctx: d }), b.$set(x), d[6] ? B ? B.p(d, y) : (B = s_(d), B.c(), B.m(_.parentNode, _)) : B && (B.d(1), B = null), d[4] ? u ? (u.p(d, y), y & 16 && W(u, 1)) : (u = a_(d), u.c(), W(u, 1), u.m(C.parentNode, C)) : u && (Xt(), j(u, 1, 1, () => {
      u = null;
    }), er()), d[0] === "verify" && d[5] !== null ? p ? p.p(d, y) : (p = o_(d), p.c(), p.m(I.parentNode, I)) : p && (p.d(1), p = null);
  }, i(d) {
    S || (W(n.$$.fragment, d), W(i.$$.fragment, d), W(P), W(N), W(L), W(m.$$.fragment, d), W(b.$$.fragment, d), W(u), S = true);
  }, o(d) {
    j(n.$$.fragment, d), j(i.$$.fragment, d), j(P), j(N), j(L), j(m.$$.fragment, d), j(b.$$.fragment, d), j(u), S = false;
  }, d(d) {
    d && (D(e), D(s), D(o), D(f), D(c), D(l), D(h), D(A), D(_), D(C), D(I)), oe(n), oe(i, d), P && P.d(d), N && N.d(d), L && L.d(d), oe(m), oe(b), B && B.d(d), u && u.d(d), p && p.d(d);
  } };
}
function $ne(t3) {
  let e, n, r;
  return { c() {
    e = H("p"), e.innerHTML = `<strong>RSA (Rivest\u2013Shamir\u2013Adleman)</strong> is a widely used public-key cryptosystem 
    for secure data transmission. RSA allows for both confidential communication (Encryption) and authentication (Signing).`, n = z(), r = H("ul"), r.innerHTML = "<li><strong>Encrypt:</strong> Use the recipient&#39;s <em>Public Key</em>. Only they can decrypt it.</li> <li><strong>Decrypt:</strong> Use your <em>Private Key</em> to read messages sent to you.</li> <li><strong>Sign:</strong> Use your <em>Private Key</em> to prove a message came from you.</li> <li><strong>Verify:</strong> Use the sender&#39;s <em>Public Key</em> to check their signature.</li>";
  }, m(s, i) {
    R(s, e, i), R(s, n, i), R(s, r, i);
  }, p: dt, d(s) {
    s && (D(e), D(n), D(r));
  } };
}
function Tne(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "RSA Cryptosystem", $$slots: { default: [Mne] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About RSA", links: t3[13], $$slots: { default: [$ne] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 2098175 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 2097152 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function Dne(t3, e, n) {
  let r, s, i, a = "encrypt", o = "", f = "", c = "", l = "", h = null, m = "", v = false;
  const b = [{ value: "encrypt", label: "Encrypt Message" }, { value: "decrypt", label: "Decrypt Ciphertext" }, { value: "sign", label: "Sign Message" }, { value: "verify", label: "Verify Signature" }];
  async function A() {
    n(6, m = ""), n(4, l = ""), n(5, h = null), n(7, v = true);
    try {
      if (!f) throw new Error("Please provide a PEM Key.");
      switch (a) {
        case "encrypt":
          if (!o) throw new Error("Please enter a message.");
          n(4, l = await xne(f, o));
          break;
        case "decrypt":
          if (!c) throw new Error("Please enter the Ciphertext (Base64).");
          n(4, l = await _ne(f, c));
          break;
        case "sign":
          if (!o) throw new Error("Please enter a message.");
          n(4, l = await Ene(f, o));
          break;
        case "verify":
          if (!o) throw new Error("Please enter the original message.");
          if (!c) throw new Error("Please enter the Signature (Base64).");
          n(5, h = await Bne(f, c, o));
          break;
      }
    } catch (P) {
      n(6, m = P.message);
    } finally {
      n(7, v = false);
    }
  }
  function _() {
    n(1, o = ""), n(3, c = ""), n(2, f = ""), n(4, l = ""), n(5, h = null), n(6, m = "");
  }
  const C = [{ text: "Wikipedia: RSA (Cryptosystem)", url: "https://en.wikipedia.org/wiki/RSA_(cryptosystem)" }, { text: "RFC 8017: PKCS #1 v2.2", url: "https://datatracker.ietf.org/doc/html/rfc8017" }, { text: "node-forge npm package", url: "https://www.npmjs.com/package/node-forge?activeTab=readme#rsa" }];
  function I(P) {
    a = P, n(0, a);
  }
  function S(P) {
    f = P, n(2, f);
  }
  function $(P) {
    o = P, n(1, o);
  }
  function F(P) {
    c = P, n(3, c);
  }
  function U(P) {
    c = P, n(3, c);
  }
  const Q = (P) => P.value === a;
  return t3.$$.update = () => {
    t3.$$.dirty & 1 && n(14, r = a === "decrypt" || a === "sign"), t3.$$.dirty & 16384 && n(9, s = r ? "Private Key (PEM):" : "Public Key (PEM):"), t3.$$.dirty & 16384 && n(8, i = r ? "-----BEGIN RSA PRIVATE KEY-----..." : "-----BEGIN PUBLIC KEY-----...");
  }, [a, o, f, c, l, h, m, v, i, s, b, A, _, C, r, I, S, $, F, U, Q];
}
class Rne extends xt {
  constructor(e) {
    super(), wt(this, e, Dne, Tne, At, {});
  }
}
async function Fne(t3, e = "pgp") {
  return e === "pgp" ? await Pne(t3) : await Nne(t3);
}
async function Pne(t3) {
  try {
    const { privateKey: e, publicKey: n } = await xU({ type: "rsa", rsaBits: t3, userIDs: [{ name: "Cryptology Playground", email: "user@playground.local" }], format: "armored" });
    return { privateKey: e, publicKey: n };
  } catch (e) {
    throw new Error(`PGP Generation failed: ${e.message}`);
  }
}
async function Nne(t3) {
  try {
    const e = await window.crypto.subtle.generateKey({ name: "RSA-OAEP", modulusLength: t3, publicExponent: new Uint8Array([1, 0, 1]), hash: "SHA-256" }, true, ["encrypt", "decrypt"]), n = await window.crypto.subtle.exportKey("pkcs8", e.privateKey), r = await window.crypto.subtle.exportKey("spki", e.publicKey);
    return { privateKey: f_(n, "PRIVATE KEY"), publicKey: f_(r, "PUBLIC KEY") };
  } catch (e) {
    throw new Error(`PEM Generation failed: ${e.message}`);
  }
}
function f_(t3, e) {
  let n = "";
  const r = new Uint8Array(t3), s = r.byteLength;
  for (let o = 0; o < s; o++) n += String.fromCharCode(r[o]);
  const a = window.btoa(n).match(/.{1,64}/g).join(`
`);
  return `-----BEGIN ${e}-----
${a}
-----END ${e}-----`;
}
function Une(t3) {
  let e;
  return { c() {
    e = we("Generate Key Pair");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function Lne(t3) {
  let e;
  return { c() {
    e = we("Generating Keys...");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function One(t3) {
  let e;
  function n(i, a) {
    return i[6] ? Lne : Une;
  }
  let r = n(t3), s = r(t3);
  return { c() {
    s.c(), e = Lt();
  }, m(i, a) {
    s.m(i, a), R(i, e, a);
  }, p(i, a) {
    r !== (r = n(i)) && (s.d(1), s = r(i), s && (s.c(), s.m(e.parentNode, e)));
  }, d(i) {
    i && D(e), s.d(i);
  } };
}
function l_(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[5]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 32 && Ze(n, r[5]);
  }, d(r) {
    r && D(e);
  } };
}
function u_(t3) {
  let e, n, r, s, i, a, o, f;
  return n = new et({ props: { label: "Private Key (Keep Secret):", value: t3[1], readonly: true, expandable: true, withCopy: true, withDownload: true, downloadName: `private_key.${t3[3]}`, rows: 6 } }), s = new et({ props: { label: "Public Key (Share Freely):", value: t3[2], readonly: true, expandable: true, withCopy: true, withDownload: true, downloadName: `public_key.${t3[3]}`, rows: 6 } }), o = new sd({ props: { data: t3[7], zipName: `rsa_keys_${t3[3]}.zip`, label: "Download Key Pair (.zip)" } }), { c() {
    e = H("div"), fe(n.$$.fragment), r = z(), fe(s.$$.fragment), i = z(), a = H("div"), fe(o.$$.fragment), V(a, "class", "download-container svelte-55c7uh"), V(e, "class", "results-area svelte-55c7uh");
  }, m(c, l) {
    R(c, e, l), ae(n, e, null), q(e, r), ae(s, e, null), q(e, i), q(e, a), ae(o, a, null), f = true;
  }, p(c, l) {
    const h = {};
    l & 2 && (h.value = c[1]), l & 8 && (h.downloadName = `private_key.${c[3]}`), n.$set(h);
    const m = {};
    l & 4 && (m.value = c[2]), l & 8 && (m.downloadName = `public_key.${c[3]}`), s.$set(m);
    const v = {};
    l & 128 && (v.data = c[7]), l & 8 && (v.zipName = `rsa_keys_${c[3]}.zip`), o.$set(v);
  }, i(c) {
    f || (W(n.$$.fragment, c), W(s.$$.fragment, c), W(o.$$.fragment, c), f = true);
  }, o(c) {
    j(n.$$.fragment, c), j(s.$$.fragment, c), j(o.$$.fragment, c), f = false;
  }, d(c) {
    c && D(e), oe(n), oe(s), oe(o);
  } };
}
function Qne(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b;
  function A(F) {
    t3[12](F);
  }
  let _ = { label: "Key Size:", options: t3[8] };
  t3[4] !== void 0 && (_.value = t3[4]), r = new Ht({ props: _ }), Qe.push(() => ze(r, "value", A));
  function C(F) {
    t3[13](F);
  }
  let I = { label: "Output Format:", options: t3[9] };
  t3[0] !== void 0 && (I.value = t3[0]), a = new Ht({ props: I }), Qe.push(() => ze(a, "value", C)), l = new ut({ props: { disabled: t3[6], $$slots: { default: [One] }, $$scope: { ctx: t3 } } }), l.$on("click", t3[10]);
  let S = t3[5] && l_(t3), $ = t3[1] && u_(t3);
  return { c() {
    e = H("div"), n = H("div"), fe(r.$$.fragment), i = z(), fe(a.$$.fragment), f = z(), c = H("div"), fe(l.$$.fragment), h = z(), S && S.c(), m = z(), $ && $.c(), v = Lt(), V(n, "class", "row svelte-55c7uh"), V(c, "class", "action-row svelte-55c7uh"), V(e, "class", "controls-container svelte-55c7uh");
  }, m(F, U) {
    R(F, e, U), q(e, n), ae(r, n, null), q(n, i), ae(a, n, null), q(e, f), q(e, c), ae(l, c, null), R(F, h, U), S && S.m(F, U), R(F, m, U), $ && $.m(F, U), R(F, v, U), b = true;
  }, p(F, U) {
    const Q = {};
    !s && U & 16 && (s = true, Q.value = F[4], qe(() => s = false)), r.$set(Q);
    const P = {};
    !o && U & 1 && (o = true, P.value = F[0], qe(() => o = false)), a.$set(P);
    const N = {};
    U & 64 && (N.disabled = F[6]), U & 16448 && (N.$$scope = { dirty: U, ctx: F }), l.$set(N), F[5] ? S ? S.p(F, U) : (S = l_(F), S.c(), S.m(m.parentNode, m)) : S && (S.d(1), S = null), F[1] ? $ ? ($.p(F, U), U & 2 && W($, 1)) : ($ = u_(F), $.c(), W($, 1), $.m(v.parentNode, v)) : $ && (Xt(), j($, 1, 1, () => {
      $ = null;
    }), er());
  }, i(F) {
    b || (W(r.$$.fragment, F), W(a.$$.fragment, F), W(l.$$.fragment, F), W($), b = true);
  }, o(F) {
    j(r.$$.fragment, F), j(a.$$.fragment, F), j(l.$$.fragment, F), j($), b = false;
  }, d(F) {
    F && (D(e), D(h), D(m), D(v)), oe(r), oe(a), oe(l), S && S.d(F), $ && $.d(F);
  } };
}
function Kne(t3) {
  let e, n, r;
  return { c() {
    e = H("p"), e.innerHTML = "<strong>Which format should I choose?</strong>", n = z(), r = H("ul"), r.innerHTML = "<li><strong>PGP (.asc):</strong> Choose this if you want to use these keys with the <em>PGP Encryption Tool</em> on this site, or with software like GPG, ProtonMail, or Kleopatra.</li> <li><strong>PEM (.pem):</strong> Choose this for raw cryptographic operations, SSL certificates, or older SSH keys. This is the &quot;naked&quot; RSA key data.</li>";
  }, m(s, i) {
    R(s, e, i), R(s, n, i), R(s, r, i);
  }, p: dt, d(s) {
    s && (D(e), D(n), D(r));
  } };
}
function Hne(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "RSA Key Pair Generator", $$slots: { default: [Qne] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About RSA Key Pair Generator", links: t3[11], $$slots: { default: [Kne] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 16639 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 16384 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function qne(t3, e, n) {
  let r, s, i = 2048, a = "pgp", o = "", f = "", c = "", l = false;
  const h = [{ value: 1024, label: "1024 bit (Legacy/Fast)" }, { value: 2048, label: "2048 bit (Standard)" }, { value: 4096, label: "4096 bit (High Security - Slow)" }], m = [{ value: "pgp", label: "PGP Format (.asc) - Best for Email/File Tools" }, { value: "pem", label: "PEM Format (.pem) - Raw RSA/SSL/SSH" }];
  async function v() {
    n(5, c = ""), n(6, l = true), n(1, o = ""), n(2, f = ""), setTimeout(async () => {
      try {
        const C = await Fne(i, a);
        n(1, o = C.privateKey), n(2, f = C.publicKey);
      } catch (C) {
        n(5, c = "Generation Failed: " + C.message);
      } finally {
        n(6, l = false);
      }
    }, 50);
  }
  const b = [{ text: "Wikipedia: RSA (Cryptosystem)", url: "https://en.wikipedia.org/wiki/RSA_(cryptosystem)" }, { text: "RFC 8017: PKCS #1 v2.2", url: "https://datatracker.ietf.org/doc/html/rfc8017" }, { text: "Acrobat (.asc files)", url: "https://www.adobe.com/acrobat/resources/document-files/asc-file.html" }];
  function A(C) {
    i = C, n(4, i);
  }
  function _(C) {
    a = C, n(0, a);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 1 && n(3, r = a === "pgp" ? "asc" : "pem"), t3.$$.dirty & 14 && n(7, s = o ? [{ name: `private_key.${r}`, content: o }, { name: `public_key.${r}`, content: f }] : []);
  }, [a, o, f, r, i, c, l, s, h, m, v, b, A, _];
}
class zne extends xt {
  constructor(e) {
    super(), wt(this, e, qne, Hne, At, {});
  }
}
async function Gne(t3) {
  return new Promise((e, n) => {
    try {
      on.pki.rsa.generateKeyPair({ bits: 2048, workers: 2 }, (r, s) => {
        if (r) return n(new Error("Key Generation Error: " + r.message));
        const { privateKey: i, publicKey: a } = s, o = on.pki.createCertificate();
        o.publicKey = a, o.serialNumber = on.util.bytesToHex(on.random.getBytesSync(16));
        const f = parseInt(t3.validDays) || 365;
        o.validity.notBefore = /* @__PURE__ */ new Date(), o.validity.notAfter = /* @__PURE__ */ new Date(), o.validity.notAfter.setDate(o.validity.notBefore.getDate() + f);
        const l = [{ name: "commonName", value: t3.commonName }, { name: "countryName", value: t3.country }, { name: "stateOrProvinceName", value: t3.state }, { name: "localityName", value: t3.locality }, { name: "organizationName", value: t3.organization }].filter((A) => A.value && A.value.trim() !== "");
        o.setSubject(l), o.setIssuer(l);
        const h = [{ name: "basicConstraints", cA: true }, { name: "keyUsage", keyCertSign: true, digitalSignature: true, cRLSign: true }];
        if (t3.sanNames && t3.sanNames.length > 0) {
          const A = t3.sanNames.map((_) => {
            const C = /^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$/.test(_);
            return { type: C ? 7 : 2, ip: C ? _ : void 0, value: C ? void 0 : _ };
          });
          h.push({ name: "subjectAltName", altNames: A });
        }
        o.setExtensions(h), o.sign(i, on.md.sha512.create());
        const m = on.pki.certificateToPem(o), v = on.pki.publicKeyToPem(a);
        let b;
        t3.passphrase ? b = on.pki.encryptRsaPrivateKey(i, t3.passphrase, { algorithm: "aes256" }) : b = on.pki.privateKeyToPem(i), e({ certificate: m, privateKey: b, publicKey: v });
      });
    } catch (r) {
      n(r);
    }
  });
}
function Vne(t3) {
  let e;
  return { c() {
    e = we("Generate Certificate");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function Yne(t3) {
  let e;
  return { c() {
    e = we("Generating Keys & Signing...");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function Wne(t3) {
  let e;
  function n(i, a) {
    return i[3] ? Yne : Vne;
  }
  let r = n(t3), s = r(t3);
  return { c() {
    s.c(), e = Lt();
  }, m(i, a) {
    s.m(i, a), R(i, e, a);
  }, p(i, a) {
    r !== (r = n(i)) && (s.d(1), s = r(i), s && (s.c(), s.m(e.parentNode, e)));
  }, d(i) {
    i && D(e), s.d(i);
  } };
}
function Jne(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function c_(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[2]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 4 && Ze(n, r[2]);
  }, d(r) {
    r && D(e);
  } };
}
function h_(t3) {
  let e, n, r, s, i, a, o, f, c, l;
  return r = new sd({ props: { data: t3[4], zipName: "x509_self_signed_certificate.zip", label: "Download All Files" } }), i = new et({ props: { label: "Certificate (CRT):", value: t3[0].certificate, readonly: true, expandable: true, withCopy: true, withDownload: true, downloadName: "certificate.crt", rows: 5 } }), o = new et({ props: { label: "Private Key:", value: t3[0].privateKey, readonly: true, expandable: true, withCopy: true, withDownload: true, downloadName: "private.key", rows: 5 } }), c = new et({ props: { label: "Public Key:", value: t3[0].publicKey, readonly: true, expandable: true, withCopy: true, withDownload: true, downloadName: "public.key", rows: 5 } }), { c() {
    e = H("div"), n = H("div"), fe(r.$$.fragment), s = z(), fe(i.$$.fragment), a = z(), fe(o.$$.fragment), f = z(), fe(c.$$.fragment), St(n, "display", "flex"), St(n, "justify-content", "center"), St(n, "margin-bottom", "1.5rem"), V(e, "class", "results-area svelte-1gz95g0");
  }, m(h, m) {
    R(h, e, m), q(e, n), ae(r, n, null), q(e, s), ae(i, e, null), q(e, a), ae(o, e, null), q(e, f), ae(c, e, null), l = true;
  }, p(h, m) {
    const v = {};
    m & 16 && (v.data = h[4]), r.$set(v);
    const b = {};
    m & 1 && (b.value = h[0].certificate), i.$set(b);
    const A = {};
    m & 1 && (A.value = h[0].privateKey), o.$set(A);
    const _ = {};
    m & 1 && (_.value = h[0].publicKey), c.$set(_);
  }, i(h) {
    l || (W(r.$$.fragment, h), W(i.$$.fragment, h), W(o.$$.fragment, h), W(c.$$.fragment, h), l = true);
  }, o(h) {
    j(r.$$.fragment, h), j(i.$$.fragment, h), j(o.$$.fragment, h), j(c.$$.fragment, h), l = false;
  }, d(h) {
    h && D(e), oe(r), oe(i), oe(o), oe(c);
  } };
}
function Zne(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U, Q, P, N, L, B, u, p, d, y, w, E, M, x, g, k, T, O, K;
  function Y(Ne) {
    t3[8](Ne);
  }
  let J = { label: "Common Name (CN):", placeholder: "Required: e.g. localhost or mysite.local" };
  t3[1].commonName !== void 0 && (J.value = t3[1].commonName), i = new et({ props: J }), Qe.push(() => ze(i, "value", Y));
  function G(Ne) {
    t3[9](Ne);
  }
  let X = { label: "Organization (O):", placeholder: "Optional: e.g. My Company" };
  t3[1].organization !== void 0 && (X.value = t3[1].organization), f = new et({ props: X }), Qe.push(() => ze(f, "value", G));
  function ie(Ne) {
    t3[10](Ne);
  }
  let de = { label: "Locality / City (L):", placeholder: "Optional: e.g. San Francisco" };
  t3[1].locality !== void 0 && (de.value = t3[1].locality), h = new et({ props: de }), Qe.push(() => ze(h, "value", ie));
  function se(Ne) {
    t3[11](Ne);
  }
  let te = { label: "State / Province (ST):", placeholder: "Optional: e.g. California" };
  t3[1].state !== void 0 && (te.value = t3[1].state), b = new et({ props: te }), Qe.push(() => ze(b, "value", se));
  function le(Ne) {
    t3[12](Ne);
  }
  let Z = { label: "Country (C):", options: t3[5] };
  t3[1].country !== void 0 && (Z.value = t3[1].country), C = new Ht({ props: Z }), Qe.push(() => ze(C, "value", le));
  function ve(Ne) {
    t3[13](Ne);
  }
  let he = { label: "Valid Days:", placeholder: "365", type: "number" };
  t3[1].validDays !== void 0 && (he.value = t3[1].validDays), U = new et({ props: he }), Qe.push(() => ze(U, "value", ve));
  function me(Ne) {
    t3[14](Ne);
  }
  let ce = { label: "Subject Alternative Names (SANs):", placeholder: "e.g. localhost, 127.0.0.1 (Comma separated)" };
  t3[1].sanNamesInput !== void 0 && (ce.value = t3[1].sanNamesInput), L = new et({ props: ce }), Qe.push(() => ze(L, "value", me));
  function ye(Ne) {
    t3[15](Ne);
  }
  let Oe = { label: "Private Key Passphrase:", placeholder: "Optional: Leave empty for no encryption", type: "password" };
  t3[1].passphrase !== void 0 && (Oe.value = t3[1].passphrase), d = new et({ props: Oe }), Qe.push(() => ze(d, "value", ye)), M = new ut({ props: { disabled: t3[3], $$slots: { default: [Wne] }, $$scope: { ctx: t3 } } }), M.$on("click", t3[6]), g = new ut({ props: { variant: "secondary", $$slots: { default: [Jne] }, $$scope: { ctx: t3 } } }), g.$on("click", t3[16]);
  let Se = t3[2] && c_(t3), Ce = t3[0] && h_(t3);
  return { c() {
    e = H("div"), n = H("div"), n.innerHTML = '<h4 class="section-title svelte-1gz95g0">Identity Information</h4>', r = z(), s = H("div"), fe(i.$$.fragment), o = z(), fe(f.$$.fragment), l = z(), fe(h.$$.fragment), v = z(), fe(b.$$.fragment), _ = z(), fe(C.$$.fragment), S = z(), $ = H("div"), $.innerHTML = '<h4 class="section-title svelte-1gz95g0">Configuration</h4>', F = z(), fe(U.$$.fragment), P = z(), N = H("div"), fe(L.$$.fragment), u = z(), p = H("div"), fe(d.$$.fragment), w = z(), E = H("div"), fe(M.$$.fragment), x = z(), fe(g.$$.fragment), k = z(), Se && Se.c(), T = z(), Ce && Ce.c(), O = Lt(), V(n, "class", "full-width svelte-1gz95g0"), V(s, "class", "full-width svelte-1gz95g0"), V($, "class", "full-width svelte-1gz95g0"), V(N, "class", "full-width svelte-1gz95g0"), V(p, "class", "full-width svelte-1gz95g0"), V(e, "class", "form-grid svelte-1gz95g0"), V(E, "class", "button-row"), St(E, "margin-top", "1.5rem");
  }, m(Ne, $e) {
    R(Ne, e, $e), q(e, n), q(e, r), q(e, s), ae(i, s, null), q(e, o), ae(f, e, null), q(e, l), ae(h, e, null), q(e, v), ae(b, e, null), q(e, _), ae(C, e, null), q(e, S), q(e, $), q(e, F), ae(U, e, null), q(e, P), q(e, N), ae(L, N, null), q(e, u), q(e, p), ae(d, p, null), R(Ne, w, $e), R(Ne, E, $e), ae(M, E, null), q(E, x), ae(g, E, null), R(Ne, k, $e), Se && Se.m(Ne, $e), R(Ne, T, $e), Ce && Ce.m(Ne, $e), R(Ne, O, $e), K = true;
  }, p(Ne, $e) {
    const Re = {};
    !a && $e & 2 && (a = true, Re.value = Ne[1].commonName, qe(() => a = false)), i.$set(Re);
    const Ge = {};
    !c && $e & 2 && (c = true, Ge.value = Ne[1].organization, qe(() => c = false)), f.$set(Ge);
    const Fe = {};
    !m && $e & 2 && (m = true, Fe.value = Ne[1].locality, qe(() => m = false)), h.$set(Fe);
    const Ue = {};
    !A && $e & 2 && (A = true, Ue.value = Ne[1].state, qe(() => A = false)), b.$set(Ue);
    const kt = {};
    !I && $e & 2 && (I = true, kt.value = Ne[1].country, qe(() => I = false)), C.$set(kt);
    const pe = {};
    !Q && $e & 2 && (Q = true, pe.value = Ne[1].validDays, qe(() => Q = false)), U.$set(pe);
    const re = {};
    !B && $e & 2 && (B = true, re.value = Ne[1].sanNamesInput, qe(() => B = false)), L.$set(re);
    const ue = {};
    !y && $e & 2 && (y = true, ue.value = Ne[1].passphrase, qe(() => y = false)), d.$set(ue);
    const xe = {};
    $e & 8 && (xe.disabled = Ne[3]), $e & 131080 && (xe.$$scope = { dirty: $e, ctx: Ne }), M.$set(xe);
    const Me = {};
    $e & 131072 && (Me.$$scope = { dirty: $e, ctx: Ne }), g.$set(Me), Ne[2] ? Se ? Se.p(Ne, $e) : (Se = c_(Ne), Se.c(), Se.m(T.parentNode, T)) : Se && (Se.d(1), Se = null), Ne[0] ? Ce ? (Ce.p(Ne, $e), $e & 1 && W(Ce, 1)) : (Ce = h_(Ne), Ce.c(), W(Ce, 1), Ce.m(O.parentNode, O)) : Ce && (Xt(), j(Ce, 1, 1, () => {
      Ce = null;
    }), er());
  }, i(Ne) {
    K || (W(i.$$.fragment, Ne), W(f.$$.fragment, Ne), W(h.$$.fragment, Ne), W(b.$$.fragment, Ne), W(C.$$.fragment, Ne), W(U.$$.fragment, Ne), W(L.$$.fragment, Ne), W(d.$$.fragment, Ne), W(M.$$.fragment, Ne), W(g.$$.fragment, Ne), W(Ce), K = true);
  }, o(Ne) {
    j(i.$$.fragment, Ne), j(f.$$.fragment, Ne), j(h.$$.fragment, Ne), j(b.$$.fragment, Ne), j(C.$$.fragment, Ne), j(U.$$.fragment, Ne), j(L.$$.fragment, Ne), j(d.$$.fragment, Ne), j(M.$$.fragment, Ne), j(g.$$.fragment, Ne), j(Ce), K = false;
  }, d(Ne) {
    Ne && (D(e), D(w), D(E), D(k), D(T), D(O)), oe(i), oe(f), oe(h), oe(b), oe(C), oe(U), oe(L), oe(d), oe(M), oe(g), Se && Se.d(Ne), Ce && Ce.d(Ne);
  } };
}
function jne(t3) {
  let e, n, r, s, i;
  return { c() {
    e = H("p"), e.innerHTML = `A <b>self-signed X.509 certificate</b> is a digital certificate that is signed 
    by the same entity it certifies, rather than by a third-party certificate 
    authority (CA). Self-signed certificates are often used in testing, 
    local development, or internal applications where trusted CA validation 
    isn\u2019t necessary.`, n = z(), r = H("p"), r.textContent = `X.509 is a standard for public key infrastructure (PKI) 
    and defines the format of public key certificates. Each certificate contains 
    a subject, a public key, issuer information, validity dates, and a
    digital signature. In a self-signed certificate, the entity (user or organization) 
    that issues the certificate is also the one that signs it. This means the Issuer 
    and Subject fields are identical. This approach eliminates the need for a CA, 
    making it quick and free to generate but less secure outside of trusted environments. 
    While self-signed certificates provide encryption, they don\u2019t verify 
    the identity of the server. Thus, they should be used only when there\u2019s an implicit 
    trust in the certificate holder, like in private or controlled environments`, s = z(), i = H("ul"), i.innerHTML = "<li><strong>Use Cases:</strong> Local development (localhost), internal testing, or private networks.</li> <li>Browsers will show a &quot;Not Secure&quot; warning because they don&#39;t trust the issuer (you). You must manually trust the cert in your OS/Browser to remove the warning.</li> <li><strong>SANs:</strong> Modern browsers (Chrome/Edge) require the domain/IP to be listed in the &quot;Subject Alternative Names&quot; (SAN) field, not just the Common Name.</li>";
  }, m(a, o) {
    R(a, e, o), R(a, n, o), R(a, r, o), R(a, s, o), R(a, i, o);
  }, p: dt, d(a) {
    a && (D(e), D(n), D(r), D(s), D(i));
  } };
}
function Xne(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "X.509 Self-Signed Certificate Generator", $$slots: { default: [Zne] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Self-Signed Certs", links: t3[7], $$slots: { default: [jne] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 131103 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 131072 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function eie(t3, e, n) {
  let r, s = { commonName: "", organization: "", locality: "", state: "", country: "US", validDays: "365", sanNamesInput: "", passphrase: "" }, i = null, a = "", o = false;
  const f = [{ value: "US", label: "United States (US)" }, { value: "GB", label: "United Kingdom (GB)" }, { value: "CA", label: "Canada (CA)" }, { value: "DE", label: "Germany (DE)" }, { value: "FR", label: "France (FR)" }, { value: "IN", label: "India (IN)" }, { value: "JP", label: "Japan (JP)" }, { value: "CN", label: "China (CN)" }, { value: "BR", label: "Brazil (BR)" }, { value: "AU", label: "Australia (AU)" }];
  async function c() {
    if (!s.commonName) {
      n(2, a = "Common Name is required.");
      return;
    }
    n(2, a = ""), n(3, o = true), n(0, i = null);
    const $ = s.sanNamesInput.split(",").map((U) => U.trim()).filter((U) => U.length > 0), F = { ...s, sanNames: $ };
    setTimeout(async () => {
      try {
        n(0, i = await Gne(F));
      } catch (U) {
        n(2, a = U.message);
      } finally {
        n(3, o = false);
      }
    }, 50);
  }
  const l = [{ text: "Wikipedia: X.509", url: "https://en.wikipedia.org/wiki/X.509" }, { text: "WorkOs", url: "https://workos.com/blog/x509-certificate" }];
  function h($) {
    t3.$$.not_equal(s.commonName, $) && (s.commonName = $, n(1, s));
  }
  function m($) {
    t3.$$.not_equal(s.organization, $) && (s.organization = $, n(1, s));
  }
  function v($) {
    t3.$$.not_equal(s.locality, $) && (s.locality = $, n(1, s));
  }
  function b($) {
    t3.$$.not_equal(s.state, $) && (s.state = $, n(1, s));
  }
  function A($) {
    t3.$$.not_equal(s.country, $) && (s.country = $, n(1, s));
  }
  function _($) {
    t3.$$.not_equal(s.validDays, $) && (s.validDays = $, n(1, s));
  }
  function C($) {
    t3.$$.not_equal(s.sanNamesInput, $) && (s.sanNamesInput = $, n(1, s));
  }
  function I($) {
    t3.$$.not_equal(s.passphrase, $) && (s.passphrase = $, n(1, s));
  }
  const S = () => {
    n(0, i = null), n(1, s.commonName = "", s);
  };
  return t3.$$.update = () => {
    t3.$$.dirty & 1 && n(4, r = i ? [{ name: "certificate.crt", content: i.certificate }, { name: "private.key", content: i.privateKey }, { name: "public.key", content: i.publicKey }] : []);
  }, [i, s, a, o, r, f, c, l, h, m, v, b, A, _, C, I, S];
}
class tie extends xt {
  constructor(e) {
    super(), wt(this, e, eie, Xne, At, {});
  }
}
var JT = { exports: {} }, ZT = { exports: {} };
(function(t3, e) {
  (function(n, r) {
    t3.exports = r();
  })(mt, function() {
    var n = n || function(r, s) {
      var i;
      if (typeof window < "u" && window.crypto && (i = window.crypto), typeof self < "u" && self.crypto && (i = self.crypto), typeof globalThis < "u" && globalThis.crypto && (i = globalThis.crypto), !i && typeof window < "u" && window.msCrypto && (i = window.msCrypto), !i && typeof mt < "u" && mt.crypto && (i = mt.crypto), !i && typeof Gl == "function") try {
        i = vl();
      } catch {
      }
      var a = function() {
        if (i) {
          if (typeof i.getRandomValues == "function") try {
            return i.getRandomValues(new Uint32Array(1))[0];
          } catch {
          }
          if (typeof i.randomBytes == "function") try {
            return i.randomBytes(4).readInt32LE();
          } catch {
          }
        }
        throw new Error("Native crypto module could not be used to get secure random number.");
      }, o = Object.create || /* @__PURE__ */ function() {
        function I() {
        }
        return function(S) {
          var $;
          return I.prototype = S, $ = new I(), I.prototype = null, $;
        };
      }(), f = {}, c = f.lib = {}, l = c.Base = /* @__PURE__ */ function() {
        return { extend: function(I) {
          var S = o(this);
          return I && S.mixIn(I), (!S.hasOwnProperty("init") || this.init === S.init) && (S.init = function() {
            S.$super.init.apply(this, arguments);
          }), S.init.prototype = S, S.$super = this, S;
        }, create: function() {
          var I = this.extend();
          return I.init.apply(I, arguments), I;
        }, init: function() {
        }, mixIn: function(I) {
          for (var S in I) I.hasOwnProperty(S) && (this[S] = I[S]);
          I.hasOwnProperty("toString") && (this.toString = I.toString);
        }, clone: function() {
          return this.init.prototype.extend(this);
        } };
      }(), h = c.WordArray = l.extend({ init: function(I, S) {
        I = this.words = I || [], S != s ? this.sigBytes = S : this.sigBytes = I.length * 4;
      }, toString: function(I) {
        return (I || v).stringify(this);
      }, concat: function(I) {
        var S = this.words, $ = I.words, F = this.sigBytes, U = I.sigBytes;
        if (this.clamp(), F % 4) for (var Q = 0; Q < U; Q++) {
          var P = $[Q >>> 2] >>> 24 - Q % 4 * 8 & 255;
          S[F + Q >>> 2] |= P << 24 - (F + Q) % 4 * 8;
        }
        else for (var N = 0; N < U; N += 4) S[F + N >>> 2] = $[N >>> 2];
        return this.sigBytes += U, this;
      }, clamp: function() {
        var I = this.words, S = this.sigBytes;
        I[S >>> 2] &= 4294967295 << 32 - S % 4 * 8, I.length = r.ceil(S / 4);
      }, clone: function() {
        var I = l.clone.call(this);
        return I.words = this.words.slice(0), I;
      }, random: function(I) {
        for (var S = [], $ = 0; $ < I; $ += 4) S.push(a());
        return new h.init(S, I);
      } }), m = f.enc = {}, v = m.Hex = { stringify: function(I) {
        for (var S = I.words, $ = I.sigBytes, F = [], U = 0; U < $; U++) {
          var Q = S[U >>> 2] >>> 24 - U % 4 * 8 & 255;
          F.push((Q >>> 4).toString(16)), F.push((Q & 15).toString(16));
        }
        return F.join("");
      }, parse: function(I) {
        for (var S = I.length, $ = [], F = 0; F < S; F += 2) $[F >>> 3] |= parseInt(I.substr(F, 2), 16) << 24 - F % 8 * 4;
        return new h.init($, S / 2);
      } }, b = m.Latin1 = { stringify: function(I) {
        for (var S = I.words, $ = I.sigBytes, F = [], U = 0; U < $; U++) {
          var Q = S[U >>> 2] >>> 24 - U % 4 * 8 & 255;
          F.push(String.fromCharCode(Q));
        }
        return F.join("");
      }, parse: function(I) {
        for (var S = I.length, $ = [], F = 0; F < S; F++) $[F >>> 2] |= (I.charCodeAt(F) & 255) << 24 - F % 4 * 8;
        return new h.init($, S);
      } }, A = m.Utf8 = { stringify: function(I) {
        try {
          return decodeURIComponent(escape(b.stringify(I)));
        } catch {
          throw new Error("Malformed UTF-8 data");
        }
      }, parse: function(I) {
        return b.parse(unescape(encodeURIComponent(I)));
      } }, _ = c.BufferedBlockAlgorithm = l.extend({ reset: function() {
        this._data = new h.init(), this._nDataBytes = 0;
      }, _append: function(I) {
        typeof I == "string" && (I = A.parse(I)), this._data.concat(I), this._nDataBytes += I.sigBytes;
      }, _process: function(I) {
        var S, $ = this._data, F = $.words, U = $.sigBytes, Q = this.blockSize, P = Q * 4, N = U / P;
        I ? N = r.ceil(N) : N = r.max((N | 0) - this._minBufferSize, 0);
        var L = N * Q, B = r.min(L * 4, U);
        if (L) {
          for (var u = 0; u < L; u += Q) this._doProcessBlock(F, u);
          S = F.splice(0, L), $.sigBytes -= B;
        }
        return new h.init(S, B);
      }, clone: function() {
        var I = l.clone.call(this);
        return I._data = this._data.clone(), I;
      }, _minBufferSize: 0 });
      c.Hasher = _.extend({ cfg: l.extend(), init: function(I) {
        this.cfg = this.cfg.extend(I), this.reset();
      }, reset: function() {
        _.reset.call(this), this._doReset();
      }, update: function(I) {
        return this._append(I), this._process(), this;
      }, finalize: function(I) {
        I && this._append(I);
        var S = this._doFinalize();
        return S;
      }, blockSize: 16, _createHelper: function(I) {
        return function(S, $) {
          return new I.init($).finalize(S);
        };
      }, _createHmacHelper: function(I) {
        return function(S, $) {
          return new C.HMAC.init(I, $).finalize(S);
        };
      } });
      var C = f.algo = {};
      return f;
    }(Math);
    return n;
  });
})(ZT);
var Lr = ZT.exports, xv = { exports: {} }, d_;
function pm() {
  return d_ || (d_ = 1, function(t3, e) {
    (function(n, r) {
      t3.exports = r(Lr);
    })(mt, function(n) {
      return function(r) {
        var s = n, i = s.lib, a = i.Base, o = i.WordArray, f = s.x64 = {};
        f.Word = a.extend({ init: function(c, l) {
          this.high = c, this.low = l;
        } }), f.WordArray = a.extend({ init: function(c, l) {
          c = this.words = c || [], l != r ? this.sigBytes = l : this.sigBytes = c.length * 8;
        }, toX32: function() {
          for (var c = this.words, l = c.length, h = [], m = 0; m < l; m++) {
            var v = c[m];
            h.push(v.high), h.push(v.low);
          }
          return o.create(h, this.sigBytes);
        }, clone: function() {
          for (var c = a.clone.call(this), l = c.words = this.words.slice(0), h = l.length, m = 0; m < h; m++) l[m] = l[m].clone();
          return c;
        } });
      }(), n;
    });
  }(xv)), xv.exports;
}
var _v = { exports: {} }, p_;
function rie() {
  return p_ || (p_ = 1, function(t3, e) {
    (function(n, r) {
      t3.exports = r(Lr);
    })(mt, function(n) {
      return function() {
        if (typeof ArrayBuffer == "function") {
          var r = n, s = r.lib, i = s.WordArray, a = i.init, o = i.init = function(f) {
            if (f instanceof ArrayBuffer && (f = new Uint8Array(f)), (f instanceof Int8Array || typeof Uint8ClampedArray < "u" && f instanceof Uint8ClampedArray || f instanceof Int16Array || f instanceof Uint16Array || f instanceof Int32Array || f instanceof Uint32Array || f instanceof Float32Array || f instanceof Float64Array) && (f = new Uint8Array(f.buffer, f.byteOffset, f.byteLength)), f instanceof Uint8Array) {
              for (var c = f.byteLength, l = [], h = 0; h < c; h++) l[h >>> 2] |= f[h] << 24 - h % 4 * 8;
              a.call(this, l, c);
            } else a.apply(this, arguments);
          };
          o.prototype = i;
        }
      }(), n.lib.WordArray;
    });
  }(_v)), _v.exports;
}
var Ev = { exports: {} }, g_;
function nie() {
  return g_ || (g_ = 1, function(t3, e) {
    (function(n, r) {
      t3.exports = r(Lr);
    })(mt, function(n) {
      return function() {
        var r = n, s = r.lib, i = s.WordArray, a = r.enc;
        a.Utf16 = a.Utf16BE = { stringify: function(f) {
          for (var c = f.words, l = f.sigBytes, h = [], m = 0; m < l; m += 2) {
            var v = c[m >>> 2] >>> 16 - m % 4 * 8 & 65535;
            h.push(String.fromCharCode(v));
          }
          return h.join("");
        }, parse: function(f) {
          for (var c = f.length, l = [], h = 0; h < c; h++) l[h >>> 1] |= f.charCodeAt(h) << 16 - h % 2 * 16;
          return i.create(l, c * 2);
        } }, a.Utf16LE = { stringify: function(f) {
          for (var c = f.words, l = f.sigBytes, h = [], m = 0; m < l; m += 2) {
            var v = o(c[m >>> 2] >>> 16 - m % 4 * 8 & 65535);
            h.push(String.fromCharCode(v));
          }
          return h.join("");
        }, parse: function(f) {
          for (var c = f.length, l = [], h = 0; h < c; h++) l[h >>> 1] |= o(f.charCodeAt(h) << 16 - h % 2 * 16);
          return i.create(l, c * 2);
        } };
        function o(f) {
          return f << 8 & 4278255360 | f >>> 8 & 16711935;
        }
      }(), n.enc.Utf16;
    });
  }(Ev)), Ev.exports;
}
var jT = { exports: {} };
(function(t3, e) {
  (function(n, r) {
    t3.exports = r(Lr);
  })(mt, function(n) {
    return function() {
      var r = n, s = r.lib, i = s.WordArray, a = r.enc;
      a.Base64 = { stringify: function(f) {
        var c = f.words, l = f.sigBytes, h = this._map;
        f.clamp();
        for (var m = [], v = 0; v < l; v += 3) for (var b = c[v >>> 2] >>> 24 - v % 4 * 8 & 255, A = c[v + 1 >>> 2] >>> 24 - (v + 1) % 4 * 8 & 255, _ = c[v + 2 >>> 2] >>> 24 - (v + 2) % 4 * 8 & 255, C = b << 16 | A << 8 | _, I = 0; I < 4 && v + I * 0.75 < l; I++) m.push(h.charAt(C >>> 6 * (3 - I) & 63));
        var S = h.charAt(64);
        if (S) for (; m.length % 4; ) m.push(S);
        return m.join("");
      }, parse: function(f) {
        var c = f.length, l = this._map, h = this._reverseMap;
        if (!h) {
          h = this._reverseMap = [];
          for (var m = 0; m < l.length; m++) h[l.charCodeAt(m)] = m;
        }
        var v = l.charAt(64);
        if (v) {
          var b = f.indexOf(v);
          b !== -1 && (c = b);
        }
        return o(f, c, h);
      }, _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=" };
      function o(f, c, l) {
        for (var h = [], m = 0, v = 0; v < c; v++) if (v % 4) {
          var b = l[f.charCodeAt(v - 1)] << v % 4 * 2, A = l[f.charCodeAt(v)] >>> 6 - v % 4 * 2, _ = b | A;
          h[m >>> 2] |= _ << 24 - m % 4 * 8, m++;
        }
        return i.create(h, m);
      }
    }(), n.enc.Base64;
  });
})(jT);
var yl = jT.exports, Bv = { exports: {} }, m_;
function iie() {
  return m_ || (m_ = 1, function(t3, e) {
    (function(n, r) {
      t3.exports = r(Lr);
    })(mt, function(n) {
      return function() {
        var r = n, s = r.lib, i = s.WordArray, a = r.enc;
        a.Base64url = { stringify: function(f, c) {
          c === void 0 && (c = true);
          var l = f.words, h = f.sigBytes, m = c ? this._safe_map : this._map;
          f.clamp();
          for (var v = [], b = 0; b < h; b += 3) for (var A = l[b >>> 2] >>> 24 - b % 4 * 8 & 255, _ = l[b + 1 >>> 2] >>> 24 - (b + 1) % 4 * 8 & 255, C = l[b + 2 >>> 2] >>> 24 - (b + 2) % 4 * 8 & 255, I = A << 16 | _ << 8 | C, S = 0; S < 4 && b + S * 0.75 < h; S++) v.push(m.charAt(I >>> 6 * (3 - S) & 63));
          var $ = m.charAt(64);
          if ($) for (; v.length % 4; ) v.push($);
          return v.join("");
        }, parse: function(f, c) {
          c === void 0 && (c = true);
          var l = f.length, h = c ? this._safe_map : this._map, m = this._reverseMap;
          if (!m) {
            m = this._reverseMap = [];
            for (var v = 0; v < h.length; v++) m[h.charCodeAt(v)] = v;
          }
          var b = h.charAt(64);
          if (b) {
            var A = f.indexOf(b);
            A !== -1 && (l = A);
          }
          return o(f, l, m);
        }, _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_" };
        function o(f, c, l) {
          for (var h = [], m = 0, v = 0; v < c; v++) if (v % 4) {
            var b = l[f.charCodeAt(v - 1)] << v % 4 * 2, A = l[f.charCodeAt(v)] >>> 6 - v % 4 * 2, _ = b | A;
            h[m >>> 2] |= _ << 24 - m % 4 * 8, m++;
          }
          return i.create(h, m);
        }
      }(), n.enc.Base64url;
    });
  }(Bv)), Bv.exports;
}
var Cv = { exports: {} }, v_;
function _0() {
  return v_ || (v_ = 1, function(t3, e) {
    (function(n, r) {
      t3.exports = r(Lr);
    })(mt, function(n) {
      return function(r) {
        var s = n, i = s.lib, a = i.WordArray, o = i.Hasher, f = s.algo, c = [];
        (function() {
          for (var A = 0; A < 64; A++) c[A] = r.abs(r.sin(A + 1)) * 4294967296 | 0;
        })();
        var l = f.MD5 = o.extend({ _doReset: function() {
          this._hash = new a.init([1732584193, 4023233417, 2562383102, 271733878]);
        }, _doProcessBlock: function(A, _) {
          for (var C = 0; C < 16; C++) {
            var I = _ + C, S = A[I];
            A[I] = (S << 8 | S >>> 24) & 16711935 | (S << 24 | S >>> 8) & 4278255360;
          }
          var $ = this._hash.words, F = A[_ + 0], U = A[_ + 1], Q = A[_ + 2], P = A[_ + 3], N = A[_ + 4], L = A[_ + 5], B = A[_ + 6], u = A[_ + 7], p = A[_ + 8], d = A[_ + 9], y = A[_ + 10], w = A[_ + 11], E = A[_ + 12], M = A[_ + 13], x = A[_ + 14], g = A[_ + 15], k = $[0], T = $[1], O = $[2], K = $[3];
          k = h(k, T, O, K, F, 7, c[0]), K = h(K, k, T, O, U, 12, c[1]), O = h(O, K, k, T, Q, 17, c[2]), T = h(T, O, K, k, P, 22, c[3]), k = h(k, T, O, K, N, 7, c[4]), K = h(K, k, T, O, L, 12, c[5]), O = h(O, K, k, T, B, 17, c[6]), T = h(T, O, K, k, u, 22, c[7]), k = h(k, T, O, K, p, 7, c[8]), K = h(K, k, T, O, d, 12, c[9]), O = h(O, K, k, T, y, 17, c[10]), T = h(T, O, K, k, w, 22, c[11]), k = h(k, T, O, K, E, 7, c[12]), K = h(K, k, T, O, M, 12, c[13]), O = h(O, K, k, T, x, 17, c[14]), T = h(T, O, K, k, g, 22, c[15]), k = m(k, T, O, K, U, 5, c[16]), K = m(K, k, T, O, B, 9, c[17]), O = m(O, K, k, T, w, 14, c[18]), T = m(T, O, K, k, F, 20, c[19]), k = m(k, T, O, K, L, 5, c[20]), K = m(K, k, T, O, y, 9, c[21]), O = m(O, K, k, T, g, 14, c[22]), T = m(T, O, K, k, N, 20, c[23]), k = m(k, T, O, K, d, 5, c[24]), K = m(K, k, T, O, x, 9, c[25]), O = m(O, K, k, T, P, 14, c[26]), T = m(T, O, K, k, p, 20, c[27]), k = m(k, T, O, K, M, 5, c[28]), K = m(K, k, T, O, Q, 9, c[29]), O = m(O, K, k, T, u, 14, c[30]), T = m(T, O, K, k, E, 20, c[31]), k = v(k, T, O, K, L, 4, c[32]), K = v(K, k, T, O, p, 11, c[33]), O = v(O, K, k, T, w, 16, c[34]), T = v(T, O, K, k, x, 23, c[35]), k = v(k, T, O, K, U, 4, c[36]), K = v(K, k, T, O, N, 11, c[37]), O = v(O, K, k, T, u, 16, c[38]), T = v(T, O, K, k, y, 23, c[39]), k = v(k, T, O, K, M, 4, c[40]), K = v(K, k, T, O, F, 11, c[41]), O = v(O, K, k, T, P, 16, c[42]), T = v(T, O, K, k, B, 23, c[43]), k = v(k, T, O, K, d, 4, c[44]), K = v(K, k, T, O, E, 11, c[45]), O = v(O, K, k, T, g, 16, c[46]), T = v(T, O, K, k, Q, 23, c[47]), k = b(k, T, O, K, F, 6, c[48]), K = b(K, k, T, O, u, 10, c[49]), O = b(O, K, k, T, x, 15, c[50]), T = b(T, O, K, k, L, 21, c[51]), k = b(k, T, O, K, E, 6, c[52]), K = b(K, k, T, O, P, 10, c[53]), O = b(O, K, k, T, y, 15, c[54]), T = b(T, O, K, k, U, 21, c[55]), k = b(k, T, O, K, p, 6, c[56]), K = b(K, k, T, O, g, 10, c[57]), O = b(O, K, k, T, B, 15, c[58]), T = b(T, O, K, k, M, 21, c[59]), k = b(k, T, O, K, N, 6, c[60]), K = b(K, k, T, O, w, 10, c[61]), O = b(O, K, k, T, Q, 15, c[62]), T = b(T, O, K, k, d, 21, c[63]), $[0] = $[0] + k | 0, $[1] = $[1] + T | 0, $[2] = $[2] + O | 0, $[3] = $[3] + K | 0;
        }, _doFinalize: function() {
          var A = this._data, _ = A.words, C = this._nDataBytes * 8, I = A.sigBytes * 8;
          _[I >>> 5] |= 128 << 24 - I % 32;
          var S = r.floor(C / 4294967296), $ = C;
          _[(I + 64 >>> 9 << 4) + 15] = (S << 8 | S >>> 24) & 16711935 | (S << 24 | S >>> 8) & 4278255360, _[(I + 64 >>> 9 << 4) + 14] = ($ << 8 | $ >>> 24) & 16711935 | ($ << 24 | $ >>> 8) & 4278255360, A.sigBytes = (_.length + 1) * 4, this._process();
          for (var F = this._hash, U = F.words, Q = 0; Q < 4; Q++) {
            var P = U[Q];
            U[Q] = (P << 8 | P >>> 24) & 16711935 | (P << 24 | P >>> 8) & 4278255360;
          }
          return F;
        }, clone: function() {
          var A = o.clone.call(this);
          return A._hash = this._hash.clone(), A;
        } });
        function h(A, _, C, I, S, $, F) {
          var U = A + (_ & C | ~_ & I) + S + F;
          return (U << $ | U >>> 32 - $) + _;
        }
        function m(A, _, C, I, S, $, F) {
          var U = A + (_ & I | C & ~I) + S + F;
          return (U << $ | U >>> 32 - $) + _;
        }
        function v(A, _, C, I, S, $, F) {
          var U = A + (_ ^ C ^ I) + S + F;
          return (U << $ | U >>> 32 - $) + _;
        }
        function b(A, _, C, I, S, $, F) {
          var U = A + (C ^ (_ | ~I)) + S + F;
          return (U << $ | U >>> 32 - $) + _;
        }
        s.MD5 = o._createHelper(l), s.HmacMD5 = o._createHmacHelper(l);
      }(Math), n.MD5;
    });
  }(Cv)), Cv.exports;
}
var kv = { exports: {} }, y_;
function XT() {
  return y_ || (y_ = 1, function(t3, e) {
    (function(n, r) {
      t3.exports = r(Lr);
    })(mt, function(n) {
      return function() {
        var r = n, s = r.lib, i = s.WordArray, a = s.Hasher, o = r.algo, f = [], c = o.SHA1 = a.extend({ _doReset: function() {
          this._hash = new i.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
        }, _doProcessBlock: function(l, h) {
          for (var m = this._hash.words, v = m[0], b = m[1], A = m[2], _ = m[3], C = m[4], I = 0; I < 80; I++) {
            if (I < 16) f[I] = l[h + I] | 0;
            else {
              var S = f[I - 3] ^ f[I - 8] ^ f[I - 14] ^ f[I - 16];
              f[I] = S << 1 | S >>> 31;
            }
            var $ = (v << 5 | v >>> 27) + C + f[I];
            I < 20 ? $ += (b & A | ~b & _) + 1518500249 : I < 40 ? $ += (b ^ A ^ _) + 1859775393 : I < 60 ? $ += (b & A | b & _ | A & _) - 1894007588 : $ += (b ^ A ^ _) - 899497514, C = _, _ = A, A = b << 30 | b >>> 2, b = v, v = $;
          }
          m[0] = m[0] + v | 0, m[1] = m[1] + b | 0, m[2] = m[2] + A | 0, m[3] = m[3] + _ | 0, m[4] = m[4] + C | 0;
        }, _doFinalize: function() {
          var l = this._data, h = l.words, m = this._nDataBytes * 8, v = l.sigBytes * 8;
          return h[v >>> 5] |= 128 << 24 - v % 32, h[(v + 64 >>> 9 << 4) + 14] = Math.floor(m / 4294967296), h[(v + 64 >>> 9 << 4) + 15] = m, l.sigBytes = h.length * 4, this._process(), this._hash;
        }, clone: function() {
          var l = a.clone.call(this);
          return l._hash = this._hash.clone(), l;
        } });
        r.SHA1 = a._createHelper(c), r.HmacSHA1 = a._createHmacHelper(c);
      }(), n.SHA1;
    });
  }(kv)), kv.exports;
}
var Iv = { exports: {} }, b_;
function gm() {
  return b_ || (b_ = 1, function(t3, e) {
    (function(n, r) {
      t3.exports = r(Lr);
    })(mt, function(n) {
      return function(r) {
        var s = n, i = s.lib, a = i.WordArray, o = i.Hasher, f = s.algo, c = [], l = [];
        (function() {
          function v(C) {
            for (var I = r.sqrt(C), S = 2; S <= I; S++) if (!(C % S)) return false;
            return true;
          }
          function b(C) {
            return (C - (C | 0)) * 4294967296 | 0;
          }
          for (var A = 2, _ = 0; _ < 64; ) v(A) && (_ < 8 && (c[_] = b(r.pow(A, 1 / 2))), l[_] = b(r.pow(A, 1 / 3)), _++), A++;
        })();
        var h = [], m = f.SHA256 = o.extend({ _doReset: function() {
          this._hash = new a.init(c.slice(0));
        }, _doProcessBlock: function(v, b) {
          for (var A = this._hash.words, _ = A[0], C = A[1], I = A[2], S = A[3], $ = A[4], F = A[5], U = A[6], Q = A[7], P = 0; P < 64; P++) {
            if (P < 16) h[P] = v[b + P] | 0;
            else {
              var N = h[P - 15], L = (N << 25 | N >>> 7) ^ (N << 14 | N >>> 18) ^ N >>> 3, B = h[P - 2], u = (B << 15 | B >>> 17) ^ (B << 13 | B >>> 19) ^ B >>> 10;
              h[P] = L + h[P - 7] + u + h[P - 16];
            }
            var p = $ & F ^ ~$ & U, d = _ & C ^ _ & I ^ C & I, y = (_ << 30 | _ >>> 2) ^ (_ << 19 | _ >>> 13) ^ (_ << 10 | _ >>> 22), w = ($ << 26 | $ >>> 6) ^ ($ << 21 | $ >>> 11) ^ ($ << 7 | $ >>> 25), E = Q + w + p + l[P] + h[P], M = y + d;
            Q = U, U = F, F = $, $ = S + E | 0, S = I, I = C, C = _, _ = E + M | 0;
          }
          A[0] = A[0] + _ | 0, A[1] = A[1] + C | 0, A[2] = A[2] + I | 0, A[3] = A[3] + S | 0, A[4] = A[4] + $ | 0, A[5] = A[5] + F | 0, A[6] = A[6] + U | 0, A[7] = A[7] + Q | 0;
        }, _doFinalize: function() {
          var v = this._data, b = v.words, A = this._nDataBytes * 8, _ = v.sigBytes * 8;
          return b[_ >>> 5] |= 128 << 24 - _ % 32, b[(_ + 64 >>> 9 << 4) + 14] = r.floor(A / 4294967296), b[(_ + 64 >>> 9 << 4) + 15] = A, v.sigBytes = b.length * 4, this._process(), this._hash;
        }, clone: function() {
          var v = o.clone.call(this);
          return v._hash = this._hash.clone(), v;
        } });
        s.SHA256 = o._createHelper(m), s.HmacSHA256 = o._createHmacHelper(m);
      }(Math), n.SHA256;
    });
  }(Iv)), Iv.exports;
}
var Sv = { exports: {} }, A_;
function sie() {
  return A_ || (A_ = 1, function(t3, e) {
    (function(n, r, s) {
      t3.exports = r(Lr, gm());
    })(mt, function(n) {
      return function() {
        var r = n, s = r.lib, i = s.WordArray, a = r.algo, o = a.SHA256, f = a.SHA224 = o.extend({ _doReset: function() {
          this._hash = new i.init([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]);
        }, _doFinalize: function() {
          var c = o._doFinalize.call(this);
          return c.sigBytes -= 4, c;
        } });
        r.SHA224 = o._createHelper(f), r.HmacSHA224 = o._createHmacHelper(f);
      }(), n.SHA224;
    });
  }(Sv)), Sv.exports;
}
var Mv = { exports: {} }, w_;
function eD() {
  return w_ || (w_ = 1, function(t3, e) {
    (function(n, r, s) {
      t3.exports = r(Lr, pm());
    })(mt, function(n) {
      return function() {
        var r = n, s = r.lib, i = s.Hasher, a = r.x64, o = a.Word, f = a.WordArray, c = r.algo;
        function l() {
          return o.create.apply(o, arguments);
        }
        var h = [l(1116352408, 3609767458), l(1899447441, 602891725), l(3049323471, 3964484399), l(3921009573, 2173295548), l(961987163, 4081628472), l(1508970993, 3053834265), l(2453635748, 2937671579), l(2870763221, 3664609560), l(3624381080, 2734883394), l(310598401, 1164996542), l(607225278, 1323610764), l(1426881987, 3590304994), l(1925078388, 4068182383), l(2162078206, 991336113), l(2614888103, 633803317), l(3248222580, 3479774868), l(3835390401, 2666613458), l(4022224774, 944711139), l(264347078, 2341262773), l(604807628, 2007800933), l(770255983, 1495990901), l(1249150122, 1856431235), l(1555081692, 3175218132), l(1996064986, 2198950837), l(2554220882, 3999719339), l(2821834349, 766784016), l(2952996808, 2566594879), l(3210313671, 3203337956), l(3336571891, 1034457026), l(3584528711, 2466948901), l(113926993, 3758326383), l(338241895, 168717936), l(666307205, 1188179964), l(773529912, 1546045734), l(1294757372, 1522805485), l(1396182291, 2643833823), l(1695183700, 2343527390), l(1986661051, 1014477480), l(2177026350, 1206759142), l(2456956037, 344077627), l(2730485921, 1290863460), l(2820302411, 3158454273), l(3259730800, 3505952657), l(3345764771, 106217008), l(3516065817, 3606008344), l(3600352804, 1432725776), l(4094571909, 1467031594), l(275423344, 851169720), l(430227734, 3100823752), l(506948616, 1363258195), l(659060556, 3750685593), l(883997877, 3785050280), l(958139571, 3318307427), l(1322822218, 3812723403), l(1537002063, 2003034995), l(1747873779, 3602036899), l(1955562222, 1575990012), l(2024104815, 1125592928), l(2227730452, 2716904306), l(2361852424, 442776044), l(2428436474, 593698344), l(2756734187, 3733110249), l(3204031479, 2999351573), l(3329325298, 3815920427), l(3391569614, 3928383900), l(3515267271, 566280711), l(3940187606, 3454069534), l(4118630271, 4000239992), l(116418474, 1914138554), l(174292421, 2731055270), l(289380356, 3203993006), l(460393269, 320620315), l(685471733, 587496836), l(852142971, 1086792851), l(1017036298, 365543100), l(1126000580, 2618297676), l(1288033470, 3409855158), l(1501505948, 4234509866), l(1607167915, 987167468), l(1816402316, 1246189591)], m = [];
        (function() {
          for (var b = 0; b < 80; b++) m[b] = l();
        })();
        var v = c.SHA512 = i.extend({ _doReset: function() {
          this._hash = new f.init([new o.init(1779033703, 4089235720), new o.init(3144134277, 2227873595), new o.init(1013904242, 4271175723), new o.init(2773480762, 1595750129), new o.init(1359893119, 2917565137), new o.init(2600822924, 725511199), new o.init(528734635, 4215389547), new o.init(1541459225, 327033209)]);
        }, _doProcessBlock: function(b, A) {
          for (var _ = this._hash.words, C = _[0], I = _[1], S = _[2], $ = _[3], F = _[4], U = _[5], Q = _[6], P = _[7], N = C.high, L = C.low, B = I.high, u = I.low, p = S.high, d = S.low, y = $.high, w = $.low, E = F.high, M = F.low, x = U.high, g = U.low, k = Q.high, T = Q.low, O = P.high, K = P.low, Y = N, J = L, G = B, X = u, ie = p, de = d, se = y, te = w, le = E, Z = M, ve = x, he = g, me = k, ce = T, ye = O, Oe = K, Se = 0; Se < 80; Se++) {
            var Ce, Ne, $e = m[Se];
            if (Se < 16) Ne = $e.high = b[A + Se * 2] | 0, Ce = $e.low = b[A + Se * 2 + 1] | 0;
            else {
              var Re = m[Se - 15], Ge = Re.high, Fe = Re.low, Ue = (Ge >>> 1 | Fe << 31) ^ (Ge >>> 8 | Fe << 24) ^ Ge >>> 7, kt = (Fe >>> 1 | Ge << 31) ^ (Fe >>> 8 | Ge << 24) ^ (Fe >>> 7 | Ge << 25), pe = m[Se - 2], re = pe.high, ue = pe.low, xe = (re >>> 19 | ue << 13) ^ (re << 3 | ue >>> 29) ^ re >>> 6, Me = (ue >>> 19 | re << 13) ^ (ue << 3 | re >>> 29) ^ (ue >>> 6 | re << 26), We = m[Se - 7], De = We.high, je = We.low, ir = m[Se - 16], Xe = ir.high, st = ir.low;
              Ce = kt + je, Ne = Ue + De + (Ce >>> 0 < kt >>> 0 ? 1 : 0), Ce = Ce + Me, Ne = Ne + xe + (Ce >>> 0 < Me >>> 0 ? 1 : 0), Ce = Ce + st, Ne = Ne + Xe + (Ce >>> 0 < st >>> 0 ? 1 : 0), $e.high = Ne, $e.low = Ce;
            }
            var Vt = le & ve ^ ~le & me, at = Z & he ^ ~Z & ce, ht = Y & G ^ Y & ie ^ G & ie, br = J & X ^ J & de ^ X & de, ot = (Y >>> 28 | J << 4) ^ (Y << 30 | J >>> 2) ^ (Y << 25 | J >>> 7), ct = (J >>> 28 | Y << 4) ^ (J << 30 | Y >>> 2) ^ (J << 25 | Y >>> 7), _r = (le >>> 14 | Z << 18) ^ (le >>> 18 | Z << 14) ^ (le << 23 | Z >>> 9), ft = (Z >>> 14 | le << 18) ^ (Z >>> 18 | le << 14) ^ (Z << 23 | le >>> 9), pt = h[Se], Cr = pt.high, nt = pt.low, lt = Oe + ft, ge = ye + _r + (lt >>> 0 < Oe >>> 0 ? 1 : 0), lt = lt + at, ge = ge + Vt + (lt >>> 0 < at >>> 0 ? 1 : 0), lt = lt + nt, ge = ge + Cr + (lt >>> 0 < nt >>> 0 ? 1 : 0), lt = lt + Ce, ge = ge + Ne + (lt >>> 0 < Ce >>> 0 ? 1 : 0), be = ct + br, Ae = ot + ht + (be >>> 0 < ct >>> 0 ? 1 : 0);
            ye = me, Oe = ce, me = ve, ce = he, ve = le, he = Z, Z = te + lt | 0, le = se + ge + (Z >>> 0 < te >>> 0 ? 1 : 0) | 0, se = ie, te = de, ie = G, de = X, G = Y, X = J, J = lt + be | 0, Y = ge + Ae + (J >>> 0 < lt >>> 0 ? 1 : 0) | 0;
          }
          L = C.low = L + J, C.high = N + Y + (L >>> 0 < J >>> 0 ? 1 : 0), u = I.low = u + X, I.high = B + G + (u >>> 0 < X >>> 0 ? 1 : 0), d = S.low = d + de, S.high = p + ie + (d >>> 0 < de >>> 0 ? 1 : 0), w = $.low = w + te, $.high = y + se + (w >>> 0 < te >>> 0 ? 1 : 0), M = F.low = M + Z, F.high = E + le + (M >>> 0 < Z >>> 0 ? 1 : 0), g = U.low = g + he, U.high = x + ve + (g >>> 0 < he >>> 0 ? 1 : 0), T = Q.low = T + ce, Q.high = k + me + (T >>> 0 < ce >>> 0 ? 1 : 0), K = P.low = K + Oe, P.high = O + ye + (K >>> 0 < Oe >>> 0 ? 1 : 0);
        }, _doFinalize: function() {
          var b = this._data, A = b.words, _ = this._nDataBytes * 8, C = b.sigBytes * 8;
          A[C >>> 5] |= 128 << 24 - C % 32, A[(C + 128 >>> 10 << 5) + 30] = Math.floor(_ / 4294967296), A[(C + 128 >>> 10 << 5) + 31] = _, b.sigBytes = A.length * 4, this._process();
          var I = this._hash.toX32();
          return I;
        }, clone: function() {
          var b = i.clone.call(this);
          return b._hash = this._hash.clone(), b;
        }, blockSize: 1024 / 32 });
        r.SHA512 = i._createHelper(v), r.HmacSHA512 = i._createHmacHelper(v);
      }(), n.SHA512;
    });
  }(Mv)), Mv.exports;
}
var $v = { exports: {} }, x_;
function aie() {
  return x_ || (x_ = 1, function(t3, e) {
    (function(n, r, s) {
      t3.exports = r(Lr, pm(), eD());
    })(mt, function(n) {
      return function() {
        var r = n, s = r.x64, i = s.Word, a = s.WordArray, o = r.algo, f = o.SHA512, c = o.SHA384 = f.extend({ _doReset: function() {
          this._hash = new a.init([new i.init(3418070365, 3238371032), new i.init(1654270250, 914150663), new i.init(2438529370, 812702999), new i.init(355462360, 4144912697), new i.init(1731405415, 4290775857), new i.init(2394180231, 1750603025), new i.init(3675008525, 1694076839), new i.init(1203062813, 3204075428)]);
        }, _doFinalize: function() {
          var l = f._doFinalize.call(this);
          return l.sigBytes -= 16, l;
        } });
        r.SHA384 = f._createHelper(c), r.HmacSHA384 = f._createHmacHelper(c);
      }(), n.SHA384;
    });
  }($v)), $v.exports;
}
var Tv = { exports: {} }, __;
function oie() {
  return __ || (__ = 1, function(t3, e) {
    (function(n, r, s) {
      t3.exports = r(Lr, pm());
    })(mt, function(n) {
      return function(r) {
        var s = n, i = s.lib, a = i.WordArray, o = i.Hasher, f = s.x64, c = f.Word, l = s.algo, h = [], m = [], v = [];
        (function() {
          for (var _ = 1, C = 0, I = 0; I < 24; I++) {
            h[_ + 5 * C] = (I + 1) * (I + 2) / 2 % 64;
            var S = C % 5, $ = (2 * _ + 3 * C) % 5;
            _ = S, C = $;
          }
          for (var _ = 0; _ < 5; _++) for (var C = 0; C < 5; C++) m[_ + 5 * C] = C + (2 * _ + 3 * C) % 5 * 5;
          for (var F = 1, U = 0; U < 24; U++) {
            for (var Q = 0, P = 0, N = 0; N < 7; N++) {
              if (F & 1) {
                var L = (1 << N) - 1;
                L < 32 ? P ^= 1 << L : Q ^= 1 << L - 32;
              }
              F & 128 ? F = F << 1 ^ 113 : F <<= 1;
            }
            v[U] = c.create(Q, P);
          }
        })();
        var b = [];
        (function() {
          for (var _ = 0; _ < 25; _++) b[_] = c.create();
        })();
        var A = l.SHA3 = o.extend({ cfg: o.cfg.extend({ outputLength: 512 }), _doReset: function() {
          for (var _ = this._state = [], C = 0; C < 25; C++) _[C] = new c.init();
          this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
        }, _doProcessBlock: function(_, C) {
          for (var I = this._state, S = this.blockSize / 2, $ = 0; $ < S; $++) {
            var F = _[C + 2 * $], U = _[C + 2 * $ + 1];
            F = (F << 8 | F >>> 24) & 16711935 | (F << 24 | F >>> 8) & 4278255360, U = (U << 8 | U >>> 24) & 16711935 | (U << 24 | U >>> 8) & 4278255360;
            var Q = I[$];
            Q.high ^= U, Q.low ^= F;
          }
          for (var P = 0; P < 24; P++) {
            for (var N = 0; N < 5; N++) {
              for (var L = 0, B = 0, u = 0; u < 5; u++) {
                var Q = I[N + 5 * u];
                L ^= Q.high, B ^= Q.low;
              }
              var p = b[N];
              p.high = L, p.low = B;
            }
            for (var N = 0; N < 5; N++) for (var d = b[(N + 4) % 5], y = b[(N + 1) % 5], w = y.high, E = y.low, L = d.high ^ (w << 1 | E >>> 31), B = d.low ^ (E << 1 | w >>> 31), u = 0; u < 5; u++) {
              var Q = I[N + 5 * u];
              Q.high ^= L, Q.low ^= B;
            }
            for (var M = 1; M < 25; M++) {
              var L, B, Q = I[M], x = Q.high, g = Q.low, k = h[M];
              k < 32 ? (L = x << k | g >>> 32 - k, B = g << k | x >>> 32 - k) : (L = g << k - 32 | x >>> 64 - k, B = x << k - 32 | g >>> 64 - k);
              var T = b[m[M]];
              T.high = L, T.low = B;
            }
            var O = b[0], K = I[0];
            O.high = K.high, O.low = K.low;
            for (var N = 0; N < 5; N++) for (var u = 0; u < 5; u++) {
              var M = N + 5 * u, Q = I[M], Y = b[M], J = b[(N + 1) % 5 + 5 * u], G = b[(N + 2) % 5 + 5 * u];
              Q.high = Y.high ^ ~J.high & G.high, Q.low = Y.low ^ ~J.low & G.low;
            }
            var Q = I[0], X = v[P];
            Q.high ^= X.high, Q.low ^= X.low;
          }
        }, _doFinalize: function() {
          var _ = this._data, C = _.words;
          this._nDataBytes * 8;
          var I = _.sigBytes * 8, S = this.blockSize * 32;
          C[I >>> 5] |= 1 << 24 - I % 32, C[(r.ceil((I + 1) / S) * S >>> 5) - 1] |= 128, _.sigBytes = C.length * 4, this._process();
          for (var $ = this._state, F = this.cfg.outputLength / 8, U = F / 8, Q = [], P = 0; P < U; P++) {
            var N = $[P], L = N.high, B = N.low;
            L = (L << 8 | L >>> 24) & 16711935 | (L << 24 | L >>> 8) & 4278255360, B = (B << 8 | B >>> 24) & 16711935 | (B << 24 | B >>> 8) & 4278255360, Q.push(B), Q.push(L);
          }
          return new a.init(Q, F);
        }, clone: function() {
          for (var _ = o.clone.call(this), C = _._state = this._state.slice(0), I = 0; I < 25; I++) C[I] = C[I].clone();
          return _;
        } });
        s.SHA3 = o._createHelper(A), s.HmacSHA3 = o._createHmacHelper(A);
      }(Math), n.SHA3;
    });
  }(Tv)), Tv.exports;
}
var Dv = { exports: {} }, E_;
function fie() {
  return E_ || (E_ = 1, function(t3, e) {
    (function(n, r) {
      t3.exports = r(Lr);
    })(mt, function(n) {
      /** @preserve
      			(c) 2012 by Cdric Mesnil. All rights reserved.
      
      			Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
      
      			    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
      			    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
      
      			THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
      			*/
      return function(r) {
        var s = n, i = s.lib, a = i.WordArray, o = i.Hasher, f = s.algo, c = a.create([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]), l = a.create([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]), h = a.create([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]), m = a.create([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]), v = a.create([0, 1518500249, 1859775393, 2400959708, 2840853838]), b = a.create([1352829926, 1548603684, 1836072691, 2053994217, 0]), A = f.RIPEMD160 = o.extend({ _doReset: function() {
          this._hash = a.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
        }, _doProcessBlock: function(U, Q) {
          for (var P = 0; P < 16; P++) {
            var N = Q + P, L = U[N];
            U[N] = (L << 8 | L >>> 24) & 16711935 | (L << 24 | L >>> 8) & 4278255360;
          }
          var B = this._hash.words, u = v.words, p = b.words, d = c.words, y = l.words, w = h.words, E = m.words, M, x, g, k, T, O, K, Y, J, G;
          O = M = B[0], K = x = B[1], Y = g = B[2], J = k = B[3], G = T = B[4];
          for (var X, P = 0; P < 80; P += 1) X = M + U[Q + d[P]] | 0, P < 16 ? X += _(x, g, k) + u[0] : P < 32 ? X += C(x, g, k) + u[1] : P < 48 ? X += I(x, g, k) + u[2] : P < 64 ? X += S(x, g, k) + u[3] : X += $(x, g, k) + u[4], X = X | 0, X = F(X, w[P]), X = X + T | 0, M = T, T = k, k = F(g, 10), g = x, x = X, X = O + U[Q + y[P]] | 0, P < 16 ? X += $(K, Y, J) + p[0] : P < 32 ? X += S(K, Y, J) + p[1] : P < 48 ? X += I(K, Y, J) + p[2] : P < 64 ? X += C(K, Y, J) + p[3] : X += _(K, Y, J) + p[4], X = X | 0, X = F(X, E[P]), X = X + G | 0, O = G, G = J, J = F(Y, 10), Y = K, K = X;
          X = B[1] + g + J | 0, B[1] = B[2] + k + G | 0, B[2] = B[3] + T + O | 0, B[3] = B[4] + M + K | 0, B[4] = B[0] + x + Y | 0, B[0] = X;
        }, _doFinalize: function() {
          var U = this._data, Q = U.words, P = this._nDataBytes * 8, N = U.sigBytes * 8;
          Q[N >>> 5] |= 128 << 24 - N % 32, Q[(N + 64 >>> 9 << 4) + 14] = (P << 8 | P >>> 24) & 16711935 | (P << 24 | P >>> 8) & 4278255360, U.sigBytes = (Q.length + 1) * 4, this._process();
          for (var L = this._hash, B = L.words, u = 0; u < 5; u++) {
            var p = B[u];
            B[u] = (p << 8 | p >>> 24) & 16711935 | (p << 24 | p >>> 8) & 4278255360;
          }
          return L;
        }, clone: function() {
          var U = o.clone.call(this);
          return U._hash = this._hash.clone(), U;
        } });
        function _(U, Q, P) {
          return U ^ Q ^ P;
        }
        function C(U, Q, P) {
          return U & Q | ~U & P;
        }
        function I(U, Q, P) {
          return (U | ~Q) ^ P;
        }
        function S(U, Q, P) {
          return U & P | Q & ~P;
        }
        function $(U, Q, P) {
          return U ^ (Q | ~P);
        }
        function F(U, Q) {
          return U << Q | U >>> 32 - Q;
        }
        s.RIPEMD160 = o._createHelper(A), s.HmacRIPEMD160 = o._createHmacHelper(A);
      }(), n.RIPEMD160;
    });
  }(Dv)), Dv.exports;
}
var Rv = { exports: {} }, B_;
function mm() {
  return B_ || (B_ = 1, function(t3, e) {
    (function(n, r) {
      t3.exports = r(Lr);
    })(mt, function(n) {
      (function() {
        var r = n, s = r.lib, i = s.Base, a = r.enc, o = a.Utf8, f = r.algo;
        f.HMAC = i.extend({ init: function(c, l) {
          c = this._hasher = new c.init(), typeof l == "string" && (l = o.parse(l));
          var h = c.blockSize, m = h * 4;
          l.sigBytes > m && (l = c.finalize(l)), l.clamp();
          for (var v = this._oKey = l.clone(), b = this._iKey = l.clone(), A = v.words, _ = b.words, C = 0; C < h; C++) A[C] ^= 1549556828, _[C] ^= 909522486;
          v.sigBytes = b.sigBytes = m, this.reset();
        }, reset: function() {
          var c = this._hasher;
          c.reset(), c.update(this._iKey);
        }, update: function(c) {
          return this._hasher.update(c), this;
        }, finalize: function(c) {
          var l = this._hasher, h = l.finalize(c);
          l.reset();
          var m = l.finalize(this._oKey.clone().concat(h));
          return m;
        } });
      })();
    });
  }(Rv)), Rv.exports;
}
var Fv = { exports: {} }, C_;
function lie() {
  return C_ || (C_ = 1, function(t3, e) {
    (function(n, r, s) {
      t3.exports = r(Lr, gm(), mm());
    })(mt, function(n) {
      return function() {
        var r = n, s = r.lib, i = s.Base, a = s.WordArray, o = r.algo, f = o.SHA256, c = o.HMAC, l = o.PBKDF2 = i.extend({ cfg: i.extend({ keySize: 128 / 32, hasher: f, iterations: 25e4 }), init: function(h) {
          this.cfg = this.cfg.extend(h);
        }, compute: function(h, m) {
          for (var v = this.cfg, b = c.create(v.hasher, h), A = a.create(), _ = a.create([1]), C = A.words, I = _.words, S = v.keySize, $ = v.iterations; C.length < S; ) {
            var F = b.update(m).finalize(_);
            b.reset();
            for (var U = F.words, Q = U.length, P = F, N = 1; N < $; N++) {
              P = b.finalize(P), b.reset();
              for (var L = P.words, B = 0; B < Q; B++) U[B] ^= L[B];
            }
            A.concat(F), I[0]++;
          }
          return A.sigBytes = S * 4, A;
        } });
        r.PBKDF2 = function(h, m, v) {
          return l.create(v).compute(h, m);
        };
      }(), n.PBKDF2;
    });
  }(Fv)), Fv.exports;
}
var Pv = { exports: {} }, k_;
function bl() {
  return k_ || (k_ = 1, function(t3, e) {
    (function(n, r, s) {
      t3.exports = r(Lr, XT(), mm());
    })(mt, function(n) {
      return function() {
        var r = n, s = r.lib, i = s.Base, a = s.WordArray, o = r.algo, f = o.MD5, c = o.EvpKDF = i.extend({ cfg: i.extend({ keySize: 128 / 32, hasher: f, iterations: 1 }), init: function(l) {
          this.cfg = this.cfg.extend(l);
        }, compute: function(l, h) {
          for (var m, v = this.cfg, b = v.hasher.create(), A = a.create(), _ = A.words, C = v.keySize, I = v.iterations; _.length < C; ) {
            m && b.update(m), m = b.update(l).finalize(h), b.reset();
            for (var S = 1; S < I; S++) m = b.finalize(m), b.reset();
            A.concat(m);
          }
          return A.sigBytes = C * 4, A;
        } });
        r.EvpKDF = function(l, h, m) {
          return c.create(m).compute(l, h);
        };
      }(), n.EvpKDF;
    });
  }(Pv)), Pv.exports;
}
var Nv = { exports: {} }, I_;
function Ii() {
  return I_ || (I_ = 1, function(t3, e) {
    (function(n, r, s) {
      t3.exports = r(Lr, bl());
    })(mt, function(n) {
      n.lib.Cipher || function(r) {
        var s = n, i = s.lib, a = i.Base, o = i.WordArray, f = i.BufferedBlockAlgorithm, c = s.enc;
        c.Utf8;
        var l = c.Base64, h = s.algo, m = h.EvpKDF, v = i.Cipher = f.extend({ cfg: a.extend(), createEncryptor: function(L, B) {
          return this.create(this._ENC_XFORM_MODE, L, B);
        }, createDecryptor: function(L, B) {
          return this.create(this._DEC_XFORM_MODE, L, B);
        }, init: function(L, B, u) {
          this.cfg = this.cfg.extend(u), this._xformMode = L, this._key = B, this.reset();
        }, reset: function() {
          f.reset.call(this), this._doReset();
        }, process: function(L) {
          return this._append(L), this._process();
        }, finalize: function(L) {
          L && this._append(L);
          var B = this._doFinalize();
          return B;
        }, keySize: 128 / 32, ivSize: 128 / 32, _ENC_XFORM_MODE: 1, _DEC_XFORM_MODE: 2, _createHelper: /* @__PURE__ */ function() {
          function L(B) {
            return typeof B == "string" ? N : U;
          }
          return function(B) {
            return { encrypt: function(u, p, d) {
              return L(p).encrypt(B, u, p, d);
            }, decrypt: function(u, p, d) {
              return L(p).decrypt(B, u, p, d);
            } };
          };
        }() });
        i.StreamCipher = v.extend({ _doFinalize: function() {
          var L = this._process(true);
          return L;
        }, blockSize: 1 });
        var b = s.mode = {}, A = i.BlockCipherMode = a.extend({ createEncryptor: function(L, B) {
          return this.Encryptor.create(L, B);
        }, createDecryptor: function(L, B) {
          return this.Decryptor.create(L, B);
        }, init: function(L, B) {
          this._cipher = L, this._iv = B;
        } }), _ = b.CBC = function() {
          var L = A.extend();
          L.Encryptor = L.extend({ processBlock: function(u, p) {
            var d = this._cipher, y = d.blockSize;
            B.call(this, u, p, y), d.encryptBlock(u, p), this._prevBlock = u.slice(p, p + y);
          } }), L.Decryptor = L.extend({ processBlock: function(u, p) {
            var d = this._cipher, y = d.blockSize, w = u.slice(p, p + y);
            d.decryptBlock(u, p), B.call(this, u, p, y), this._prevBlock = w;
          } });
          function B(u, p, d) {
            var y, w = this._iv;
            w ? (y = w, this._iv = r) : y = this._prevBlock;
            for (var E = 0; E < d; E++) u[p + E] ^= y[E];
          }
          return L;
        }(), C = s.pad = {}, I = C.Pkcs7 = { pad: function(L, B) {
          for (var u = B * 4, p = u - L.sigBytes % u, d = p << 24 | p << 16 | p << 8 | p, y = [], w = 0; w < p; w += 4) y.push(d);
          var E = o.create(y, p);
          L.concat(E);
        }, unpad: function(L) {
          var B = L.words[L.sigBytes - 1 >>> 2] & 255;
          L.sigBytes -= B;
        } };
        i.BlockCipher = v.extend({ cfg: v.cfg.extend({ mode: _, padding: I }), reset: function() {
          var L;
          v.reset.call(this);
          var B = this.cfg, u = B.iv, p = B.mode;
          this._xformMode == this._ENC_XFORM_MODE ? L = p.createEncryptor : (L = p.createDecryptor, this._minBufferSize = 1), this._mode && this._mode.__creator == L ? this._mode.init(this, u && u.words) : (this._mode = L.call(p, this, u && u.words), this._mode.__creator = L);
        }, _doProcessBlock: function(L, B) {
          this._mode.processBlock(L, B);
        }, _doFinalize: function() {
          var L, B = this.cfg.padding;
          return this._xformMode == this._ENC_XFORM_MODE ? (B.pad(this._data, this.blockSize), L = this._process(true)) : (L = this._process(true), B.unpad(L)), L;
        }, blockSize: 128 / 32 });
        var S = i.CipherParams = a.extend({ init: function(L) {
          this.mixIn(L);
        }, toString: function(L) {
          return (L || this.formatter).stringify(this);
        } }), $ = s.format = {}, F = $.OpenSSL = { stringify: function(L) {
          var B, u = L.ciphertext, p = L.salt;
          return p ? B = o.create([1398893684, 1701076831]).concat(p).concat(u) : B = u, B.toString(l);
        }, parse: function(L) {
          var B, u = l.parse(L), p = u.words;
          return p[0] == 1398893684 && p[1] == 1701076831 && (B = o.create(p.slice(2, 4)), p.splice(0, 4), u.sigBytes -= 16), S.create({ ciphertext: u, salt: B });
        } }, U = i.SerializableCipher = a.extend({ cfg: a.extend({ format: F }), encrypt: function(L, B, u, p) {
          p = this.cfg.extend(p);
          var d = L.createEncryptor(u, p), y = d.finalize(B), w = d.cfg;
          return S.create({ ciphertext: y, key: u, iv: w.iv, algorithm: L, mode: w.mode, padding: w.padding, blockSize: L.blockSize, formatter: p.format });
        }, decrypt: function(L, B, u, p) {
          p = this.cfg.extend(p), B = this._parse(B, p.format);
          var d = L.createDecryptor(u, p).finalize(B.ciphertext);
          return d;
        }, _parse: function(L, B) {
          return typeof L == "string" ? B.parse(L, this) : L;
        } }), Q = s.kdf = {}, P = Q.OpenSSL = { execute: function(L, B, u, p, d) {
          if (p || (p = o.random(64 / 8)), d) var y = m.create({ keySize: B + u, hasher: d }).compute(L, p);
          else var y = m.create({ keySize: B + u }).compute(L, p);
          var w = o.create(y.words.slice(B), u * 4);
          return y.sigBytes = B * 4, S.create({ key: y, iv: w, salt: p });
        } }, N = i.PasswordBasedCipher = U.extend({ cfg: U.cfg.extend({ kdf: P }), encrypt: function(L, B, u, p) {
          p = this.cfg.extend(p);
          var d = p.kdf.execute(u, L.keySize, L.ivSize, p.salt, p.hasher);
          p.iv = d.iv;
          var y = U.encrypt.call(this, L, B, d.key, p);
          return y.mixIn(d), y;
        }, decrypt: function(L, B, u, p) {
          p = this.cfg.extend(p), B = this._parse(B, p.format);
          var d = p.kdf.execute(u, L.keySize, L.ivSize, B.salt, p.hasher);
          p.iv = d.iv;
          var y = U.decrypt.call(this, L, B, d.key, p);
          return y;
        } });
      }();
    });
  }(Nv)), Nv.exports;
}
var Uv = { exports: {} }, S_;
function uie() {
  return S_ || (S_ = 1, function(t3, e) {
    (function(n, r, s) {
      t3.exports = r(Lr, Ii());
    })(mt, function(n) {
      return n.mode.CFB = function() {
        var r = n.lib.BlockCipherMode.extend();
        r.Encryptor = r.extend({ processBlock: function(i, a) {
          var o = this._cipher, f = o.blockSize;
          s.call(this, i, a, f, o), this._prevBlock = i.slice(a, a + f);
        } }), r.Decryptor = r.extend({ processBlock: function(i, a) {
          var o = this._cipher, f = o.blockSize, c = i.slice(a, a + f);
          s.call(this, i, a, f, o), this._prevBlock = c;
        } });
        function s(i, a, o, f) {
          var c, l = this._iv;
          l ? (c = l.slice(0), this._iv = void 0) : c = this._prevBlock, f.encryptBlock(c, 0);
          for (var h = 0; h < o; h++) i[a + h] ^= c[h];
        }
        return r;
      }(), n.mode.CFB;
    });
  }(Uv)), Uv.exports;
}
var Lv = { exports: {} }, M_;
function cie() {
  return M_ || (M_ = 1, function(t3, e) {
    (function(n, r, s) {
      t3.exports = r(Lr, Ii());
    })(mt, function(n) {
      return n.mode.CTR = function() {
        var r = n.lib.BlockCipherMode.extend(), s = r.Encryptor = r.extend({ processBlock: function(i, a) {
          var o = this._cipher, f = o.blockSize, c = this._iv, l = this._counter;
          c && (l = this._counter = c.slice(0), this._iv = void 0);
          var h = l.slice(0);
          o.encryptBlock(h, 0), l[f - 1] = l[f - 1] + 1 | 0;
          for (var m = 0; m < f; m++) i[a + m] ^= h[m];
        } });
        return r.Decryptor = s, r;
      }(), n.mode.CTR;
    });
  }(Lv)), Lv.exports;
}
var Ov = { exports: {} }, $_;
function hie() {
  return $_ || ($_ = 1, function(t3, e) {
    (function(n, r, s) {
      t3.exports = r(Lr, Ii());
    })(mt, function(n) {
      /** @preserve
      * Counter block mode compatible with  Dr Brian Gladman fileenc.c
      * derived from CryptoJS.mode.CTR
      * Jan Hruby jhruby.web@gmail.com
      */
      return n.mode.CTRGladman = function() {
        var r = n.lib.BlockCipherMode.extend();
        function s(o) {
          if ((o >> 24 & 255) === 255) {
            var f = o >> 16 & 255, c = o >> 8 & 255, l = o & 255;
            f === 255 ? (f = 0, c === 255 ? (c = 0, l === 255 ? l = 0 : ++l) : ++c) : ++f, o = 0, o += f << 16, o += c << 8, o += l;
          } else o += 1 << 24;
          return o;
        }
        function i(o) {
          return (o[0] = s(o[0])) === 0 && (o[1] = s(o[1])), o;
        }
        var a = r.Encryptor = r.extend({ processBlock: function(o, f) {
          var c = this._cipher, l = c.blockSize, h = this._iv, m = this._counter;
          h && (m = this._counter = h.slice(0), this._iv = void 0), i(m);
          var v = m.slice(0);
          c.encryptBlock(v, 0);
          for (var b = 0; b < l; b++) o[f + b] ^= v[b];
        } });
        return r.Decryptor = a, r;
      }(), n.mode.CTRGladman;
    });
  }(Ov)), Ov.exports;
}
var Qv = { exports: {} }, T_;
function die() {
  return T_ || (T_ = 1, function(t3, e) {
    (function(n, r, s) {
      t3.exports = r(Lr, Ii());
    })(mt, function(n) {
      return n.mode.OFB = function() {
        var r = n.lib.BlockCipherMode.extend(), s = r.Encryptor = r.extend({ processBlock: function(i, a) {
          var o = this._cipher, f = o.blockSize, c = this._iv, l = this._keystream;
          c && (l = this._keystream = c.slice(0), this._iv = void 0), o.encryptBlock(l, 0);
          for (var h = 0; h < f; h++) i[a + h] ^= l[h];
        } });
        return r.Decryptor = s, r;
      }(), n.mode.OFB;
    });
  }(Qv)), Qv.exports;
}
var Kv = { exports: {} }, D_;
function pie() {
  return D_ || (D_ = 1, function(t3, e) {
    (function(n, r, s) {
      t3.exports = r(Lr, Ii());
    })(mt, function(n) {
      return n.mode.ECB = function() {
        var r = n.lib.BlockCipherMode.extend();
        return r.Encryptor = r.extend({ processBlock: function(s, i) {
          this._cipher.encryptBlock(s, i);
        } }), r.Decryptor = r.extend({ processBlock: function(s, i) {
          this._cipher.decryptBlock(s, i);
        } }), r;
      }(), n.mode.ECB;
    });
  }(Kv)), Kv.exports;
}
var Hv = { exports: {} }, R_;
function gie() {
  return R_ || (R_ = 1, function(t3, e) {
    (function(n, r, s) {
      t3.exports = r(Lr, Ii());
    })(mt, function(n) {
      return n.pad.AnsiX923 = { pad: function(r, s) {
        var i = r.sigBytes, a = s * 4, o = a - i % a, f = i + o - 1;
        r.clamp(), r.words[f >>> 2] |= o << 24 - f % 4 * 8, r.sigBytes += o;
      }, unpad: function(r) {
        var s = r.words[r.sigBytes - 1 >>> 2] & 255;
        r.sigBytes -= s;
      } }, n.pad.Ansix923;
    });
  }(Hv)), Hv.exports;
}
var qv = { exports: {} }, F_;
function mie() {
  return F_ || (F_ = 1, function(t3, e) {
    (function(n, r, s) {
      t3.exports = r(Lr, Ii());
    })(mt, function(n) {
      return n.pad.Iso10126 = { pad: function(r, s) {
        var i = s * 4, a = i - r.sigBytes % i;
        r.concat(n.lib.WordArray.random(a - 1)).concat(n.lib.WordArray.create([a << 24], 1));
      }, unpad: function(r) {
        var s = r.words[r.sigBytes - 1 >>> 2] & 255;
        r.sigBytes -= s;
      } }, n.pad.Iso10126;
    });
  }(qv)), qv.exports;
}
var zv = { exports: {} }, P_;
function vie() {
  return P_ || (P_ = 1, function(t3, e) {
    (function(n, r, s) {
      t3.exports = r(Lr, Ii());
    })(mt, function(n) {
      return n.pad.Iso97971 = { pad: function(r, s) {
        r.concat(n.lib.WordArray.create([2147483648], 1)), n.pad.ZeroPadding.pad(r, s);
      }, unpad: function(r) {
        n.pad.ZeroPadding.unpad(r), r.sigBytes--;
      } }, n.pad.Iso97971;
    });
  }(zv)), zv.exports;
}
var Gv = { exports: {} }, N_;
function yie() {
  return N_ || (N_ = 1, function(t3, e) {
    (function(n, r, s) {
      t3.exports = r(Lr, Ii());
    })(mt, function(n) {
      return n.pad.ZeroPadding = { pad: function(r, s) {
        var i = s * 4;
        r.clamp(), r.sigBytes += i - (r.sigBytes % i || i);
      }, unpad: function(r) {
        for (var s = r.words, i = r.sigBytes - 1, i = r.sigBytes - 1; i >= 0; i--) if (s[i >>> 2] >>> 24 - i % 4 * 8 & 255) {
          r.sigBytes = i + 1;
          break;
        }
      } }, n.pad.ZeroPadding;
    });
  }(Gv)), Gv.exports;
}
var Vv = { exports: {} }, U_;
function bie() {
  return U_ || (U_ = 1, function(t3, e) {
    (function(n, r, s) {
      t3.exports = r(Lr, Ii());
    })(mt, function(n) {
      return n.pad.NoPadding = { pad: function() {
      }, unpad: function() {
      } }, n.pad.NoPadding;
    });
  }(Vv)), Vv.exports;
}
var Yv = { exports: {} }, L_;
function Aie() {
  return L_ || (L_ = 1, function(t3, e) {
    (function(n, r, s) {
      t3.exports = r(Lr, Ii());
    })(mt, function(n) {
      return function(r) {
        var s = n, i = s.lib, a = i.CipherParams, o = s.enc, f = o.Hex, c = s.format;
        c.Hex = { stringify: function(l) {
          return l.ciphertext.toString(f);
        }, parse: function(l) {
          var h = f.parse(l);
          return a.create({ ciphertext: h });
        } };
      }(), n.format.Hex;
    });
  }(Yv)), Yv.exports;
}
var tD = { exports: {} };
(function(t3, e) {
  (function(n, r, s) {
    t3.exports = r(Lr, yl, _0(), bl(), Ii());
  })(mt, function(n) {
    return function() {
      var r = n, s = r.lib, i = s.BlockCipher, a = r.algo, o = [], f = [], c = [], l = [], h = [], m = [], v = [], b = [], A = [], _ = [];
      (function() {
        for (var S = [], $ = 0; $ < 256; $++) $ < 128 ? S[$] = $ << 1 : S[$] = $ << 1 ^ 283;
        for (var F = 0, U = 0, $ = 0; $ < 256; $++) {
          var Q = U ^ U << 1 ^ U << 2 ^ U << 3 ^ U << 4;
          Q = Q >>> 8 ^ Q & 255 ^ 99, o[F] = Q, f[Q] = F;
          var P = S[F], N = S[P], L = S[N], B = S[Q] * 257 ^ Q * 16843008;
          c[F] = B << 24 | B >>> 8, l[F] = B << 16 | B >>> 16, h[F] = B << 8 | B >>> 24, m[F] = B;
          var B = L * 16843009 ^ N * 65537 ^ P * 257 ^ F * 16843008;
          v[Q] = B << 24 | B >>> 8, b[Q] = B << 16 | B >>> 16, A[Q] = B << 8 | B >>> 24, _[Q] = B, F ? (F = P ^ S[S[S[L ^ P]]], U ^= S[S[U]]) : F = U = 1;
        }
      })();
      var C = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], I = a.AES = i.extend({ _doReset: function() {
        var S;
        if (!(this._nRounds && this._keyPriorReset === this._key)) {
          for (var $ = this._keyPriorReset = this._key, F = $.words, U = $.sigBytes / 4, Q = this._nRounds = U + 6, P = (Q + 1) * 4, N = this._keySchedule = [], L = 0; L < P; L++) L < U ? N[L] = F[L] : (S = N[L - 1], L % U ? U > 6 && L % U == 4 && (S = o[S >>> 24] << 24 | o[S >>> 16 & 255] << 16 | o[S >>> 8 & 255] << 8 | o[S & 255]) : (S = S << 8 | S >>> 24, S = o[S >>> 24] << 24 | o[S >>> 16 & 255] << 16 | o[S >>> 8 & 255] << 8 | o[S & 255], S ^= C[L / U | 0] << 24), N[L] = N[L - U] ^ S);
          for (var B = this._invKeySchedule = [], u = 0; u < P; u++) {
            var L = P - u;
            if (u % 4) var S = N[L];
            else var S = N[L - 4];
            u < 4 || L <= 4 ? B[u] = S : B[u] = v[o[S >>> 24]] ^ b[o[S >>> 16 & 255]] ^ A[o[S >>> 8 & 255]] ^ _[o[S & 255]];
          }
        }
      }, encryptBlock: function(S, $) {
        this._doCryptBlock(S, $, this._keySchedule, c, l, h, m, o);
      }, decryptBlock: function(S, $) {
        var F = S[$ + 1];
        S[$ + 1] = S[$ + 3], S[$ + 3] = F, this._doCryptBlock(S, $, this._invKeySchedule, v, b, A, _, f);
        var F = S[$ + 1];
        S[$ + 1] = S[$ + 3], S[$ + 3] = F;
      }, _doCryptBlock: function(S, $, F, U, Q, P, N, L) {
        for (var B = this._nRounds, u = S[$] ^ F[0], p = S[$ + 1] ^ F[1], d = S[$ + 2] ^ F[2], y = S[$ + 3] ^ F[3], w = 4, E = 1; E < B; E++) {
          var M = U[u >>> 24] ^ Q[p >>> 16 & 255] ^ P[d >>> 8 & 255] ^ N[y & 255] ^ F[w++], x = U[p >>> 24] ^ Q[d >>> 16 & 255] ^ P[y >>> 8 & 255] ^ N[u & 255] ^ F[w++], g = U[d >>> 24] ^ Q[y >>> 16 & 255] ^ P[u >>> 8 & 255] ^ N[p & 255] ^ F[w++], k = U[y >>> 24] ^ Q[u >>> 16 & 255] ^ P[p >>> 8 & 255] ^ N[d & 255] ^ F[w++];
          u = M, p = x, d = g, y = k;
        }
        var M = (L[u >>> 24] << 24 | L[p >>> 16 & 255] << 16 | L[d >>> 8 & 255] << 8 | L[y & 255]) ^ F[w++], x = (L[p >>> 24] << 24 | L[d >>> 16 & 255] << 16 | L[y >>> 8 & 255] << 8 | L[u & 255]) ^ F[w++], g = (L[d >>> 24] << 24 | L[y >>> 16 & 255] << 16 | L[u >>> 8 & 255] << 8 | L[p & 255]) ^ F[w++], k = (L[y >>> 24] << 24 | L[u >>> 16 & 255] << 16 | L[p >>> 8 & 255] << 8 | L[d & 255]) ^ F[w++];
        S[$] = M, S[$ + 1] = x, S[$ + 2] = g, S[$ + 3] = k;
      }, keySize: 256 / 32 });
      r.AES = i._createHelper(I);
    }(), n.AES;
  });
})(tD);
var rD = tD.exports, Wv = { exports: {} }, O_;
function wie() {
  return O_ || (O_ = 1, function(t3, e) {
    (function(n, r, s) {
      t3.exports = r(Lr, yl, _0(), bl(), Ii());
    })(mt, function(n) {
      return function() {
        var r = n, s = r.lib, i = s.WordArray, a = s.BlockCipher, o = r.algo, f = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4], c = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32], l = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28], h = [{ 0: 8421888, 268435456: 32768, 536870912: 8421378, 805306368: 2, 1073741824: 512, 1342177280: 8421890, 1610612736: 8389122, 1879048192: 8388608, 2147483648: 514, 2415919104: 8389120, 2684354560: 33280, 2952790016: 8421376, 3221225472: 32770, 3489660928: 8388610, 3758096384: 0, 4026531840: 33282, 134217728: 0, 402653184: 8421890, 671088640: 33282, 939524096: 32768, 1207959552: 8421888, 1476395008: 512, 1744830464: 8421378, 2013265920: 2, 2281701376: 8389120, 2550136832: 33280, 2818572288: 8421376, 3087007744: 8389122, 3355443200: 8388610, 3623878656: 32770, 3892314112: 514, 4160749568: 8388608, 1: 32768, 268435457: 2, 536870913: 8421888, 805306369: 8388608, 1073741825: 8421378, 1342177281: 33280, 1610612737: 512, 1879048193: 8389122, 2147483649: 8421890, 2415919105: 8421376, 2684354561: 8388610, 2952790017: 33282, 3221225473: 514, 3489660929: 8389120, 3758096385: 32770, 4026531841: 0, 134217729: 8421890, 402653185: 8421376, 671088641: 8388608, 939524097: 512, 1207959553: 32768, 1476395009: 8388610, 1744830465: 2, 2013265921: 33282, 2281701377: 32770, 2550136833: 8389122, 2818572289: 514, 3087007745: 8421888, 3355443201: 8389120, 3623878657: 0, 3892314113: 33280, 4160749569: 8421378 }, { 0: 1074282512, 16777216: 16384, 33554432: 524288, 50331648: 1074266128, 67108864: 1073741840, 83886080: 1074282496, 100663296: 1073758208, 117440512: 16, 134217728: 540672, 150994944: 1073758224, 167772160: 1073741824, 184549376: 540688, 201326592: 524304, 218103808: 0, 234881024: 16400, 251658240: 1074266112, 8388608: 1073758208, 25165824: 540688, 41943040: 16, 58720256: 1073758224, 75497472: 1074282512, 92274688: 1073741824, 109051904: 524288, 125829120: 1074266128, 142606336: 524304, 159383552: 0, 176160768: 16384, 192937984: 1074266112, 209715200: 1073741840, 226492416: 540672, 243269632: 1074282496, 260046848: 16400, 268435456: 0, 285212672: 1074266128, 301989888: 1073758224, 318767104: 1074282496, 335544320: 1074266112, 352321536: 16, 369098752: 540688, 385875968: 16384, 402653184: 16400, 419430400: 524288, 436207616: 524304, 452984832: 1073741840, 469762048: 540672, 486539264: 1073758208, 503316480: 1073741824, 520093696: 1074282512, 276824064: 540688, 293601280: 524288, 310378496: 1074266112, 327155712: 16384, 343932928: 1073758208, 360710144: 1074282512, 377487360: 16, 394264576: 1073741824, 411041792: 1074282496, 427819008: 1073741840, 444596224: 1073758224, 461373440: 524304, 478150656: 0, 494927872: 16400, 511705088: 1074266128, 528482304: 540672 }, { 0: 260, 1048576: 0, 2097152: 67109120, 3145728: 65796, 4194304: 65540, 5242880: 67108868, 6291456: 67174660, 7340032: 67174400, 8388608: 67108864, 9437184: 67174656, 10485760: 65792, 11534336: 67174404, 12582912: 67109124, 13631488: 65536, 14680064: 4, 15728640: 256, 524288: 67174656, 1572864: 67174404, 2621440: 0, 3670016: 67109120, 4718592: 67108868, 5767168: 65536, 6815744: 65540, 7864320: 260, 8912896: 4, 9961472: 256, 11010048: 67174400, 12058624: 65796, 13107200: 65792, 14155776: 67109124, 15204352: 67174660, 16252928: 67108864, 16777216: 67174656, 17825792: 65540, 18874368: 65536, 19922944: 67109120, 20971520: 256, 22020096: 67174660, 23068672: 67108868, 24117248: 0, 25165824: 67109124, 26214400: 67108864, 27262976: 4, 28311552: 65792, 29360128: 67174400, 30408704: 260, 31457280: 65796, 32505856: 67174404, 17301504: 67108864, 18350080: 260, 19398656: 67174656, 20447232: 0, 21495808: 65540, 22544384: 67109120, 23592960: 256, 24641536: 67174404, 25690112: 65536, 26738688: 67174660, 27787264: 65796, 28835840: 67108868, 29884416: 67109124, 30932992: 67174400, 31981568: 4, 33030144: 65792 }, { 0: 2151682048, 65536: 2147487808, 131072: 4198464, 196608: 2151677952, 262144: 0, 327680: 4198400, 393216: 2147483712, 458752: 4194368, 524288: 2147483648, 589824: 4194304, 655360: 64, 720896: 2147487744, 786432: 2151678016, 851968: 4160, 917504: 4096, 983040: 2151682112, 32768: 2147487808, 98304: 64, 163840: 2151678016, 229376: 2147487744, 294912: 4198400, 360448: 2151682112, 425984: 0, 491520: 2151677952, 557056: 4096, 622592: 2151682048, 688128: 4194304, 753664: 4160, 819200: 2147483648, 884736: 4194368, 950272: 4198464, 1015808: 2147483712, 1048576: 4194368, 1114112: 4198400, 1179648: 2147483712, 1245184: 0, 1310720: 4160, 1376256: 2151678016, 1441792: 2151682048, 1507328: 2147487808, 1572864: 2151682112, 1638400: 2147483648, 1703936: 2151677952, 1769472: 4198464, 1835008: 2147487744, 1900544: 4194304, 1966080: 64, 2031616: 4096, 1081344: 2151677952, 1146880: 2151682112, 1212416: 0, 1277952: 4198400, 1343488: 4194368, 1409024: 2147483648, 1474560: 2147487808, 1540096: 64, 1605632: 2147483712, 1671168: 4096, 1736704: 2147487744, 1802240: 2151678016, 1867776: 4160, 1933312: 2151682048, 1998848: 4194304, 2064384: 4198464 }, { 0: 128, 4096: 17039360, 8192: 262144, 12288: 536870912, 16384: 537133184, 20480: 16777344, 24576: 553648256, 28672: 262272, 32768: 16777216, 36864: 537133056, 40960: 536871040, 45056: 553910400, 49152: 553910272, 53248: 0, 57344: 17039488, 61440: 553648128, 2048: 17039488, 6144: 553648256, 10240: 128, 14336: 17039360, 18432: 262144, 22528: 537133184, 26624: 553910272, 30720: 536870912, 34816: 537133056, 38912: 0, 43008: 553910400, 47104: 16777344, 51200: 536871040, 55296: 553648128, 59392: 16777216, 63488: 262272, 65536: 262144, 69632: 128, 73728: 536870912, 77824: 553648256, 81920: 16777344, 86016: 553910272, 90112: 537133184, 94208: 16777216, 98304: 553910400, 102400: 553648128, 106496: 17039360, 110592: 537133056, 114688: 262272, 118784: 536871040, 122880: 0, 126976: 17039488, 67584: 553648256, 71680: 16777216, 75776: 17039360, 79872: 537133184, 83968: 536870912, 88064: 17039488, 92160: 128, 96256: 553910272, 100352: 262272, 104448: 553910400, 108544: 0, 112640: 553648128, 116736: 16777344, 120832: 262144, 124928: 537133056, 129024: 536871040 }, { 0: 268435464, 256: 8192, 512: 270532608, 768: 270540808, 1024: 268443648, 1280: 2097152, 1536: 2097160, 1792: 268435456, 2048: 0, 2304: 268443656, 2560: 2105344, 2816: 8, 3072: 270532616, 3328: 2105352, 3584: 8200, 3840: 270540800, 128: 270532608, 384: 270540808, 640: 8, 896: 2097152, 1152: 2105352, 1408: 268435464, 1664: 268443648, 1920: 8200, 2176: 2097160, 2432: 8192, 2688: 268443656, 2944: 270532616, 3200: 0, 3456: 270540800, 3712: 2105344, 3968: 268435456, 4096: 268443648, 4352: 270532616, 4608: 270540808, 4864: 8200, 5120: 2097152, 5376: 268435456, 5632: 268435464, 5888: 2105344, 6144: 2105352, 6400: 0, 6656: 8, 6912: 270532608, 7168: 8192, 7424: 268443656, 7680: 270540800, 7936: 2097160, 4224: 8, 4480: 2105344, 4736: 2097152, 4992: 268435464, 5248: 268443648, 5504: 8200, 5760: 270540808, 6016: 270532608, 6272: 270540800, 6528: 270532616, 6784: 8192, 7040: 2105352, 7296: 2097160, 7552: 0, 7808: 268435456, 8064: 268443656 }, { 0: 1048576, 16: 33555457, 32: 1024, 48: 1049601, 64: 34604033, 80: 0, 96: 1, 112: 34603009, 128: 33555456, 144: 1048577, 160: 33554433, 176: 34604032, 192: 34603008, 208: 1025, 224: 1049600, 240: 33554432, 8: 34603009, 24: 0, 40: 33555457, 56: 34604032, 72: 1048576, 88: 33554433, 104: 33554432, 120: 1025, 136: 1049601, 152: 33555456, 168: 34603008, 184: 1048577, 200: 1024, 216: 34604033, 232: 1, 248: 1049600, 256: 33554432, 272: 1048576, 288: 33555457, 304: 34603009, 320: 1048577, 336: 33555456, 352: 34604032, 368: 1049601, 384: 1025, 400: 34604033, 416: 1049600, 432: 1, 448: 0, 464: 34603008, 480: 33554433, 496: 1024, 264: 1049600, 280: 33555457, 296: 34603009, 312: 1, 328: 33554432, 344: 1048576, 360: 1025, 376: 34604032, 392: 33554433, 408: 34603008, 424: 0, 440: 34604033, 456: 1049601, 472: 1024, 488: 33555456, 504: 1048577 }, { 0: 134219808, 1: 131072, 2: 134217728, 3: 32, 4: 131104, 5: 134350880, 6: 134350848, 7: 2048, 8: 134348800, 9: 134219776, 10: 133120, 11: 134348832, 12: 2080, 13: 0, 14: 134217760, 15: 133152, 2147483648: 2048, 2147483649: 134350880, 2147483650: 134219808, 2147483651: 134217728, 2147483652: 134348800, 2147483653: 133120, 2147483654: 133152, 2147483655: 32, 2147483656: 134217760, 2147483657: 2080, 2147483658: 131104, 2147483659: 134350848, 2147483660: 0, 2147483661: 134348832, 2147483662: 134219776, 2147483663: 131072, 16: 133152, 17: 134350848, 18: 32, 19: 2048, 20: 134219776, 21: 134217760, 22: 134348832, 23: 131072, 24: 0, 25: 131104, 26: 134348800, 27: 134219808, 28: 134350880, 29: 133120, 30: 2080, 31: 134217728, 2147483664: 131072, 2147483665: 2048, 2147483666: 134348832, 2147483667: 133152, 2147483668: 32, 2147483669: 134348800, 2147483670: 134217728, 2147483671: 134219808, 2147483672: 134350880, 2147483673: 134217760, 2147483674: 134219776, 2147483675: 0, 2147483676: 133120, 2147483677: 2080, 2147483678: 131104, 2147483679: 134350848 }], m = [4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504, 2147483679], v = o.DES = a.extend({ _doReset: function() {
          for (var C = this._key, I = C.words, S = [], $ = 0; $ < 56; $++) {
            var F = f[$] - 1;
            S[$] = I[F >>> 5] >>> 31 - F % 32 & 1;
          }
          for (var U = this._subKeys = [], Q = 0; Q < 16; Q++) {
            for (var P = U[Q] = [], N = l[Q], $ = 0; $ < 24; $++) P[$ / 6 | 0] |= S[(c[$] - 1 + N) % 28] << 31 - $ % 6, P[4 + ($ / 6 | 0)] |= S[28 + (c[$ + 24] - 1 + N) % 28] << 31 - $ % 6;
            P[0] = P[0] << 1 | P[0] >>> 31;
            for (var $ = 1; $ < 7; $++) P[$] = P[$] >>> ($ - 1) * 4 + 3;
            P[7] = P[7] << 5 | P[7] >>> 27;
          }
          for (var L = this._invSubKeys = [], $ = 0; $ < 16; $++) L[$] = U[15 - $];
        }, encryptBlock: function(C, I) {
          this._doCryptBlock(C, I, this._subKeys);
        }, decryptBlock: function(C, I) {
          this._doCryptBlock(C, I, this._invSubKeys);
        }, _doCryptBlock: function(C, I, S) {
          this._lBlock = C[I], this._rBlock = C[I + 1], b.call(this, 4, 252645135), b.call(this, 16, 65535), A.call(this, 2, 858993459), A.call(this, 8, 16711935), b.call(this, 1, 1431655765);
          for (var $ = 0; $ < 16; $++) {
            for (var F = S[$], U = this._lBlock, Q = this._rBlock, P = 0, N = 0; N < 8; N++) P |= h[N][((Q ^ F[N]) & m[N]) >>> 0];
            this._lBlock = Q, this._rBlock = U ^ P;
          }
          var L = this._lBlock;
          this._lBlock = this._rBlock, this._rBlock = L, b.call(this, 1, 1431655765), A.call(this, 8, 16711935), A.call(this, 2, 858993459), b.call(this, 16, 65535), b.call(this, 4, 252645135), C[I] = this._lBlock, C[I + 1] = this._rBlock;
        }, keySize: 64 / 32, ivSize: 64 / 32, blockSize: 64 / 32 });
        function b(C, I) {
          var S = (this._lBlock >>> C ^ this._rBlock) & I;
          this._rBlock ^= S, this._lBlock ^= S << C;
        }
        function A(C, I) {
          var S = (this._rBlock >>> C ^ this._lBlock) & I;
          this._lBlock ^= S, this._rBlock ^= S << C;
        }
        r.DES = a._createHelper(v);
        var _ = o.TripleDES = a.extend({ _doReset: function() {
          var C = this._key, I = C.words;
          if (I.length !== 2 && I.length !== 4 && I.length < 6) throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
          var S = I.slice(0, 2), $ = I.length < 4 ? I.slice(0, 2) : I.slice(2, 4), F = I.length < 6 ? I.slice(0, 2) : I.slice(4, 6);
          this._des1 = v.createEncryptor(i.create(S)), this._des2 = v.createEncryptor(i.create($)), this._des3 = v.createEncryptor(i.create(F));
        }, encryptBlock: function(C, I) {
          this._des1.encryptBlock(C, I), this._des2.decryptBlock(C, I), this._des3.encryptBlock(C, I);
        }, decryptBlock: function(C, I) {
          this._des3.decryptBlock(C, I), this._des2.encryptBlock(C, I), this._des1.decryptBlock(C, I);
        }, keySize: 192 / 32, ivSize: 64 / 32, blockSize: 64 / 32 });
        r.TripleDES = a._createHelper(_);
      }(), n.TripleDES;
    });
  }(Wv)), Wv.exports;
}
var Jv = { exports: {} }, Q_;
function xie() {
  return Q_ || (Q_ = 1, function(t3, e) {
    (function(n, r, s) {
      t3.exports = r(Lr, yl, _0(), bl(), Ii());
    })(mt, function(n) {
      return function() {
        var r = n, s = r.lib, i = s.StreamCipher, a = r.algo, o = a.RC4 = i.extend({ _doReset: function() {
          for (var l = this._key, h = l.words, m = l.sigBytes, v = this._S = [], b = 0; b < 256; b++) v[b] = b;
          for (var b = 0, A = 0; b < 256; b++) {
            var _ = b % m, C = h[_ >>> 2] >>> 24 - _ % 4 * 8 & 255;
            A = (A + v[b] + C) % 256;
            var I = v[b];
            v[b] = v[A], v[A] = I;
          }
          this._i = this._j = 0;
        }, _doProcessBlock: function(l, h) {
          l[h] ^= f.call(this);
        }, keySize: 256 / 32, ivSize: 0 });
        function f() {
          for (var l = this._S, h = this._i, m = this._j, v = 0, b = 0; b < 4; b++) {
            h = (h + 1) % 256, m = (m + l[h]) % 256;
            var A = l[h];
            l[h] = l[m], l[m] = A, v |= l[(l[h] + l[m]) % 256] << 24 - b * 8;
          }
          return this._i = h, this._j = m, v;
        }
        r.RC4 = i._createHelper(o);
        var c = a.RC4Drop = o.extend({ cfg: o.cfg.extend({ drop: 192 }), _doReset: function() {
          o._doReset.call(this);
          for (var l = this.cfg.drop; l > 0; l--) f.call(this);
        } });
        r.RC4Drop = i._createHelper(c);
      }(), n.RC4;
    });
  }(Jv)), Jv.exports;
}
var Zv = { exports: {} }, K_;
function _ie() {
  return K_ || (K_ = 1, function(t3, e) {
    (function(n, r, s) {
      t3.exports = r(Lr, yl, _0(), bl(), Ii());
    })(mt, function(n) {
      return function() {
        var r = n, s = r.lib, i = s.StreamCipher, a = r.algo, o = [], f = [], c = [], l = a.Rabbit = i.extend({ _doReset: function() {
          for (var m = this._key.words, v = this.cfg.iv, b = 0; b < 4; b++) m[b] = (m[b] << 8 | m[b] >>> 24) & 16711935 | (m[b] << 24 | m[b] >>> 8) & 4278255360;
          var A = this._X = [m[0], m[3] << 16 | m[2] >>> 16, m[1], m[0] << 16 | m[3] >>> 16, m[2], m[1] << 16 | m[0] >>> 16, m[3], m[2] << 16 | m[1] >>> 16], _ = this._C = [m[2] << 16 | m[2] >>> 16, m[0] & 4294901760 | m[1] & 65535, m[3] << 16 | m[3] >>> 16, m[1] & 4294901760 | m[2] & 65535, m[0] << 16 | m[0] >>> 16, m[2] & 4294901760 | m[3] & 65535, m[1] << 16 | m[1] >>> 16, m[3] & 4294901760 | m[0] & 65535];
          this._b = 0;
          for (var b = 0; b < 4; b++) h.call(this);
          for (var b = 0; b < 8; b++) _[b] ^= A[b + 4 & 7];
          if (v) {
            var C = v.words, I = C[0], S = C[1], $ = (I << 8 | I >>> 24) & 16711935 | (I << 24 | I >>> 8) & 4278255360, F = (S << 8 | S >>> 24) & 16711935 | (S << 24 | S >>> 8) & 4278255360, U = $ >>> 16 | F & 4294901760, Q = F << 16 | $ & 65535;
            _[0] ^= $, _[1] ^= U, _[2] ^= F, _[3] ^= Q, _[4] ^= $, _[5] ^= U, _[6] ^= F, _[7] ^= Q;
            for (var b = 0; b < 4; b++) h.call(this);
          }
        }, _doProcessBlock: function(m, v) {
          var b = this._X;
          h.call(this), o[0] = b[0] ^ b[5] >>> 16 ^ b[3] << 16, o[1] = b[2] ^ b[7] >>> 16 ^ b[5] << 16, o[2] = b[4] ^ b[1] >>> 16 ^ b[7] << 16, o[3] = b[6] ^ b[3] >>> 16 ^ b[1] << 16;
          for (var A = 0; A < 4; A++) o[A] = (o[A] << 8 | o[A] >>> 24) & 16711935 | (o[A] << 24 | o[A] >>> 8) & 4278255360, m[v + A] ^= o[A];
        }, blockSize: 128 / 32, ivSize: 64 / 32 });
        function h() {
          for (var m = this._X, v = this._C, b = 0; b < 8; b++) f[b] = v[b];
          v[0] = v[0] + 1295307597 + this._b | 0, v[1] = v[1] + 3545052371 + (v[0] >>> 0 < f[0] >>> 0 ? 1 : 0) | 0, v[2] = v[2] + 886263092 + (v[1] >>> 0 < f[1] >>> 0 ? 1 : 0) | 0, v[3] = v[3] + 1295307597 + (v[2] >>> 0 < f[2] >>> 0 ? 1 : 0) | 0, v[4] = v[4] + 3545052371 + (v[3] >>> 0 < f[3] >>> 0 ? 1 : 0) | 0, v[5] = v[5] + 886263092 + (v[4] >>> 0 < f[4] >>> 0 ? 1 : 0) | 0, v[6] = v[6] + 1295307597 + (v[5] >>> 0 < f[5] >>> 0 ? 1 : 0) | 0, v[7] = v[7] + 3545052371 + (v[6] >>> 0 < f[6] >>> 0 ? 1 : 0) | 0, this._b = v[7] >>> 0 < f[7] >>> 0 ? 1 : 0;
          for (var b = 0; b < 8; b++) {
            var A = m[b] + v[b], _ = A & 65535, C = A >>> 16, I = ((_ * _ >>> 17) + _ * C >>> 15) + C * C, S = ((A & 4294901760) * A | 0) + ((A & 65535) * A | 0);
            c[b] = I ^ S;
          }
          m[0] = c[0] + (c[7] << 16 | c[7] >>> 16) + (c[6] << 16 | c[6] >>> 16) | 0, m[1] = c[1] + (c[0] << 8 | c[0] >>> 24) + c[7] | 0, m[2] = c[2] + (c[1] << 16 | c[1] >>> 16) + (c[0] << 16 | c[0] >>> 16) | 0, m[3] = c[3] + (c[2] << 8 | c[2] >>> 24) + c[1] | 0, m[4] = c[4] + (c[3] << 16 | c[3] >>> 16) + (c[2] << 16 | c[2] >>> 16) | 0, m[5] = c[5] + (c[4] << 8 | c[4] >>> 24) + c[3] | 0, m[6] = c[6] + (c[5] << 16 | c[5] >>> 16) + (c[4] << 16 | c[4] >>> 16) | 0, m[7] = c[7] + (c[6] << 8 | c[6] >>> 24) + c[5] | 0;
        }
        r.Rabbit = i._createHelper(l);
      }(), n.Rabbit;
    });
  }(Zv)), Zv.exports;
}
var jv = { exports: {} }, H_;
function Eie() {
  return H_ || (H_ = 1, function(t3, e) {
    (function(n, r, s) {
      t3.exports = r(Lr, yl, _0(), bl(), Ii());
    })(mt, function(n) {
      return function() {
        var r = n, s = r.lib, i = s.StreamCipher, a = r.algo, o = [], f = [], c = [], l = a.RabbitLegacy = i.extend({ _doReset: function() {
          var m = this._key.words, v = this.cfg.iv, b = this._X = [m[0], m[3] << 16 | m[2] >>> 16, m[1], m[0] << 16 | m[3] >>> 16, m[2], m[1] << 16 | m[0] >>> 16, m[3], m[2] << 16 | m[1] >>> 16], A = this._C = [m[2] << 16 | m[2] >>> 16, m[0] & 4294901760 | m[1] & 65535, m[3] << 16 | m[3] >>> 16, m[1] & 4294901760 | m[2] & 65535, m[0] << 16 | m[0] >>> 16, m[2] & 4294901760 | m[3] & 65535, m[1] << 16 | m[1] >>> 16, m[3] & 4294901760 | m[0] & 65535];
          this._b = 0;
          for (var _ = 0; _ < 4; _++) h.call(this);
          for (var _ = 0; _ < 8; _++) A[_] ^= b[_ + 4 & 7];
          if (v) {
            var C = v.words, I = C[0], S = C[1], $ = (I << 8 | I >>> 24) & 16711935 | (I << 24 | I >>> 8) & 4278255360, F = (S << 8 | S >>> 24) & 16711935 | (S << 24 | S >>> 8) & 4278255360, U = $ >>> 16 | F & 4294901760, Q = F << 16 | $ & 65535;
            A[0] ^= $, A[1] ^= U, A[2] ^= F, A[3] ^= Q, A[4] ^= $, A[5] ^= U, A[6] ^= F, A[7] ^= Q;
            for (var _ = 0; _ < 4; _++) h.call(this);
          }
        }, _doProcessBlock: function(m, v) {
          var b = this._X;
          h.call(this), o[0] = b[0] ^ b[5] >>> 16 ^ b[3] << 16, o[1] = b[2] ^ b[7] >>> 16 ^ b[5] << 16, o[2] = b[4] ^ b[1] >>> 16 ^ b[7] << 16, o[3] = b[6] ^ b[3] >>> 16 ^ b[1] << 16;
          for (var A = 0; A < 4; A++) o[A] = (o[A] << 8 | o[A] >>> 24) & 16711935 | (o[A] << 24 | o[A] >>> 8) & 4278255360, m[v + A] ^= o[A];
        }, blockSize: 128 / 32, ivSize: 64 / 32 });
        function h() {
          for (var m = this._X, v = this._C, b = 0; b < 8; b++) f[b] = v[b];
          v[0] = v[0] + 1295307597 + this._b | 0, v[1] = v[1] + 3545052371 + (v[0] >>> 0 < f[0] >>> 0 ? 1 : 0) | 0, v[2] = v[2] + 886263092 + (v[1] >>> 0 < f[1] >>> 0 ? 1 : 0) | 0, v[3] = v[3] + 1295307597 + (v[2] >>> 0 < f[2] >>> 0 ? 1 : 0) | 0, v[4] = v[4] + 3545052371 + (v[3] >>> 0 < f[3] >>> 0 ? 1 : 0) | 0, v[5] = v[5] + 886263092 + (v[4] >>> 0 < f[4] >>> 0 ? 1 : 0) | 0, v[6] = v[6] + 1295307597 + (v[5] >>> 0 < f[5] >>> 0 ? 1 : 0) | 0, v[7] = v[7] + 3545052371 + (v[6] >>> 0 < f[6] >>> 0 ? 1 : 0) | 0, this._b = v[7] >>> 0 < f[7] >>> 0 ? 1 : 0;
          for (var b = 0; b < 8; b++) {
            var A = m[b] + v[b], _ = A & 65535, C = A >>> 16, I = ((_ * _ >>> 17) + _ * C >>> 15) + C * C, S = ((A & 4294901760) * A | 0) + ((A & 65535) * A | 0);
            c[b] = I ^ S;
          }
          m[0] = c[0] + (c[7] << 16 | c[7] >>> 16) + (c[6] << 16 | c[6] >>> 16) | 0, m[1] = c[1] + (c[0] << 8 | c[0] >>> 24) + c[7] | 0, m[2] = c[2] + (c[1] << 16 | c[1] >>> 16) + (c[0] << 16 | c[0] >>> 16) | 0, m[3] = c[3] + (c[2] << 8 | c[2] >>> 24) + c[1] | 0, m[4] = c[4] + (c[3] << 16 | c[3] >>> 16) + (c[2] << 16 | c[2] >>> 16) | 0, m[5] = c[5] + (c[4] << 8 | c[4] >>> 24) + c[3] | 0, m[6] = c[6] + (c[5] << 16 | c[5] >>> 16) + (c[4] << 16 | c[4] >>> 16) | 0, m[7] = c[7] + (c[6] << 8 | c[6] >>> 24) + c[5] | 0;
        }
        r.RabbitLegacy = i._createHelper(l);
      }(), n.RabbitLegacy;
    });
  }(jv)), jv.exports;
}
var Xv = { exports: {} }, q_;
function Bie() {
  return q_ || (q_ = 1, function(t3, e) {
    (function(n, r, s) {
      t3.exports = r(Lr, yl, _0(), bl(), Ii());
    })(mt, function(n) {
      return function() {
        var r = n, s = r.lib, i = s.BlockCipher, a = r.algo;
        const o = 16, f = [608135816, 2242054355, 320440878, 57701188, 2752067618, 698298832, 137296536, 3964562569, 1160258022, 953160567, 3193202383, 887688300, 3232508343, 3380367581, 1065670069, 3041331479, 2450970073, 2306472731], c = [[3509652390, 2564797868, 805139163, 3491422135, 3101798381, 1780907670, 3128725573, 4046225305, 614570311, 3012652279, 134345442, 2240740374, 1667834072, 1901547113, 2757295779, 4103290238, 227898511, 1921955416, 1904987480, 2182433518, 2069144605, 3260701109, 2620446009, 720527379, 3318853667, 677414384, 3393288472, 3101374703, 2390351024, 1614419982, 1822297739, 2954791486, 3608508353, 3174124327, 2024746970, 1432378464, 3864339955, 2857741204, 1464375394, 1676153920, 1439316330, 715854006, 3033291828, 289532110, 2706671279, 2087905683, 3018724369, 1668267050, 732546397, 1947742710, 3462151702, 2609353502, 2950085171, 1814351708, 2050118529, 680887927, 999245976, 1800124847, 3300911131, 1713906067, 1641548236, 4213287313, 1216130144, 1575780402, 4018429277, 3917837745, 3693486850, 3949271944, 596196993, 3549867205, 258830323, 2213823033, 772490370, 2760122372, 1774776394, 2652871518, 566650946, 4142492826, 1728879713, 2882767088, 1783734482, 3629395816, 2517608232, 2874225571, 1861159788, 326777828, 3124490320, 2130389656, 2716951837, 967770486, 1724537150, 2185432712, 2364442137, 1164943284, 2105845187, 998989502, 3765401048, 2244026483, 1075463327, 1455516326, 1322494562, 910128902, 469688178, 1117454909, 936433444, 3490320968, 3675253459, 1240580251, 122909385, 2157517691, 634681816, 4142456567, 3825094682, 3061402683, 2540495037, 79693498, 3249098678, 1084186820, 1583128258, 426386531, 1761308591, 1047286709, 322548459, 995290223, 1845252383, 2603652396, 3431023940, 2942221577, 3202600964, 3727903485, 1712269319, 422464435, 3234572375, 1170764815, 3523960633, 3117677531, 1434042557, 442511882, 3600875718, 1076654713, 1738483198, 4213154764, 2393238008, 3677496056, 1014306527, 4251020053, 793779912, 2902807211, 842905082, 4246964064, 1395751752, 1040244610, 2656851899, 3396308128, 445077038, 3742853595, 3577915638, 679411651, 2892444358, 2354009459, 1767581616, 3150600392, 3791627101, 3102740896, 284835224, 4246832056, 1258075500, 768725851, 2589189241, 3069724005, 3532540348, 1274779536, 3789419226, 2764799539, 1660621633, 3471099624, 4011903706, 913787905, 3497959166, 737222580, 2514213453, 2928710040, 3937242737, 1804850592, 3499020752, 2949064160, 2386320175, 2390070455, 2415321851, 4061277028, 2290661394, 2416832540, 1336762016, 1754252060, 3520065937, 3014181293, 791618072, 3188594551, 3933548030, 2332172193, 3852520463, 3043980520, 413987798, 3465142937, 3030929376, 4245938359, 2093235073, 3534596313, 375366246, 2157278981, 2479649556, 555357303, 3870105701, 2008414854, 3344188149, 4221384143, 3956125452, 2067696032, 3594591187, 2921233993, 2428461, 544322398, 577241275, 1471733935, 610547355, 4027169054, 1432588573, 1507829418, 2025931657, 3646575487, 545086370, 48609733, 2200306550, 1653985193, 298326376, 1316178497, 3007786442, 2064951626, 458293330, 2589141269, 3591329599, 3164325604, 727753846, 2179363840, 146436021, 1461446943, 4069977195, 705550613, 3059967265, 3887724982, 4281599278, 3313849956, 1404054877, 2845806497, 146425753, 1854211946], [1266315497, 3048417604, 3681880366, 3289982499, 290971e4, 1235738493, 2632868024, 2414719590, 3970600049, 1771706367, 1449415276, 3266420449, 422970021, 1963543593, 2690192192, 3826793022, 1062508698, 1531092325, 1804592342, 2583117782, 2714934279, 4024971509, 1294809318, 4028980673, 1289560198, 2221992742, 1669523910, 35572830, 157838143, 1052438473, 1016535060, 1802137761, 1753167236, 1386275462, 3080475397, 2857371447, 1040679964, 2145300060, 2390574316, 1461121720, 2956646967, 4031777805, 4028374788, 33600511, 2920084762, 1018524850, 629373528, 3691585981, 3515945977, 2091462646, 2486323059, 586499841, 988145025, 935516892, 3367335476, 2599673255, 2839830854, 265290510, 3972581182, 2759138881, 3795373465, 1005194799, 847297441, 406762289, 1314163512, 1332590856, 1866599683, 4127851711, 750260880, 613907577, 1450815602, 3165620655, 3734664991, 3650291728, 3012275730, 3704569646, 1427272223, 778793252, 1343938022, 2676280711, 2052605720, 1946737175, 3164576444, 3914038668, 3967478842, 3682934266, 1661551462, 3294938066, 4011595847, 840292616, 3712170807, 616741398, 312560963, 711312465, 1351876610, 322626781, 1910503582, 271666773, 2175563734, 1594956187, 70604529, 3617834859, 1007753275, 1495573769, 4069517037, 2549218298, 2663038764, 504708206, 2263041392, 3941167025, 2249088522, 1514023603, 1998579484, 1312622330, 694541497, 2582060303, 2151582166, 1382467621, 776784248, 2618340202, 3323268794, 2497899128, 2784771155, 503983604, 4076293799, 907881277, 423175695, 432175456, 1378068232, 4145222326, 3954048622, 3938656102, 3820766613, 2793130115, 2977904593, 26017576, 3274890735, 3194772133, 1700274565, 1756076034, 4006520079, 3677328699, 720338349, 1533947780, 354530856, 688349552, 3973924725, 1637815568, 332179504, 3949051286, 53804574, 2852348879, 3044236432, 1282449977, 3583942155, 3416972820, 4006381244, 1617046695, 2628476075, 3002303598, 1686838959, 431878346, 2686675385, 1700445008, 1080580658, 1009431731, 832498133, 3223435511, 2605976345, 2271191193, 2516031870, 1648197032, 4164389018, 2548247927, 300782431, 375919233, 238389289, 3353747414, 2531188641, 2019080857, 1475708069, 455242339, 2609103871, 448939670, 3451063019, 1395535956, 2413381860, 1841049896, 1491858159, 885456874, 4264095073, 4001119347, 1565136089, 3898914787, 1108368660, 540939232, 1173283510, 2745871338, 3681308437, 4207628240, 3343053890, 4016749493, 1699691293, 1103962373, 3625875870, 2256883143, 3830138730, 1031889488, 3479347698, 1535977030, 4236805024, 3251091107, 2132092099, 1774941330, 1199868427, 1452454533, 157007616, 2904115357, 342012276, 595725824, 1480756522, 206960106, 497939518, 591360097, 863170706, 2375253569, 3596610801, 1814182875, 2094937945, 3421402208, 1082520231, 3463918190, 2785509508, 435703966, 3908032597, 1641649973, 2842273706, 3305899714, 1510255612, 2148256476, 2655287854, 3276092548, 4258621189, 236887753, 3681803219, 274041037, 1734335097, 3815195456, 3317970021, 1899903192, 1026095262, 4050517792, 356393447, 2410691914, 3873677099, 3682840055], [3913112168, 2491498743, 4132185628, 2489919796, 1091903735, 1979897079, 3170134830, 3567386728, 3557303409, 857797738, 1136121015, 1342202287, 507115054, 2535736646, 337727348, 3213592640, 1301675037, 2528481711, 1895095763, 1721773893, 3216771564, 62756741, 2142006736, 835421444, 2531993523, 1442658625, 3659876326, 2882144922, 676362277, 1392781812, 170690266, 3921047035, 1759253602, 3611846912, 1745797284, 664899054, 1329594018, 3901205900, 3045908486, 2062866102, 2865634940, 3543621612, 3464012697, 1080764994, 553557557, 3656615353, 3996768171, 991055499, 499776247, 1265440854, 648242737, 3940784050, 980351604, 3713745714, 1749149687, 3396870395, 4211799374, 3640570775, 1161844396, 3125318951, 1431517754, 545492359, 4268468663, 3499529547, 1437099964, 2702547544, 3433638243, 2581715763, 2787789398, 1060185593, 1593081372, 2418618748, 4260947970, 69676912, 2159744348, 86519011, 2512459080, 3838209314, 1220612927, 3339683548, 133810670, 1090789135, 1078426020, 1569222167, 845107691, 3583754449, 4072456591, 1091646820, 628848692, 1613405280, 3757631651, 526609435, 236106946, 48312990, 2942717905, 3402727701, 1797494240, 859738849, 992217954, 4005476642, 2243076622, 3870952857, 3732016268, 765654824, 3490871365, 2511836413, 1685915746, 3888969200, 1414112111, 2273134842, 3281911079, 4080962846, 172450625, 2569994100, 980381355, 4109958455, 2819808352, 2716589560, 2568741196, 3681446669, 3329971472, 1835478071, 660984891, 3704678404, 4045999559, 3422617507, 3040415634, 1762651403, 1719377915, 3470491036, 2693910283, 3642056355, 3138596744, 1364962596, 2073328063, 1983633131, 926494387, 3423689081, 2150032023, 4096667949, 1749200295, 3328846651, 309677260, 2016342300, 1779581495, 3079819751, 111262694, 1274766160, 443224088, 298511866, 1025883608, 3806446537, 1145181785, 168956806, 3641502830, 3584813610, 1689216846, 3666258015, 3200248200, 1692713982, 2646376535, 4042768518, 1618508792, 1610833997, 3523052358, 4130873264, 2001055236, 3610705100, 2202168115, 4028541809, 2961195399, 1006657119, 2006996926, 3186142756, 1430667929, 3210227297, 1314452623, 4074634658, 4101304120, 2273951170, 1399257539, 3367210612, 3027628629, 1190975929, 2062231137, 2333990788, 2221543033, 2438960610, 1181637006, 548689776, 2362791313, 3372408396, 3104550113, 3145860560, 296247880, 1970579870, 3078560182, 3769228297, 1714227617, 3291629107, 3898220290, 166772364, 1251581989, 493813264, 448347421, 195405023, 2709975567, 677966185, 3703036547, 1463355134, 2715995803, 1338867538, 1343315457, 2802222074, 2684532164, 233230375, 2599980071, 2000651841, 3277868038, 1638401717, 4028070440, 3237316320, 6314154, 819756386, 300326615, 590932579, 1405279636, 3267499572, 3150704214, 2428286686, 3959192993, 3461946742, 1862657033, 1266418056, 963775037, 2089974820, 2263052895, 1917689273, 448879540, 3550394620, 3981727096, 150775221, 3627908307, 1303187396, 508620638, 2975983352, 2726630617, 1817252668, 1876281319, 1457606340, 908771278, 3720792119, 3617206836, 2455994898, 1729034894, 1080033504], [976866871, 3556439503, 2881648439, 1522871579, 1555064734, 1336096578, 3548522304, 2579274686, 3574697629, 3205460757, 3593280638, 3338716283, 3079412587, 564236357, 2993598910, 1781952180, 1464380207, 3163844217, 3332601554, 1699332808, 1393555694, 1183702653, 3581086237, 1288719814, 691649499, 2847557200, 2895455976, 3193889540, 2717570544, 1781354906, 1676643554, 2592534050, 3230253752, 1126444790, 2770207658, 2633158820, 2210423226, 2615765581, 2414155088, 3127139286, 673620729, 2805611233, 1269405062, 4015350505, 3341807571, 4149409754, 1057255273, 2012875353, 2162469141, 2276492801, 2601117357, 993977747, 3918593370, 2654263191, 753973209, 36408145, 2530585658, 25011837, 3520020182, 2088578344, 530523599, 2918365339, 1524020338, 1518925132, 3760827505, 3759777254, 1202760957, 3985898139, 3906192525, 674977740, 4174734889, 2031300136, 2019492241, 3983892565, 4153806404, 3822280332, 352677332, 2297720250, 60907813, 90501309, 3286998549, 1016092578, 2535922412, 2839152426, 457141659, 509813237, 4120667899, 652014361, 1966332200, 2975202805, 55981186, 2327461051, 676427537, 3255491064, 2882294119, 3433927263, 1307055953, 942726286, 933058658, 2468411793, 3933900994, 4215176142, 1361170020, 2001714738, 2830558078, 3274259782, 1222529897, 1679025792, 2729314320, 3714953764, 1770335741, 151462246, 3013232138, 1682292957, 1483529935, 471910574, 1539241949, 458788160, 3436315007, 1807016891, 3718408830, 978976581, 1043663428, 3165965781, 1927990952, 4200891579, 2372276910, 3208408903, 3533431907, 1412390302, 2931980059, 4132332400, 1947078029, 3881505623, 4168226417, 2941484381, 1077988104, 1320477388, 886195818, 18198404, 3786409e3, 2509781533, 112762804, 3463356488, 1866414978, 891333506, 18488651, 661792760, 1628790961, 3885187036, 3141171499, 876946877, 2693282273, 1372485963, 791857591, 2686433993, 3759982718, 3167212022, 3472953795, 2716379847, 445679433, 3561995674, 3504004811, 3574258232, 54117162, 3331405415, 2381918588, 3769707343, 4154350007, 1140177722, 4074052095, 668550556, 3214352940, 367459370, 261225585, 2610173221, 4209349473, 3468074219, 3265815641, 314222801, 3066103646, 3808782860, 282218597, 3406013506, 3773591054, 379116347, 1285071038, 846784868, 2669647154, 3771962079, 3550491691, 2305946142, 453669953, 1268987020, 3317592352, 3279303384, 3744833421, 2610507566, 3859509063, 266596637, 3847019092, 517658769, 3462560207, 3443424879, 370717030, 4247526661, 2224018117, 4143653529, 4112773975, 2788324899, 2477274417, 1456262402, 2901442914, 1517677493, 1846949527, 2295493580, 3734397586, 2176403920, 1280348187, 1908823572, 3871786941, 846861322, 1172426758, 3287448474, 3383383037, 1655181056, 3139813346, 901632758, 1897031941, 2986607138, 3066810236, 3447102507, 1393639104, 373351379, 950779232, 625454576, 3124240540, 4148612726, 2007998917, 544563296, 2244738638, 2330496472, 2058025392, 1291430526, 424198748, 50039436, 29584100, 3605783033, 2429876329, 2791104160, 1057563949, 3255363231, 3075367218, 3463963227, 1469046755, 985887462]];
        var l = { pbox: [], sbox: [] };
        function h(_, C) {
          let I = C >> 24 & 255, S = C >> 16 & 255, $ = C >> 8 & 255, F = C & 255, U = _.sbox[0][I] + _.sbox[1][S];
          return U = U ^ _.sbox[2][$], U = U + _.sbox[3][F], U;
        }
        function m(_, C, I) {
          let S = C, $ = I, F;
          for (let U = 0; U < o; ++U) S = S ^ _.pbox[U], $ = h(_, S) ^ $, F = S, S = $, $ = F;
          return F = S, S = $, $ = F, $ = $ ^ _.pbox[o], S = S ^ _.pbox[o + 1], { left: S, right: $ };
        }
        function v(_, C, I) {
          let S = C, $ = I, F;
          for (let U = o + 1; U > 1; --U) S = S ^ _.pbox[U], $ = h(_, S) ^ $, F = S, S = $, $ = F;
          return F = S, S = $, $ = F, $ = $ ^ _.pbox[1], S = S ^ _.pbox[0], { left: S, right: $ };
        }
        function b(_, C, I) {
          for (let Q = 0; Q < 4; Q++) {
            _.sbox[Q] = [];
            for (let P = 0; P < 256; P++) _.sbox[Q][P] = c[Q][P];
          }
          let S = 0;
          for (let Q = 0; Q < o + 2; Q++) _.pbox[Q] = f[Q] ^ C[S], S++, S >= I && (S = 0);
          let $ = 0, F = 0, U = 0;
          for (let Q = 0; Q < o + 2; Q += 2) U = m(_, $, F), $ = U.left, F = U.right, _.pbox[Q] = $, _.pbox[Q + 1] = F;
          for (let Q = 0; Q < 4; Q++) for (let P = 0; P < 256; P += 2) U = m(_, $, F), $ = U.left, F = U.right, _.sbox[Q][P] = $, _.sbox[Q][P + 1] = F;
          return true;
        }
        var A = a.Blowfish = i.extend({ _doReset: function() {
          if (this._keyPriorReset !== this._key) {
            var _ = this._keyPriorReset = this._key, C = _.words, I = _.sigBytes / 4;
            b(l, C, I);
          }
        }, encryptBlock: function(_, C) {
          var I = m(l, _[C], _[C + 1]);
          _[C] = I.left, _[C + 1] = I.right;
        }, decryptBlock: function(_, C) {
          var I = v(l, _[C], _[C + 1]);
          _[C] = I.left, _[C + 1] = I.right;
        }, blockSize: 64 / 32, keySize: 128 / 32, ivSize: 64 / 32 });
        r.Blowfish = i._createHelper(A);
      }(), n.Blowfish;
    });
  }(Xv)), Xv.exports;
}
(function(t3, e) {
  (function(n, r, s) {
    t3.exports = r(Lr, pm(), rie(), nie(), yl, iie(), _0(), XT(), gm(), sie(), eD(), aie(), oie(), fie(), mm(), lie(), bl(), Ii(), uie(), cie(), hie(), die(), pie(), gie(), mie(), vie(), yie(), bie(), Aie(), rD, wie(), xie(), _ie(), Eie(), Bie());
  })(mt, function(n) {
    return n;
  });
})(JT);
var Cie = JT.exports;
const ur = Fa(Cie), nD = { CBC: ur.mode.CBC, ECB: ur.mode.ECB, CTR: ur.mode.CTR, OFB: ur.mode.OFB, CFB: ur.mode.CFB }, iD = { Pkcs7: ur.pad.Pkcs7, ZeroPadding: ur.pad.ZeroPadding, NoPadding: ur.pad.NoPadding, Iso10126: ur.pad.Iso10126, Iso97971: ur.pad.Iso97971 };
function kie(t3, e, n, r, s) {
  try {
    const i = L1(e), a = n ? L1(n) : void 0, o = { mode: nD[r] || ur.mode.CBC, padding: iD[s] || ur.pad.Pkcs7 };
    return a && r !== "ECB" && (o.iv = a), ur.AES.encrypt(t3, i, o).toString();
  } catch (i) {
    throw new Error("Encryption Error: " + i.message);
  }
}
function Iie(t3, e, n, r, s) {
  try {
    const i = L1(e), a = n ? L1(n) : void 0, o = { mode: nD[r] || ur.mode.CBC, padding: iD[s] || ur.pad.Pkcs7 };
    a && r !== "ECB" && (o.iv = a);
    const c = ur.AES.decrypt(t3, i, o).toString(ur.enc.Utf8);
    if (!c) throw new Error("Decryption failed (empty result). Wrong Key/IV?");
    return c;
  } catch (i) {
    throw new Error("Decryption Error: " + i.message);
  }
}
function L1(t3) {
  return /^[0-9a-fA-F]+$/.test(t3) && t3.length % 2 === 0 ? ur.enc.Hex.parse(t3) : ur.enc.Utf8.parse(t3);
}
function Sie(t3) {
  const e = ur.lib.WordArray.random(t3 / 8), n = ur.lib.WordArray.random(128 / 8);
  return { key: e.toString(ur.enc.Hex), iv: n.toString(ur.enc.Hex) };
}
function z_(t3) {
  let e, n, r;
  function s(a) {
    t3[24](a);
  }
  let i = { label: "Initialization Vector (IV) - Hex:", placeholder: "16 bytes (32 hex chars)" };
  return t3[4] !== void 0 && (i.value = t3[4]), e = new et({ props: i }), Qe.push(() => ze(e, "value", s)), { c() {
    fe(e.$$.fragment);
  }, m(a, o) {
    ae(e, a, o), r = true;
  }, p(a, o) {
    const f = {};
    !n && o & 16 && (n = true, f.value = a[4], qe(() => n = false)), e.$set(f);
  }, i(a) {
    r || (W(e.$$.fragment, a), r = true);
  }, o(a) {
    j(e.$$.fragment, a), r = false;
  }, d(a) {
    oe(e, a);
  } };
}
function Mie(t3) {
  let e = t3[1] === "encrypt" ? "Encrypt Message" : "Decrypt Message", n;
  return { c() {
    n = we(e);
  }, m(r, s) {
    R(r, n, s);
  }, p(r, s) {
    s & 2 && e !== (e = r[1] === "encrypt" ? "Encrypt Message" : "Decrypt Message") && Ze(n, e);
  }, d(r) {
    r && D(n);
  } };
}
function $ie(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function G_(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[8]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 256 && Ze(n, r[8]);
  }, d(r) {
    r && D(e);
  } };
}
function V_(t3) {
  let e, n;
  return e = new et({ props: { label: t3[1] === "encrypt" ? "Encrypted Output (Base64):" : "Decrypted Plaintext:", value: t3[7], readonly: true, expandable: true, withCopy: true, rows: 3 } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, s) {
    const i = {};
    s & 2 && (i.label = r[1] === "encrypt" ? "Encrypted Output (Base64):" : "Decrypted Plaintext:"), s & 128 && (i.value = r[7]), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function Tie(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U, Q, P, N, L, B, u, p, d, y, w, E, M, x, g;
  function k(he) {
    t3[18](he);
  }
  let T = { label: "Operation:", options: t3[10] };
  t3[1] !== void 0 && (T.value = t3[1]), n = new Ht({ props: T }), Qe.push(() => ze(n, "value", k));
  function O(he) {
    t3[19](he);
  }
  let K = { label: "Key Size:", options: t3[11] };
  t3[5] !== void 0 && (K.value = t3[5]), i = new Ht({ props: K }), Qe.push(() => ze(i, "value", O));
  function Y(he) {
    t3[20](he);
  }
  let J = { label: "Block Mode:", options: t3[12] };
  t3[0] !== void 0 && (J.value = t3[0]), f = new Ht({ props: J }), Qe.push(() => ze(f, "value", Y));
  function G(he) {
    t3[21](he);
  }
  let X = { label: "Padding:", options: t3[13] };
  t3[6] !== void 0 && (X.value = t3[6]), h = new Ht({ props: X }), Qe.push(() => ze(h, "value", G));
  function ie(he) {
    t3[22](he);
  }
  let de = { label: t3[1] === "encrypt" ? "Plaintext:" : "Ciphertext (Base64):", placeholder: t3[1] === "encrypt" ? "Secret message..." : "Encrypted string...", expandable: true, rows: 3 };
  t3[2] !== void 0 && (de.value = t3[2]), b = new et({ props: de }), Qe.push(() => ze(b, "value", ie));
  function se(he) {
    t3[23](he);
  }
  let te = { label: "Secret Key (Hex or String):", placeholder: `Enter ${parseInt(t3[5]) / 8} bytes...` };
  t3[3] !== void 0 && (te.value = t3[3]), S = new et({ props: te }), Qe.push(() => ze(S, "value", se));
  let le = t3[9] && z_(t3);
  L = new ut({ props: { $$slots: { default: [Mie] }, $$scope: { ctx: t3 } } }), L.$on("click", t3[15]), u = new ut({ props: { variant: "secondary", $$slots: { default: [$ie] }, $$scope: { ctx: t3 } } }), u.$on("click", t3[25]), d = new hn({}), d.$on("click", t3[16]);
  let Z = t3[8] && G_(t3), ve = t3[7] && V_(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), fe(i.$$.fragment), o = z(), fe(f.$$.fragment), l = z(), fe(h.$$.fragment), v = z(), fe(b.$$.fragment), _ = z(), C = H("div"), I = H("div"), fe(S.$$.fragment), F = z(), U = H("button"), U.textContent = "Generate Random", Q = z(), le && le.c(), P = z(), N = H("div"), fe(L.$$.fragment), B = z(), fe(u.$$.fragment), p = z(), fe(d.$$.fragment), y = z(), Z && Z.c(), w = z(), ve && ve.c(), E = Lt(), V(e, "class", "controls-grid svelte-1n6923t"), V(U, "class", "gen-btn svelte-1n6923t"), V(U, "title", "Generate Random Key & IV"), V(I, "class", "key-group svelte-1n6923t"), V(C, "class", "split-view svelte-1n6923t"), V(N, "class", "button-row");
  }, m(he, me) {
    R(he, e, me), ae(n, e, null), q(e, s), ae(i, e, null), q(e, o), ae(f, e, null), q(e, l), ae(h, e, null), R(he, v, me), ae(b, he, me), R(he, _, me), R(he, C, me), q(C, I), ae(S, I, null), q(I, F), q(I, U), q(C, Q), le && le.m(C, null), R(he, P, me), R(he, N, me), ae(L, N, null), q(N, B), ae(u, N, null), q(N, p), ae(d, N, null), R(he, y, me), Z && Z.m(he, me), R(he, w, me), ve && ve.m(he, me), R(he, E, me), M = true, x || (g = Kt(U, "click", t3[14]), x = true);
  }, p(he, me) {
    const ce = {};
    !r && me & 2 && (r = true, ce.value = he[1], qe(() => r = false)), n.$set(ce);
    const ye = {};
    !a && me & 32 && (a = true, ye.value = he[5], qe(() => a = false)), i.$set(ye);
    const Oe = {};
    !c && me & 1 && (c = true, Oe.value = he[0], qe(() => c = false)), f.$set(Oe);
    const Se = {};
    !m && me & 64 && (m = true, Se.value = he[6], qe(() => m = false)), h.$set(Se);
    const Ce = {};
    me & 2 && (Ce.label = he[1] === "encrypt" ? "Plaintext:" : "Ciphertext (Base64):"), me & 2 && (Ce.placeholder = he[1] === "encrypt" ? "Secret message..." : "Encrypted string..."), !A && me & 4 && (A = true, Ce.value = he[2], qe(() => A = false)), b.$set(Ce);
    const Ne = {};
    me & 32 && (Ne.placeholder = `Enter ${parseInt(he[5]) / 8} bytes...`), !$ && me & 8 && ($ = true, Ne.value = he[3], qe(() => $ = false)), S.$set(Ne), he[9] ? le ? (le.p(he, me), me & 512 && W(le, 1)) : (le = z_(he), le.c(), W(le, 1), le.m(C, null)) : le && (Xt(), j(le, 1, 1, () => {
      le = null;
    }), er());
    const $e = {};
    me & 67108866 && ($e.$$scope = { dirty: me, ctx: he }), L.$set($e);
    const Re = {};
    me & 67108864 && (Re.$$scope = { dirty: me, ctx: he }), u.$set(Re), he[8] ? Z ? Z.p(he, me) : (Z = G_(he), Z.c(), Z.m(w.parentNode, w)) : Z && (Z.d(1), Z = null), he[7] ? ve ? (ve.p(he, me), me & 128 && W(ve, 1)) : (ve = V_(he), ve.c(), W(ve, 1), ve.m(E.parentNode, E)) : ve && (Xt(), j(ve, 1, 1, () => {
      ve = null;
    }), er());
  }, i(he) {
    M || (W(n.$$.fragment, he), W(i.$$.fragment, he), W(f.$$.fragment, he), W(h.$$.fragment, he), W(b.$$.fragment, he), W(S.$$.fragment, he), W(le), W(L.$$.fragment, he), W(u.$$.fragment, he), W(d.$$.fragment, he), W(ve), M = true);
  }, o(he) {
    j(n.$$.fragment, he), j(i.$$.fragment, he), j(f.$$.fragment, he), j(h.$$.fragment, he), j(b.$$.fragment, he), j(S.$$.fragment, he), j(le), j(L.$$.fragment, he), j(u.$$.fragment, he), j(d.$$.fragment, he), j(ve), M = false;
  }, d(he) {
    he && (D(e), D(v), D(_), D(C), D(P), D(N), D(y), D(w), D(E)), oe(n), oe(i), oe(f), oe(h), oe(b, he), oe(S), le && le.d(), oe(L), oe(u), oe(d), Z && Z.d(he), ve && ve.d(he), x = false, g();
  } };
}
function Die(t3) {
  let e, n, r, s, i, a, o;
  return { c() {
    e = H("p"), e.innerHTML = `<strong>Advanced Encryption Standard (AES)</strong> is a symmetric key block cipher, standardized by 
    the National Institute of Standards and Technology (NIST) in 2001. 
    It is used worldwide to secure data and communications and has become the most widely adopted encryption algorithm.`, n = z(), r = H("p"), r.innerHTML = "<strong>AES Key Features:</strong>", s = z(), i = H("ul"), i.innerHTML = `<li><strong>Symmetric Encryption:</strong> AES uses the same key for both encryption and decryption, making it 
        faster and more efficient compared to asymmetric encryption methods like RSA.</li> <li><strong>Block Cipher:</strong> AES processes data in fixed-size blocks (128 bits). 
        If the input data is larger, it is divided into multiple blocks and processed sequentially.</li> <li><strong>Key Sizes:</strong> AES supports three different key sizes: 128, 192, and 256 bits. 
        AES-128 is commonly used, but AES-256 is preferred for higher security levels.</li> <li><strong>Security:</strong> AES is considered secure against all practical cryptographic attacks, 
        including brute force, and has been extensively analyzed by cryptographers. As of now, no effective attack has been found.</li> <li><strong>Modes: </strong>The tool supports the modes: <b>CBC, ECB (not secure), CTR, OFB, CFB</b></li>`, a = z(), o = H("ul"), o.innerHTML = "<li><strong>Block Modes:</strong> <ul><li><strong>CBC (Recommended):</strong> Uses an IV to make each block unique. Secure.</li> <li><strong>ECB (Unsafe):</strong> Encrypts identical blocks identically. Do not use for secrets.</li> <li><strong>GCM/CTR:</strong> Stream-like modes, very fast.</li></ul></li> <li><strong>IV (Initialization Vector):</strong> Random data mixed with the first block to ensure randomness.</li>";
  }, m(f, c) {
    R(f, e, c), R(f, n, c), R(f, r, c), R(f, s, c), R(f, i, c), R(f, a, c), R(f, o, c);
  }, p: dt, d(f) {
    f && (D(e), D(n), D(r), D(s), D(i), D(a), D(o));
  } };
}
function Rie(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "AES Encryption / Decryption", $$slots: { default: [Tie] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About AES", links: t3[17], $$slots: { default: [Die] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 67109887 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 67108864 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function Fie(t3, e, n) {
  let r, s = "encrypt", i = "", a = "", o = "", f = "256", c = "CBC", l = "Pkcs7", h = "", m = "";
  const v = [{ value: "encrypt", label: "Encrypt (Plaintext -> Base64)" }, { value: "decrypt", label: "Decrypt (Base64 -> Plaintext)" }], b = [{ value: "128", label: "AES-128 (16 byte key)" }, { value: "192", label: "AES-192 (24 byte key)" }, { value: "256", label: "AES-256 (32 byte key)" }], A = [{ value: "CBC", label: "CBC (Cipher Block Chaining)" }, { value: "ECB", label: "ECB (Electronic Codebook)" }, { value: "CTR", label: "CTR (Counter)" }, { value: "OFB", label: "OFB (Output Feedback)" }, { value: "CFB", label: "CFB (Cipher Feedback)" }], _ = [{ value: "Pkcs7", label: "Pkcs7 (Default)" }, { value: "ZeroPadding", label: "ZeroPadding" }, { value: "Iso10126", label: "Iso10126" }, { value: "NoPadding", label: "NoPadding" }];
  function C() {
    const p = Sie(parseInt(f));
    n(3, a = p.key), n(4, o = p.iv);
  }
  function I() {
    if (n(8, m = ""), n(7, h = ""), !i) return n(8, m = "Please enter text to process.");
    if (!a) return n(8, m = "Please provide a secret key.");
    if (r && !o) return n(8, m = "IV is required for this mode.");
    try {
      s === "encrypt" ? n(7, h = kie(i, a, o, c, l)) : n(7, h = Iie(i, a, o, c, l));
    } catch (p) {
      n(8, m = p.message);
    }
  }
  function S() {
    n(1, s = s === "encrypt" ? "decrypt" : "encrypt"), h && !m ? (n(2, i = h), n(7, h = "")) : (n(2, i = ""), n(7, h = ""));
  }
  const $ = [{ text: "AES - Wikipedia", url: "https://en.wikipedia.org/wiki/Advanced_Encryption_Standard" }, { text: "How does AES work? - Crypto StackExchange", url: "https://crypto.stackexchange.com/questions/3926/how-does-aes-work" }, { text: "AES Key Lengths - Keylength.com", url: "https://www.keylength.com/en/4/" }];
  function F(p) {
    s = p, n(1, s);
  }
  function U(p) {
    f = p, n(5, f);
  }
  function Q(p) {
    c = p, n(0, c);
  }
  function P(p) {
    l = p, n(6, l);
  }
  function N(p) {
    i = p, n(2, i);
  }
  function L(p) {
    a = p, n(3, a);
  }
  function B(p) {
    o = p, n(4, o);
  }
  const u = () => {
    n(2, i = ""), n(7, h = ""), n(8, m = "");
  };
  return t3.$$.update = () => {
    t3.$$.dirty & 1 && n(9, r = c !== "ECB");
  }, [c, s, i, a, o, f, l, h, m, r, v, b, A, _, C, I, S, $, F, U, Q, P, N, L, B, u];
}
let Pie = class extends xt {
  constructor(e) {
    super(), wt(this, e, Fie, Rie, At, {});
  }
};
const sD = { CBC: ur.mode.CBC, ECB: ur.mode.ECB }, aD = { Pkcs7: ur.pad.Pkcs7, ZeroPadding: ur.pad.ZeroPadding, NoPadding: ur.pad.NoPadding };
function Nie(t3, e, n, r, s) {
  try {
    const i = O1(e), a = n ? O1(n) : void 0;
    if (i.sigBytes !== 8) throw new Error(`Invalid Key Length: DES requires exactly 8 bytes (64 bits). You provided ${i.sigBytes} bytes.`);
    const o = { mode: sD[r] || ur.mode.CBC, padding: aD[s] || ur.pad.Pkcs7 };
    return a && r !== "ECB" && (o.iv = a), ur.DES.encrypt(t3, i, o).toString();
  } catch (i) {
    throw new Error("Encryption Error: " + i.message);
  }
}
function Uie(t3, e, n, r, s) {
  try {
    const i = O1(e), a = n ? O1(n) : void 0;
    if (i.sigBytes !== 8) throw new Error("Invalid Key Length: DES requires exactly 8 bytes.");
    const o = { mode: sD[r] || ur.mode.CBC, padding: aD[s] || ur.pad.Pkcs7 };
    a && r !== "ECB" && (o.iv = a);
    const c = ur.DES.decrypt(t3, i, o).toString(ur.enc.Utf8);
    if (!c) throw new Error("Decryption failed. Check Key, IV, or Mode.");
    return c;
  } catch (i) {
    throw new Error("Decryption Error: " + i.message);
  }
}
function Lie() {
  return { key: ur.lib.WordArray.random(8).toString(ur.enc.Hex), iv: ur.lib.WordArray.random(8).toString(ur.enc.Hex) };
}
function O1(t3) {
  return /^[0-9a-fA-F]+$/.test(t3) && t3.length % 2 === 0 ? ur.enc.Hex.parse(t3) : ur.enc.Utf8.parse(t3);
}
function Y_(t3) {
  let e, n, r;
  function s(a) {
    t3[21](a);
  }
  let i = { label: "Initialization Vector (IV):", placeholder: "8 bytes (16 hex chars)" };
  return t3[4] !== void 0 && (i.value = t3[4]), e = new et({ props: i }), Qe.push(() => ze(e, "value", s)), { c() {
    fe(e.$$.fragment);
  }, m(a, o) {
    ae(e, a, o), r = true;
  }, p(a, o) {
    const f = {};
    !n && o & 16 && (n = true, f.value = a[4], qe(() => n = false)), e.$set(f);
  }, i(a) {
    r || (W(e.$$.fragment, a), r = true);
  }, o(a) {
    j(e.$$.fragment, a), r = false;
  }, d(a) {
    oe(e, a);
  } };
}
function Oie(t3) {
  let e = t3[1] === "encrypt" ? "Encrypt Message" : "Decrypt Message", n;
  return { c() {
    n = we(e);
  }, m(r, s) {
    R(r, n, s);
  }, p(r, s) {
    s & 2 && e !== (e = r[1] === "encrypt" ? "Encrypt Message" : "Decrypt Message") && Ze(n, e);
  }, d(r) {
    r && D(n);
  } };
}
function Qie(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function W_(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[7]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 128 && Ze(n, r[7]);
  }, d(r) {
    r && D(e);
  } };
}
function J_(t3) {
  let e, n;
  return e = new et({ props: { label: t3[1] === "encrypt" ? "Encrypted Output (Base64):" : "Decrypted Plaintext:", value: t3[6], readonly: true, expandable: true, withCopy: true, rows: 3 } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, s) {
    const i = {};
    s & 2 && (i.label = r[1] === "encrypt" ? "Encrypted Output (Base64):" : "Decrypted Plaintext:"), s & 64 && (i.value = r[6]), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function Kie(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U, Q, P, N, L, B, u, p, d, y, w, E;
  function M(se) {
    t3[16](se);
  }
  let x = { label: "Operation:", options: t3[9] };
  t3[1] !== void 0 && (x.value = t3[1]), n = new Ht({ props: x }), Qe.push(() => ze(n, "value", M));
  function g(se) {
    t3[17](se);
  }
  let k = { label: "Block Mode:", options: t3[10] };
  t3[0] !== void 0 && (k.value = t3[0]), i = new Ht({ props: k }), Qe.push(() => ze(i, "value", g));
  function T(se) {
    t3[18](se);
  }
  let O = { label: "Padding:", options: t3[11] };
  t3[5] !== void 0 && (O.value = t3[5]), f = new Ht({ props: O }), Qe.push(() => ze(f, "value", T));
  function K(se) {
    t3[19](se);
  }
  let Y = { label: t3[1] === "encrypt" ? "Plaintext:" : "Ciphertext (Base64):", placeholder: t3[1] === "encrypt" ? "Secret message..." : "Encrypted string...", expandable: true, rows: 3 };
  t3[2] !== void 0 && (Y.value = t3[2]), h = new et({ props: Y }), Qe.push(() => ze(h, "value", K));
  function J(se) {
    t3[20](se);
  }
  let G = { label: "Secret Key (8 Bytes / 16 Hex Chars):", placeholder: "e.g. 0123456789ABCDEF" };
  t3[3] !== void 0 && (G.value = t3[3]), _ = new et({ props: G }), Qe.push(() => ze(_, "value", J));
  let X = t3[8] && Y_(t3);
  Q = new ut({ props: { $$slots: { default: [Oie] }, $$scope: { ctx: t3 } } }), Q.$on("click", t3[13]), N = new ut({ props: { variant: "secondary", $$slots: { default: [Qie] }, $$scope: { ctx: t3 } } }), N.$on("click", t3[22]), B = new hn({}), B.$on("click", t3[14]);
  let ie = t3[7] && W_(t3), de = t3[6] && J_(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), fe(i.$$.fragment), o = z(), fe(f.$$.fragment), l = z(), fe(h.$$.fragment), v = z(), b = H("div"), A = H("div"), fe(_.$$.fragment), I = z(), S = H("button"), S.textContent = "Generate Random", $ = z(), X && X.c(), F = z(), U = H("div"), fe(Q.$$.fragment), P = z(), fe(N.$$.fragment), L = z(), fe(B.$$.fragment), u = z(), ie && ie.c(), p = z(), de && de.c(), d = Lt(), V(e, "class", "controls-grid svelte-1h5izvs"), V(S, "class", "gen-btn svelte-1h5izvs"), V(S, "title", "Generate Random Key & IV"), V(A, "class", "key-group svelte-1h5izvs"), V(b, "class", "split-view svelte-1h5izvs"), V(U, "class", "button-row");
  }, m(se, te) {
    R(se, e, te), ae(n, e, null), q(e, s), ae(i, e, null), q(e, o), ae(f, e, null), R(se, l, te), ae(h, se, te), R(se, v, te), R(se, b, te), q(b, A), ae(_, A, null), q(A, I), q(A, S), q(b, $), X && X.m(b, null), R(se, F, te), R(se, U, te), ae(Q, U, null), q(U, P), ae(N, U, null), q(U, L), ae(B, U, null), R(se, u, te), ie && ie.m(se, te), R(se, p, te), de && de.m(se, te), R(se, d, te), y = true, w || (E = Kt(S, "click", t3[12]), w = true);
  }, p(se, te) {
    const le = {};
    !r && te & 2 && (r = true, le.value = se[1], qe(() => r = false)), n.$set(le);
    const Z = {};
    !a && te & 1 && (a = true, Z.value = se[0], qe(() => a = false)), i.$set(Z);
    const ve = {};
    !c && te & 32 && (c = true, ve.value = se[5], qe(() => c = false)), f.$set(ve);
    const he = {};
    te & 2 && (he.label = se[1] === "encrypt" ? "Plaintext:" : "Ciphertext (Base64):"), te & 2 && (he.placeholder = se[1] === "encrypt" ? "Secret message..." : "Encrypted string..."), !m && te & 4 && (m = true, he.value = se[2], qe(() => m = false)), h.$set(he);
    const me = {};
    !C && te & 8 && (C = true, me.value = se[3], qe(() => C = false)), _.$set(me), se[8] ? X ? (X.p(se, te), te & 256 && W(X, 1)) : (X = Y_(se), X.c(), W(X, 1), X.m(b, null)) : X && (Xt(), j(X, 1, 1, () => {
      X = null;
    }), er());
    const ce = {};
    te & 8388610 && (ce.$$scope = { dirty: te, ctx: se }), Q.$set(ce);
    const ye = {};
    te & 8388608 && (ye.$$scope = { dirty: te, ctx: se }), N.$set(ye), se[7] ? ie ? ie.p(se, te) : (ie = W_(se), ie.c(), ie.m(p.parentNode, p)) : ie && (ie.d(1), ie = null), se[6] ? de ? (de.p(se, te), te & 64 && W(de, 1)) : (de = J_(se), de.c(), W(de, 1), de.m(d.parentNode, d)) : de && (Xt(), j(de, 1, 1, () => {
      de = null;
    }), er());
  }, i(se) {
    y || (W(n.$$.fragment, se), W(i.$$.fragment, se), W(f.$$.fragment, se), W(h.$$.fragment, se), W(_.$$.fragment, se), W(X), W(Q.$$.fragment, se), W(N.$$.fragment, se), W(B.$$.fragment, se), W(de), y = true);
  }, o(se) {
    j(n.$$.fragment, se), j(i.$$.fragment, se), j(f.$$.fragment, se), j(h.$$.fragment, se), j(_.$$.fragment, se), j(X), j(Q.$$.fragment, se), j(N.$$.fragment, se), j(B.$$.fragment, se), j(de), y = false;
  }, d(se) {
    se && (D(e), D(l), D(v), D(b), D(F), D(U), D(u), D(p), D(d)), oe(n), oe(i), oe(f), oe(h, se), oe(_), X && X.d(), oe(Q), oe(N), oe(B), ie && ie.d(se), de && de.d(se), w = false, E();
  } };
}
function Hie(t3) {
  let e, n, r, s, i, a, o, f, c;
  return { c() {
    e = H("p"), e.innerHTML = "<strong>DES (Data Encryption Standard)</strong> is a historic encryption algorithm from the 1970s.", n = z(), r = H("p"), r.innerHTML = "<strong>Warning:</strong> DES uses a short 56-bit key (represented as 64 bits/8 bytes), which is considered <strong>insecure</strong> today because it can be brute-forced easily. Use AES for secure applications.", s = z(), i = H("ul"), i.innerHTML = "<li><strong>Key Size:</strong> Strictly 8 bytes (64 bits).</li> <li><strong>Block Size:</strong> 8 bytes (64 bits).</li>", a = z(), o = H("p"), o.innerHTML = "<b>Modes:</b>", f = z(), c = H("ul"), c.innerHTML = "<li><b>ECB (Electronic Codebook):</b> Simplest form, but less secure.</li> <li><b>CBC (Cipher Block Chaining):</b> Uses an initialization vector (IV) for better security.</li>";
  }, m(l, h) {
    R(l, e, h), R(l, n, h), R(l, r, h), R(l, s, h), R(l, i, h), R(l, a, h), R(l, o, h), R(l, f, h), R(l, c, h);
  }, p: dt, d(l) {
    l && (D(e), D(n), D(r), D(s), D(i), D(a), D(o), D(f), D(c));
  } };
}
function qie(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "DES Encryption / Decryption", $$slots: { default: [Kie] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About DES", links: t3[15], $$slots: { default: [Hie] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 8389119 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 8388608 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function zie(t3, e, n) {
  let r, s = "encrypt", i = "", a = "", o = "", f = "CBC", c = "Pkcs7", l = "", h = "";
  const m = [{ value: "encrypt", label: "Encrypt (Plaintext -> Base64)" }, { value: "decrypt", label: "Decrypt (Base64 -> Plaintext)" }], v = [{ value: "CBC", label: "CBC (Cipher Block Chaining)" }, { value: "ECB", label: "ECB (Electronic Codebook)" }], b = [{ value: "Pkcs7", label: "Pkcs7 (Default)" }, { value: "ZeroPadding", label: "ZeroPadding" }, { value: "NoPadding", label: "NoPadding" }];
  function A() {
    const L = Lie();
    n(3, a = L.key), n(4, o = L.iv);
  }
  function _() {
    if (n(7, h = ""), n(6, l = ""), !i) return n(7, h = "Please enter text to process.");
    if (!a) return n(7, h = "Please provide a secret key.");
    if (r && !o) return n(7, h = "IV is required for this mode.");
    try {
      s === "encrypt" ? n(6, l = Nie(i, a, o, f, c)) : n(6, l = Uie(i, a, o, f, c));
    } catch (L) {
      n(7, h = L.message);
    }
  }
  function C() {
    n(1, s = s === "encrypt" ? "decrypt" : "encrypt"), l && !h ? (n(2, i = l), n(6, l = "")) : (n(2, i = ""), n(6, l = ""));
  }
  const I = [{ text: "DES - Wikipedia", url: "https://en.wikipedia.org/wiki/Data_Encryption_Standard" }, { text: "DES - Splunk", url: "https://www.splunk.com/en_us/blog/learn/des-data-encryption-standard.html" }, { text: "DES - Tutorialspoint", url: "https://www.tutorialspoint.com/cryptography/data_encryption_standard.htm" }];
  function S(L) {
    s = L, n(1, s);
  }
  function $(L) {
    f = L, n(0, f);
  }
  function F(L) {
    c = L, n(5, c);
  }
  function U(L) {
    i = L, n(2, i);
  }
  function Q(L) {
    a = L, n(3, a);
  }
  function P(L) {
    o = L, n(4, o);
  }
  const N = () => {
    n(2, i = ""), n(6, l = ""), n(7, h = "");
  };
  return t3.$$.update = () => {
    t3.$$.dirty & 1 && n(8, r = f !== "ECB");
  }, [f, s, i, a, o, c, l, h, r, m, v, b, A, _, C, I, S, $, F, U, Q, P, N];
}
class Gie extends xt {
  constructor(e) {
    super(), wt(this, e, zie, qie, At, {});
  }
}
const oD = { ECB: ur.mode.ECB, CBC: ur.mode.CBC }, fD = { Pkcs7: ur.pad.Pkcs7, ZeroPadding: ur.pad.ZeroPadding, NoPadding: ur.pad.NoPadding };
function Vie(t3, e, n, r, s) {
  try {
    const i = Q1(e), a = n ? Q1(n) : void 0;
    if (i.sigBytes !== 24 && i.sigBytes !== 16) throw new Error(`Invalid Key Length: 3DES requires 16 or 24 bytes. You provided ${i.sigBytes} bytes.`);
    const o = { mode: oD[r] || ur.mode.ECB, padding: fD[s] || ur.pad.Pkcs7 };
    return a && r !== "ECB" && (o.iv = a), ur.TripleDES.encrypt(t3, i, o).toString();
  } catch (i) {
    throw new Error("Encryption Error: " + i.message);
  }
}
function Yie(t3, e, n, r, s) {
  try {
    const i = Q1(e), a = n ? Q1(n) : void 0;
    if (i.sigBytes !== 24 && i.sigBytes !== 16) throw new Error("Invalid Key Length: 3DES requires 16 or 24 bytes.");
    const o = { mode: oD[r] || ur.mode.ECB, padding: fD[s] || ur.pad.Pkcs7 };
    a && r !== "ECB" && (o.iv = a);
    const c = ur.TripleDES.decrypt(t3, i, o).toString(ur.enc.Utf8);
    if (!c) throw new Error("Decryption failed. Check Key, IV, or Mode.");
    return c;
  } catch (i) {
    throw new Error("Decryption Error: " + i.message);
  }
}
function Wie(t3 = 24) {
  return { key: ur.lib.WordArray.random(t3).toString(ur.enc.Hex), iv: ur.lib.WordArray.random(8).toString(ur.enc.Hex) };
}
function Q1(t3) {
  return /^[0-9a-fA-F]+$/.test(t3) && t3.length % 2 === 0 ? ur.enc.Hex.parse(t3) : ur.enc.Utf8.parse(t3);
}
function Z_(t3) {
  let e, n, r;
  function s(a) {
    t3[24](a);
  }
  let i = { label: "Initialization Vector (IV) - 8 Bytes:", placeholder: "8 bytes (16 hex chars)" };
  return t3[4] !== void 0 && (i.value = t3[4]), e = new et({ props: i }), Qe.push(() => ze(e, "value", s)), { c() {
    fe(e.$$.fragment);
  }, m(a, o) {
    ae(e, a, o), r = true;
  }, p(a, o) {
    const f = {};
    !n && o & 16 && (n = true, f.value = a[4], qe(() => n = false)), e.$set(f);
  }, i(a) {
    r || (W(e.$$.fragment, a), r = true);
  }, o(a) {
    j(e.$$.fragment, a), r = false;
  }, d(a) {
    oe(e, a);
  } };
}
function Jie(t3) {
  let e = t3[1] === "encrypt" ? "Encrypt Message" : "Decrypt Message", n;
  return { c() {
    n = we(e);
  }, m(r, s) {
    R(r, n, s);
  }, p(r, s) {
    s & 2 && e !== (e = r[1] === "encrypt" ? "Encrypt Message" : "Decrypt Message") && Ze(n, e);
  }, d(r) {
    r && D(n);
  } };
}
function Zie(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function j_(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[8]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 256 && Ze(n, r[8]);
  }, d(r) {
    r && D(e);
  } };
}
function X_(t3) {
  let e, n;
  return e = new et({ props: { label: t3[1] === "encrypt" ? "Encrypted Output (Base64):" : "Decrypted Plaintext:", value: t3[7], readonly: true, expandable: true, withCopy: true, rows: 3 } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, s) {
    const i = {};
    s & 2 && (i.label = r[1] === "encrypt" ? "Encrypted Output (Base64):" : "Decrypted Plaintext:"), s & 128 && (i.value = r[7]), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function jie(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U, Q, P, N, L, B, u, p, d, y, w, E, M, x, g;
  function k(he) {
    t3[18](he);
  }
  let T = { label: "Operation:", options: t3[10] };
  t3[1] !== void 0 && (T.value = t3[1]), n = new Ht({ props: T }), Qe.push(() => ze(n, "value", k));
  function O(he) {
    t3[19](he);
  }
  let K = { label: "Key Length:", options: t3[11] };
  t3[5] !== void 0 && (K.value = t3[5]), i = new Ht({ props: K }), Qe.push(() => ze(i, "value", O));
  function Y(he) {
    t3[20](he);
  }
  let J = { label: "Block Mode:", options: t3[12] };
  t3[0] !== void 0 && (J.value = t3[0]), f = new Ht({ props: J }), Qe.push(() => ze(f, "value", Y));
  function G(he) {
    t3[21](he);
  }
  let X = { label: "Padding:", options: t3[13] };
  t3[6] !== void 0 && (X.value = t3[6]), h = new Ht({ props: X }), Qe.push(() => ze(h, "value", G));
  function ie(he) {
    t3[22](he);
  }
  let de = { label: t3[1] === "encrypt" ? "Plaintext:" : "Ciphertext (Base64):", placeholder: t3[1] === "encrypt" ? "Secret message..." : "Encrypted string...", expandable: true, rows: 3 };
  t3[2] !== void 0 && (de.value = t3[2]), b = new et({ props: de }), Qe.push(() => ze(b, "value", ie));
  function se(he) {
    t3[23](he);
  }
  let te = { label: `Secret Key (${t3[5]} Bytes / ${parseInt(t3[5]) * 2} Hex Chars):`, placeholder: `Enter ${t3[5]} bytes...` };
  t3[3] !== void 0 && (te.value = t3[3]), S = new et({ props: te }), Qe.push(() => ze(S, "value", se));
  let le = t3[9] && Z_(t3);
  L = new ut({ props: { $$slots: { default: [Jie] }, $$scope: { ctx: t3 } } }), L.$on("click", t3[15]), u = new ut({ props: { variant: "secondary", $$slots: { default: [Zie] }, $$scope: { ctx: t3 } } }), u.$on("click", t3[25]), d = new hn({}), d.$on("click", t3[16]);
  let Z = t3[8] && j_(t3), ve = t3[7] && X_(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), fe(i.$$.fragment), o = z(), fe(f.$$.fragment), l = z(), fe(h.$$.fragment), v = z(), fe(b.$$.fragment), _ = z(), C = H("div"), I = H("div"), fe(S.$$.fragment), F = z(), U = H("button"), U.textContent = "Generate Random", Q = z(), le && le.c(), P = z(), N = H("div"), fe(L.$$.fragment), B = z(), fe(u.$$.fragment), p = z(), fe(d.$$.fragment), y = z(), Z && Z.c(), w = z(), ve && ve.c(), E = Lt(), V(e, "class", "controls-grid svelte-1n6923t"), V(U, "class", "gen-btn svelte-1n6923t"), V(U, "title", "Generate Random Key & IV"), V(I, "class", "key-group svelte-1n6923t"), V(C, "class", "split-view svelte-1n6923t"), V(N, "class", "button-row");
  }, m(he, me) {
    R(he, e, me), ae(n, e, null), q(e, s), ae(i, e, null), q(e, o), ae(f, e, null), q(e, l), ae(h, e, null), R(he, v, me), ae(b, he, me), R(he, _, me), R(he, C, me), q(C, I), ae(S, I, null), q(I, F), q(I, U), q(C, Q), le && le.m(C, null), R(he, P, me), R(he, N, me), ae(L, N, null), q(N, B), ae(u, N, null), q(N, p), ae(d, N, null), R(he, y, me), Z && Z.m(he, me), R(he, w, me), ve && ve.m(he, me), R(he, E, me), M = true, x || (g = Kt(U, "click", t3[14]), x = true);
  }, p(he, me) {
    const ce = {};
    !r && me & 2 && (r = true, ce.value = he[1], qe(() => r = false)), n.$set(ce);
    const ye = {};
    !a && me & 32 && (a = true, ye.value = he[5], qe(() => a = false)), i.$set(ye);
    const Oe = {};
    !c && me & 1 && (c = true, Oe.value = he[0], qe(() => c = false)), f.$set(Oe);
    const Se = {};
    !m && me & 64 && (m = true, Se.value = he[6], qe(() => m = false)), h.$set(Se);
    const Ce = {};
    me & 2 && (Ce.label = he[1] === "encrypt" ? "Plaintext:" : "Ciphertext (Base64):"), me & 2 && (Ce.placeholder = he[1] === "encrypt" ? "Secret message..." : "Encrypted string..."), !A && me & 4 && (A = true, Ce.value = he[2], qe(() => A = false)), b.$set(Ce);
    const Ne = {};
    me & 32 && (Ne.label = `Secret Key (${he[5]} Bytes / ${parseInt(he[5]) * 2} Hex Chars):`), me & 32 && (Ne.placeholder = `Enter ${he[5]} bytes...`), !$ && me & 8 && ($ = true, Ne.value = he[3], qe(() => $ = false)), S.$set(Ne), he[9] ? le ? (le.p(he, me), me & 512 && W(le, 1)) : (le = Z_(he), le.c(), W(le, 1), le.m(C, null)) : le && (Xt(), j(le, 1, 1, () => {
      le = null;
    }), er());
    const $e = {};
    me & 67108866 && ($e.$$scope = { dirty: me, ctx: he }), L.$set($e);
    const Re = {};
    me & 67108864 && (Re.$$scope = { dirty: me, ctx: he }), u.$set(Re), he[8] ? Z ? Z.p(he, me) : (Z = j_(he), Z.c(), Z.m(w.parentNode, w)) : Z && (Z.d(1), Z = null), he[7] ? ve ? (ve.p(he, me), me & 128 && W(ve, 1)) : (ve = X_(he), ve.c(), W(ve, 1), ve.m(E.parentNode, E)) : ve && (Xt(), j(ve, 1, 1, () => {
      ve = null;
    }), er());
  }, i(he) {
    M || (W(n.$$.fragment, he), W(i.$$.fragment, he), W(f.$$.fragment, he), W(h.$$.fragment, he), W(b.$$.fragment, he), W(S.$$.fragment, he), W(le), W(L.$$.fragment, he), W(u.$$.fragment, he), W(d.$$.fragment, he), W(ve), M = true);
  }, o(he) {
    j(n.$$.fragment, he), j(i.$$.fragment, he), j(f.$$.fragment, he), j(h.$$.fragment, he), j(b.$$.fragment, he), j(S.$$.fragment, he), j(le), j(L.$$.fragment, he), j(u.$$.fragment, he), j(d.$$.fragment, he), j(ve), M = false;
  }, d(he) {
    he && (D(e), D(v), D(_), D(C), D(P), D(N), D(y), D(w), D(E)), oe(n), oe(i), oe(f), oe(h), oe(b, he), oe(S), le && le.d(), oe(L), oe(u), oe(d), Z && Z.d(he), ve && ve.d(he), x = false, g();
  } };
}
function Xie(t3) {
  let e, n, r, s, i;
  return { c() {
    e = H("p"), e.innerHTML = "<strong>Triple DES</strong> applies the DES algorithm three times to each data block to improve security over standard DES.", n = z(), r = H("ul"), r.innerHTML = "<li><b>Note:</b> ECB mode is generally not recommended for sensitive data, as it does not hide data patterns.</li> <li><strong>Key 1, Key 2, Key 3:</strong> Uses 3 keys (effectively 168 bits) or 2 keys (112 bits).</li> <li><strong>Legacy:</strong> While stronger than DES, 3DES is slow and has been deprecated by NIST. Use AES for new applications.</li>", s = z(), i = H("p"), i.textContent = "Use for demonstration purposes only.", St(i, "color", "gray"), St(i, "font-size", "small");
  }, m(a, o) {
    R(a, e, o), R(a, n, o), R(a, r, o), R(a, s, o), R(a, i, o);
  }, p: dt, d(a) {
    a && (D(e), D(n), D(r), D(s), D(i));
  } };
}
function ese(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Triple DES Encryption / Decryption", $$slots: { default: [jie] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Triple DES (3DES)", links: t3[17], $$slots: { default: [Xie] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 67109887 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 67108864 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function tse(t3, e, n) {
  let r, s = "encrypt", i = "", a = "", o = "", f = "24", c = "ECB", l = "Pkcs7", h = "", m = "";
  const v = [{ value: "encrypt", label: "Encrypt (Plaintext -> Base64)" }, { value: "decrypt", label: "Decrypt (Base64 -> Plaintext)" }], b = [{ value: "24", label: "24 Bytes (192 bits) - Standard" }, { value: "16", label: "16 Bytes (128 bits)" }], A = [{ value: "ECB", label: "ECB (Electronic Codebook)" }, { value: "CBC", label: "CBC (Cipher Block Chaining)" }], _ = [{ value: "Pkcs7", label: "Pkcs7 (Default)" }, { value: "ZeroPadding", label: "ZeroPadding" }, { value: "NoPadding", label: "NoPadding" }];
  function C() {
    const p = Wie(parseInt(f));
    n(3, a = p.key), n(4, o = p.iv);
  }
  function I() {
    if (n(8, m = ""), n(7, h = ""), !i) return n(8, m = "Please enter text to process.");
    if (!a) return n(8, m = "Please provide a secret key.");
    if (r && !o) return n(8, m = "IV is required for this mode.");
    try {
      s === "encrypt" ? n(7, h = Vie(i, a, o, c, l)) : n(7, h = Yie(i, a, o, c, l));
    } catch (p) {
      n(8, m = p.message);
    }
  }
  function S() {
    n(1, s = s === "encrypt" ? "decrypt" : "encrypt"), h && !m ? (n(2, i = h), n(7, h = "")) : (n(2, i = ""), n(7, h = ""));
  }
  const $ = [{ text: "Triple DES - Wikipedia", url: "https://en.wikipedia.org/wiki/Triple_DES" }, { text: "Triple DES - Splunk", url: "https://www.splunk.com/en_us/blog/learn/triple-des-data-encryption-standard.html" }, { text: "Triple DES - Geeks for Geeks", url: "https://www.geeksforgeeks.org/computer-networks/triple-des-3des/" }];
  function F(p) {
    s = p, n(1, s);
  }
  function U(p) {
    f = p, n(5, f);
  }
  function Q(p) {
    c = p, n(0, c);
  }
  function P(p) {
    l = p, n(6, l);
  }
  function N(p) {
    i = p, n(2, i);
  }
  function L(p) {
    a = p, n(3, a);
  }
  function B(p) {
    o = p, n(4, o);
  }
  const u = () => {
    n(2, i = ""), n(7, h = ""), n(8, m = "");
  };
  return t3.$$.update = () => {
    t3.$$.dirty & 1 && n(9, r = c !== "ECB");
  }, [c, s, i, a, o, f, l, h, m, r, v, b, A, _, C, I, S, $, F, U, Q, P, N, L, B, u];
}
class rse extends xt {
  constructor(e) {
    super(), wt(this, e, tse, ese, At, {});
  }
}
function nse(t3) {
  let e, n, r, s, i, a, o, f, c;
  return { c() {
    e = H("div"), n = H("label"), r = H("input"), s = z(), i = H("span"), a = z(), o = H("span"), o.textContent = "Auto Update", V(r, "type", "checkbox"), V(r, "class", "svelte-um1uj4"), V(i, "class", "slider svelte-um1uj4"), V(n, "class", "switch svelte-um1uj4"), V(o, "class", "label-text svelte-um1uj4"), V(e, "class", "auto-update-wrapper svelte-um1uj4");
  }, m(l, h) {
    R(l, e, h), q(e, n), q(n, r), r.checked = t3[0], q(n, s), q(n, i), q(e, a), q(e, o), f || (c = Kt(r, "change", t3[1]), f = true);
  }, p(l, [h]) {
    h & 1 && (r.checked = l[0]);
  }, i: dt, o: dt, d(l) {
    l && D(e), f = false, c();
  } };
}
function ise(t3, e, n) {
  let { checked: r = false } = e;
  function s() {
    r = this.checked, n(0, r);
  }
  return t3.$$set = (i) => {
    "checked" in i && n(0, r = i.checked);
  }, [r, s];
}
class xr extends xt {
  constructor(e) {
    super(), wt(this, e, ise, nse, At, { checked: 0 });
  }
}
var lp = { exports: {} }, lD = { exports: {} };
(function(t3, e) {
  (function(n, r) {
    t3.exports = r(Lr);
  })(mt, function(n) {
    return n.enc.Utf8;
  });
})(lD);
var sse = lD.exports, ase = { exports: {} };
(function(t3, e) {
  (function(n, r) {
    t3.exports = r(Lr);
  })(mt, function(n) {
    return n.enc.Latin1;
  });
})(ase);
var uD = { exports: {} };
(function(t3, e) {
  (function(n, r) {
    t3.exports = r(Lr);
  })(mt, function(n) {
    return n.enc.Hex;
  });
})(uD);
var ose = uD.exports, cD = { exports: {} };
(function(t3, e) {
  (function(n, r, s) {
    t3.exports = r(Lr, gm(), mm());
  })(mt, function(n) {
    return n.HmacSHA256;
  });
})(cD);
var fse = cD.exports, Id = {};
Id.version = "1.0.0";
Id.encode = function(e) {
  return e.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
};
Id.decode = function(e) {
  return e += Array(5 - e.length % 4).join("="), e = e.replace(/\-/g, "+").replace(/\_/g, "/"), new hr(e, "base64");
};
Id.validate = function(e) {
  return /^[A-Za-z0-9\-_]+$/.test(e);
};
var lse = Id, ey = { exports: {} }, eE;
function use() {
  return eE || (eE = 1, function(t3, e) {
    var n = b4(), r = function(s) {
      var i = n.decode64toHex(s);
      if (i.length !== n.hexBits(256)) throw new Error("Secret must be 32 url-safe base64-encoded bytes.");
      this.signingKeyHex = i.slice(0, n.hexBits(128)), this.signingKey = n.Hex.parse(this.signingKeyHex), this.encryptionKeyHex = i.slice(n.hexBits(128)), this.encryptionKey = n.Hex.parse(this.encryptionKeyHex);
    };
    t3.exports = r;
  }(ey)), ey.exports;
}
var ty = { exports: {} }, tE;
function cse() {
  return tE || (tE = 1, function(t3) {
    var e = b4();
    t3 = t3.exports = function(n) {
      var r = function(i) {
        i = i || {}, this.secret = i.secret || n.secret, this.ttl = i.ttl || n.ttl, i.ttl === 0 && (this.ttl = 0), this.message = i.message, this.cipherText = i.cipherText, this.token = i.token, this.version = i.version || e.parseHex(n.versionHex), this.optsIV = i.iv, this.maxClockSkew = 60, i.time ? this.setTime(Date.parse(i.time)) : this.setTime();
      };
      return r.prototype = { setIV: e.setIV, setTime: function(i) {
        this.time = e.timeBytes(i);
      }, toString: function() {
        return this.encoded ? this.token : this.message;
      }, encode: function(i) {
        if (!this.secret) throw new Error("Secret not set");
        return this.encoded = true, this.setIV(this.optsIV), this.message = i || this.message, this.cipherText = e.encryptMessage(this.message, this.secret.encryptionKey, this.iv), this.token = e.createToken(this.secret.signingKey, this.time, this.iv, this.cipherText), this.token;
      }, decode: function(i) {
        if (!this.secret) throw new Error("Secret not set");
        this.encoded = false, this.token = i || this.token;
        var a = e.decode64toHex(this.token), o = e.hexBits(8), f = o + e.hexBits(64), c = f + e.hexBits(128), l = a.length - e.hexBits(256), h = e.parseHex(a.slice(o, f));
        if (this.version = e.parseHex(a.slice(0, o)), this.version != 128) throw new Error("Invalid version");
        this.time = new Date(h * 1e3);
        var m = /* @__PURE__ */ new Date(), v = (m - this.time) / 1e3;
        if (this.ttl > 0) {
          if (v > this.ttl) throw new Error("Invalid Token: TTL");
          if (m / 1e3 + this.maxClockSkew < h) throw new Error("far-future timestamp");
        }
        this.ivHex = a.slice(f, c), this.iv = e.Hex.parse(this.ivHex), this.cipherTextHex = a.slice(c, l), this.cipherText = e.Hex.parse(this.cipherTextHex), this.hmacHex = a.slice(l);
        for (var b = e.createHmac(this.secret.signingKey, e.timeBytes(this.time), this.iv, this.cipherText), A = b.toString(e.Hex), _ = 0, C = 0; C < 64; C++) _ += A.charCodeAt(C) ^ this.hmacHex.charCodeAt(C);
        if (_ != 0) throw new Error("Invalid Token: HMAC");
        return this.message = e.decryptMessage(this.cipherText, this.secret.encryptionKey, this.iv), this.message;
      } }, r;
    };
  }(ty)), ty.exports;
}
var rE;
function b4() {
  return rE || (rE = 1, function(t3, e) {
    var n = rD, r = sse, s = ose, i = yl, a = fse, o = lse, f = vl();
    String.prototype.lpad = function(I, S) {
      for (var $ = this; $.length < S; ) $ = I + $;
      return $;
    };
    var c = function(S) {
      return S.replace(/\+/g, "-").replace(/\//g, "_");
    }, l = function(S) {
      return parseInt("0x" + S);
    }, h = function(S) {
      return S / 8 * 2;
    }, m = function(S) {
      var $ = o.decode(S.replace(/=+$/, ""));
      return new hr.from($).toString("hex");
    }, v = function(S) {
      var $ = "";
      for (var F in S) $ += Number(F).toString(16).lpad("0", 2);
      return $;
    }, b = function(I) {
      return f.randomBytes(128 / 8).toString("hex");
    }, A = function(S) {
      return S ? this.ivHex = v(S) : this.ivHex = b(), this.iv = s.parse(this.ivHex), this.ivHex;
    }, _ = function(S) {
      S ? S = S / 1e3 : S = Math.round(/* @__PURE__ */ new Date() / 1e3);
      var $ = S.toString(16).lpad("0", "16");
      return s.parse($);
    }, C = function(S) {
      this.Hex = s, this.Base64 = i, this.parseHex = l, this.decode64toHex = m, this.hexBits = h, this.urlsafe = c, this.setSecret = function(F) {
        return this.secret = new this.Secret(F), this.secret;
      }, this.ArrayToHex = v, this.setIV = A, this.encryptMessage = function($, F, U) {
        var Q = n.encrypt($, F, { iv: U });
        return Q.ciphertext;
      }, this.decryptMessage = function($, F, U) {
        var Q = {};
        Q.key = F, Q.iv = U, Q.ciphertext = $;
        var P = n.decrypt(Q, F, { iv: U });
        return P.toString(r);
      }, this.timeBytes = _, this.createToken = function($, F, U, Q) {
        var P = this.createHmac($, F, U, Q), N = s.parse(this.versionHex);
        return N = N.concat(F), N = N.concat(U), N = N.concat(Q), N = N.concat(P), c(N.toString(i));
      }, this.createHmac = function(F, U, Q, P) {
        var N = s.parse(this.versionHex);
        return N = N.concat(U), N = N.concat(Q), N = N.concat(P), a(N, F);
      }, this.Secret = use(), this.Token = cse()(this), S = S || {}, this.ttl = S.ttl || 60, S.ttl === 0 && (this.ttl = 0), this.versionHex = "80", this.setIV(S.iv), S.secret && this.setSecret(S.secret);
    };
    e = t3.exports = C, C.call(e);
  }(lp, lp.exports)), lp.exports;
}
var hse = b4();
const K1 = Fa(hse);
function nE() {
  const t3 = new Uint8Array(32);
  window.crypto.getRandomValues(t3);
  let e = "";
  for (let n = 0; n < t3.length; n++) e += String.fromCharCode(t3[n]);
  return window.btoa(e).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
function dse(t3, e) {
  try {
    const n = new K1.Secret(e);
    return new K1.Token({ secret: n, ttl: 0 }).encode(t3);
  } catch {
    throw new Error("Encryption failed. Check your key format.");
  }
}
function pse(t3, e) {
  try {
    const n = new K1.Secret(e), s = new K1.Token({ secret: n, token: t3, ttl: 0 }).decode();
    if (!s) throw new Error("Invalid Token or Key");
    return s;
  } catch {
    throw new Error("Decryption failed. Ensure the key matches and the text is a valid Fernet token.");
  }
}
function gse(t3) {
  let e = t3[2] === "encrypt" ? "Encrypt Message" : "Decrypt Token", n;
  return { c() {
    n = we(e);
  }, m(r, s) {
    R(r, n, s);
  }, p(r, s) {
    s & 4 && e !== (e = r[2] === "encrypt" ? "Encrypt Message" : "Decrypt Token") && Ze(n, e);
  }, d(r) {
    r && D(n);
  } };
}
function mse(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function iE(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[5]), V(e, "class", "msg error svelte-10f7tbs");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 32 && Ze(n, r[5]);
  }, d(r) {
    r && D(e);
  } };
}
function sE(t3) {
  let e, n, r = t3[2] === "encrypt" ? "Encrypted Token:" : "Decrypted Message:", s, i, a, o, f;
  return { c() {
    e = H("div"), n = H("label"), s = we(r), i = z(), a = H("textarea"), o = z(), f = H("small"), f.textContent = "Result copied to clipboard automatically (optional logic)", V(n, "class", "svelte-10f7tbs"), a.readOnly = true, V(a, "rows", "4"), a.value = t3[4], V(a, "class", "result-box svelte-10f7tbs"), V(e, "class", "result-area");
  }, m(c, l) {
    R(c, e, l), q(e, n), q(n, s), q(e, i), q(e, a), q(e, o), q(e, f);
  }, p(c, l) {
    l & 4 && r !== (r = c[2] === "encrypt" ? "Encrypted Token:" : "Decrypted Message:") && Ze(s, r), l & 16 && (a.value = c[4]);
  }, d(c) {
    c && D(e);
  } };
}
function vse(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S = t3[2] === "encrypt" ? "Plaintext Message" : "Fernet Token (Ciphertext)", $, F, U, Q, P, N, L, B, u, p, d, y, w, E, M, x, g, k, T;
  L = new ut({ props: { $$slots: { default: [gse] }, $$scope: { ctx: t3 } } }), L.$on("click", t3[7]), p = new ut({ props: { variant: "secondary", $$slots: { default: [mse] }, $$scope: { ctx: t3 } } }), p.$on("click", t3[13]);
  function O(G) {
    t3[14](G);
  }
  let K = {};
  t3[1] !== void 0 && (K.checked = t3[1]), w = new xr({ props: K }), Qe.push(() => ze(w, "checked", O));
  let Y = t3[5] && iE(t3), J = t3[4] && sE(t3);
  return { c() {
    e = H("div"), n = H("button"), n.textContent = "Encrypt", r = z(), s = H("button"), s.textContent = "Decrypt", i = z(), a = H("div"), o = H("div"), f = H("label"), f.textContent = "Secret Key (32-byte Base64)", c = z(), l = H("div"), h = H("input"), m = z(), v = H("button"), v.textContent = "\u{1F3B2}", b = z(), A = H("small"), A.textContent = "Fernet requires a specific 32-byte URL-safe base64 key.", _ = z(), C = H("div"), I = H("label"), $ = we(S), F = z(), U = H("textarea"), P = z(), N = H("div"), fe(L.$$.fragment), B = z(), u = H("div"), fe(p.$$.fragment), d = z(), y = H("div"), fe(w.$$.fragment), M = z(), Y && Y.c(), x = z(), J && J.c(), V(n, "class", "svelte-10f7tbs"), Zt(n, "active", t3[2] === "encrypt"), V(s, "class", "svelte-10f7tbs"), Zt(s, "active", t3[2] === "decrypt"), V(e, "class", "tabs svelte-10f7tbs"), V(f, "class", "svelte-10f7tbs"), V(h, "type", "text"), V(h, "placeholder", "Paste Fernet Key here..."), V(h, "class", "key-input svelte-10f7tbs"), V(v, "class", "gen-btn svelte-10f7tbs"), V(v, "title", "Generate New Key"), V(l, "class", "key-row svelte-10f7tbs"), V(A, "class", "hint svelte-10f7tbs"), V(o, "class", "form-group svelte-10f7tbs"), V(I, "class", "svelte-10f7tbs"), V(U, "rows", "4"), V(U, "placeholder", Q = t3[2] === "encrypt" ? "Type secret message..." : "Paste gAAAAAB... string"), V(U, "class", "svelte-10f7tbs"), V(C, "class", "form-group svelte-10f7tbs"), St(u, "margin-left", "10px"), St(y, "margin-left", "auto"), V(N, "class", "action-row svelte-10f7tbs"), V(a, "class", "tool-content");
  }, m(G, X) {
    R(G, e, X), q(e, n), q(e, r), q(e, s), R(G, i, X), R(G, a, X), q(a, o), q(o, f), q(o, c), q(o, l), q(l, h), yr(h, t3[3]), q(l, m), q(l, v), q(o, b), q(o, A), q(a, _), q(a, C), q(C, I), q(I, $), q(C, F), q(C, U), yr(U, t3[0]), q(a, P), q(a, N), ae(L, N, null), q(N, B), q(N, u), ae(p, u, null), q(N, d), q(N, y), ae(w, y, null), q(a, M), Y && Y.m(a, null), q(a, x), J && J.m(a, null), g = true, k || (T = [Kt(n, "click", t3[9]), Kt(s, "click", t3[10]), Kt(h, "input", t3[11]), Kt(v, "click", t3[6]), Kt(U, "input", t3[12])], k = true);
  }, p(G, X) {
    (!g || X & 4) && Zt(n, "active", G[2] === "encrypt"), (!g || X & 4) && Zt(s, "active", G[2] === "decrypt"), X & 8 && h.value !== G[3] && yr(h, G[3]), (!g || X & 4) && S !== (S = G[2] === "encrypt" ? "Plaintext Message" : "Fernet Token (Ciphertext)") && Ze($, S), (!g || X & 4 && Q !== (Q = G[2] === "encrypt" ? "Type secret message..." : "Paste gAAAAAB... string")) && V(U, "placeholder", Q), X & 1 && yr(U, G[0]);
    const ie = {};
    X & 32772 && (ie.$$scope = { dirty: X, ctx: G }), L.$set(ie);
    const de = {};
    X & 32768 && (de.$$scope = { dirty: X, ctx: G }), p.$set(de);
    const se = {};
    !E && X & 2 && (E = true, se.checked = G[1], qe(() => E = false)), w.$set(se), G[5] ? Y ? Y.p(G, X) : (Y = iE(G), Y.c(), Y.m(a, x)) : Y && (Y.d(1), Y = null), G[4] ? J ? J.p(G, X) : (J = sE(G), J.c(), J.m(a, null)) : J && (J.d(1), J = null);
  }, i(G) {
    g || (W(L.$$.fragment, G), W(p.$$.fragment, G), W(w.$$.fragment, G), g = true);
  }, o(G) {
    j(L.$$.fragment, G), j(p.$$.fragment, G), j(w.$$.fragment, G), g = false;
  }, d(G) {
    G && (D(e), D(i), D(a)), oe(L), oe(p), oe(w), Y && Y.d(), J && J.d(), k = false, Mn(T);
  } };
}
function yse(t3) {
  let e, n, r, s, i;
  return { c() {
    e = H("p"), e.innerHTML = `This application uses <b>Fernet</b> from the <a href="https://www.npmjs.com/package/fernet">npm package</a>. 
    Fernet encryption is a method of symmetric encryption that provides both confidentiality and authentication for data. 
    It uses a secret key to encrypt and decrypt messages, ensuring that only authorized parties can access the original information.`, n = z(), r = H("ul"), r.innerHTML = "<li><b>Encryption:</b> Enter plaintext and click Encrypt to generate an encrypted message</li> <li><b>Decryption:</b> Paste the encrypted message and key, then click Decrypt to recover the original plaintext.</li> <li><b>Randomness:</b> Generates a new IV (Initialization Vector) every time, so encrypting &quot;Hello&quot; twice results in different tokens.</li>", s = z(), i = H("p"), i.innerHTML = "<b>Note:</b> Fernet uses AES in CBC mode with HMAC for authentication.";
  }, m(a, o) {
    R(a, e, o), R(a, n, o), R(a, r, o), R(a, s, o), R(a, i, o);
  }, p: dt, d(a) {
    a && (D(e), D(n), D(r), D(s), D(i));
  } };
}
function bse(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Fernet Encryption", $$slots: { default: [vse] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Fernet", links: t3[8], $$slots: { default: [yse] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 32831 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 32768 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function Ase(t3, e, n) {
  let r = "encrypt", s = "", i = "", a = "", o = "", f = true;
  qb(() => {
    s || n(3, s = nE());
  });
  function c() {
    n(3, s = nE());
  }
  function l() {
    if (n(5, o = ""), n(4, a = ""), !s || !i) {
      n(5, o = "Please provide both a Key and Input Text.");
      return;
    }
    try {
      r === "encrypt" ? n(4, a = dse(i, s)) : n(4, a = pse(i, s));
    } catch (I) {
      n(5, o = I.message);
    }
  }
  const h = [{ text: "Fernet Spec (GitHub)", url: "https://github.com/fernet/spec" }], m = () => {
    n(2, r = "encrypt"), n(5, o = ""), n(4, a = "");
  }, v = () => {
    n(2, r = "decrypt"), n(5, o = ""), n(4, a = "");
  };
  function b() {
    s = this.value, n(3, s);
  }
  function A() {
    i = this.value, n(0, i);
  }
  const _ = () => {
    n(0, i = ""), n(4, a = null);
  };
  function C(I) {
    f = I, n(1, f);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 3 && f && i && l();
  }, [i, f, r, s, a, o, c, l, h, m, v, b, A, _, C];
}
class wse extends xt {
  constructor(e) {
    super(), wt(this, e, Ase, bse, At, {});
  }
}
function xse(t3, e) {
  if (!t3) return "";
  const n = (e % 26 + 26) % 26;
  return t3.split("").map((r) => {
    if (r.match(/[a-z]/i)) {
      const s = r.charCodeAt(0);
      if (s >= 65 && s <= 90) return String.fromCharCode((s - 65 + n) % 26 + 65);
      if (s >= 97 && s <= 122) return String.fromCharCode((s - 97 + n) % 26 + 97);
    }
    return r;
  }).join("");
}
function _se(t3) {
  let e = t3[3] === "encrypt" ? "Encrypt" : "Decrypt", n;
  return { c() {
    n = we(e);
  }, m(r, s) {
    R(r, n, s);
  }, p(r, s) {
    s & 8 && e !== (e = r[3] === "encrypt" ? "Encrypt" : "Decrypt") && Ze(n, e);
  }, d(r) {
    r && D(n);
  } };
}
function Ese(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function aE(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[5]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 32 && Ze(n, r[5]);
  }, d(r) {
    r && D(e);
  } };
}
function oE(t3) {
  let e, n;
  return e = new et({ props: { label: "Result:", value: t3[4], readonly: true, expandable: true, withCopy: true, rows: 3 } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, s) {
    const i = {};
    s & 16 && (i.value = r[4]), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function Bse(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U, Q, P, N, L, B, u;
  function p(k) {
    t3[10](k);
  }
  let d = { label: "Operation:", options: t3[6] };
  t3[3] !== void 0 && (d.value = t3[3]), n = new Ht({ props: d }), Qe.push(() => ze(n, "value", p));
  function y(k) {
    t3[12](k);
  }
  let w = { label: t3[3] === "encrypt" ? "Plaintext:" : "Ciphertext:", placeholder: t3[3] === "encrypt" ? "Message to hide..." : "Message to reveal...", expandable: true, rows: 3 };
  t3[0] !== void 0 && (w.value = t3[0]), l = new et({ props: w }), Qe.push(() => ze(l, "value", y)), b = new ut({ props: { $$slots: { default: [_se] }, $$scope: { ctx: t3 } } }), b.$on("click", t3[7]), _ = new ut({ props: { variant: "secondary", $$slots: { default: [Ese] }, $$scope: { ctx: t3 } } }), _.$on("click", t3[13]), I = new hn({}), I.$on("click", t3[8]);
  function E(k) {
    t3[14](k);
  }
  let M = {};
  t3[2] !== void 0 && (M.checked = t3[2]), F = new xr({ props: M }), Qe.push(() => ze(F, "checked", E));
  let x = t3[5] && aE(t3), g = t3[4] && oE(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), i = H("div"), a = H("label"), a.textContent = "Shift Amount (ROT):", o = z(), f = H("input"), c = z(), fe(l.$$.fragment), m = z(), v = H("div"), fe(b.$$.fragment), A = z(), fe(_.$$.fragment), C = z(), fe(I.$$.fragment), S = z(), $ = H("div"), fe(F.$$.fragment), Q = z(), x && x.c(), P = z(), g && g.c(), N = Lt(), V(a, "for", "shift-input"), V(a, "class", "svelte-y5chxz"), V(f, "id", "shift-input"), V(f, "type", "number"), V(f, "min", "1"), V(f, "max", "25"), V(f, "class", "svelte-y5chxz"), V(i, "class", "shift-control svelte-y5chxz"), V(e, "class", "controls-row svelte-y5chxz"), St($, "margin-left", "auto"), V(v, "class", "button-row");
  }, m(k, T) {
    R(k, e, T), ae(n, e, null), q(e, s), q(e, i), q(i, a), q(i, o), q(i, f), yr(f, t3[1]), R(k, c, T), ae(l, k, T), R(k, m, T), R(k, v, T), ae(b, v, null), q(v, A), ae(_, v, null), q(v, C), ae(I, v, null), q(v, S), q(v, $), ae(F, $, null), R(k, Q, T), x && x.m(k, T), R(k, P, T), g && g.m(k, T), R(k, N, T), L = true, B || (u = Kt(f, "input", t3[11]), B = true);
  }, p(k, T) {
    const O = {};
    !r && T & 8 && (r = true, O.value = k[3], qe(() => r = false)), n.$set(O), T & 2 && Nn(f.value) !== k[1] && yr(f, k[1]);
    const K = {};
    T & 8 && (K.label = k[3] === "encrypt" ? "Plaintext:" : "Ciphertext:"), T & 8 && (K.placeholder = k[3] === "encrypt" ? "Message to hide..." : "Message to reveal..."), !h && T & 1 && (h = true, K.value = k[0], qe(() => h = false)), l.$set(K);
    const Y = {};
    T & 32776 && (Y.$$scope = { dirty: T, ctx: k }), b.$set(Y);
    const J = {};
    T & 32768 && (J.$$scope = { dirty: T, ctx: k }), _.$set(J);
    const G = {};
    !U && T & 4 && (U = true, G.checked = k[2], qe(() => U = false)), F.$set(G), k[5] ? x ? x.p(k, T) : (x = aE(k), x.c(), x.m(P.parentNode, P)) : x && (x.d(1), x = null), k[4] ? g ? (g.p(k, T), T & 16 && W(g, 1)) : (g = oE(k), g.c(), W(g, 1), g.m(N.parentNode, N)) : g && (Xt(), j(g, 1, 1, () => {
      g = null;
    }), er());
  }, i(k) {
    L || (W(n.$$.fragment, k), W(l.$$.fragment, k), W(b.$$.fragment, k), W(_.$$.fragment, k), W(I.$$.fragment, k), W(F.$$.fragment, k), W(g), L = true);
  }, o(k) {
    j(n.$$.fragment, k), j(l.$$.fragment, k), j(b.$$.fragment, k), j(_.$$.fragment, k), j(I.$$.fragment, k), j(F.$$.fragment, k), j(g), L = false;
  }, d(k) {
    k && (D(e), D(c), D(m), D(v), D(Q), D(P), D(N)), oe(n), oe(l, k), oe(b), oe(_), oe(I), oe(F), x && x.d(k), g && g.d(k), B = false, u();
  } };
}
function Cse(t3) {
  let e, n, r, s, i;
  return { c() {
    e = H("p"), e.innerHTML = `The <b>Caesar Cipher</b> is one of the simplest and oldest known encryption techniques, 
    attributed to Julius Caesar. It&#39;s a type of substitution cipher where each
    letter in the plaintext is shifted a fixed number of positions down or up the alphabet.`, n = z(), r = H("p"), r.textContent = `The cipher relies on a 'shift' value, which is the number of positions each letter 
    will be moved. For example, with a shift of 3: 'A' becomes 'D', 'B' becomes 'E',  
    'Z' becomes 'C' (wrapping back to the beginning of the alphabet).`, s = z(), i = H("p"), i.textContent = `Caesar Cipher is easy to break, especially with brute force, because there 
    are only 26 possible shifts for the English alphabet. Due to its simplicity 
    and low security, it's primarily used for educational purposes rather than 
    for secure communication.`;
  }, m(a, o) {
    R(a, e, o), R(a, n, o), R(a, r, o), R(a, s, o), R(a, i, o);
  }, p: dt, d(a) {
    a && (D(e), D(n), D(r), D(s), D(i));
  } };
}
function kse(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Caesar Cipher", $$slots: { default: [Bse] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Caesar Cipher", links: t3[9], $$slots: { default: [Cse] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 32831 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 32768 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function Ise(t3, e, n) {
  let r = "encrypt", s = "", i = 3, a = "", o = "", f = true;
  const c = [{ value: "encrypt", label: "Encrypt (Shift Forward)" }, { value: "decrypt", label: "Decrypt (Shift Backward)" }];
  function l() {
    if (n(5, o = ""), n(4, a = ""), !s) {
      n(5, o = "Please enter text.");
      return;
    }
    const I = r === "encrypt" ? i : -i;
    try {
      n(4, a = xse(s, I));
    } catch (S) {
      n(5, o = S.message);
    }
  }
  function h() {
    n(3, r = r === "encrypt" ? "decrypt" : "encrypt"), a && !o && (n(0, s = a), n(4, a = ""));
  }
  const m = [{ text: "Wikipedia", url: "https://en.wikipedia.org/wiki/Caesar_cipher" }, { text: "Geeks for Geeks", url: "https://www.geeksforgeeks.org/caesar-cipher-in-cryptography" }];
  function v(I) {
    r = I, n(3, r);
  }
  function b() {
    i = Nn(this.value), n(1, i);
  }
  function A(I) {
    s = I, n(0, s);
  }
  const _ = () => {
    n(0, s = ""), n(4, a = "");
  };
  function C(I) {
    f = I, n(2, f);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 7 && f && s && i && l();
  }, [s, i, f, r, a, o, c, l, h, m, v, b, A, _, C];
}
class Sse extends xt {
  constructor(e) {
    super(), wt(this, e, Ise, kse, At, {});
  }
}
const z0 = 26;
function Mse(t3, e) {
  for (; e !== 0; ) {
    let n = e;
    e = t3 % e, t3 = n;
  }
  return t3;
}
function $se(t3, e) {
  t3 = (t3 % e + e) % e;
  for (let n = 1; n < e; n++) if (t3 * n % e === 1) return n;
  throw new Error(`Modular inverse does not exist for a=${t3} under modulo ${e}.`);
}
function Tse(t3, e) {
  if (isNaN(t3) || isNaN(e)) throw new Error("Keys must be integers.");
  if (Mse(t3, z0) !== 1) throw new Error(`Key 'a' (${t3}) is invalid. It must be coprime to 26 (share no common factors). Try 3, 5, 7, 9, 11...`);
}
function Dse(t3, e, n, r) {
  if (!t3) return "";
  e = parseInt(e), n = parseInt(n), Tse(e, n);
  let s = "", i = 0;
  r === "decrypt" && (i = $se(e, z0));
  for (let a = 0; a < t3.length; a++) {
    const o = t3[a];
    if (o.match(/[a-z]/i)) {
      const c = o === o.toUpperCase() ? 65 : 97, l = o.charCodeAt(0) - c;
      let h;
      r === "encrypt" ? h = (e * l + n) % z0 : h = (i * (l - n) % z0 + z0) % z0, s += String.fromCharCode(h + c);
    } else s += o;
  }
  return s;
}
function fE(t3, e, n) {
  const r = t3.slice();
  return r[20] = e[n], r;
}
function lE(t3) {
  let e, n, r;
  function s() {
    return t3[16](t3[20]);
  }
  return { c() {
    e = H("button"), e.textContent = `${t3[20]} `, V(e, "class", "chip svelte-k0fpsx"), Zt(e, "active", parseInt(t3[1]) === t3[20]);
  }, m(i, a) {
    R(i, e, a), n || (r = Kt(e, "click", s), n = true);
  }, p(i, a) {
    t3 = i, a & 258 && Zt(e, "active", parseInt(t3[1]) === t3[20]);
  }, d(i) {
    i && D(e), n = false, r();
  } };
}
function Rse(t3) {
  let e = t3[4] === "encrypt" ? "Encrypt" : "Decrypt", n;
  return { c() {
    n = we(e);
  }, m(r, s) {
    R(r, n, s);
  }, p(r, s) {
    s & 16 && e !== (e = r[4] === "encrypt" ? "Encrypt" : "Decrypt") && Ze(n, e);
  }, d(r) {
    r && D(n);
  } };
}
function Fse(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function uE(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[6]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 64 && Ze(n, r[6]);
  }, d(r) {
    r && D(e);
  } };
}
function cE(t3) {
  let e, n;
  return e = new et({ props: { label: "Result:", value: t3[5], readonly: true, expandable: true, withCopy: true, rows: 3 } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, s) {
    const i = {};
    s & 32 && (i.value = r[5]), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function Pse(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U, Q, P, N, L, B, u, p, d, y, w, E, M, x, g, k, T, O, K, Y, J;
  function G(me) {
    t3[13](me);
  }
  let X = { label: "Operation:", options: t3[7] };
  t3[4] !== void 0 && (X.value = t3[4]), n = new Ht({ props: X }), Qe.push(() => ze(n, "value", G));
  let ie = Mr(t3[8]), de = [];
  for (let me = 0; me < ie.length; me += 1) de[me] = lE(fE(t3, ie, me));
  function se(me) {
    t3[17](me);
  }
  let te = { label: t3[4] === "encrypt" ? "Plaintext:" : "Ciphertext:", placeholder: t3[4] === "encrypt" ? "Message to encrypt..." : "Message to decrypt...", expandable: true, rows: 3 };
  t3[0] !== void 0 && (te.value = t3[0]), P = new et({ props: te }), Qe.push(() => ze(P, "value", se)), u = new ut({ props: { $$slots: { default: [Rse] }, $$scope: { ctx: t3 } } }), u.$on("click", t3[9]), d = new ut({ props: { variant: "secondary", $$slots: { default: [Fse] }, $$scope: { ctx: t3 } } }), d.$on("click", t3[18]), w = new hn({}), w.$on("click", t3[10]);
  function le(me) {
    t3[19](me);
  }
  let Z = {};
  t3[3] !== void 0 && (Z.checked = t3[3]), x = new xr({ props: Z }), Qe.push(() => ze(x, "checked", le));
  let ve = t3[6] && uE(t3), he = t3[5] && cE(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), i = H("div"), a = H("div"), o = H("label"), o.textContent = "Key A (Multiplier):", f = z(), c = H("input"), l = z(), h = H("small"), h.textContent = "Must be coprime to 26", m = z(), v = H("div"), b = H("label"), b.textContent = "Key B (Shift):", A = z(), _ = H("input"), C = z(), I = H("small"), I.textContent = "Any integer", S = z(), $ = H("div"), F = H("span"), F.textContent = "Valid 'a' suggestions:", U = z();
    for (let me = 0; me < de.length; me += 1) de[me].c();
    Q = z(), fe(P.$$.fragment), L = z(), B = H("div"), fe(u.$$.fragment), p = z(), fe(d.$$.fragment), y = z(), fe(w.$$.fragment), E = z(), M = H("div"), fe(x.$$.fragment), k = z(), ve && ve.c(), T = z(), he && he.c(), O = Lt(), V(o, "for", "key-a"), V(o, "class", "svelte-k0fpsx"), V(c, "id", "key-a"), V(c, "type", "number"), V(c, "placeholder", "e.g. 5"), V(c, "class", "svelte-k0fpsx"), V(h, "class", "hint svelte-k0fpsx"), V(a, "class", "k-group svelte-k0fpsx"), V(b, "for", "key-b"), V(b, "class", "svelte-k0fpsx"), V(_, "id", "key-b"), V(_, "type", "number"), V(_, "placeholder", "e.g. 8"), V(_, "class", "svelte-k0fpsx"), V(I, "class", "hint svelte-k0fpsx"), V(v, "class", "k-group svelte-k0fpsx"), V(i, "class", "key-inputs svelte-k0fpsx"), V(e, "class", "controls-row svelte-k0fpsx"), V($, "class", "coprime-suggestions svelte-k0fpsx"), St(M, "margin-left", "auto"), V(B, "class", "button-row");
  }, m(me, ce) {
    R(me, e, ce), ae(n, e, null), q(e, s), q(e, i), q(i, a), q(a, o), q(a, f), q(a, c), yr(c, t3[1]), q(a, l), q(a, h), q(i, m), q(i, v), q(v, b), q(v, A), q(v, _), yr(_, t3[2]), q(v, C), q(v, I), R(me, S, ce), R(me, $, ce), q($, F), q($, U);
    for (let ye = 0; ye < de.length; ye += 1) de[ye] && de[ye].m($, null);
    R(me, Q, ce), ae(P, me, ce), R(me, L, ce), R(me, B, ce), ae(u, B, null), q(B, p), ae(d, B, null), q(B, y), ae(w, B, null), q(B, E), q(B, M), ae(x, M, null), R(me, k, ce), ve && ve.m(me, ce), R(me, T, ce), he && he.m(me, ce), R(me, O, ce), K = true, Y || (J = [Kt(c, "input", t3[14]), Kt(_, "input", t3[15])], Y = true);
  }, p(me, ce) {
    const ye = {};
    if (!r && ce & 16 && (r = true, ye.value = me[4], qe(() => r = false)), n.$set(ye), ce & 2 && Nn(c.value) !== me[1] && yr(c, me[1]), ce & 4 && Nn(_.value) !== me[2] && yr(_, me[2]), ce & 2306) {
      ie = Mr(me[8]);
      let $e;
      for ($e = 0; $e < ie.length; $e += 1) {
        const Re = fE(me, ie, $e);
        de[$e] ? de[$e].p(Re, ce) : (de[$e] = lE(Re), de[$e].c(), de[$e].m($, null));
      }
      for (; $e < de.length; $e += 1) de[$e].d(1);
      de.length = ie.length;
    }
    const Oe = {};
    ce & 16 && (Oe.label = me[4] === "encrypt" ? "Plaintext:" : "Ciphertext:"), ce & 16 && (Oe.placeholder = me[4] === "encrypt" ? "Message to encrypt..." : "Message to decrypt..."), !N && ce & 1 && (N = true, Oe.value = me[0], qe(() => N = false)), P.$set(Oe);
    const Se = {};
    ce & 8388624 && (Se.$$scope = { dirty: ce, ctx: me }), u.$set(Se);
    const Ce = {};
    ce & 8388608 && (Ce.$$scope = { dirty: ce, ctx: me }), d.$set(Ce);
    const Ne = {};
    !g && ce & 8 && (g = true, Ne.checked = me[3], qe(() => g = false)), x.$set(Ne), me[6] ? ve ? ve.p(me, ce) : (ve = uE(me), ve.c(), ve.m(T.parentNode, T)) : ve && (ve.d(1), ve = null), me[5] ? he ? (he.p(me, ce), ce & 32 && W(he, 1)) : (he = cE(me), he.c(), W(he, 1), he.m(O.parentNode, O)) : he && (Xt(), j(he, 1, 1, () => {
      he = null;
    }), er());
  }, i(me) {
    K || (W(n.$$.fragment, me), W(P.$$.fragment, me), W(u.$$.fragment, me), W(d.$$.fragment, me), W(w.$$.fragment, me), W(x.$$.fragment, me), W(he), K = true);
  }, o(me) {
    j(n.$$.fragment, me), j(P.$$.fragment, me), j(u.$$.fragment, me), j(d.$$.fragment, me), j(w.$$.fragment, me), j(x.$$.fragment, me), j(he), K = false;
  }, d(me) {
    me && (D(e), D(S), D($), D(Q), D(L), D(B), D(k), D(T), D(O)), oe(n), jn(de, me), oe(P, me), oe(u), oe(d), oe(w), oe(x), ve && ve.d(me), he && he.d(me), Y = false, Mn(J);
  } };
}
function Nse(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v = "26", b, A, _, C, I, S = "-1", $, F, U = "26", Q, P, N;
  return { c() {
    e = H("p"), e.innerHTML = `An <b>Affine Monoalphabetic Substitution Cipher</b> is a type of cipher that applies 
    a mathematical transformation to each letter in the plaintext to produce the ciphertext. 
    It is a specific form of monoalphabetic substitution cipher, meaning 
    it maps each letter of the plaintext to exactly one letter of the ciphertext alphabet.`, n = z(), r = H("p"), r.textContent = `Each letter in the alphabet is assigned a unique number. For example, 
    in the standard 26-letter English alphabet: A = 0, B = 1, C = 2, ..., Z = 25. 
    The cipher uses a function of the form: C = (a * P + b) mod 26, where:`, s = z(), i = H("ul"), i.innerHTML = `<li><b>C</b> is the ciphertext letter<br/></li> <li><b>P</b> is the plaintext letter <br/></li> <li><b>a</b> and <b>b</b> are keys for the cipher, with a typically chosen to be coprime with 26 
    (for the English alphabet) to ensure a unique mapping for each letter</li>`, a = z(), o = H("p"), o.innerHTML = "<strong>The Math:</strong>", f = z(), c = H("ul"), l = H("li"), h = H("strong"), h.textContent = "Encryption:", m = we(" C = (a * P + b) mod "), b = we(v), A = z(), _ = H("li"), C = H("strong"), C.textContent = "Decryption:", I = we(" P = a^"), $ = we(S), F = we(" * (C - b) mod "), Q = we(U), P = z(), N = H("p"), N.innerHTML = `The multiplier <em>a</em> must be <strong>coprime</strong> to 26 (they share no common factors other than 1). 
    This ensures that each letter maps to a unique result, allowing decryption. If <em>a</em> is an even number or 13, information is lost.`;
  }, m(L, B) {
    R(L, e, B), R(L, n, B), R(L, r, B), R(L, s, B), R(L, i, B), R(L, a, B), R(L, o, B), R(L, f, B), R(L, c, B), q(c, l), q(l, h), q(l, m), q(l, b), q(c, A), q(c, _), q(_, C), q(_, I), q(_, $), q(_, F), q(_, Q), R(L, P, B), R(L, N, B);
  }, p: dt, d(L) {
    L && (D(e), D(n), D(r), D(s), D(i), D(a), D(o), D(f), D(c), D(P), D(N));
  } };
}
function Use(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Affine Cipher", $$slots: { default: [Pse] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Affine Cipher", links: t3[12], $$slots: { default: [Nse] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 8388735 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 8388608 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function Lse(t3, e, n) {
  let r = "encrypt", s = "", i = "5", a = "8", o = "", f = "", c = true;
  const l = [{ value: "encrypt", label: "Encrypt" }, { value: "decrypt", label: "Decrypt" }], h = [1, 3, 5, 7, 9, 11, 15, 17, 19, 21, 23, 25];
  function m() {
    if (n(6, f = ""), n(5, o = ""), !s) return n(6, f = "Please enter text.");
    if (!i || !a) return n(6, f = "Please provide both keys (a and b).");
    try {
      n(5, o = Dse(s, i, a, r));
    } catch (Q) {
      n(6, f = Q.message);
    }
  }
  function v() {
    n(4, r = r === "encrypt" ? "decrypt" : "encrypt"), o && !f && (n(0, s = o), n(5, o = ""));
  }
  function b(Q) {
    n(1, i = Q.toString());
  }
  const A = [{ text: "Wikipedia", url: "https://en.wikipedia.org/wiki/Affine_cipher" }, { text: "Geeks for Geeks", url: "https://www.geeksforgeeks.org/implementation-affine-cipher" }];
  function _(Q) {
    r = Q, n(4, r);
  }
  function C() {
    i = Nn(this.value), n(1, i);
  }
  function I() {
    a = Nn(this.value), n(2, a);
  }
  const S = (Q) => b(Q);
  function $(Q) {
    s = Q, n(0, s);
  }
  const F = () => {
    n(0, s = ""), n(5, o = "");
  };
  function U(Q) {
    c = Q, n(3, c);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 15 && c && s && i && a && m();
  }, [s, i, a, c, r, o, f, l, h, m, v, b, A, _, C, I, S, $, F, U];
}
class Ose extends xt {
  constructor(e) {
    super(), wt(this, e, Lse, Use, At, {});
  }
}
const hD = { A: "aaaaa", B: "aaaab", C: "aaaba", D: "aaabb", E: "aabaa", F: "aabab", G: "aabba", H: "aabbb", I: "abaaa", J: "abaab", K: "ababa", L: "ababb", M: "abbaa", N: "abbab", O: "abbba", P: "abbbb", Q: "baaaa", R: "baaab", S: "baaba", T: "baabb", U: "babaa", V: "babab", W: "babba", X: "babbb", Y: "bbaaa", Z: "bbaab" }, Qse = Object.entries(hD).reduce((t3, [e, n]) => (t3[n] || (t3[n] = e), t3), {});
function Kse(t3) {
  return t3 ? t3.toUpperCase().split("").map((e) => e === " " ? " " : hD[e] || "").join(" ").replace(/\s+/g, " ").trim() : "";
}
function Hse(t3) {
  return t3 ? t3.toLowerCase().replace(/[^ab ]/g, "").split(" ").map((r) => (r.match(/.{1,5}/g) || []).map((i) => Qse[i] || "?").join("")).join(" ") : "";
}
function qse(t3) {
  let e = t3[2] === "encode" ? "Encode" : "Decode", n;
  return { c() {
    n = we(e);
  }, m(r, s) {
    R(r, n, s);
  }, p(r, s) {
    s & 4 && e !== (e = r[2] === "encode" ? "Encode" : "Decode") && Ze(n, e);
  }, d(r) {
    r && D(n);
  } };
}
function zse(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function hE(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[4]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 16 && Ze(n, r[4]);
  }, d(r) {
    r && D(e);
  } };
}
function dE(t3) {
  let e, n;
  return e = new et({ props: { label: "Result:", value: t3[3], readonly: true, expandable: true, withCopy: true, rows: 4 } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, s) {
    const i = {};
    s & 8 && (i.value = r[3]), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function Gse(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F;
  function U(d) {
    t3[9](d);
  }
  let Q = { label: "Operation:", options: t3[5] };
  t3[2] !== void 0 && (Q.value = t3[2]), n = new Ht({ props: Q }), Qe.push(() => ze(n, "value", U));
  function P(d) {
    t3[10](d);
  }
  let N = { label: t3[2] === "encode" ? "Plaintext:" : "Bacon Ciphertext (A/B):", placeholder: t3[2] === "encode" ? "Secret message..." : "aaaaa baaab...", expandable: true, rows: 3 };
  t3[0] !== void 0 && (N.value = t3[0]), i = new et({ props: N }), Qe.push(() => ze(i, "value", P)), c = new ut({ props: { $$slots: { default: [qse] }, $$scope: { ctx: t3 } } }), c.$on("click", t3[6]), h = new ut({ props: { variant: "secondary", $$slots: { default: [zse] }, $$scope: { ctx: t3 } } }), h.$on("click", t3[11]), v = new hn({}), v.$on("click", t3[7]);
  function L(d) {
    t3[12](d);
  }
  let B = {};
  t3[1] !== void 0 && (B.checked = t3[1]), _ = new xr({ props: B }), Qe.push(() => ze(_, "checked", L));
  let u = t3[4] && hE(t3), p = t3[3] && dE(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), fe(i.$$.fragment), o = z(), f = H("div"), fe(c.$$.fragment), l = z(), fe(h.$$.fragment), m = z(), fe(v.$$.fragment), b = z(), A = H("div"), fe(_.$$.fragment), I = z(), u && u.c(), S = z(), p && p.c(), $ = Lt(), V(e, "class", "controls-row svelte-1drwtid"), St(A, "margin-left", "auto"), V(f, "class", "button-row");
  }, m(d, y) {
    R(d, e, y), ae(n, e, null), R(d, s, y), ae(i, d, y), R(d, o, y), R(d, f, y), ae(c, f, null), q(f, l), ae(h, f, null), q(f, m), ae(v, f, null), q(f, b), q(f, A), ae(_, A, null), R(d, I, y), u && u.m(d, y), R(d, S, y), p && p.m(d, y), R(d, $, y), F = true;
  }, p(d, y) {
    const w = {};
    !r && y & 4 && (r = true, w.value = d[2], qe(() => r = false)), n.$set(w);
    const E = {};
    y & 4 && (E.label = d[2] === "encode" ? "Plaintext:" : "Bacon Ciphertext (A/B):"), y & 4 && (E.placeholder = d[2] === "encode" ? "Secret message..." : "aaaaa baaab..."), !a && y & 1 && (a = true, E.value = d[0], qe(() => a = false)), i.$set(E);
    const M = {};
    y & 8196 && (M.$$scope = { dirty: y, ctx: d }), c.$set(M);
    const x = {};
    y & 8192 && (x.$$scope = { dirty: y, ctx: d }), h.$set(x);
    const g = {};
    !C && y & 2 && (C = true, g.checked = d[1], qe(() => C = false)), _.$set(g), d[4] ? u ? u.p(d, y) : (u = hE(d), u.c(), u.m(S.parentNode, S)) : u && (u.d(1), u = null), d[3] ? p ? (p.p(d, y), y & 8 && W(p, 1)) : (p = dE(d), p.c(), W(p, 1), p.m($.parentNode, $)) : p && (Xt(), j(p, 1, 1, () => {
      p = null;
    }), er());
  }, i(d) {
    F || (W(n.$$.fragment, d), W(i.$$.fragment, d), W(c.$$.fragment, d), W(h.$$.fragment, d), W(v.$$.fragment, d), W(_.$$.fragment, d), W(p), F = true);
  }, o(d) {
    j(n.$$.fragment, d), j(i.$$.fragment, d), j(c.$$.fragment, d), j(h.$$.fragment, d), j(v.$$.fragment, d), j(_.$$.fragment, d), j(p), F = false;
  }, d(d) {
    d && (D(e), D(s), D(o), D(f), D(I), D(S), D($)), oe(n), oe(i, d), oe(c), oe(h), oe(v), oe(_), u && u.d(d), p && p.d(d);
  } };
}
function Vse(t3) {
  let e, n, r;
  return { c() {
    e = H("p"), e.textContent = `The Bacon cipher, also known as Bacon's cipher, is a steganographic 
    method developed by Sir Francis Bacon in the early 17th century. 
    It encodes messages through binary coding, where text is concealed by 
    using two distinct typefaces or styles of text (for example, bold and regular).`, n = z(), r = H("p"), r.innerHTML = `This cipher falls under the category of steganography because the encoded 
    message is hidden within the text\u2019s format rather than in the content itself. 
    Each letter in the English alphabet is represented by a sequence of five 
    binary characters (A or B). Bacon originally mapped out 24 letters
    (I and J, as well as U and V, were each treated as a single letter).
    For example: <b>A=AAAAA, B=AAAAB, C=AAABA, D=AAABB</b> etc`;
  }, m(s, i) {
    R(s, e, i), R(s, n, i), R(s, r, i);
  }, p: dt, d(s) {
    s && (D(e), D(n), D(r));
  } };
}
function Yse(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Bacon Cipher", $$slots: { default: [Gse] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Bacon Cipher", links: t3[8], $$slots: { default: [Vse] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 8223 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 8192 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function Wse(t3, e, n) {
  let r = "encode", s = "", i = "", a = "", o = true;
  const f = [{ value: "encode", label: "Encode (Text -> Bacon)" }, { value: "decode", label: "Decode (Bacon -> Text)" }];
  function c() {
    if (n(4, a = ""), n(3, i = ""), !s) return n(4, a = "Please enter text.");
    try {
      r === "encode" ? n(3, i = Kse(s)) : n(3, i = Hse(s));
    } catch (_) {
      n(4, a = _.message);
    }
  }
  function l() {
    n(2, r = r === "encode" ? "decode" : "encode"), i && !a && (n(0, s = i), n(3, i = ""));
  }
  const h = [{ text: "Wikipedia", url: "https://en.wikipedia.org/wiki/Bacon's_cipher" }, { text: "Practical Cryptography", url: "http://www.practicalcryptography.com/ciphers/baconian-cipher" }];
  function m(_) {
    r = _, n(2, r);
  }
  function v(_) {
    s = _, n(0, s);
  }
  const b = () => {
    n(0, s = ""), n(3, i = "");
  };
  function A(_) {
    o = _, n(1, o);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 3 && o && s && c();
  }, [s, o, r, i, a, f, c, l, h, m, v, b, A];
}
class Jse extends xt {
  constructor(e) {
    super(), wt(this, e, Wse, Yse, At, {});
  }
}
const dD = "BGWKZQPNDSIOAXEFCLUMTHYVR", A4 = {}, w4 = {};
for (let t3 = 0; t3 < 25; t3++) {
  const e = dD[t3], n = Math.floor(t3 / 5) + 1, r = t3 % 5 + 1;
  A4[e] = { row: n, col: r }, w4[`${n},${r}`] = e;
}
function Zse(t3) {
  if (!t3) return "";
  const e = t3.toUpperCase().replace(/J/g, "I").replace(/[^A-Z]/g, "");
  if (e.length === 0) return "";
  const n = [], r = [];
  for (const a of e) {
    const o = A4[a];
    o && (n.push(o.row), r.push(o.col));
  }
  const s = [...n, ...r];
  let i = "";
  for (let a = 0; a < s.length; a += 2) {
    const o = s[a], f = s[a + 1];
    i += w4[`${o},${f}`];
  }
  return i;
}
function jse(t3) {
  if (!t3) return "";
  const e = t3.toUpperCase().replace(/[^A-Z]/g, "");
  if (e.length === 0) return "";
  const n = [];
  for (const o of e) {
    const f = A4[o];
    f && (n.push(f.row), n.push(f.col));
  }
  const r = n.length / 2, s = n.slice(0, r), i = n.slice(r);
  let a = "";
  for (let o = 0; o < s.length; o++) {
    const f = s[o], c = i[o];
    a += w4[`${f},${c}`];
  }
  return a;
}
function Xse() {
  return dD;
}
function pE(t3, e, n) {
  const r = t3.slice();
  return r[15] = e[n], r;
}
function gE(t3, e, n) {
  const r = t3.slice();
  return r[18] = e[n], r;
}
function eae(t3) {
  let e = t3[2] === "encrypt" ? "Encrypt" : "Decrypt", n;
  return { c() {
    n = we(e);
  }, m(r, s) {
    R(r, n, s);
  }, p(r, s) {
    s & 4 && e !== (e = r[2] === "encrypt" ? "Encrypt" : "Decrypt") && Ze(n, e);
  }, d(r) {
    r && D(n);
  } };
}
function tae(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function mE(t3) {
  let e;
  return { c() {
    e = H("div"), e.textContent = `${t3[18]}`, V(e, "class", "grid-cell svelte-1w5d8a4");
  }, m(n, r) {
    R(n, e, r);
  }, p: dt, d(n) {
    n && D(e);
  } };
}
function vE(t3) {
  let e, n, r = Mr(t3[15]), s = [];
  for (let i = 0; i < r.length; i += 1) s[i] = mE(gE(t3, r, i));
  return { c() {
    e = H("div");
    for (let i = 0; i < s.length; i += 1) s[i].c();
    n = z(), V(e, "class", "grid-row svelte-1w5d8a4");
  }, m(i, a) {
    R(i, e, a);
    for (let o = 0; o < s.length; o += 1) s[o] && s[o].m(e, null);
    q(e, n);
  }, p(i, a) {
    if (a & 64) {
      r = Mr(i[15]);
      let o;
      for (o = 0; o < r.length; o += 1) {
        const f = gE(i, r, o);
        s[o] ? s[o].p(f, a) : (s[o] = mE(f), s[o].c(), s[o].m(e, n));
      }
      for (; o < s.length; o += 1) s[o].d(1);
      s.length = r.length;
    }
  }, d(i) {
    i && D(e), jn(s, i);
  } };
}
function yE(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[4]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 16 && Ze(n, r[4]);
  }, d(r) {
    r && D(e);
  } };
}
function bE(t3) {
  let e, n;
  return e = new et({ props: { label: "Result:", value: t3[3], readonly: true, expandable: true, withCopy: true, rows: 3 } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, s) {
    const i = {};
    s & 8 && (i.value = r[3]), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function rae(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U, Q, P, N, L, B;
  function u(T) {
    t3[10](T);
  }
  let p = { label: "Operation:", options: t3[5] };
  t3[2] !== void 0 && (p.value = t3[2]), r = new Ht({ props: p }), Qe.push(() => ze(r, "value", u));
  function d(T) {
    t3[11](T);
  }
  let y = { label: t3[2] === "encrypt" ? "Plaintext:" : "Ciphertext:", placeholder: t3[2] === "encrypt" ? "Message to encrypt..." : "Message to decrypt...", expandable: true, rows: 3 };
  t3[0] !== void 0 && (y.value = t3[0]), a = new et({ props: y }), Qe.push(() => ze(a, "value", d)), l = new ut({ props: { $$slots: { default: [eae] }, $$scope: { ctx: t3 } } }), l.$on("click", t3[7]), m = new ut({ props: { variant: "secondary", $$slots: { default: [tae] }, $$scope: { ctx: t3 } } }), m.$on("click", t3[12]), b = new hn({}), b.$on("click", t3[8]);
  function w(T) {
    t3[13](T);
  }
  let E = {};
  t3[1] !== void 0 && (E.checked = t3[1]), C = new xr({ props: E }), Qe.push(() => ze(C, "checked", w));
  let M = Mr(t3[6]), x = [];
  for (let T = 0; T < M.length; T += 1) x[T] = vE(pE(t3, M, T));
  let g = t3[4] && yE(t3), k = t3[3] && bE(t3);
  return { c() {
    e = H("div"), n = H("div"), fe(r.$$.fragment), i = z(), fe(a.$$.fragment), f = z(), c = H("div"), fe(l.$$.fragment), h = z(), fe(m.$$.fragment), v = z(), fe(b.$$.fragment), A = z(), _ = H("div"), fe(C.$$.fragment), S = z(), $ = H("div"), F = H("div"), F.textContent = "Polybius Square", U = z(), Q = H("div");
    for (let T = 0; T < x.length; T += 1) x[T].c();
    P = z(), g && g.c(), N = z(), k && k.c(), L = Lt(), St(_, "margin-left", "auto"), V(c, "class", "button-row"), V(n, "class", "controls svelte-1w5d8a4"), V(F, "class", "grid-title svelte-1w5d8a4"), V(Q, "class", "polybius-grid svelte-1w5d8a4"), V($, "class", "grid-display svelte-1w5d8a4"), V(e, "class", "layout svelte-1w5d8a4");
  }, m(T, O) {
    R(T, e, O), q(e, n), ae(r, n, null), q(n, i), ae(a, n, null), q(n, f), q(n, c), ae(l, c, null), q(c, h), ae(m, c, null), q(c, v), ae(b, c, null), q(c, A), q(c, _), ae(C, _, null), q(e, S), q(e, $), q($, F), q($, U), q($, Q);
    for (let K = 0; K < x.length; K += 1) x[K] && x[K].m(Q, null);
    R(T, P, O), g && g.m(T, O), R(T, N, O), k && k.m(T, O), R(T, L, O), B = true;
  }, p(T, O) {
    const K = {};
    !s && O & 4 && (s = true, K.value = T[2], qe(() => s = false)), r.$set(K);
    const Y = {};
    O & 4 && (Y.label = T[2] === "encrypt" ? "Plaintext:" : "Ciphertext:"), O & 4 && (Y.placeholder = T[2] === "encrypt" ? "Message to encrypt..." : "Message to decrypt..."), !o && O & 1 && (o = true, Y.value = T[0], qe(() => o = false)), a.$set(Y);
    const J = {};
    O & 2097156 && (J.$$scope = { dirty: O, ctx: T }), l.$set(J);
    const G = {};
    O & 2097152 && (G.$$scope = { dirty: O, ctx: T }), m.$set(G);
    const X = {};
    if (!I && O & 2 && (I = true, X.checked = T[1], qe(() => I = false)), C.$set(X), O & 64) {
      M = Mr(T[6]);
      let ie;
      for (ie = 0; ie < M.length; ie += 1) {
        const de = pE(T, M, ie);
        x[ie] ? x[ie].p(de, O) : (x[ie] = vE(de), x[ie].c(), x[ie].m(Q, null));
      }
      for (; ie < x.length; ie += 1) x[ie].d(1);
      x.length = M.length;
    }
    T[4] ? g ? g.p(T, O) : (g = yE(T), g.c(), g.m(N.parentNode, N)) : g && (g.d(1), g = null), T[3] ? k ? (k.p(T, O), O & 8 && W(k, 1)) : (k = bE(T), k.c(), W(k, 1), k.m(L.parentNode, L)) : k && (Xt(), j(k, 1, 1, () => {
      k = null;
    }), er());
  }, i(T) {
    B || (W(r.$$.fragment, T), W(a.$$.fragment, T), W(l.$$.fragment, T), W(m.$$.fragment, T), W(b.$$.fragment, T), W(C.$$.fragment, T), W(k), B = true);
  }, o(T) {
    j(r.$$.fragment, T), j(a.$$.fragment, T), j(l.$$.fragment, T), j(m.$$.fragment, T), j(b.$$.fragment, T), j(C.$$.fragment, T), j(k), B = false;
  }, d(T) {
    T && (D(e), D(P), D(N), D(L)), oe(r), oe(a), oe(l), oe(m), oe(b), oe(C), jn(x, T), g && g.d(T), k && k.d(T);
  } };
}
function nae(t3) {
  let e, n, r, s, i;
  return { c() {
    e = H("p"), e.textContent = `The Bifid cipher is a classical encryption technique that combines 
    both substitution and transposition to encrypt messages. Developed 
    by the French cryptographer F\xE9lix Delastelle in the early 20th century 
    the Bifid cipher is known for its simplicity and effectiveness.`, n = z(), r = H("p"), r.textContent = `The cipher uses a Polybius square, which is a 5x5 grid filled with letters. 
    The grid typically contains the letters A-Z (I and J are usually 
    combined to fit into the 25 squares).`, s = z(), i = H("ol"), i.innerHTML = "<li><strong>Coordinates:</strong> Each letter is converted to its (Row, Column) numbers from the Polybius Square.</li> <li><strong>Transposition:</strong> All Rows are written in a line, followed by all Columns.</li> <li><strong>Regrouping:</strong> This long string of numbers is read in pairs of two.</li> <li><strong>Substitution:</strong> These new pairs are converted back into letters using the same square.</li>";
  }, m(a, o) {
    R(a, e, o), R(a, n, o), R(a, r, o), R(a, s, o), R(a, i, o);
  }, p: dt, d(a) {
    a && (D(e), D(n), D(r), D(s), D(i));
  } };
}
function iae(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Bifid Cipher", $$slots: { default: [rae] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Bifid Cipher", links: t3[9], $$slots: { default: [nae] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 2097183 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 2097152 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function sae(t3, e, n) {
  let r = "encrypt", s = "", i = "", a = "", o = true;
  const f = [{ value: "encrypt", label: "Encrypt" }, { value: "decrypt", label: "Decrypt" }], c = Xse(), l = [];
  for (let I = 0; I < 5; I++) l.push(c.slice(I * 5, (I + 1) * 5).split(""));
  function h() {
    if (n(4, a = ""), n(3, i = ""), !s) return n(4, a = "Please enter text.");
    try {
      r === "encrypt" ? n(3, i = Zse(s)) : n(3, i = jse(s));
    } catch (I) {
      n(4, a = I.message);
    }
  }
  function m() {
    n(2, r = r === "encrypt" ? "decrypt" : "encrypt"), i && !a && (n(0, s = i), n(3, i = ""));
  }
  const v = [{ text: "Wikipedia", url: "https://en.wikipedia.org/wiki/Bifid_cipher" }, { text: "Geeks for Geeks", url: "https://www.geeksforgeeks.org/bifid-cipher-in-cryptography" }];
  function b(I) {
    r = I, n(2, r);
  }
  function A(I) {
    s = I, n(0, s);
  }
  const _ = () => {
    n(0, s = ""), n(3, i = "");
  };
  function C(I) {
    o = I, n(1, o);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 3 && o && s && h();
  }, [s, o, r, i, a, f, l, h, m, v, b, A, _, C];
}
class aae extends xt {
  constructor(e) {
    super(), wt(this, e, sae, iae, At, {});
  }
}
var pD = { exports: {} };
(function(t3) {
  (function(e) {
    var n = function(ge) {
      var be, Ae = new Float64Array(16);
      if (ge) for (be = 0; be < ge.length; be++) Ae[be] = ge[be];
      return Ae;
    }, r = function() {
      throw new Error("no PRNG");
    }, s = new Uint8Array(16), i = new Uint8Array(32);
    i[0] = 9;
    var a = n(), o = n([1]), f = n([56129, 1]), c = n([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), l = n([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), h = n([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), m = n([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), v = n([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function b(ge, be, Ae, ne) {
      ge[be] = Ae >> 24 & 255, ge[be + 1] = Ae >> 16 & 255, ge[be + 2] = Ae >> 8 & 255, ge[be + 3] = Ae & 255, ge[be + 4] = ne >> 24 & 255, ge[be + 5] = ne >> 16 & 255, ge[be + 6] = ne >> 8 & 255, ge[be + 7] = ne & 255;
    }
    function A(ge, be, Ae, ne, _e) {
      var Te, Ye = 0;
      for (Te = 0; Te < _e; Te++) Ye |= ge[be + Te] ^ Ae[ne + Te];
      return (1 & Ye - 1 >>> 8) - 1;
    }
    function _(ge, be, Ae, ne) {
      return A(ge, be, Ae, ne, 16);
    }
    function C(ge, be, Ae, ne) {
      return A(ge, be, Ae, ne, 32);
    }
    function I(ge, be, Ae, ne) {
      for (var _e = ne[0] & 255 | (ne[1] & 255) << 8 | (ne[2] & 255) << 16 | (ne[3] & 255) << 24, Te = Ae[0] & 255 | (Ae[1] & 255) << 8 | (Ae[2] & 255) << 16 | (Ae[3] & 255) << 24, Ye = Ae[4] & 255 | (Ae[5] & 255) << 8 | (Ae[6] & 255) << 16 | (Ae[7] & 255) << 24, Pe = Ae[8] & 255 | (Ae[9] & 255) << 8 | (Ae[10] & 255) << 16 | (Ae[11] & 255) << 24, He = Ae[12] & 255 | (Ae[13] & 255) << 8 | (Ae[14] & 255) << 16 | (Ae[15] & 255) << 24, _t = ne[4] & 255 | (ne[5] & 255) << 8 | (ne[6] & 255) << 16 | (ne[7] & 255) << 24, vt = be[0] & 255 | (be[1] & 255) << 8 | (be[2] & 255) << 16 | (be[3] & 255) << 24, cr = be[4] & 255 | (be[5] & 255) << 8 | (be[6] & 255) << 16 | (be[7] & 255) << 24, Tt = be[8] & 255 | (be[9] & 255) << 8 | (be[10] & 255) << 16 | (be[11] & 255) << 24, Gt = be[12] & 255 | (be[13] & 255) << 8 | (be[14] & 255) << 16 | (be[15] & 255) << 24, Yt = ne[8] & 255 | (ne[9] & 255) << 8 | (ne[10] & 255) << 16 | (ne[11] & 255) << 24, or = Ae[16] & 255 | (Ae[17] & 255) << 8 | (Ae[18] & 255) << 16 | (Ae[19] & 255) << 24, sr = Ae[20] & 255 | (Ae[21] & 255) << 8 | (Ae[22] & 255) << 16 | (Ae[23] & 255) << 24, Wt = Ae[24] & 255 | (Ae[25] & 255) << 8 | (Ae[26] & 255) << 16 | (Ae[27] & 255) << 24, tr = Ae[28] & 255 | (Ae[29] & 255) << 8 | (Ae[30] & 255) << 16 | (Ae[31] & 255) << 24, Jt = ne[12] & 255 | (ne[13] & 255) << 8 | (ne[14] & 255) << 16 | (ne[15] & 255) << 24, Ft = _e, Ut = Te, Mt = Ye, Pt = Pe, Nt = He, It = _t, tt = vt, rt = cr, Et = Tt, yt = Gt, bt = Yt, Dt = or, vr = sr, kr = Wt, $r = tr, Ir = Jt, Le, Pr = 0; Pr < 20; Pr += 2) Le = Ft + vr | 0, Nt ^= Le << 7 | Le >>> 25, Le = Nt + Ft | 0, Et ^= Le << 9 | Le >>> 23, Le = Et + Nt | 0, vr ^= Le << 13 | Le >>> 19, Le = vr + Et | 0, Ft ^= Le << 18 | Le >>> 14, Le = It + Ut | 0, yt ^= Le << 7 | Le >>> 25, Le = yt + It | 0, kr ^= Le << 9 | Le >>> 23, Le = kr + yt | 0, Ut ^= Le << 13 | Le >>> 19, Le = Ut + kr | 0, It ^= Le << 18 | Le >>> 14, Le = bt + tt | 0, $r ^= Le << 7 | Le >>> 25, Le = $r + bt | 0, Mt ^= Le << 9 | Le >>> 23, Le = Mt + $r | 0, tt ^= Le << 13 | Le >>> 19, Le = tt + Mt | 0, bt ^= Le << 18 | Le >>> 14, Le = Ir + Dt | 0, Pt ^= Le << 7 | Le >>> 25, Le = Pt + Ir | 0, rt ^= Le << 9 | Le >>> 23, Le = rt + Pt | 0, Dt ^= Le << 13 | Le >>> 19, Le = Dt + rt | 0, Ir ^= Le << 18 | Le >>> 14, Le = Ft + Pt | 0, Ut ^= Le << 7 | Le >>> 25, Le = Ut + Ft | 0, Mt ^= Le << 9 | Le >>> 23, Le = Mt + Ut | 0, Pt ^= Le << 13 | Le >>> 19, Le = Pt + Mt | 0, Ft ^= Le << 18 | Le >>> 14, Le = It + Nt | 0, tt ^= Le << 7 | Le >>> 25, Le = tt + It | 0, rt ^= Le << 9 | Le >>> 23, Le = rt + tt | 0, Nt ^= Le << 13 | Le >>> 19, Le = Nt + rt | 0, It ^= Le << 18 | Le >>> 14, Le = bt + yt | 0, Dt ^= Le << 7 | Le >>> 25, Le = Dt + bt | 0, Et ^= Le << 9 | Le >>> 23, Le = Et + Dt | 0, yt ^= Le << 13 | Le >>> 19, Le = yt + Et | 0, bt ^= Le << 18 | Le >>> 14, Le = Ir + $r | 0, vr ^= Le << 7 | Le >>> 25, Le = vr + Ir | 0, kr ^= Le << 9 | Le >>> 23, Le = kr + vr | 0, $r ^= Le << 13 | Le >>> 19, Le = $r + kr | 0, Ir ^= Le << 18 | Le >>> 14;
      Ft = Ft + _e | 0, Ut = Ut + Te | 0, Mt = Mt + Ye | 0, Pt = Pt + Pe | 0, Nt = Nt + He | 0, It = It + _t | 0, tt = tt + vt | 0, rt = rt + cr | 0, Et = Et + Tt | 0, yt = yt + Gt | 0, bt = bt + Yt | 0, Dt = Dt + or | 0, vr = vr + sr | 0, kr = kr + Wt | 0, $r = $r + tr | 0, Ir = Ir + Jt | 0, ge[0] = Ft >>> 0 & 255, ge[1] = Ft >>> 8 & 255, ge[2] = Ft >>> 16 & 255, ge[3] = Ft >>> 24 & 255, ge[4] = Ut >>> 0 & 255, ge[5] = Ut >>> 8 & 255, ge[6] = Ut >>> 16 & 255, ge[7] = Ut >>> 24 & 255, ge[8] = Mt >>> 0 & 255, ge[9] = Mt >>> 8 & 255, ge[10] = Mt >>> 16 & 255, ge[11] = Mt >>> 24 & 255, ge[12] = Pt >>> 0 & 255, ge[13] = Pt >>> 8 & 255, ge[14] = Pt >>> 16 & 255, ge[15] = Pt >>> 24 & 255, ge[16] = Nt >>> 0 & 255, ge[17] = Nt >>> 8 & 255, ge[18] = Nt >>> 16 & 255, ge[19] = Nt >>> 24 & 255, ge[20] = It >>> 0 & 255, ge[21] = It >>> 8 & 255, ge[22] = It >>> 16 & 255, ge[23] = It >>> 24 & 255, ge[24] = tt >>> 0 & 255, ge[25] = tt >>> 8 & 255, ge[26] = tt >>> 16 & 255, ge[27] = tt >>> 24 & 255, ge[28] = rt >>> 0 & 255, ge[29] = rt >>> 8 & 255, ge[30] = rt >>> 16 & 255, ge[31] = rt >>> 24 & 255, ge[32] = Et >>> 0 & 255, ge[33] = Et >>> 8 & 255, ge[34] = Et >>> 16 & 255, ge[35] = Et >>> 24 & 255, ge[36] = yt >>> 0 & 255, ge[37] = yt >>> 8 & 255, ge[38] = yt >>> 16 & 255, ge[39] = yt >>> 24 & 255, ge[40] = bt >>> 0 & 255, ge[41] = bt >>> 8 & 255, ge[42] = bt >>> 16 & 255, ge[43] = bt >>> 24 & 255, ge[44] = Dt >>> 0 & 255, ge[45] = Dt >>> 8 & 255, ge[46] = Dt >>> 16 & 255, ge[47] = Dt >>> 24 & 255, ge[48] = vr >>> 0 & 255, ge[49] = vr >>> 8 & 255, ge[50] = vr >>> 16 & 255, ge[51] = vr >>> 24 & 255, ge[52] = kr >>> 0 & 255, ge[53] = kr >>> 8 & 255, ge[54] = kr >>> 16 & 255, ge[55] = kr >>> 24 & 255, ge[56] = $r >>> 0 & 255, ge[57] = $r >>> 8 & 255, ge[58] = $r >>> 16 & 255, ge[59] = $r >>> 24 & 255, ge[60] = Ir >>> 0 & 255, ge[61] = Ir >>> 8 & 255, ge[62] = Ir >>> 16 & 255, ge[63] = Ir >>> 24 & 255;
    }
    function S(ge, be, Ae, ne) {
      for (var _e = ne[0] & 255 | (ne[1] & 255) << 8 | (ne[2] & 255) << 16 | (ne[3] & 255) << 24, Te = Ae[0] & 255 | (Ae[1] & 255) << 8 | (Ae[2] & 255) << 16 | (Ae[3] & 255) << 24, Ye = Ae[4] & 255 | (Ae[5] & 255) << 8 | (Ae[6] & 255) << 16 | (Ae[7] & 255) << 24, Pe = Ae[8] & 255 | (Ae[9] & 255) << 8 | (Ae[10] & 255) << 16 | (Ae[11] & 255) << 24, He = Ae[12] & 255 | (Ae[13] & 255) << 8 | (Ae[14] & 255) << 16 | (Ae[15] & 255) << 24, _t = ne[4] & 255 | (ne[5] & 255) << 8 | (ne[6] & 255) << 16 | (ne[7] & 255) << 24, vt = be[0] & 255 | (be[1] & 255) << 8 | (be[2] & 255) << 16 | (be[3] & 255) << 24, cr = be[4] & 255 | (be[5] & 255) << 8 | (be[6] & 255) << 16 | (be[7] & 255) << 24, Tt = be[8] & 255 | (be[9] & 255) << 8 | (be[10] & 255) << 16 | (be[11] & 255) << 24, Gt = be[12] & 255 | (be[13] & 255) << 8 | (be[14] & 255) << 16 | (be[15] & 255) << 24, Yt = ne[8] & 255 | (ne[9] & 255) << 8 | (ne[10] & 255) << 16 | (ne[11] & 255) << 24, or = Ae[16] & 255 | (Ae[17] & 255) << 8 | (Ae[18] & 255) << 16 | (Ae[19] & 255) << 24, sr = Ae[20] & 255 | (Ae[21] & 255) << 8 | (Ae[22] & 255) << 16 | (Ae[23] & 255) << 24, Wt = Ae[24] & 255 | (Ae[25] & 255) << 8 | (Ae[26] & 255) << 16 | (Ae[27] & 255) << 24, tr = Ae[28] & 255 | (Ae[29] & 255) << 8 | (Ae[30] & 255) << 16 | (Ae[31] & 255) << 24, Jt = ne[12] & 255 | (ne[13] & 255) << 8 | (ne[14] & 255) << 16 | (ne[15] & 255) << 24, Ft = _e, Ut = Te, Mt = Ye, Pt = Pe, Nt = He, It = _t, tt = vt, rt = cr, Et = Tt, yt = Gt, bt = Yt, Dt = or, vr = sr, kr = Wt, $r = tr, Ir = Jt, Le, Pr = 0; Pr < 20; Pr += 2) Le = Ft + vr | 0, Nt ^= Le << 7 | Le >>> 25, Le = Nt + Ft | 0, Et ^= Le << 9 | Le >>> 23, Le = Et + Nt | 0, vr ^= Le << 13 | Le >>> 19, Le = vr + Et | 0, Ft ^= Le << 18 | Le >>> 14, Le = It + Ut | 0, yt ^= Le << 7 | Le >>> 25, Le = yt + It | 0, kr ^= Le << 9 | Le >>> 23, Le = kr + yt | 0, Ut ^= Le << 13 | Le >>> 19, Le = Ut + kr | 0, It ^= Le << 18 | Le >>> 14, Le = bt + tt | 0, $r ^= Le << 7 | Le >>> 25, Le = $r + bt | 0, Mt ^= Le << 9 | Le >>> 23, Le = Mt + $r | 0, tt ^= Le << 13 | Le >>> 19, Le = tt + Mt | 0, bt ^= Le << 18 | Le >>> 14, Le = Ir + Dt | 0, Pt ^= Le << 7 | Le >>> 25, Le = Pt + Ir | 0, rt ^= Le << 9 | Le >>> 23, Le = rt + Pt | 0, Dt ^= Le << 13 | Le >>> 19, Le = Dt + rt | 0, Ir ^= Le << 18 | Le >>> 14, Le = Ft + Pt | 0, Ut ^= Le << 7 | Le >>> 25, Le = Ut + Ft | 0, Mt ^= Le << 9 | Le >>> 23, Le = Mt + Ut | 0, Pt ^= Le << 13 | Le >>> 19, Le = Pt + Mt | 0, Ft ^= Le << 18 | Le >>> 14, Le = It + Nt | 0, tt ^= Le << 7 | Le >>> 25, Le = tt + It | 0, rt ^= Le << 9 | Le >>> 23, Le = rt + tt | 0, Nt ^= Le << 13 | Le >>> 19, Le = Nt + rt | 0, It ^= Le << 18 | Le >>> 14, Le = bt + yt | 0, Dt ^= Le << 7 | Le >>> 25, Le = Dt + bt | 0, Et ^= Le << 9 | Le >>> 23, Le = Et + Dt | 0, yt ^= Le << 13 | Le >>> 19, Le = yt + Et | 0, bt ^= Le << 18 | Le >>> 14, Le = Ir + $r | 0, vr ^= Le << 7 | Le >>> 25, Le = vr + Ir | 0, kr ^= Le << 9 | Le >>> 23, Le = kr + vr | 0, $r ^= Le << 13 | Le >>> 19, Le = $r + kr | 0, Ir ^= Le << 18 | Le >>> 14;
      ge[0] = Ft >>> 0 & 255, ge[1] = Ft >>> 8 & 255, ge[2] = Ft >>> 16 & 255, ge[3] = Ft >>> 24 & 255, ge[4] = It >>> 0 & 255, ge[5] = It >>> 8 & 255, ge[6] = It >>> 16 & 255, ge[7] = It >>> 24 & 255, ge[8] = bt >>> 0 & 255, ge[9] = bt >>> 8 & 255, ge[10] = bt >>> 16 & 255, ge[11] = bt >>> 24 & 255, ge[12] = Ir >>> 0 & 255, ge[13] = Ir >>> 8 & 255, ge[14] = Ir >>> 16 & 255, ge[15] = Ir >>> 24 & 255, ge[16] = tt >>> 0 & 255, ge[17] = tt >>> 8 & 255, ge[18] = tt >>> 16 & 255, ge[19] = tt >>> 24 & 255, ge[20] = rt >>> 0 & 255, ge[21] = rt >>> 8 & 255, ge[22] = rt >>> 16 & 255, ge[23] = rt >>> 24 & 255, ge[24] = Et >>> 0 & 255, ge[25] = Et >>> 8 & 255, ge[26] = Et >>> 16 & 255, ge[27] = Et >>> 24 & 255, ge[28] = yt >>> 0 & 255, ge[29] = yt >>> 8 & 255, ge[30] = yt >>> 16 & 255, ge[31] = yt >>> 24 & 255;
    }
    function $(ge, be, Ae, ne) {
      I(ge, be, Ae, ne);
    }
    function F(ge, be, Ae, ne) {
      S(ge, be, Ae, ne);
    }
    var U = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function Q(ge, be, Ae, ne, _e, Te, Ye) {
      var Pe = new Uint8Array(16), He = new Uint8Array(64), _t, vt;
      for (vt = 0; vt < 16; vt++) Pe[vt] = 0;
      for (vt = 0; vt < 8; vt++) Pe[vt] = Te[vt];
      for (; _e >= 64; ) {
        for ($(He, Pe, Ye, U), vt = 0; vt < 64; vt++) ge[be + vt] = Ae[ne + vt] ^ He[vt];
        for (_t = 1, vt = 8; vt < 16; vt++) _t = _t + (Pe[vt] & 255) | 0, Pe[vt] = _t & 255, _t >>>= 8;
        _e -= 64, be += 64, ne += 64;
      }
      if (_e > 0) for ($(He, Pe, Ye, U), vt = 0; vt < _e; vt++) ge[be + vt] = Ae[ne + vt] ^ He[vt];
      return 0;
    }
    function P(ge, be, Ae, ne, _e) {
      var Te = new Uint8Array(16), Ye = new Uint8Array(64), Pe, He;
      for (He = 0; He < 16; He++) Te[He] = 0;
      for (He = 0; He < 8; He++) Te[He] = ne[He];
      for (; Ae >= 64; ) {
        for ($(Ye, Te, _e, U), He = 0; He < 64; He++) ge[be + He] = Ye[He];
        for (Pe = 1, He = 8; He < 16; He++) Pe = Pe + (Te[He] & 255) | 0, Te[He] = Pe & 255, Pe >>>= 8;
        Ae -= 64, be += 64;
      }
      if (Ae > 0) for ($(Ye, Te, _e, U), He = 0; He < Ae; He++) ge[be + He] = Ye[He];
      return 0;
    }
    function N(ge, be, Ae, ne, _e) {
      var Te = new Uint8Array(32);
      F(Te, ne, _e, U);
      for (var Ye = new Uint8Array(8), Pe = 0; Pe < 8; Pe++) Ye[Pe] = ne[Pe + 16];
      return P(ge, be, Ae, Ye, Te);
    }
    function L(ge, be, Ae, ne, _e, Te, Ye) {
      var Pe = new Uint8Array(32);
      F(Pe, Te, Ye, U);
      for (var He = new Uint8Array(8), _t = 0; _t < 8; _t++) He[_t] = Te[_t + 16];
      return Q(ge, be, Ae, ne, _e, He, Pe);
    }
    var B = function(ge) {
      this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0;
      var be, Ae, ne, _e, Te, Ye, Pe, He;
      be = ge[0] & 255 | (ge[1] & 255) << 8, this.r[0] = be & 8191, Ae = ge[2] & 255 | (ge[3] & 255) << 8, this.r[1] = (be >>> 13 | Ae << 3) & 8191, ne = ge[4] & 255 | (ge[5] & 255) << 8, this.r[2] = (Ae >>> 10 | ne << 6) & 7939, _e = ge[6] & 255 | (ge[7] & 255) << 8, this.r[3] = (ne >>> 7 | _e << 9) & 8191, Te = ge[8] & 255 | (ge[9] & 255) << 8, this.r[4] = (_e >>> 4 | Te << 12) & 255, this.r[5] = Te >>> 1 & 8190, Ye = ge[10] & 255 | (ge[11] & 255) << 8, this.r[6] = (Te >>> 14 | Ye << 2) & 8191, Pe = ge[12] & 255 | (ge[13] & 255) << 8, this.r[7] = (Ye >>> 11 | Pe << 5) & 8065, He = ge[14] & 255 | (ge[15] & 255) << 8, this.r[8] = (Pe >>> 8 | He << 8) & 8191, this.r[9] = He >>> 5 & 127, this.pad[0] = ge[16] & 255 | (ge[17] & 255) << 8, this.pad[1] = ge[18] & 255 | (ge[19] & 255) << 8, this.pad[2] = ge[20] & 255 | (ge[21] & 255) << 8, this.pad[3] = ge[22] & 255 | (ge[23] & 255) << 8, this.pad[4] = ge[24] & 255 | (ge[25] & 255) << 8, this.pad[5] = ge[26] & 255 | (ge[27] & 255) << 8, this.pad[6] = ge[28] & 255 | (ge[29] & 255) << 8, this.pad[7] = ge[30] & 255 | (ge[31] & 255) << 8;
    };
    B.prototype.blocks = function(ge, be, Ae) {
      for (var ne = this.fin ? 0 : 2048, _e, Te, Ye, Pe, He, _t, vt, cr, Tt, Gt, Yt, or, sr, Wt, tr, Jt, Ft, Ut, Mt, Pt = this.h[0], Nt = this.h[1], It = this.h[2], tt = this.h[3], rt = this.h[4], Et = this.h[5], yt = this.h[6], bt = this.h[7], Dt = this.h[8], vr = this.h[9], kr = this.r[0], $r = this.r[1], Ir = this.r[2], Le = this.r[3], Pr = this.r[4], en = this.r[5], tn = this.r[6], Rr = this.r[7], Jr = this.r[8], Zr = this.r[9]; Ae >= 16; ) _e = ge[be + 0] & 255 | (ge[be + 1] & 255) << 8, Pt += _e & 8191, Te = ge[be + 2] & 255 | (ge[be + 3] & 255) << 8, Nt += (_e >>> 13 | Te << 3) & 8191, Ye = ge[be + 4] & 255 | (ge[be + 5] & 255) << 8, It += (Te >>> 10 | Ye << 6) & 8191, Pe = ge[be + 6] & 255 | (ge[be + 7] & 255) << 8, tt += (Ye >>> 7 | Pe << 9) & 8191, He = ge[be + 8] & 255 | (ge[be + 9] & 255) << 8, rt += (Pe >>> 4 | He << 12) & 8191, Et += He >>> 1 & 8191, _t = ge[be + 10] & 255 | (ge[be + 11] & 255) << 8, yt += (He >>> 14 | _t << 2) & 8191, vt = ge[be + 12] & 255 | (ge[be + 13] & 255) << 8, bt += (_t >>> 11 | vt << 5) & 8191, cr = ge[be + 14] & 255 | (ge[be + 15] & 255) << 8, Dt += (vt >>> 8 | cr << 8) & 8191, vr += cr >>> 5 | ne, Tt = 0, Gt = Tt, Gt += Pt * kr, Gt += Nt * (5 * Zr), Gt += It * (5 * Jr), Gt += tt * (5 * Rr), Gt += rt * (5 * tn), Tt = Gt >>> 13, Gt &= 8191, Gt += Et * (5 * en), Gt += yt * (5 * Pr), Gt += bt * (5 * Le), Gt += Dt * (5 * Ir), Gt += vr * (5 * $r), Tt += Gt >>> 13, Gt &= 8191, Yt = Tt, Yt += Pt * $r, Yt += Nt * kr, Yt += It * (5 * Zr), Yt += tt * (5 * Jr), Yt += rt * (5 * Rr), Tt = Yt >>> 13, Yt &= 8191, Yt += Et * (5 * tn), Yt += yt * (5 * en), Yt += bt * (5 * Pr), Yt += Dt * (5 * Le), Yt += vr * (5 * Ir), Tt += Yt >>> 13, Yt &= 8191, or = Tt, or += Pt * Ir, or += Nt * $r, or += It * kr, or += tt * (5 * Zr), or += rt * (5 * Jr), Tt = or >>> 13, or &= 8191, or += Et * (5 * Rr), or += yt * (5 * tn), or += bt * (5 * en), or += Dt * (5 * Pr), or += vr * (5 * Le), Tt += or >>> 13, or &= 8191, sr = Tt, sr += Pt * Le, sr += Nt * Ir, sr += It * $r, sr += tt * kr, sr += rt * (5 * Zr), Tt = sr >>> 13, sr &= 8191, sr += Et * (5 * Jr), sr += yt * (5 * Rr), sr += bt * (5 * tn), sr += Dt * (5 * en), sr += vr * (5 * Pr), Tt += sr >>> 13, sr &= 8191, Wt = Tt, Wt += Pt * Pr, Wt += Nt * Le, Wt += It * Ir, Wt += tt * $r, Wt += rt * kr, Tt = Wt >>> 13, Wt &= 8191, Wt += Et * (5 * Zr), Wt += yt * (5 * Jr), Wt += bt * (5 * Rr), Wt += Dt * (5 * tn), Wt += vr * (5 * en), Tt += Wt >>> 13, Wt &= 8191, tr = Tt, tr += Pt * en, tr += Nt * Pr, tr += It * Le, tr += tt * Ir, tr += rt * $r, Tt = tr >>> 13, tr &= 8191, tr += Et * kr, tr += yt * (5 * Zr), tr += bt * (5 * Jr), tr += Dt * (5 * Rr), tr += vr * (5 * tn), Tt += tr >>> 13, tr &= 8191, Jt = Tt, Jt += Pt * tn, Jt += Nt * en, Jt += It * Pr, Jt += tt * Le, Jt += rt * Ir, Tt = Jt >>> 13, Jt &= 8191, Jt += Et * $r, Jt += yt * kr, Jt += bt * (5 * Zr), Jt += Dt * (5 * Jr), Jt += vr * (5 * Rr), Tt += Jt >>> 13, Jt &= 8191, Ft = Tt, Ft += Pt * Rr, Ft += Nt * tn, Ft += It * en, Ft += tt * Pr, Ft += rt * Le, Tt = Ft >>> 13, Ft &= 8191, Ft += Et * Ir, Ft += yt * $r, Ft += bt * kr, Ft += Dt * (5 * Zr), Ft += vr * (5 * Jr), Tt += Ft >>> 13, Ft &= 8191, Ut = Tt, Ut += Pt * Jr, Ut += Nt * Rr, Ut += It * tn, Ut += tt * en, Ut += rt * Pr, Tt = Ut >>> 13, Ut &= 8191, Ut += Et * Le, Ut += yt * Ir, Ut += bt * $r, Ut += Dt * kr, Ut += vr * (5 * Zr), Tt += Ut >>> 13, Ut &= 8191, Mt = Tt, Mt += Pt * Zr, Mt += Nt * Jr, Mt += It * Rr, Mt += tt * tn, Mt += rt * en, Tt = Mt >>> 13, Mt &= 8191, Mt += Et * Pr, Mt += yt * Le, Mt += bt * Ir, Mt += Dt * $r, Mt += vr * kr, Tt += Mt >>> 13, Mt &= 8191, Tt = (Tt << 2) + Tt | 0, Tt = Tt + Gt | 0, Gt = Tt & 8191, Tt = Tt >>> 13, Yt += Tt, Pt = Gt, Nt = Yt, It = or, tt = sr, rt = Wt, Et = tr, yt = Jt, bt = Ft, Dt = Ut, vr = Mt, be += 16, Ae -= 16;
      this.h[0] = Pt, this.h[1] = Nt, this.h[2] = It, this.h[3] = tt, this.h[4] = rt, this.h[5] = Et, this.h[6] = yt, this.h[7] = bt, this.h[8] = Dt, this.h[9] = vr;
    }, B.prototype.finish = function(ge, be) {
      var Ae = new Uint16Array(10), ne, _e, Te, Ye;
      if (this.leftover) {
        for (Ye = this.leftover, this.buffer[Ye++] = 1; Ye < 16; Ye++) this.buffer[Ye] = 0;
        this.fin = 1, this.blocks(this.buffer, 0, 16);
      }
      for (ne = this.h[1] >>> 13, this.h[1] &= 8191, Ye = 2; Ye < 10; Ye++) this.h[Ye] += ne, ne = this.h[Ye] >>> 13, this.h[Ye] &= 8191;
      for (this.h[0] += ne * 5, ne = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += ne, ne = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += ne, Ae[0] = this.h[0] + 5, ne = Ae[0] >>> 13, Ae[0] &= 8191, Ye = 1; Ye < 10; Ye++) Ae[Ye] = this.h[Ye] + ne, ne = Ae[Ye] >>> 13, Ae[Ye] &= 8191;
      for (Ae[9] -= 8192, _e = (ne ^ 1) - 1, Ye = 0; Ye < 10; Ye++) Ae[Ye] &= _e;
      for (_e = ~_e, Ye = 0; Ye < 10; Ye++) this.h[Ye] = this.h[Ye] & _e | Ae[Ye];
      for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535, this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535, this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535, this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535, this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535, this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535, this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535, this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535, Te = this.h[0] + this.pad[0], this.h[0] = Te & 65535, Ye = 1; Ye < 8; Ye++) Te = (this.h[Ye] + this.pad[Ye] | 0) + (Te >>> 16) | 0, this.h[Ye] = Te & 65535;
      ge[be + 0] = this.h[0] >>> 0 & 255, ge[be + 1] = this.h[0] >>> 8 & 255, ge[be + 2] = this.h[1] >>> 0 & 255, ge[be + 3] = this.h[1] >>> 8 & 255, ge[be + 4] = this.h[2] >>> 0 & 255, ge[be + 5] = this.h[2] >>> 8 & 255, ge[be + 6] = this.h[3] >>> 0 & 255, ge[be + 7] = this.h[3] >>> 8 & 255, ge[be + 8] = this.h[4] >>> 0 & 255, ge[be + 9] = this.h[4] >>> 8 & 255, ge[be + 10] = this.h[5] >>> 0 & 255, ge[be + 11] = this.h[5] >>> 8 & 255, ge[be + 12] = this.h[6] >>> 0 & 255, ge[be + 13] = this.h[6] >>> 8 & 255, ge[be + 14] = this.h[7] >>> 0 & 255, ge[be + 15] = this.h[7] >>> 8 & 255;
    }, B.prototype.update = function(ge, be, Ae) {
      var ne, _e;
      if (this.leftover) {
        for (_e = 16 - this.leftover, _e > Ae && (_e = Ae), ne = 0; ne < _e; ne++) this.buffer[this.leftover + ne] = ge[be + ne];
        if (Ae -= _e, be += _e, this.leftover += _e, this.leftover < 16) return;
        this.blocks(this.buffer, 0, 16), this.leftover = 0;
      }
      if (Ae >= 16 && (_e = Ae - Ae % 16, this.blocks(ge, be, _e), be += _e, Ae -= _e), Ae) {
        for (ne = 0; ne < Ae; ne++) this.buffer[this.leftover + ne] = ge[be + ne];
        this.leftover += Ae;
      }
    };
    function u(ge, be, Ae, ne, _e, Te) {
      var Ye = new B(Te);
      return Ye.update(Ae, ne, _e), Ye.finish(ge, be), 0;
    }
    function p(ge, be, Ae, ne, _e, Te) {
      var Ye = new Uint8Array(16);
      return u(Ye, 0, Ae, ne, _e, Te), _(ge, be, Ye, 0);
    }
    function d(ge, be, Ae, ne, _e) {
      var Te;
      if (Ae < 32) return -1;
      for (L(ge, 0, be, 0, Ae, ne, _e), u(ge, 16, ge, 32, Ae - 32, ge), Te = 0; Te < 16; Te++) ge[Te] = 0;
      return 0;
    }
    function y(ge, be, Ae, ne, _e) {
      var Te, Ye = new Uint8Array(32);
      if (Ae < 32 || (N(Ye, 0, 32, ne, _e), p(be, 16, be, 32, Ae - 32, Ye) !== 0)) return -1;
      for (L(ge, 0, be, 0, Ae, ne, _e), Te = 0; Te < 32; Te++) ge[Te] = 0;
      return 0;
    }
    function w(ge, be) {
      var Ae;
      for (Ae = 0; Ae < 16; Ae++) ge[Ae] = be[Ae] | 0;
    }
    function E(ge) {
      var be, Ae, ne = 1;
      for (be = 0; be < 16; be++) Ae = ge[be] + ne + 65535, ne = Math.floor(Ae / 65536), ge[be] = Ae - ne * 65536;
      ge[0] += ne - 1 + 37 * (ne - 1);
    }
    function M(ge, be, Ae) {
      for (var ne, _e = ~(Ae - 1), Te = 0; Te < 16; Te++) ne = _e & (ge[Te] ^ be[Te]), ge[Te] ^= ne, be[Te] ^= ne;
    }
    function x(ge, be) {
      var Ae, ne, _e, Te = n(), Ye = n();
      for (Ae = 0; Ae < 16; Ae++) Ye[Ae] = be[Ae];
      for (E(Ye), E(Ye), E(Ye), ne = 0; ne < 2; ne++) {
        for (Te[0] = Ye[0] - 65517, Ae = 1; Ae < 15; Ae++) Te[Ae] = Ye[Ae] - 65535 - (Te[Ae - 1] >> 16 & 1), Te[Ae - 1] &= 65535;
        Te[15] = Ye[15] - 32767 - (Te[14] >> 16 & 1), _e = Te[15] >> 16 & 1, Te[14] &= 65535, M(Ye, Te, 1 - _e);
      }
      for (Ae = 0; Ae < 16; Ae++) ge[2 * Ae] = Ye[Ae] & 255, ge[2 * Ae + 1] = Ye[Ae] >> 8;
    }
    function g(ge, be) {
      var Ae = new Uint8Array(32), ne = new Uint8Array(32);
      return x(Ae, ge), x(ne, be), C(Ae, 0, ne, 0);
    }
    function k(ge) {
      var be = new Uint8Array(32);
      return x(be, ge), be[0] & 1;
    }
    function T(ge, be) {
      var Ae;
      for (Ae = 0; Ae < 16; Ae++) ge[Ae] = be[2 * Ae] + (be[2 * Ae + 1] << 8);
      ge[15] &= 32767;
    }
    function O(ge, be, Ae) {
      for (var ne = 0; ne < 16; ne++) ge[ne] = be[ne] + Ae[ne];
    }
    function K(ge, be, Ae) {
      for (var ne = 0; ne < 16; ne++) ge[ne] = be[ne] - Ae[ne];
    }
    function Y(ge, be, Ae) {
      var ne, _e, Te = 0, Ye = 0, Pe = 0, He = 0, _t = 0, vt = 0, cr = 0, Tt = 0, Gt = 0, Yt = 0, or = 0, sr = 0, Wt = 0, tr = 0, Jt = 0, Ft = 0, Ut = 0, Mt = 0, Pt = 0, Nt = 0, It = 0, tt = 0, rt = 0, Et = 0, yt = 0, bt = 0, Dt = 0, vr = 0, kr = 0, $r = 0, Ir = 0, Le = Ae[0], Pr = Ae[1], en = Ae[2], tn = Ae[3], Rr = Ae[4], Jr = Ae[5], Zr = Ae[6], Vn = Ae[7], un = Ae[8], On = Ae[9], Qn = Ae[10], Kn = Ae[11], oi = Ae[12], Ki = Ae[13], Hi = Ae[14], qi = Ae[15];
      ne = be[0], Te += ne * Le, Ye += ne * Pr, Pe += ne * en, He += ne * tn, _t += ne * Rr, vt += ne * Jr, cr += ne * Zr, Tt += ne * Vn, Gt += ne * un, Yt += ne * On, or += ne * Qn, sr += ne * Kn, Wt += ne * oi, tr += ne * Ki, Jt += ne * Hi, Ft += ne * qi, ne = be[1], Ye += ne * Le, Pe += ne * Pr, He += ne * en, _t += ne * tn, vt += ne * Rr, cr += ne * Jr, Tt += ne * Zr, Gt += ne * Vn, Yt += ne * un, or += ne * On, sr += ne * Qn, Wt += ne * Kn, tr += ne * oi, Jt += ne * Ki, Ft += ne * Hi, Ut += ne * qi, ne = be[2], Pe += ne * Le, He += ne * Pr, _t += ne * en, vt += ne * tn, cr += ne * Rr, Tt += ne * Jr, Gt += ne * Zr, Yt += ne * Vn, or += ne * un, sr += ne * On, Wt += ne * Qn, tr += ne * Kn, Jt += ne * oi, Ft += ne * Ki, Ut += ne * Hi, Mt += ne * qi, ne = be[3], He += ne * Le, _t += ne * Pr, vt += ne * en, cr += ne * tn, Tt += ne * Rr, Gt += ne * Jr, Yt += ne * Zr, or += ne * Vn, sr += ne * un, Wt += ne * On, tr += ne * Qn, Jt += ne * Kn, Ft += ne * oi, Ut += ne * Ki, Mt += ne * Hi, Pt += ne * qi, ne = be[4], _t += ne * Le, vt += ne * Pr, cr += ne * en, Tt += ne * tn, Gt += ne * Rr, Yt += ne * Jr, or += ne * Zr, sr += ne * Vn, Wt += ne * un, tr += ne * On, Jt += ne * Qn, Ft += ne * Kn, Ut += ne * oi, Mt += ne * Ki, Pt += ne * Hi, Nt += ne * qi, ne = be[5], vt += ne * Le, cr += ne * Pr, Tt += ne * en, Gt += ne * tn, Yt += ne * Rr, or += ne * Jr, sr += ne * Zr, Wt += ne * Vn, tr += ne * un, Jt += ne * On, Ft += ne * Qn, Ut += ne * Kn, Mt += ne * oi, Pt += ne * Ki, Nt += ne * Hi, It += ne * qi, ne = be[6], cr += ne * Le, Tt += ne * Pr, Gt += ne * en, Yt += ne * tn, or += ne * Rr, sr += ne * Jr, Wt += ne * Zr, tr += ne * Vn, Jt += ne * un, Ft += ne * On, Ut += ne * Qn, Mt += ne * Kn, Pt += ne * oi, Nt += ne * Ki, It += ne * Hi, tt += ne * qi, ne = be[7], Tt += ne * Le, Gt += ne * Pr, Yt += ne * en, or += ne * tn, sr += ne * Rr, Wt += ne * Jr, tr += ne * Zr, Jt += ne * Vn, Ft += ne * un, Ut += ne * On, Mt += ne * Qn, Pt += ne * Kn, Nt += ne * oi, It += ne * Ki, tt += ne * Hi, rt += ne * qi, ne = be[8], Gt += ne * Le, Yt += ne * Pr, or += ne * en, sr += ne * tn, Wt += ne * Rr, tr += ne * Jr, Jt += ne * Zr, Ft += ne * Vn, Ut += ne * un, Mt += ne * On, Pt += ne * Qn, Nt += ne * Kn, It += ne * oi, tt += ne * Ki, rt += ne * Hi, Et += ne * qi, ne = be[9], Yt += ne * Le, or += ne * Pr, sr += ne * en, Wt += ne * tn, tr += ne * Rr, Jt += ne * Jr, Ft += ne * Zr, Ut += ne * Vn, Mt += ne * un, Pt += ne * On, Nt += ne * Qn, It += ne * Kn, tt += ne * oi, rt += ne * Ki, Et += ne * Hi, yt += ne * qi, ne = be[10], or += ne * Le, sr += ne * Pr, Wt += ne * en, tr += ne * tn, Jt += ne * Rr, Ft += ne * Jr, Ut += ne * Zr, Mt += ne * Vn, Pt += ne * un, Nt += ne * On, It += ne * Qn, tt += ne * Kn, rt += ne * oi, Et += ne * Ki, yt += ne * Hi, bt += ne * qi, ne = be[11], sr += ne * Le, Wt += ne * Pr, tr += ne * en, Jt += ne * tn, Ft += ne * Rr, Ut += ne * Jr, Mt += ne * Zr, Pt += ne * Vn, Nt += ne * un, It += ne * On, tt += ne * Qn, rt += ne * Kn, Et += ne * oi, yt += ne * Ki, bt += ne * Hi, Dt += ne * qi, ne = be[12], Wt += ne * Le, tr += ne * Pr, Jt += ne * en, Ft += ne * tn, Ut += ne * Rr, Mt += ne * Jr, Pt += ne * Zr, Nt += ne * Vn, It += ne * un, tt += ne * On, rt += ne * Qn, Et += ne * Kn, yt += ne * oi, bt += ne * Ki, Dt += ne * Hi, vr += ne * qi, ne = be[13], tr += ne * Le, Jt += ne * Pr, Ft += ne * en, Ut += ne * tn, Mt += ne * Rr, Pt += ne * Jr, Nt += ne * Zr, It += ne * Vn, tt += ne * un, rt += ne * On, Et += ne * Qn, yt += ne * Kn, bt += ne * oi, Dt += ne * Ki, vr += ne * Hi, kr += ne * qi, ne = be[14], Jt += ne * Le, Ft += ne * Pr, Ut += ne * en, Mt += ne * tn, Pt += ne * Rr, Nt += ne * Jr, It += ne * Zr, tt += ne * Vn, rt += ne * un, Et += ne * On, yt += ne * Qn, bt += ne * Kn, Dt += ne * oi, vr += ne * Ki, kr += ne * Hi, $r += ne * qi, ne = be[15], Ft += ne * Le, Ut += ne * Pr, Mt += ne * en, Pt += ne * tn, Nt += ne * Rr, It += ne * Jr, tt += ne * Zr, rt += ne * Vn, Et += ne * un, yt += ne * On, bt += ne * Qn, Dt += ne * Kn, vr += ne * oi, kr += ne * Ki, $r += ne * Hi, Ir += ne * qi, Te += 38 * Ut, Ye += 38 * Mt, Pe += 38 * Pt, He += 38 * Nt, _t += 38 * It, vt += 38 * tt, cr += 38 * rt, Tt += 38 * Et, Gt += 38 * yt, Yt += 38 * bt, or += 38 * Dt, sr += 38 * vr, Wt += 38 * kr, tr += 38 * $r, Jt += 38 * Ir, _e = 1, ne = Te + _e + 65535, _e = Math.floor(ne / 65536), Te = ne - _e * 65536, ne = Ye + _e + 65535, _e = Math.floor(ne / 65536), Ye = ne - _e * 65536, ne = Pe + _e + 65535, _e = Math.floor(ne / 65536), Pe = ne - _e * 65536, ne = He + _e + 65535, _e = Math.floor(ne / 65536), He = ne - _e * 65536, ne = _t + _e + 65535, _e = Math.floor(ne / 65536), _t = ne - _e * 65536, ne = vt + _e + 65535, _e = Math.floor(ne / 65536), vt = ne - _e * 65536, ne = cr + _e + 65535, _e = Math.floor(ne / 65536), cr = ne - _e * 65536, ne = Tt + _e + 65535, _e = Math.floor(ne / 65536), Tt = ne - _e * 65536, ne = Gt + _e + 65535, _e = Math.floor(ne / 65536), Gt = ne - _e * 65536, ne = Yt + _e + 65535, _e = Math.floor(ne / 65536), Yt = ne - _e * 65536, ne = or + _e + 65535, _e = Math.floor(ne / 65536), or = ne - _e * 65536, ne = sr + _e + 65535, _e = Math.floor(ne / 65536), sr = ne - _e * 65536, ne = Wt + _e + 65535, _e = Math.floor(ne / 65536), Wt = ne - _e * 65536, ne = tr + _e + 65535, _e = Math.floor(ne / 65536), tr = ne - _e * 65536, ne = Jt + _e + 65535, _e = Math.floor(ne / 65536), Jt = ne - _e * 65536, ne = Ft + _e + 65535, _e = Math.floor(ne / 65536), Ft = ne - _e * 65536, Te += _e - 1 + 37 * (_e - 1), _e = 1, ne = Te + _e + 65535, _e = Math.floor(ne / 65536), Te = ne - _e * 65536, ne = Ye + _e + 65535, _e = Math.floor(ne / 65536), Ye = ne - _e * 65536, ne = Pe + _e + 65535, _e = Math.floor(ne / 65536), Pe = ne - _e * 65536, ne = He + _e + 65535, _e = Math.floor(ne / 65536), He = ne - _e * 65536, ne = _t + _e + 65535, _e = Math.floor(ne / 65536), _t = ne - _e * 65536, ne = vt + _e + 65535, _e = Math.floor(ne / 65536), vt = ne - _e * 65536, ne = cr + _e + 65535, _e = Math.floor(ne / 65536), cr = ne - _e * 65536, ne = Tt + _e + 65535, _e = Math.floor(ne / 65536), Tt = ne - _e * 65536, ne = Gt + _e + 65535, _e = Math.floor(ne / 65536), Gt = ne - _e * 65536, ne = Yt + _e + 65535, _e = Math.floor(ne / 65536), Yt = ne - _e * 65536, ne = or + _e + 65535, _e = Math.floor(ne / 65536), or = ne - _e * 65536, ne = sr + _e + 65535, _e = Math.floor(ne / 65536), sr = ne - _e * 65536, ne = Wt + _e + 65535, _e = Math.floor(ne / 65536), Wt = ne - _e * 65536, ne = tr + _e + 65535, _e = Math.floor(ne / 65536), tr = ne - _e * 65536, ne = Jt + _e + 65535, _e = Math.floor(ne / 65536), Jt = ne - _e * 65536, ne = Ft + _e + 65535, _e = Math.floor(ne / 65536), Ft = ne - _e * 65536, Te += _e - 1 + 37 * (_e - 1), ge[0] = Te, ge[1] = Ye, ge[2] = Pe, ge[3] = He, ge[4] = _t, ge[5] = vt, ge[6] = cr, ge[7] = Tt, ge[8] = Gt, ge[9] = Yt, ge[10] = or, ge[11] = sr, ge[12] = Wt, ge[13] = tr, ge[14] = Jt, ge[15] = Ft;
    }
    function J(ge, be) {
      Y(ge, be, be);
    }
    function G(ge, be) {
      var Ae = n(), ne;
      for (ne = 0; ne < 16; ne++) Ae[ne] = be[ne];
      for (ne = 253; ne >= 0; ne--) J(Ae, Ae), ne !== 2 && ne !== 4 && Y(Ae, Ae, be);
      for (ne = 0; ne < 16; ne++) ge[ne] = Ae[ne];
    }
    function X(ge, be) {
      var Ae = n(), ne;
      for (ne = 0; ne < 16; ne++) Ae[ne] = be[ne];
      for (ne = 250; ne >= 0; ne--) J(Ae, Ae), ne !== 1 && Y(Ae, Ae, be);
      for (ne = 0; ne < 16; ne++) ge[ne] = Ae[ne];
    }
    function ie(ge, be, Ae) {
      var ne = new Uint8Array(32), _e = new Float64Array(80), Te, Ye, Pe = n(), He = n(), _t = n(), vt = n(), cr = n(), Tt = n();
      for (Ye = 0; Ye < 31; Ye++) ne[Ye] = be[Ye];
      for (ne[31] = be[31] & 127 | 64, ne[0] &= 248, T(_e, Ae), Ye = 0; Ye < 16; Ye++) He[Ye] = _e[Ye], vt[Ye] = Pe[Ye] = _t[Ye] = 0;
      for (Pe[0] = vt[0] = 1, Ye = 254; Ye >= 0; --Ye) Te = ne[Ye >>> 3] >>> (Ye & 7) & 1, M(Pe, He, Te), M(_t, vt, Te), O(cr, Pe, _t), K(Pe, Pe, _t), O(_t, He, vt), K(He, He, vt), J(vt, cr), J(Tt, Pe), Y(Pe, _t, Pe), Y(_t, He, cr), O(cr, Pe, _t), K(Pe, Pe, _t), J(He, Pe), K(_t, vt, Tt), Y(Pe, _t, f), O(Pe, Pe, vt), Y(_t, _t, Pe), Y(Pe, vt, Tt), Y(vt, He, _e), J(He, cr), M(Pe, He, Te), M(_t, vt, Te);
      for (Ye = 0; Ye < 16; Ye++) _e[Ye + 16] = Pe[Ye], _e[Ye + 32] = _t[Ye], _e[Ye + 48] = He[Ye], _e[Ye + 64] = vt[Ye];
      var Gt = _e.subarray(32), Yt = _e.subarray(16);
      return G(Gt, Gt), Y(Yt, Yt, Gt), x(ge, Yt), 0;
    }
    function de(ge, be) {
      return ie(ge, be, i);
    }
    function se(ge, be) {
      return r(be, 32), de(ge, be);
    }
    function te(ge, be, Ae) {
      var ne = new Uint8Array(32);
      return ie(ne, Ae, be), F(ge, s, ne, U);
    }
    var le = d, Z = y;
    function ve(ge, be, Ae, ne, _e, Te) {
      var Ye = new Uint8Array(32);
      return te(Ye, _e, Te), le(ge, be, Ae, ne, Ye);
    }
    function he(ge, be, Ae, ne, _e, Te) {
      var Ye = new Uint8Array(32);
      return te(Ye, _e, Te), Z(ge, be, Ae, ne, Ye);
    }
    var me = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
    function ce(ge, be, Ae, ne) {
      for (var _e = new Int32Array(16), Te = new Int32Array(16), Ye, Pe, He, _t, vt, cr, Tt, Gt, Yt, or, sr, Wt, tr, Jt, Ft, Ut, Mt, Pt, Nt, It, tt, rt, Et, yt, bt, Dt, vr = ge[0], kr = ge[1], $r = ge[2], Ir = ge[3], Le = ge[4], Pr = ge[5], en = ge[6], tn = ge[7], Rr = be[0], Jr = be[1], Zr = be[2], Vn = be[3], un = be[4], On = be[5], Qn = be[6], Kn = be[7], oi = 0; ne >= 128; ) {
        for (Nt = 0; Nt < 16; Nt++) It = 8 * Nt + oi, _e[Nt] = Ae[It + 0] << 24 | Ae[It + 1] << 16 | Ae[It + 2] << 8 | Ae[It + 3], Te[Nt] = Ae[It + 4] << 24 | Ae[It + 5] << 16 | Ae[It + 6] << 8 | Ae[It + 7];
        for (Nt = 0; Nt < 80; Nt++) if (Ye = vr, Pe = kr, He = $r, _t = Ir, vt = Le, cr = Pr, Tt = en, Gt = tn, Yt = Rr, or = Jr, sr = Zr, Wt = Vn, tr = un, Jt = On, Ft = Qn, Ut = Kn, tt = tn, rt = Kn, Et = rt & 65535, yt = rt >>> 16, bt = tt & 65535, Dt = tt >>> 16, tt = (Le >>> 14 | un << 18) ^ (Le >>> 18 | un << 14) ^ (un >>> 9 | Le << 23), rt = (un >>> 14 | Le << 18) ^ (un >>> 18 | Le << 14) ^ (Le >>> 9 | un << 23), Et += rt & 65535, yt += rt >>> 16, bt += tt & 65535, Dt += tt >>> 16, tt = Le & Pr ^ ~Le & en, rt = un & On ^ ~un & Qn, Et += rt & 65535, yt += rt >>> 16, bt += tt & 65535, Dt += tt >>> 16, tt = me[Nt * 2], rt = me[Nt * 2 + 1], Et += rt & 65535, yt += rt >>> 16, bt += tt & 65535, Dt += tt >>> 16, tt = _e[Nt % 16], rt = Te[Nt % 16], Et += rt & 65535, yt += rt >>> 16, bt += tt & 65535, Dt += tt >>> 16, yt += Et >>> 16, bt += yt >>> 16, Dt += bt >>> 16, Mt = bt & 65535 | Dt << 16, Pt = Et & 65535 | yt << 16, tt = Mt, rt = Pt, Et = rt & 65535, yt = rt >>> 16, bt = tt & 65535, Dt = tt >>> 16, tt = (vr >>> 28 | Rr << 4) ^ (Rr >>> 2 | vr << 30) ^ (Rr >>> 7 | vr << 25), rt = (Rr >>> 28 | vr << 4) ^ (vr >>> 2 | Rr << 30) ^ (vr >>> 7 | Rr << 25), Et += rt & 65535, yt += rt >>> 16, bt += tt & 65535, Dt += tt >>> 16, tt = vr & kr ^ vr & $r ^ kr & $r, rt = Rr & Jr ^ Rr & Zr ^ Jr & Zr, Et += rt & 65535, yt += rt >>> 16, bt += tt & 65535, Dt += tt >>> 16, yt += Et >>> 16, bt += yt >>> 16, Dt += bt >>> 16, Gt = bt & 65535 | Dt << 16, Ut = Et & 65535 | yt << 16, tt = _t, rt = Wt, Et = rt & 65535, yt = rt >>> 16, bt = tt & 65535, Dt = tt >>> 16, tt = Mt, rt = Pt, Et += rt & 65535, yt += rt >>> 16, bt += tt & 65535, Dt += tt >>> 16, yt += Et >>> 16, bt += yt >>> 16, Dt += bt >>> 16, _t = bt & 65535 | Dt << 16, Wt = Et & 65535 | yt << 16, kr = Ye, $r = Pe, Ir = He, Le = _t, Pr = vt, en = cr, tn = Tt, vr = Gt, Jr = Yt, Zr = or, Vn = sr, un = Wt, On = tr, Qn = Jt, Kn = Ft, Rr = Ut, Nt % 16 === 15) for (It = 0; It < 16; It++) tt = _e[It], rt = Te[It], Et = rt & 65535, yt = rt >>> 16, bt = tt & 65535, Dt = tt >>> 16, tt = _e[(It + 9) % 16], rt = Te[(It + 9) % 16], Et += rt & 65535, yt += rt >>> 16, bt += tt & 65535, Dt += tt >>> 16, Mt = _e[(It + 1) % 16], Pt = Te[(It + 1) % 16], tt = (Mt >>> 1 | Pt << 31) ^ (Mt >>> 8 | Pt << 24) ^ Mt >>> 7, rt = (Pt >>> 1 | Mt << 31) ^ (Pt >>> 8 | Mt << 24) ^ (Pt >>> 7 | Mt << 25), Et += rt & 65535, yt += rt >>> 16, bt += tt & 65535, Dt += tt >>> 16, Mt = _e[(It + 14) % 16], Pt = Te[(It + 14) % 16], tt = (Mt >>> 19 | Pt << 13) ^ (Pt >>> 29 | Mt << 3) ^ Mt >>> 6, rt = (Pt >>> 19 | Mt << 13) ^ (Mt >>> 29 | Pt << 3) ^ (Pt >>> 6 | Mt << 26), Et += rt & 65535, yt += rt >>> 16, bt += tt & 65535, Dt += tt >>> 16, yt += Et >>> 16, bt += yt >>> 16, Dt += bt >>> 16, _e[It] = bt & 65535 | Dt << 16, Te[It] = Et & 65535 | yt << 16;
        tt = vr, rt = Rr, Et = rt & 65535, yt = rt >>> 16, bt = tt & 65535, Dt = tt >>> 16, tt = ge[0], rt = be[0], Et += rt & 65535, yt += rt >>> 16, bt += tt & 65535, Dt += tt >>> 16, yt += Et >>> 16, bt += yt >>> 16, Dt += bt >>> 16, ge[0] = vr = bt & 65535 | Dt << 16, be[0] = Rr = Et & 65535 | yt << 16, tt = kr, rt = Jr, Et = rt & 65535, yt = rt >>> 16, bt = tt & 65535, Dt = tt >>> 16, tt = ge[1], rt = be[1], Et += rt & 65535, yt += rt >>> 16, bt += tt & 65535, Dt += tt >>> 16, yt += Et >>> 16, bt += yt >>> 16, Dt += bt >>> 16, ge[1] = kr = bt & 65535 | Dt << 16, be[1] = Jr = Et & 65535 | yt << 16, tt = $r, rt = Zr, Et = rt & 65535, yt = rt >>> 16, bt = tt & 65535, Dt = tt >>> 16, tt = ge[2], rt = be[2], Et += rt & 65535, yt += rt >>> 16, bt += tt & 65535, Dt += tt >>> 16, yt += Et >>> 16, bt += yt >>> 16, Dt += bt >>> 16, ge[2] = $r = bt & 65535 | Dt << 16, be[2] = Zr = Et & 65535 | yt << 16, tt = Ir, rt = Vn, Et = rt & 65535, yt = rt >>> 16, bt = tt & 65535, Dt = tt >>> 16, tt = ge[3], rt = be[3], Et += rt & 65535, yt += rt >>> 16, bt += tt & 65535, Dt += tt >>> 16, yt += Et >>> 16, bt += yt >>> 16, Dt += bt >>> 16, ge[3] = Ir = bt & 65535 | Dt << 16, be[3] = Vn = Et & 65535 | yt << 16, tt = Le, rt = un, Et = rt & 65535, yt = rt >>> 16, bt = tt & 65535, Dt = tt >>> 16, tt = ge[4], rt = be[4], Et += rt & 65535, yt += rt >>> 16, bt += tt & 65535, Dt += tt >>> 16, yt += Et >>> 16, bt += yt >>> 16, Dt += bt >>> 16, ge[4] = Le = bt & 65535 | Dt << 16, be[4] = un = Et & 65535 | yt << 16, tt = Pr, rt = On, Et = rt & 65535, yt = rt >>> 16, bt = tt & 65535, Dt = tt >>> 16, tt = ge[5], rt = be[5], Et += rt & 65535, yt += rt >>> 16, bt += tt & 65535, Dt += tt >>> 16, yt += Et >>> 16, bt += yt >>> 16, Dt += bt >>> 16, ge[5] = Pr = bt & 65535 | Dt << 16, be[5] = On = Et & 65535 | yt << 16, tt = en, rt = Qn, Et = rt & 65535, yt = rt >>> 16, bt = tt & 65535, Dt = tt >>> 16, tt = ge[6], rt = be[6], Et += rt & 65535, yt += rt >>> 16, bt += tt & 65535, Dt += tt >>> 16, yt += Et >>> 16, bt += yt >>> 16, Dt += bt >>> 16, ge[6] = en = bt & 65535 | Dt << 16, be[6] = Qn = Et & 65535 | yt << 16, tt = tn, rt = Kn, Et = rt & 65535, yt = rt >>> 16, bt = tt & 65535, Dt = tt >>> 16, tt = ge[7], rt = be[7], Et += rt & 65535, yt += rt >>> 16, bt += tt & 65535, Dt += tt >>> 16, yt += Et >>> 16, bt += yt >>> 16, Dt += bt >>> 16, ge[7] = tn = bt & 65535 | Dt << 16, be[7] = Kn = Et & 65535 | yt << 16, oi += 128, ne -= 128;
      }
      return ne;
    }
    function ye(ge, be, Ae) {
      var ne = new Int32Array(8), _e = new Int32Array(8), Te = new Uint8Array(256), Ye, Pe = Ae;
      for (ne[0] = 1779033703, ne[1] = 3144134277, ne[2] = 1013904242, ne[3] = 2773480762, ne[4] = 1359893119, ne[5] = 2600822924, ne[6] = 528734635, ne[7] = 1541459225, _e[0] = 4089235720, _e[1] = 2227873595, _e[2] = 4271175723, _e[3] = 1595750129, _e[4] = 2917565137, _e[5] = 725511199, _e[6] = 4215389547, _e[7] = 327033209, ce(ne, _e, be, Ae), Ae %= 128, Ye = 0; Ye < Ae; Ye++) Te[Ye] = be[Pe - Ae + Ye];
      for (Te[Ae] = 128, Ae = 256 - 128 * (Ae < 112 ? 1 : 0), Te[Ae - 9] = 0, b(Te, Ae - 8, Pe / 536870912 | 0, Pe << 3), ce(ne, _e, Te, Ae), Ye = 0; Ye < 8; Ye++) b(ge, 8 * Ye, ne[Ye], _e[Ye]);
      return 0;
    }
    function Oe(ge, be) {
      var Ae = n(), ne = n(), _e = n(), Te = n(), Ye = n(), Pe = n(), He = n(), _t = n(), vt = n();
      K(Ae, ge[1], ge[0]), K(vt, be[1], be[0]), Y(Ae, Ae, vt), O(ne, ge[0], ge[1]), O(vt, be[0], be[1]), Y(ne, ne, vt), Y(_e, ge[3], be[3]), Y(_e, _e, l), Y(Te, ge[2], be[2]), O(Te, Te, Te), K(Ye, ne, Ae), K(Pe, Te, _e), O(He, Te, _e), O(_t, ne, Ae), Y(ge[0], Ye, Pe), Y(ge[1], _t, He), Y(ge[2], He, Pe), Y(ge[3], Ye, _t);
    }
    function Se(ge, be, Ae) {
      var ne;
      for (ne = 0; ne < 4; ne++) M(ge[ne], be[ne], Ae);
    }
    function Ce(ge, be) {
      var Ae = n(), ne = n(), _e = n();
      G(_e, be[2]), Y(Ae, be[0], _e), Y(ne, be[1], _e), x(ge, ne), ge[31] ^= k(Ae) << 7;
    }
    function Ne(ge, be, Ae) {
      var ne, _e;
      for (w(ge[0], a), w(ge[1], o), w(ge[2], o), w(ge[3], a), _e = 255; _e >= 0; --_e) ne = Ae[_e / 8 | 0] >> (_e & 7) & 1, Se(ge, be, ne), Oe(be, ge), Oe(ge, ge), Se(ge, be, ne);
    }
    function $e(ge, be) {
      var Ae = [n(), n(), n(), n()];
      w(Ae[0], h), w(Ae[1], m), w(Ae[2], o), Y(Ae[3], h, m), Ne(ge, Ae, be);
    }
    function Re(ge, be, Ae) {
      var ne = new Uint8Array(64), _e = [n(), n(), n(), n()], Te;
      for (Ae || r(be, 32), ye(ne, be, 32), ne[0] &= 248, ne[31] &= 127, ne[31] |= 64, $e(_e, ne), Ce(ge, _e), Te = 0; Te < 32; Te++) be[Te + 32] = ge[Te];
      return 0;
    }
    var Ge = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function Fe(ge, be) {
      var Ae, ne, _e, Te;
      for (ne = 63; ne >= 32; --ne) {
        for (Ae = 0, _e = ne - 32, Te = ne - 12; _e < Te; ++_e) be[_e] += Ae - 16 * be[ne] * Ge[_e - (ne - 32)], Ae = Math.floor((be[_e] + 128) / 256), be[_e] -= Ae * 256;
        be[_e] += Ae, be[ne] = 0;
      }
      for (Ae = 0, _e = 0; _e < 32; _e++) be[_e] += Ae - (be[31] >> 4) * Ge[_e], Ae = be[_e] >> 8, be[_e] &= 255;
      for (_e = 0; _e < 32; _e++) be[_e] -= Ae * Ge[_e];
      for (ne = 0; ne < 32; ne++) be[ne + 1] += be[ne] >> 8, ge[ne] = be[ne] & 255;
    }
    function Ue(ge) {
      var be = new Float64Array(64), Ae;
      for (Ae = 0; Ae < 64; Ae++) be[Ae] = ge[Ae];
      for (Ae = 0; Ae < 64; Ae++) ge[Ae] = 0;
      Fe(ge, be);
    }
    function kt(ge, be, Ae, ne) {
      var _e = new Uint8Array(64), Te = new Uint8Array(64), Ye = new Uint8Array(64), Pe, He, _t = new Float64Array(64), vt = [n(), n(), n(), n()];
      ye(_e, ne, 32), _e[0] &= 248, _e[31] &= 127, _e[31] |= 64;
      var cr = Ae + 64;
      for (Pe = 0; Pe < Ae; Pe++) ge[64 + Pe] = be[Pe];
      for (Pe = 0; Pe < 32; Pe++) ge[32 + Pe] = _e[32 + Pe];
      for (ye(Ye, ge.subarray(32), Ae + 32), Ue(Ye), $e(vt, Ye), Ce(ge, vt), Pe = 32; Pe < 64; Pe++) ge[Pe] = ne[Pe];
      for (ye(Te, ge, Ae + 64), Ue(Te), Pe = 0; Pe < 64; Pe++) _t[Pe] = 0;
      for (Pe = 0; Pe < 32; Pe++) _t[Pe] = Ye[Pe];
      for (Pe = 0; Pe < 32; Pe++) for (He = 0; He < 32; He++) _t[Pe + He] += Te[Pe] * _e[He];
      return Fe(ge.subarray(32), _t), cr;
    }
    function pe(ge, be) {
      var Ae = n(), ne = n(), _e = n(), Te = n(), Ye = n(), Pe = n(), He = n();
      return w(ge[2], o), T(ge[1], be), J(_e, ge[1]), Y(Te, _e, c), K(_e, _e, ge[2]), O(Te, ge[2], Te), J(Ye, Te), J(Pe, Ye), Y(He, Pe, Ye), Y(Ae, He, _e), Y(Ae, Ae, Te), X(Ae, Ae), Y(Ae, Ae, _e), Y(Ae, Ae, Te), Y(Ae, Ae, Te), Y(ge[0], Ae, Te), J(ne, ge[0]), Y(ne, ne, Te), g(ne, _e) && Y(ge[0], ge[0], v), J(ne, ge[0]), Y(ne, ne, Te), g(ne, _e) ? -1 : (k(ge[0]) === be[31] >> 7 && K(ge[0], a, ge[0]), Y(ge[3], ge[0], ge[1]), 0);
    }
    function re(ge, be, Ae, ne) {
      var _e, Te = new Uint8Array(32), Ye = new Uint8Array(64), Pe = [n(), n(), n(), n()], He = [n(), n(), n(), n()];
      if (Ae < 64 || pe(He, ne)) return -1;
      for (_e = 0; _e < Ae; _e++) ge[_e] = be[_e];
      for (_e = 0; _e < 32; _e++) ge[_e + 32] = ne[_e];
      if (ye(Ye, ge, Ae), Ue(Ye), Ne(Pe, He, Ye), $e(He, be.subarray(32)), Oe(Pe, He), Ce(Te, Pe), Ae -= 64, C(be, 0, Te, 0)) {
        for (_e = 0; _e < Ae; _e++) ge[_e] = 0;
        return -1;
      }
      for (_e = 0; _e < Ae; _e++) ge[_e] = be[_e + 64];
      return Ae;
    }
    var ue = 32, xe = 24, Me = 32, We = 16, De = 32, je = 32, ir = 32, Xe = 32, st = 32, Vt = xe, at = Me, ht = We, br = 64, ot = 32, ct = 64, _r = 32, ft = 64;
    e.lowlevel = { crypto_core_hsalsa20: F, crypto_stream_xor: L, crypto_stream: N, crypto_stream_salsa20_xor: Q, crypto_stream_salsa20: P, crypto_onetimeauth: u, crypto_onetimeauth_verify: p, crypto_verify_16: _, crypto_verify_32: C, crypto_secretbox: d, crypto_secretbox_open: y, crypto_scalarmult: ie, crypto_scalarmult_base: de, crypto_box_beforenm: te, crypto_box_afternm: le, crypto_box: ve, crypto_box_open: he, crypto_box_keypair: se, crypto_hash: ye, crypto_sign: kt, crypto_sign_keypair: Re, crypto_sign_open: re, crypto_secretbox_KEYBYTES: ue, crypto_secretbox_NONCEBYTES: xe, crypto_secretbox_ZEROBYTES: Me, crypto_secretbox_BOXZEROBYTES: We, crypto_scalarmult_BYTES: De, crypto_scalarmult_SCALARBYTES: je, crypto_box_PUBLICKEYBYTES: ir, crypto_box_SECRETKEYBYTES: Xe, crypto_box_BEFORENMBYTES: st, crypto_box_NONCEBYTES: Vt, crypto_box_ZEROBYTES: at, crypto_box_BOXZEROBYTES: ht, crypto_sign_BYTES: br, crypto_sign_PUBLICKEYBYTES: ot, crypto_sign_SECRETKEYBYTES: ct, crypto_sign_SEEDBYTES: _r, crypto_hash_BYTES: ft, gf: n, D: c, L: Ge, pack25519: x, unpack25519: T, M: Y, A: O, S: J, Z: K, pow2523: X, add: Oe, set25519: w, modL: Fe, scalarmult: Ne, scalarbase: $e };
    function pt(ge, be) {
      if (ge.length !== ue) throw new Error("bad key size");
      if (be.length !== xe) throw new Error("bad nonce size");
    }
    function Cr(ge, be) {
      if (ge.length !== ir) throw new Error("bad public key size");
      if (be.length !== Xe) throw new Error("bad secret key size");
    }
    function nt() {
      for (var ge = 0; ge < arguments.length; ge++) if (!(arguments[ge] instanceof Uint8Array)) throw new TypeError("unexpected type, use Uint8Array");
    }
    function lt(ge) {
      for (var be = 0; be < ge.length; be++) ge[be] = 0;
    }
    e.randomBytes = function(ge) {
      var be = new Uint8Array(ge);
      return r(be, ge), be;
    }, e.secretbox = function(ge, be, Ae) {
      nt(ge, be, Ae), pt(Ae, be);
      for (var ne = new Uint8Array(Me + ge.length), _e = new Uint8Array(ne.length), Te = 0; Te < ge.length; Te++) ne[Te + Me] = ge[Te];
      return d(_e, ne, ne.length, be, Ae), _e.subarray(We);
    }, e.secretbox.open = function(ge, be, Ae) {
      nt(ge, be, Ae), pt(Ae, be);
      for (var ne = new Uint8Array(We + ge.length), _e = new Uint8Array(ne.length), Te = 0; Te < ge.length; Te++) ne[Te + We] = ge[Te];
      return ne.length < 32 || y(_e, ne, ne.length, be, Ae) !== 0 ? null : _e.subarray(Me);
    }, e.secretbox.keyLength = ue, e.secretbox.nonceLength = xe, e.secretbox.overheadLength = We, e.scalarMult = function(ge, be) {
      if (nt(ge, be), ge.length !== je) throw new Error("bad n size");
      if (be.length !== De) throw new Error("bad p size");
      var Ae = new Uint8Array(De);
      return ie(Ae, ge, be), Ae;
    }, e.scalarMult.base = function(ge) {
      if (nt(ge), ge.length !== je) throw new Error("bad n size");
      var be = new Uint8Array(De);
      return de(be, ge), be;
    }, e.scalarMult.scalarLength = je, e.scalarMult.groupElementLength = De, e.box = function(ge, be, Ae, ne) {
      var _e = e.box.before(Ae, ne);
      return e.secretbox(ge, be, _e);
    }, e.box.before = function(ge, be) {
      nt(ge, be), Cr(ge, be);
      var Ae = new Uint8Array(st);
      return te(Ae, ge, be), Ae;
    }, e.box.after = e.secretbox, e.box.open = function(ge, be, Ae, ne) {
      var _e = e.box.before(Ae, ne);
      return e.secretbox.open(ge, be, _e);
    }, e.box.open.after = e.secretbox.open, e.box.keyPair = function() {
      var ge = new Uint8Array(ir), be = new Uint8Array(Xe);
      return se(ge, be), { publicKey: ge, secretKey: be };
    }, e.box.keyPair.fromSecretKey = function(ge) {
      if (nt(ge), ge.length !== Xe) throw new Error("bad secret key size");
      var be = new Uint8Array(ir);
      return de(be, ge), { publicKey: be, secretKey: new Uint8Array(ge) };
    }, e.box.publicKeyLength = ir, e.box.secretKeyLength = Xe, e.box.sharedKeyLength = st, e.box.nonceLength = Vt, e.box.overheadLength = e.secretbox.overheadLength, e.sign = function(ge, be) {
      if (nt(ge, be), be.length !== ct) throw new Error("bad secret key size");
      var Ae = new Uint8Array(br + ge.length);
      return kt(Ae, ge, ge.length, be), Ae;
    }, e.sign.open = function(ge, be) {
      if (nt(ge, be), be.length !== ot) throw new Error("bad public key size");
      var Ae = new Uint8Array(ge.length), ne = re(Ae, ge, ge.length, be);
      if (ne < 0) return null;
      for (var _e = new Uint8Array(ne), Te = 0; Te < _e.length; Te++) _e[Te] = Ae[Te];
      return _e;
    }, e.sign.detached = function(ge, be) {
      for (var Ae = e.sign(ge, be), ne = new Uint8Array(br), _e = 0; _e < ne.length; _e++) ne[_e] = Ae[_e];
      return ne;
    }, e.sign.detached.verify = function(ge, be, Ae) {
      if (nt(ge, be, Ae), be.length !== br) throw new Error("bad signature size");
      if (Ae.length !== ot) throw new Error("bad public key size");
      var ne = new Uint8Array(br + ge.length), _e = new Uint8Array(br + ge.length), Te;
      for (Te = 0; Te < br; Te++) ne[Te] = be[Te];
      for (Te = 0; Te < ge.length; Te++) ne[Te + br] = ge[Te];
      return re(_e, ne, ne.length, Ae) >= 0;
    }, e.sign.keyPair = function() {
      var ge = new Uint8Array(ot), be = new Uint8Array(ct);
      return Re(ge, be), { publicKey: ge, secretKey: be };
    }, e.sign.keyPair.fromSecretKey = function(ge) {
      if (nt(ge), ge.length !== ct) throw new Error("bad secret key size");
      for (var be = new Uint8Array(ot), Ae = 0; Ae < be.length; Ae++) be[Ae] = ge[32 + Ae];
      return { publicKey: be, secretKey: new Uint8Array(ge) };
    }, e.sign.keyPair.fromSeed = function(ge) {
      if (nt(ge), ge.length !== _r) throw new Error("bad seed size");
      for (var be = new Uint8Array(ot), Ae = new Uint8Array(ct), ne = 0; ne < 32; ne++) Ae[ne] = ge[ne];
      return Re(be, Ae, true), { publicKey: be, secretKey: Ae };
    }, e.sign.publicKeyLength = ot, e.sign.secretKeyLength = ct, e.sign.seedLength = _r, e.sign.signatureLength = br, e.hash = function(ge) {
      nt(ge);
      var be = new Uint8Array(ft);
      return ye(be, ge, ge.length), be;
    }, e.hash.hashLength = ft, e.verify = function(ge, be) {
      return nt(ge, be), ge.length === 0 || be.length === 0 || ge.length !== be.length ? false : A(ge, 0, be, 0, ge.length) === 0;
    }, e.setPRNG = function(ge) {
      r = ge;
    }, function() {
      var ge = typeof self < "u" ? self.crypto || self.msCrypto : null;
      if (ge && ge.getRandomValues) {
        var be = 65536;
        e.setPRNG(function(Ae, ne) {
          var _e, Te = new Uint8Array(ne);
          for (_e = 0; _e < ne; _e += be) ge.getRandomValues(Te.subarray(_e, _e + Math.min(ne - _e, be)));
          for (_e = 0; _e < ne; _e++) Ae[_e] = Te[_e];
          lt(Te);
        });
      } else typeof Gl < "u" && (ge = vl(), ge && ge.randomBytes && e.setPRNG(function(Ae, ne) {
        var _e, Te = ge.randomBytes(ne);
        for (_e = 0; _e < ne; _e++) Ae[_e] = Te[_e];
        lt(Te);
      }));
    }();
  })(t3.exports ? t3.exports : self.nacl = self.nacl || {});
})(pD);
var oae = pD.exports;
const AE = Fa(oae);
var gD = { exports: {} };
(function(t3) {
  (function(e, n) {
    t3.exports ? t3.exports = n() : (e.nacl || (e.nacl = {}), e.nacl.util = n());
  })(mt, function() {
    var e = {};
    function n(r) {
      if (!/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(r)) throw new TypeError("invalid encoding");
    }
    return e.decodeUTF8 = function(r) {
      if (typeof r != "string") throw new TypeError("expected string");
      var s, i = unescape(encodeURIComponent(r)), a = new Uint8Array(i.length);
      for (s = 0; s < i.length; s++) a[s] = i.charCodeAt(s);
      return a;
    }, e.encodeUTF8 = function(r) {
      var s, i = [];
      for (s = 0; s < r.length; s++) i.push(String.fromCharCode(r[s]));
      return decodeURIComponent(escape(i.join("")));
    }, typeof atob > "u" ? typeof hr.from < "u" ? (e.encodeBase64 = function(r) {
      return hr.from(r).toString("base64");
    }, e.decodeBase64 = function(r) {
      return n(r), new Uint8Array(Array.prototype.slice.call(hr.from(r, "base64"), 0));
    }) : (e.encodeBase64 = function(r) {
      return new hr(r).toString("base64");
    }, e.decodeBase64 = function(r) {
      return n(r), new Uint8Array(Array.prototype.slice.call(new hr(r, "base64"), 0));
    }) : (e.encodeBase64 = function(r) {
      var s, i = [], a = r.length;
      for (s = 0; s < a; s++) i.push(String.fromCharCode(r[s]));
      return btoa(i.join(""));
    }, e.decodeBase64 = function(r) {
      n(r);
      var s, i = atob(r), a = new Uint8Array(i.length);
      for (s = 0; s < i.length; s++) a[s] = i.charCodeAt(s);
      return a;
    }), e;
  });
})(gD);
var fae = gD.exports;
const O0 = Fa(fae);
class lae {
  constructor(e, n) {
    if (e.length !== 32) throw new Error("Key must be 32 bytes.");
    if (n.length !== 12) throw new Error("Nonce must be 12 bytes.");
    this.key = e, this.nonce = n, this.counter = 1;
  }
  _quarterRound(e, n, r, s, i) {
    e[n] = e[n] + e[r] | 0, e[i] ^= e[n], e[i] = e[i] << 16 | e[i] >>> 16, e[s] = e[s] + e[i] | 0, e[r] ^= e[s], e[r] = e[r] << 12 | e[r] >>> 20, e[n] = e[n] + e[r] | 0, e[i] ^= e[n], e[i] = e[i] << 8 | e[i] >>> 24, e[s] = e[s] + e[i] | 0, e[r] ^= e[s], e[r] = e[r] << 7 | e[r] >>> 25;
  }
  _getKeyStreamBlock(e) {
    const n = new Uint32Array(16), r = new Uint32Array(this.key.buffer, this.key.byteOffset, 8), s = new Uint32Array(this.nonce.buffer, this.nonce.byteOffset, 3);
    n[0] = 1634760805, n[1] = 857760878, n[2] = 2036477234, n[3] = 1797285236, n[4] = r[0], n[5] = r[1], n[6] = r[2], n[7] = r[3], n[8] = r[4], n[9] = r[5], n[10] = r[6], n[11] = r[7], n[12] = e, n[13] = s[0], n[14] = s[1], n[15] = s[2];
    const i = new Uint32Array(n);
    for (let f = 0; f < 10; f++) this._quarterRound(i, 0, 4, 8, 12), this._quarterRound(i, 1, 5, 9, 13), this._quarterRound(i, 2, 6, 10, 14), this._quarterRound(i, 3, 7, 11, 15), this._quarterRound(i, 0, 5, 10, 15), this._quarterRound(i, 1, 6, 11, 12), this._quarterRound(i, 2, 7, 8, 13), this._quarterRound(i, 3, 4, 9, 14);
    const a = new Uint8Array(64), o = new Uint32Array(a.buffer);
    for (let f = 0; f < 16; f++) o[f] = i[f] + n[f] | 0;
    return a;
  }
  crypt(e) {
    const n = new Uint8Array(e.length);
    let r = this.counter;
    for (let s = 0; s < e.length; s += 64) {
      const i = this._getKeyStreamBlock(r++), a = Math.min(64, e.length - s);
      for (let o = 0; o < a; o++) n[s + o] = e[s + o] ^ i[o];
    }
    return n;
  }
}
const mb = (t3) => Array.from(t3).map((e) => e.toString(16).padStart(2, "0")).join(""), ry = (t3) => {
  const e = t3.replace(/\s+/g, "");
  if (e.length % 2 !== 0) throw new Error("Invalid Hex string.");
  const n = new Uint8Array(e.length / 2);
  for (let r = 0; r < e.length; r += 2) n[r / 2] = parseInt(e.substr(r, 2), 16);
  return n;
};
function uae(t3, e, n, r, s) {
  if (!e) throw new Error("Key is required.");
  if (!n) throw new Error("Nonce is required.");
  let i, a;
  try {
    i = ry(e);
  } catch {
    const l = O0.decodeUTF8(e);
    i = new Uint8Array(32), i.set(l.slice(0, 32));
  }
  try {
    a = ry(n);
  } catch {
    const l = O0.decodeUTF8(n);
    a = new Uint8Array(12), a.set(l.slice(0, 12));
  }
  if (i.length !== 32) throw new Error(`Key must be 32 bytes (got ${i.length}).`);
  if (a.length !== 12) throw new Error(`Nonce must be 12 bytes (got ${a.length}).`);
  let o;
  if (r === "encrypt") o = O0.decodeUTF8(t3);
  else try {
    o = s === "Base64" ? O0.decodeBase64(t3) : ry(t3);
  } catch {
    throw new Error(`Invalid ${s} input.`);
  }
  const c = new lae(i, a).crypt(o);
  if (r === "encrypt") return s === "Base64" ? O0.encodeBase64(c) : mb(c);
  try {
    return O0.encodeUTF8(c);
  } catch {
    return "Error: Decrypted data is not valid UTF-8 text.";
  }
}
function cae() {
  return { key: mb(AE.randomBytes(32)), nonce: mb(AE.randomBytes(12)) };
}
function hae(t3) {
  let e = t3[0] === "encrypt" ? "Encrypt" : "Decrypt", n;
  return { c() {
    n = we(e);
  }, m(r, s) {
    R(r, n, s);
  }, p(r, s) {
    s & 1 && e !== (e = r[0] === "encrypt" ? "Encrypt" : "Decrypt") && Ze(n, e);
  }, d(r) {
    r && D(n);
  } };
}
function dae(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function wE(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[7]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 128 && Ze(n, r[7]);
  }, d(r) {
    r && D(e);
  } };
}
function xE(t3) {
  let e, n;
  return e = new et({ props: { label: "Result:", value: t3[6], readonly: true, expandable: true, withCopy: true, rows: 3 } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, s) {
    const i = {};
    s & 64 && (i.value = r[6]), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function pae(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U, Q, P, N, L, B, u, p, d, y, w, E, M, x, g, k, T, O;
  function K(Z) {
    t3[13](Z);
  }
  let Y = { label: "Operation:", options: t3[8] };
  t3[0] !== void 0 && (Y.value = t3[0]), n = new Ht({ props: Y }), Qe.push(() => ze(n, "value", K));
  function J(Z) {
    t3[14](Z);
  }
  let G = { label: "Format:", options: t3[9] };
  t3[5] !== void 0 && (G.value = t3[5]), i = new Ht({ props: G }), Qe.push(() => ze(i, "value", J));
  function X(Z) {
    t3[17](Z);
  }
  let ie = { label: t3[0] === "encrypt" ? "Plaintext:" : `Ciphertext (${t3[5]}):`, placeholder: t3[0] === "encrypt" ? "Message to encrypt..." : "Ciphertext to decrypt...", expandable: true, rows: 3 };
  t3[1] !== void 0 && (ie.value = t3[1]), F = new et({ props: ie }), Qe.push(() => ze(F, "value", X)), N = new ut({ props: { $$slots: { default: [hae] }, $$scope: { ctx: t3 } } }), N.$on("click", t3[10]), B = new ut({ props: { variant: "secondary", $$slots: { default: [dae] }, $$scope: { ctx: t3 } } }), B.$on("click", t3[18]), p = new hn({}), p.$on("click", t3[11]);
  function de(Z) {
    t3[19](Z);
  }
  let se = {};
  t3[4] !== void 0 && (se.checked = t3[4]), w = new xr({ props: se }), Qe.push(() => ze(w, "checked", de));
  let te = t3[7] && wE(t3), le = t3[6] && xE(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), fe(i.$$.fragment), o = z(), f = H("div"), c = H("div"), l = H("label"), l.textContent = "Key (32-byte Hex):", h = z(), m = H("input"), b = z(), A = H("div"), _ = H("label"), _.textContent = "Nonce (12-byte Hex):", C = z(), I = H("input"), $ = z(), fe(F.$$.fragment), Q = z(), P = H("div"), fe(N.$$.fragment), L = z(), fe(B.$$.fragment), u = z(), fe(p.$$.fragment), d = z(), y = H("div"), fe(w.$$.fragment), M = z(), te && te.c(), x = z(), le && le.c(), g = Lt(), V(e, "class", "controls-row svelte-pyu2z2"), V(l, "for", "chacha-key"), V(l, "class", "svelte-pyu2z2"), V(m, "id", "chacha-key"), V(m, "type", "text"), V(m, "placeholder", v = t3[0] === "encrypt" ? "Leave empty for random..." : "Required for decryption..."), V(m, "class", "svelte-pyu2z2"), V(c, "class", "param-input svelte-pyu2z2"), V(_, "for", "chacha-nonce"), V(_, "class", "svelte-pyu2z2"), V(I, "id", "chacha-nonce"), V(I, "type", "text"), V(I, "placeholder", S = t3[0] === "encrypt" ? "Leave empty for random..." : "Required for decryption..."), V(I, "class", "svelte-pyu2z2"), V(A, "class", "param-input svelte-pyu2z2"), V(f, "class", "params-row svelte-pyu2z2"), St(y, "margin-left", "auto"), V(P, "class", "button-row");
  }, m(Z, ve) {
    R(Z, e, ve), ae(n, e, null), q(e, s), ae(i, e, null), R(Z, o, ve), R(Z, f, ve), q(f, c), q(c, l), q(c, h), q(c, m), yr(m, t3[2]), q(f, b), q(f, A), q(A, _), q(A, C), q(A, I), yr(I, t3[3]), R(Z, $, ve), ae(F, Z, ve), R(Z, Q, ve), R(Z, P, ve), ae(N, P, null), q(P, L), ae(B, P, null), q(P, u), ae(p, P, null), q(P, d), q(P, y), ae(w, y, null), R(Z, M, ve), te && te.m(Z, ve), R(Z, x, ve), le && le.m(Z, ve), R(Z, g, ve), k = true, T || (O = [Kt(m, "input", t3[15]), Kt(I, "input", t3[16])], T = true);
  }, p(Z, ve) {
    const he = {};
    !r && ve & 1 && (r = true, he.value = Z[0], qe(() => r = false)), n.$set(he);
    const me = {};
    !a && ve & 32 && (a = true, me.value = Z[5], qe(() => a = false)), i.$set(me), (!k || ve & 1 && v !== (v = Z[0] === "encrypt" ? "Leave empty for random..." : "Required for decryption...")) && V(m, "placeholder", v), ve & 4 && m.value !== Z[2] && yr(m, Z[2]), (!k || ve & 1 && S !== (S = Z[0] === "encrypt" ? "Leave empty for random..." : "Required for decryption...")) && V(I, "placeholder", S), ve & 8 && I.value !== Z[3] && yr(I, Z[3]);
    const ce = {};
    ve & 33 && (ce.label = Z[0] === "encrypt" ? "Plaintext:" : `Ciphertext (${Z[5]}):`), ve & 1 && (ce.placeholder = Z[0] === "encrypt" ? "Message to encrypt..." : "Ciphertext to decrypt..."), !U && ve & 2 && (U = true, ce.value = Z[1], qe(() => U = false)), F.$set(ce);
    const ye = {};
    ve & 1048577 && (ye.$$scope = { dirty: ve, ctx: Z }), N.$set(ye);
    const Oe = {};
    ve & 1048576 && (Oe.$$scope = { dirty: ve, ctx: Z }), B.$set(Oe);
    const Se = {};
    !E && ve & 16 && (E = true, Se.checked = Z[4], qe(() => E = false)), w.$set(Se), Z[7] ? te ? te.p(Z, ve) : (te = wE(Z), te.c(), te.m(x.parentNode, x)) : te && (te.d(1), te = null), Z[6] ? le ? (le.p(Z, ve), ve & 64 && W(le, 1)) : (le = xE(Z), le.c(), W(le, 1), le.m(g.parentNode, g)) : le && (Xt(), j(le, 1, 1, () => {
      le = null;
    }), er());
  }, i(Z) {
    k || (W(n.$$.fragment, Z), W(i.$$.fragment, Z), W(F.$$.fragment, Z), W(N.$$.fragment, Z), W(B.$$.fragment, Z), W(p.$$.fragment, Z), W(w.$$.fragment, Z), W(le), k = true);
  }, o(Z) {
    j(n.$$.fragment, Z), j(i.$$.fragment, Z), j(F.$$.fragment, Z), j(N.$$.fragment, Z), j(B.$$.fragment, Z), j(p.$$.fragment, Z), j(w.$$.fragment, Z), j(le), k = false;
  }, d(Z) {
    Z && (D(e), D(o), D(f), D($), D(Q), D(P), D(M), D(x), D(g)), oe(n), oe(i), oe(F, Z), oe(N), oe(B), oe(p), oe(w), te && te.d(Z), le && le.d(Z), T = false, Mn(O);
  } };
}
function gae(t3) {
  let e, n, r, s, i;
  return { c() {
    e = H("p"), e.innerHTML = `<b>ChaCha20</b> is a high-speed, secure symmetric stream cipher designed by 
    cryptographer Daniel J. Bernstein. It is an improved variant of 
    the earlier Salsa20 cipher, and it has gained popularity due to its 
    performance, simplicity, and robustness against cryptographic attacks.`, n = z(), r = H("p"), r.textContent = `ChaCha20 is often used in applications requiring high security and speed, 
    such as TLS for encrypted internet connections and mobile communications. 
    It operates on 512-bit blocks of data, processed in 20 rounds (by default) 
    to increase security. Each round consists of a series of quarter-round 
    transformations that mix data in a way that ensures diffusion and confusion, 
    making it resistant to cryptographic attacks. 
    Major tech companies like Google have adopted ChaCha20 for encrypting 
    HTTPS traffic in Google Chrome, especially for mobile clients.`, s = z(), i = H("p"), i.innerHTML = `<i>Note: This tool uses the IETF variant of ChaCha20 (96-bit nonce, 32-bit counter). 
    It performs raw encryption without an authentication tag (Poly1305 is not included in this specific tool).</i>`;
  }, m(a, o) {
    R(a, e, o), R(a, n, o), R(a, r, o), R(a, s, o), R(a, i, o);
  }, p: dt, d(a) {
    a && (D(e), D(n), D(r), D(s), D(i));
  } };
}
function mae(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "ChaCha20 Cipher", $$slots: { default: [pae] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About ChaCha20", links: t3[12], $$slots: { default: [gae] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 1048831 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 1048576 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function vae(t3, e, n) {
  let r = "encrypt", s = "", i = "", a = "", o = "Base64", f = "", c = "", l = true;
  const h = [{ value: "encrypt", label: "Encrypt (Text \u2192 Cipher)" }, { value: "decrypt", label: "Decrypt (Cipher \u2192 Text)" }], m = [{ value: "Base64", label: "Base64" }, { value: "Hex", label: "Hexadecimal" }];
  function v() {
    if (n(7, c = ""), n(6, f = ""), !s) {
      n(7, c = "Please enter text.");
      return;
    }
    if (r === "encrypt" && (!i || !a)) {
      const Q = cae();
      i || n(2, i = Q.key), a || n(3, a = Q.nonce);
    }
    if (!i || !a) {
      l || n(7, c = "Key and Nonce are required.");
      return;
    }
    try {
      n(6, f = uae(s, i, a, r, o));
    } catch (Q) {
      n(7, c = Q.message);
    }
  }
  function b() {
    n(0, r = r === "encrypt" ? "decrypt" : "encrypt"), f && !c && (n(1, s = f), n(6, f = ""));
  }
  const A = [{ text: "Wikipedia", url: "https://en.wikipedia.org/wiki/ChaCha20-Poly1305" }, { text: "RFC 8439", url: "https://datatracker.ietf.org/doc/html/rfc8439" }];
  function _(Q) {
    r = Q, n(0, r);
  }
  function C(Q) {
    o = Q, n(5, o);
  }
  function I() {
    i = this.value, n(2, i);
  }
  function S() {
    a = this.value, n(3, a);
  }
  function $(Q) {
    s = Q, n(1, s);
  }
  const F = () => {
    n(1, s = ""), n(6, f = ""), n(2, i = ""), n(3, a = "");
  };
  function U(Q) {
    l = Q, n(4, l);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 31 && l && s && (r === "encrypt" || i && a) && v();
  }, [r, s, i, a, l, o, f, c, h, m, v, b, A, _, C, I, S, $, F, U];
}
class yae extends xt {
  constructor(e) {
    super(), wt(this, e, vae, mae, At, {});
  }
}
const kn = 4294967295, an = 65535, ho = 255, x4 = 8, vb = 9, mD = 0, vD = 99, yD = 67324752, _4 = 134695760, bD = _4, yb = 33639248, AD = 101010256, bb = 101075792, wD = 117853008, Yo = 22, hh = 20, dh = 56, bae = Yo + hh + dh, xD = 12, _D = 20, H1 = 4, ED = 1, BD = 39169, CD = 10, kD = 1, E4 = 21589, Aae = 28789, wae = 25461, ID = 6534, SD = 30837, MD = 30805, Ab = 1, xae = 6, _ae = 2, Eae = 4, Bae = 6, wb = 8, xb = 2048, q1 = 16, _b = 1, Eb = 2, Bb = 4, Cb = 32, _E = 61440, ph = 16384, gh = 73, Gp = 420, z1 = 2048, G1 = 1024, V1 = 512, Cae = 20, EE = 45, BE = 51, Vp = "/", r0 = 30, B4 = 10, uc = 14, cc = 18, CE = new Date(2107, 11, 31), kE = new Date(1980, 0, 1), lr = void 0, ll = "undefined", E0 = "function", kae = "object", Iae = 64;
let $D = 2;
try {
  typeof navigator != ll && navigator.hardwareConcurrency && ($D = navigator.hardwareConcurrency);
} catch {
}
const Sae = { workerURI: "./core/web-worker-wasm.js", wasmURI: "./core/streams/zlib-wasm/zlib-streams.wasm", chunkSize: 64 * 1024, maxWorkers: $D, terminateWorkerTimeout: 5e3, useWebWorkers: true, useCompressionStream: true, CompressionStream: typeof CompressionStream != ll && CompressionStream, DecompressionStream: typeof DecompressionStream != ll && DecompressionStream }, TD = Object.assign({}, Sae);
function DD() {
  return TD;
}
function RD(t3) {
  return Math.max(t3.chunkSize, Iae);
}
function Sd(t3) {
  const { baseURI: e, chunkSize: n, maxWorkers: r, terminateWorkerTimeout: s, useCompressionStream: i, useWebWorkers: a, CompressionStream: o, DecompressionStream: f, CompressionStreamZlib: c, DecompressionStreamZlib: l, workerURI: h, wasmURI: m } = t3;
  Ys("baseURI", e), Ys("wasmURI", m), Ys("workerURI", h), Ys("chunkSize", n), Ys("maxWorkers", r), Ys("terminateWorkerTimeout", s), Ys("useCompressionStream", i), Ys("useWebWorkers", a), Ys("CompressionStream", o), Ys("DecompressionStream", f), Ys("CompressionStreamZlib", c), Ys("DecompressionStreamZlib", l);
}
function Ys(t3, e) {
  e !== lr && (TD[t3] = e);
}
function Mae(t3) {
  let e;
  t3({ workerURI: () => (e || (e = "data:text/javascript," + encodeURIComponent(`(t=>{"function"==typeof define&&define.amd?define(t):t()})(function(){"use strict";const{Array:t,Object:e,Number:n,Math:s,Error:r,Uint8Array:o,Uint16Array:i,Uint32Array:c,Int32Array:a,Map:h,DataView:f,Promise:l,TextEncoder:u,crypto:w,postMessage:p,TransformStream:d,ReadableStream:y,WritableStream:m,CompressionStream:g,DecompressionStream:S}=self,b=void 0,v="undefined",k="function",z=[];for(let t=0;256>t;t++){let e=t;for(let t=0;8>t;t++)1&e?e=e>>>1^3988292384:e>>>=1;z[t]=e}class C{constructor(t){this.t=t||-1}append(t){let e=0|this.t;for(let n=0,s=0|t.length;s>n;n++)e=e>>>8^z[255&(e^t[n])];this.t=e}get(){return~this.t}}class A extends d{constructor(){let t;const e=new C;super({transform(t,n){e.append(t),n.enqueue(t)},flush(){const n=new o(4);new f(n.buffer).setUint32(0,e.get()),t.value=n}}),t=this}}const x={concat(t,e){if(0===t.length||0===e.length)return t.concat(e);const n=t[t.length-1],s=x.o(n);return 32===s?t.concat(e):x.i(e,s,0|n,t.slice(0,t.length-1))},h(t){const e=t.length;if(0===e)return 0;const n=t[e-1];return 32*(e-1)+x.o(n)},l(t,e){if(32*t.length<e)return t;const n=(t=t.slice(0,s.ceil(e/32))).length;return e&=31,n>0&&e&&(t[n-1]=x.u(e,t[n-1]&2147483648>>e-1,1)),t},u:(t,e,n)=>32===t?e:(n?0|e:e<<32-t)+1099511627776*t,o:t=>s.round(t/1099511627776)||32,i(t,e,n,s){for(void 0===s&&(s=[]);e>=32;e-=32)s.push(n),n=0;if(0===e)return s.concat(t);for(let r=0;r<t.length;r++)s.push(n|t[r]>>>e),n=t[r]<<32-e;const r=t.length?t[t.length-1]:0,o=x.o(r);return s.push(x.u(e+o&31,e+o>32?n:s.pop(),1)),s}},I={bytes:{p(t){const e=x.h(t)/8,n=new o(e);let s;for(let r=0;e>r;r++)3&r||(s=t[r/4]),n[r]=s>>>24,s<<=8;return n},m(t){const e=[];let n,s=0;for(n=0;n<t.length;n++)s=s<<8|t[n],3&~n||(e.push(s),s=0);return 3&n&&e.push(x.u(8*(3&n),s)),e}}},R=class{constructor(t){const e=this;e.blockSize=512,e.S=[1732584193,4023233417,2562383102,271733878,3285377520],e.v=[1518500249,1859775393,2400959708,3395469782],t?(e.k=t.k.slice(0),e.C=t.C.slice(0),e.A=t.A):e.reset()}reset(){const t=this;return t.k=t.S.slice(0),t.C=[],t.A=0,t}update(t){const e=this;"string"==typeof t&&(t=I.I.m(t));const n=e.C=x.concat(e.C,t),s=e.A,o=e.A=s+x.h(t);if(o>9007199254740991)throw new r("Cannot hash more than 2^53 - 1 bits");const i=new c(n);let a=0;for(let t=e.blockSize+s-(e.blockSize+s&e.blockSize-1);o>=t;t+=e.blockSize)e.R(i.subarray(16*a,16*(a+1))),a+=1;return n.splice(0,16*a),e}P(){const t=this;let e=t.C;const n=t.k;e=x.concat(e,[x.u(1,1)]);for(let t=e.length+2;15&t;t++)e.push(0);for(e.push(s.floor(t.A/4294967296)),e.push(0|t.A);e.length;)t.R(e.splice(0,16));return t.reset(),n}U(t,e,n,s){return t>19?t>39?t>59?t>79?void 0:e^n^s:e&n|e&s|n&s:e^n^s:e&n|~e&s}V(t,e){return e<<t|e>>>32-t}R(e){const n=this,r=n.k,o=t(80);for(let t=0;16>t;t++)o[t]=e[t];let i=r[0],c=r[1],a=r[2],h=r[3],f=r[4];for(let t=0;79>=t;t++){16>t||(o[t]=n.V(1,o[t-3]^o[t-8]^o[t-14]^o[t-16]));const e=n.V(5,i)+n.U(t,c,a,h)+f+o[t]+n.v[s.floor(t/20)]|0;f=h,h=a,a=n.V(30,c),c=i,i=e}r[0]=r[0]+i|0,r[1]=r[1]+c|0,r[2]=r[2]+a|0,r[3]=r[3]+h|0,r[4]=r[4]+f|0}},P={getRandomValues(t){const e=new c(t.buffer),n=t=>{let e=987654321;const n=4294967295;return()=>(e=36969*(65535&e)+(e>>16)&n,(((e<<16)+(t=18e3*(65535&t)+(t>>16)&n)&n)/4294967296+.5)*(s.random()>.5?1:-1))};for(let r,o=0;o<t.length;o+=4){const t=n(4294967296*(r||s.random()));r=987654071*t(),e[o/4]=4294967296*t()|0}return t}},U={importKey:t=>new U.M(I.bytes.m(t)),_(t,e,n,s){if(n=n||1e4,0>s||0>n)throw new r("invalid params to pbkdf2");const o=1+(s>>5)<<2;let i,c,a,h,l;const u=new ArrayBuffer(o),w=new f(u);let p=0;const d=x;for(e=I.bytes.m(e),l=1;(o||1)>p;l++){for(i=c=t.encrypt(d.concat(e,[l])),a=1;n>a;a++)for(c=t.encrypt(c),h=0;h<c.length;h++)i[h]^=c[h];for(a=0;(o||1)>p&&a<i.length;a++)w.setInt32(p,i[a]),p+=4}return u.slice(0,s/8)},M:class{constructor(t){const e=this,n=e.B=R,s=[[],[]];e.D=[new n,new n];const r=e.D[0].blockSize/32;t.length>r&&(t=(new n).update(t).P());for(let e=0;r>e;e++)s[0][e]=909522486^t[e],s[1][e]=1549556828^t[e];e.D[0].update(s[0]),e.D[1].update(s[1]),e.W=new n(e.D[0])}reset(){const t=this;t.W=new t.B(t.D[0]),t.K=!1}update(t){this.K=!0,this.W.update(t)}digest(){const t=this,e=t.W.P(),n=new t.B(t.D[1]).update(e).P();return t.reset(),n}encrypt(t){if(this.K)throw new r("encrypt on already updated hmac called!");return this.update(t),this.digest(t)}}},V=typeof w!=v&&typeof w.getRandomValues==k,M="Invalid password",_="Invalid signature",B="zipjs-abort-check-password";function D(t){return V?w.getRandomValues(t):P.getRandomValues(t)}const W=16,K={name:"PBKDF2"},E=e.assign({hash:{name:"HMAC"}},K),L=e.assign({iterations:1e3,hash:{name:"SHA-1"}},K),O=["deriveBits"],T=[8,12,16],j=[16,24,32],H=10,Z=[0,0,0,0],F=typeof w!=v,N=F&&w.subtle,q=F&&typeof N!=v,G=I.bytes,J=class{constructor(t){const e=this;e.L=[[[],[],[],[],[]],[[],[],[],[],[]]],e.L[0][0][0]||e.O();const n=e.L[0][4],s=e.L[1],o=t.length;let i,c,a,h=1;if(4!==o&&6!==o&&8!==o)throw new r("invalid aes key size");for(e.v=[c=t.slice(0),a=[]],i=o;4*o+28>i;i++){let t=c[i-1];(i%o===0||8===o&&i%o===4)&&(t=n[t>>>24]<<24^n[t>>16&255]<<16^n[t>>8&255]<<8^n[255&t],i%o===0&&(t=t<<8^t>>>24^h<<24,h=h<<1^283*(h>>7))),c[i]=c[i-o]^t}for(let t=0;i;t++,i--){const e=c[3&t?i:i-4];a[t]=4>=i||4>t?e:s[0][n[e>>>24]]^s[1][n[e>>16&255]]^s[2][n[e>>8&255]]^s[3][n[255&e]]}}encrypt(t){return this.T(t,0)}decrypt(t){return this.T(t,1)}O(){const t=this.L[0],e=this.L[1],n=t[4],s=e[4],r=[],o=[];let i,c,a,h;for(let t=0;256>t;t++)o[(r[t]=t<<1^283*(t>>7))^t]=t;for(let f=i=0;!n[f];f^=c||1,i=o[i]||1){let o=i^i<<1^i<<2^i<<3^i<<4;o=o>>8^255&o^99,n[f]=o,s[o]=f,h=r[a=r[c=r[f]]];let l=16843009*h^65537*a^257*c^16843008*f,u=257*r[o]^16843008*o;for(let n=0;4>n;n++)t[n][f]=u=u<<24^u>>>8,e[n][o]=l=l<<24^l>>>8}for(let n=0;5>n;n++)t[n]=t[n].slice(0),e[n]=e[n].slice(0)}T(t,e){if(4!==t.length)throw new r("invalid aes block size");const n=this.v[e],s=n.length/4-2,o=[0,0,0,0],i=this.L[e],c=i[0],a=i[1],h=i[2],f=i[3],l=i[4];let u,w,p,d=t[0]^n[0],y=t[e?3:1]^n[1],m=t[2]^n[2],g=t[e?1:3]^n[3],S=4;for(let t=0;s>t;t++)u=c[d>>>24]^a[y>>16&255]^h[m>>8&255]^f[255&g]^n[S],w=c[y>>>24]^a[m>>16&255]^h[g>>8&255]^f[255&d]^n[S+1],p=c[m>>>24]^a[g>>16&255]^h[d>>8&255]^f[255&y]^n[S+2],g=c[g>>>24]^a[d>>16&255]^h[y>>8&255]^f[255&m]^n[S+3],S+=4,d=u,y=w,m=p;for(let t=0;4>t;t++)o[e?3&-t:t]=l[d>>>24]<<24^l[y>>16&255]<<16^l[m>>8&255]<<8^l[255&g]^n[S++],u=d,d=y,y=m,m=g,g=u;return o}},Q=class{constructor(t,e){this.j=t,this.H=e,this.Z=e}reset(){this.Z=this.H}update(t){return this.F(this.j,t,this.Z)}N(t){if(255&~(t>>24))t+=1<<24;else{let e=t>>16&255,n=t>>8&255,s=255&t;255===e?(e=0,255===n?(n=0,255===s?s=0:++s):++n):++e,t=0,t+=e<<16,t+=n<<8,t+=s}return t}q(t){0===(t[0]=this.N(t[0]))&&(t[1]=this.N(t[1]))}F(t,e,n){let s;if(!(s=e.length))return[];const r=x.h(e);for(let r=0;s>r;r+=4){this.q(n);const s=t.encrypt(n);e[r]^=s[0],e[r+1]^=s[1],e[r+2]^=s[2],e[r+3]^=s[3]}return x.l(e,r)}},X=U.M;let Y=F&&q&&typeof N.importKey==k,$=F&&q&&typeof N.deriveBits==k;class tt extends d{constructor({password:t,rawPassword:n,signed:s,encryptionStrength:i,checkPasswordOnly:c}){super({start(){e.assign(this,{ready:new l(t=>this.G=t),password:rt(t,n),signed:s,J:i-1,pending:new o})},async transform(t,e){const n=this,{password:s,J:i,G:a,ready:h}=n;s?(await(async(t,e,n,s)=>{const o=await st(t,e,n,it(s,0,T[e])),i=it(s,T[e]);if(o[0]!=i[0]||o[1]!=i[1])throw new r(M)})(n,i,s,it(t,0,T[i]+2)),t=it(t,T[i]+2),c?e.error(new r(B)):a()):await h;const f=new o(t.length-H-(t.length-H)%W);e.enqueue(nt(n,t,f,0,H,!0))},async flush(t){const{signed:e,X:n,Y:s,pending:i,ready:c}=this;if(s&&n){await c;const a=it(i,0,i.length-H),h=it(i,i.length-H);let f=new o;if(a.length){const t=at(G,a);s.update(t);const e=n.update(t);f=ct(G,e)}if(e){const t=it(ct(G,s.digest()),0,H);for(let e=0;H>e;e++)if(t[e]!=h[e])throw new r(_)}t.enqueue(f)}}})}}class et extends d{constructor({password:t,rawPassword:n,encryptionStrength:s}){let r;super({start(){e.assign(this,{ready:new l(t=>this.G=t),password:rt(t,n),J:s-1,pending:new o})},async transform(t,e){const n=this,{password:s,J:r,G:i,ready:c}=n;let a=new o;s?(a=await(async(t,e,n)=>{const s=D(new o(T[e]));return ot(s,await st(t,e,n,s))})(n,r,s),i()):await c;const h=new o(a.length+t.length-t.length%W);h.set(a,0),e.enqueue(nt(n,t,h,a.length,0))},async flush(t){const{X:e,Y:n,pending:s,ready:i}=this;if(n&&e){await i;let c=new o;if(s.length){const t=e.update(at(G,s));n.update(t),c=ct(G,t)}r.signature=ct(G,n.digest()).slice(0,H),t.enqueue(ot(c,r.signature))}}}),r=this}}function nt(t,e,n,s,r,i){const{X:c,Y:a,pending:h}=t,f=e.length-r;let l;for(h.length&&(e=ot(h,e),n=((t,e)=>{if(e&&e>t.length){const n=t;(t=new o(e)).set(n,0)}return t})(n,f-f%W)),l=0;f-W>=l;l+=W){const t=at(G,it(e,l,l+W));i&&a.update(t);const r=c.update(t);i||a.update(r),n.set(ct(G,r),l+s)}return t.pending=it(e,l),n}async function st(n,s,r,i){n.password=null;const c=await(async(t,e,n,s,r)=>{if(!Y)return U.importKey(e);try{return await N.importKey("raw",e,n,!1,r)}catch{return Y=!1,U.importKey(e)}})(0,r,E,0,O),a=await(async(t,e,n)=>{if(!$)return U._(e,t.salt,L.iterations,n);try{return await N.deriveBits(t,e,n)}catch{return $=!1,U._(e,t.salt,L.iterations,n)}})(e.assign({salt:i},L),c,8*(2*j[s]+2)),h=new o(a),f=at(G,it(h,0,j[s])),l=at(G,it(h,j[s],2*j[s])),u=it(h,2*j[s]);return e.assign(n,{keys:{key:f,$:l,passwordVerification:u},X:new Q(new J(f),t.from(Z)),Y:new X(l)}),u}function rt(t,e){return e===b?(t=>{if(typeof u==v){const e=new o((t=unescape(encodeURIComponent(t))).length);for(let n=0;n<e.length;n++)e[n]=t.charCodeAt(n);return e}return(new u).encode(t)})(t):e}function ot(t,e){let n=t;return t.length+e.length&&(n=new o(t.length+e.length),n.set(t,0),n.set(e,t.length)),n}function it(t,e,n){return t.subarray(e,n)}function ct(t,e){return t.p(e)}function at(t,e){return t.m(e)}class ht extends d{constructor({password:t,passwordVerification:n,checkPasswordOnly:s}){super({start(){e.assign(this,{password:t,passwordVerification:n}),wt(this,t)},transform(t,e){const n=this;if(n.password){const e=lt(n,t.subarray(0,12));if(n.password=null,e.at(-1)!=n.passwordVerification)throw new r(M);t=t.subarray(12)}s?e.error(new r(B)):e.enqueue(lt(n,t))}})}}class ft extends d{constructor({password:t,passwordVerification:n}){super({start(){e.assign(this,{password:t,passwordVerification:n}),wt(this,t)},transform(t,e){const n=this;let s,r;if(n.password){n.password=null;const e=D(new o(12));e[11]=n.passwordVerification,s=new o(t.length+e.length),s.set(ut(n,e),0),r=12}else s=new o(t.length),r=0;s.set(ut(n,t),r),e.enqueue(s)}})}}function lt(t,e){const n=new o(e.length);for(let s=0;s<e.length;s++)n[s]=dt(t)^e[s],pt(t,n[s]);return n}function ut(t,e){const n=new o(e.length);for(let s=0;s<e.length;s++)n[s]=dt(t)^e[s],pt(t,e[s]);return n}function wt(t,n){const s=[305419896,591751049,878082192];e.assign(t,{keys:s,tt:new C(s[0]),et:new C(s[2])});for(let e=0;e<n.length;e++)pt(t,n.charCodeAt(e))}function pt(t,e){let[n,r,o]=t.keys;t.tt.append([e]),n=~t.tt.get(),r=mt(s.imul(mt(r+yt(n)),134775813)+1),t.et.append([r>>>24]),o=~t.et.get(),t.keys=[n,r,o]}function dt(t){const e=2|t.keys[2];return yt(s.imul(e,1^e)>>>8)}function yt(t){return 255&t}function mt(t){return 4294967295&t}class gt extends d{constructor(t,{chunkSize:e,nt:n,CompressionStream:s}){super({});const{compressed:r,encrypted:o,useCompressionStream:i,zipCrypto:c,signed:a,level:h}=t,l=this;let u,w,p=super.readable;o&&!c||!a||(u=new A,p=kt(p,u)),r&&(p=vt(p,i,{level:h,chunkSize:e},s,n,s)),o&&(c?p=kt(p,new ft(t)):(w=new et(t),p=kt(p,w))),bt(l,p,()=>{let t;o&&!c&&(t=w.signature),o&&!c||!a||(t=new f(u.value.buffer).getUint32(0)),l.signature=t})}}class St extends d{constructor(t,{chunkSize:e,st:n,DecompressionStream:s}){super({});const{zipCrypto:o,encrypted:i,signed:c,signature:a,compressed:h,useCompressionStream:l,rt:u}=t;let w,p,d=super.readable;i&&(o?d=kt(d,new ht(t)):(p=new tt(t),d=kt(d,p))),h&&(d=vt(d,l,{chunkSize:e,rt:u},s,n,s)),i&&!o||!c||(w=new A,d=kt(d,w)),bt(this,d,()=>{if((!i||o)&&c){const t=new f(w.value.buffer);if(a!=t.getUint32(0,!1))throw new r(_)}})}}function bt(t,n,s){n=kt(n,new d({flush:s})),e.defineProperty(t,"readable",{get:()=>n})}function vt(t,e,n,s,r,o){const i=e&&s?s:r||o,c=n.rt?"deflate64-raw":"deflate-raw";try{t=kt(t,new i(c,n))}catch(s){if(!e)throw s;if(r)t=kt(t,new r(c,n));else{if(!o)throw s;t=kt(t,new o(c,n))}}return t}function kt(t,e){return t.pipeThrough(e)}const zt="data",Ct="close";class At extends d{constructor(t,n){super({});const s=this,{codecType:o}=t;let i;o.startsWith("deflate")?i=gt:o.startsWith("inflate")&&(i=St),s.outputSize=0;let c=0;const a=new i(t,n),h=super.readable,f=new d({transform(t,e){t&&t.length&&(c+=t.length,e.enqueue(t))},flush(){e.assign(s,{inputSize:c})}}),l=new d({transform(e,n){if(e&&e.length&&(n.enqueue(e),s.outputSize+=e.length,t.outputSize!==b&&s.outputSize>t.outputSize))throw new r("Invalid uncompressed size")},flush(){const{signature:t}=a;e.assign(s,{signature:t,inputSize:c})}});e.defineProperty(s,"readable",{get:()=>h.pipeThrough(f).pipeThrough(a).pipeThrough(l)})}}class xt extends d{constructor(t){let e;super({transform:function n(s,r){if(e){const t=new o(e.length+s.length);t.set(e),t.set(s,e.length),s=t,e=null}s.length>t?(r.enqueue(s.slice(0,t)),n(s.slice(t),r)):e=s},flush(t){e&&e.length&&t.enqueue(e)}})}}const It=new h,Rt=new h;let Pt,Ut,Vt,Mt,_t,Bt=0;async function Dt(t){try{const{options:e,config:s}=t;if(!e.useCompressionStream)try{await self.initModule(t.config)}catch{e.useCompressionStream=!0}s.CompressionStream=self.CompressionStream,s.DecompressionStream=self.DecompressionStream;const r={highWaterMark:1},o=t.readable||new y({async pull(t){const e=new l(t=>It.set(Bt,t));Wt({type:"pull",messageId:Bt}),Bt=(Bt+1)%n.MAX_SAFE_INTEGER;const{value:s,done:r}=await e;t.enqueue(s),r&&t.close()}},r),i=t.writable||new m({async write(t){let e;const s=new l(t=>e=t);Rt.set(Bt,e),Wt({type:zt,value:t,messageId:Bt}),Bt=(Bt+1)%n.MAX_SAFE_INTEGER,await s}},r),c=new At(e,s);Pt=new AbortController;const{signal:a}=Pt;await o.pipeThrough(c).pipeThrough(new xt(s.chunkSize)).pipeTo(i,{signal:a,preventClose:!0,preventAbort:!0}),await i.getWriter().close();const{signature:h,inputSize:f,outputSize:u}=c;Wt({type:Ct,result:{signature:h,inputSize:f,outputSize:u}})}catch(t){t.outputSize=0,Kt(t)}}function Wt(t){let{value:e}=t;if(e)if(e.length)try{e=new o(e),t.value=e.buffer,p(t,[t.value])}catch{p(t)}else p(t);else p(t)}function Kt(t=new r("Unknown error")){const{message:e,stack:n,code:s,name:o,outputSize:i}=t;p({error:{message:e,stack:n,code:s,name:o,outputSize:i}})}function Et(t,e,n={}){const i="number"==typeof n.level?n.level:-1,c="number"==typeof n.ot?n.ot:65536,a="number"==typeof n.it?n.it:65536;return new d({start(){let n;if(this.ct=Vt(c),this.in=Vt(a),this.it=a,this.ht=new o(c),t?(this.ft=Ut.deflate_process,this.lt=Ut.deflate_last_consumed,this.ut=Ut.deflate_end,this.wt=Ut.deflate_new(),n="gzip"===e?Ut.deflate_init_gzip(this.wt,i):"deflate-raw"===e?Ut.deflate_init_raw(this.wt,i):Ut.deflate_init(this.wt,i)):"deflate64-raw"===e?(this.ft=Ut.inflate9_process,this.lt=Ut.inflate9_last_consumed,this.ut=Ut.inflate9_end,this.wt=Ut.inflate9_new(),n=Ut.inflate9_init_raw(this.wt)):(this.ft=Ut.inflate_process,this.lt=Ut.inflate_last_consumed,this.ut=Ut.inflate_end,this.wt=Ut.inflate_new(),n="deflate-raw"===e?Ut.inflate_init_raw(this.wt):"gzip"===e?Ut.inflate_init_gzip(this.wt):Ut.inflate_init(this.wt)),0!==n)throw new r("init failed:"+n)},transform(e,n){try{const i=e,a=new o(_t.buffer),h=this.ft,f=this.lt,l=this.ct,u=this.ht;let w=0;for(;w<i.length;){const e=s.min(i.length-w,32768);this.in&&this.it>=e||(this.in&&Mt&&Mt(this.in),this.in=Vt(e),this.it=e),a.set(i.subarray(w,w+e),this.in);const o=h(this.wt,this.in,e,l,c,0),p=16777215&o;if(p&&(u.set(a.subarray(l,l+p),0),n.enqueue(u.slice(0,p))),!t){const t=o>>24&255,e=128&t?t-256:t;if(0>e)throw new r("process error:"+e)}const d=f(this.wt);if(0===d)break;w+=d}}catch(t){this.ut&&this.wt&&this.ut(this.wt),this.in&&Mt&&Mt(this.in),this.ct&&Mt&&Mt(this.ct),n.error(t)}},flush(e){try{const n=new o(_t.buffer),s=this.ft,i=this.ct,a=this.ht;for(;;){const o=s(this.wt,0,0,i,c,4),h=16777215&o,f=o>>24&255;if(!t){const t=128&f?f-256:f;if(0>t)throw new r("process error:"+t)}if(h&&(a.set(n.subarray(i,i+h),0),e.enqueue(a.slice(0,h))),1===f||0===h)break}}catch(t){e.error(t)}finally{if(this.ut&&this.wt){const t=this.ut(this.wt);0!==t&&e.error(new r("end error:"+t))}this.in&&Mt&&Mt(this.in),this.ct&&Mt&&Mt(this.ct)}}})}addEventListener("message",({data:t})=>{const{type:e,messageId:n,value:s,done:r}=t;try{if("start"==e&&Dt(t),e==zt){const t=It.get(n);It.delete(n),t({value:new o(s),done:r})}if("ack"==e){const t=Rt.get(n);Rt.delete(n),t()}e==Ct&&Pt.abort()}catch(t){Kt(t)}});class Lt{constructor(t="deflate",e){return Et(!0,t,e)}}class Ot{constructor(t="deflate",e){return Et(!1,t,e)}}let Tt=!1;self.initModule=async t=>{try{const e=await(async(t,{baseURI:e})=>{if(!Tt){let n,s;try{try{s=new URL(t,e)}catch{}const r=await fetch(s);n=await r.arrayBuffer()}catch(e){if(!t.startsWith("data:application/wasm;base64,"))throw e;n=(t=>{const e=t.split(",")[1],n=atob(e),s=n.length,r=new o(s);for(let t=0;s>t;++t)r[t]=n.charCodeAt(t);return r.buffer})(t)}(t=>{if(Ut=t,({malloc:Vt,free:Mt,memory:_t}=Ut),"function"!=typeof Vt||"function"!=typeof Mt||!_t)throw Ut=Vt=Mt=_t=null,new r("Invalid WASM module")})((await WebAssembly.instantiate(n)).instance.exports),Tt=!0}})(t.wasmURI,t);return t.nt=Lt,t.st=Ot,e}catch{}}});
`)), e) });
}
const FD = [];
for (let t3 = 0; t3 < 256; t3++) {
  let e = t3;
  for (let n = 0; n < 8; n++) e & 1 ? e = e >>> 1 ^ 3988292384 : e = e >>> 1;
  FD[t3] = e;
}
class Y1 {
  constructor(e) {
    this.crc = e || -1;
  }
  append(e) {
    let n = this.crc | 0;
    for (let r = 0, s = e.length | 0; r < s; r++) n = n >>> 8 ^ FD[(n ^ e[r]) & 255];
    this.crc = n;
  }
  get() {
    return ~this.crc;
  }
}
class PD extends TransformStream {
  constructor() {
    let e;
    const n = new Y1();
    super({ transform(r, s) {
      n.append(r), s.enqueue(r);
    }, flush() {
      const r = new Uint8Array(4);
      new DataView(r.buffer).setUint32(0, n.get()), e.value = r;
    } }), e = this;
  }
}
function Yp(t3) {
  if (typeof TextEncoder == ll) {
    t3 = unescape(encodeURIComponent(t3));
    const e = new Uint8Array(t3.length);
    for (let n = 0; n < e.length; n++) e[n] = t3.charCodeAt(n);
    return e;
  } else return new TextEncoder().encode(t3);
}
const cs = { concat(t3, e) {
  if (t3.length === 0 || e.length === 0) return t3.concat(e);
  const n = t3[t3.length - 1], r = cs.getPartial(n);
  return r === 32 ? t3.concat(e) : cs._shiftRight(e, r, n | 0, t3.slice(0, t3.length - 1));
}, bitLength(t3) {
  const e = t3.length;
  if (e === 0) return 0;
  const n = t3[e - 1];
  return (e - 1) * 32 + cs.getPartial(n);
}, clamp(t3, e) {
  if (t3.length * 32 < e) return t3;
  t3 = t3.slice(0, Math.ceil(e / 32));
  const n = t3.length;
  return e = e & 31, n > 0 && e && (t3[n - 1] = cs.partial(e, t3[n - 1] & 2147483648 >> e - 1, 1)), t3;
}, partial(t3, e, n) {
  return t3 === 32 ? e : (n ? e | 0 : e << 32 - t3) + t3 * 1099511627776;
}, getPartial(t3) {
  return Math.round(t3 / 1099511627776) || 32;
}, _shiftRight(t3, e, n, r) {
  for (r === void 0 && (r = []); e >= 32; e -= 32) r.push(n), n = 0;
  if (e === 0) return r.concat(t3);
  for (let a = 0; a < t3.length; a++) r.push(n | t3[a] >>> e), n = t3[a] << 32 - e;
  const s = t3.length ? t3[t3.length - 1] : 0, i = cs.getPartial(s);
  return r.push(cs.partial(e + i & 31, e + i > 32 ? n : r.pop(), 1)), r;
} }, W1 = { bytes: { fromBits(t3) {
  const n = cs.bitLength(t3) / 8, r = new Uint8Array(n);
  let s;
  for (let i = 0; i < n; i++) i & 3 || (s = t3[i / 4]), r[i] = s >>> 24, s <<= 8;
  return r;
}, toBits(t3) {
  const e = [];
  let n, r = 0;
  for (n = 0; n < t3.length; n++) r = r << 8 | t3[n], (n & 3) === 3 && (e.push(r), r = 0);
  return n & 3 && e.push(cs.partial(8 * (n & 3), r)), e;
} } }, ND = {};
ND.sha1 = class {
  constructor(t3) {
    const e = this;
    e.blockSize = 512, e._init = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], e._key = [1518500249, 1859775393, 2400959708, 3395469782], t3 ? (e._h = t3._h.slice(0), e._buffer = t3._buffer.slice(0), e._length = t3._length) : e.reset();
  }
  reset() {
    const t3 = this;
    return t3._h = t3._init.slice(0), t3._buffer = [], t3._length = 0, t3;
  }
  update(t3) {
    const e = this;
    typeof t3 == "string" && (t3 = W1.utf8String.toBits(t3));
    const n = e._buffer = cs.concat(e._buffer, t3), r = e._length, s = e._length = r + cs.bitLength(t3);
    if (s > 9007199254740991) throw new Error("Cannot hash more than 2^53 - 1 bits");
    const i = new Uint32Array(n);
    let a = 0;
    for (let o = e.blockSize + r - (e.blockSize + r & e.blockSize - 1); o <= s; o += e.blockSize) e._block(i.subarray(16 * a, 16 * (a + 1))), a += 1;
    return n.splice(0, 16 * a), e;
  }
  finalize() {
    const t3 = this;
    let e = t3._buffer;
    const n = t3._h;
    e = cs.concat(e, [cs.partial(1, 1)]);
    for (let r = e.length + 2; r & 15; r++) e.push(0);
    for (e.push(Math.floor(t3._length / 4294967296)), e.push(t3._length | 0); e.length; ) t3._block(e.splice(0, 16));
    return t3.reset(), n;
  }
  _f(t3, e, n, r) {
    if (t3 <= 19) return e & n | ~e & r;
    if (t3 <= 39) return e ^ n ^ r;
    if (t3 <= 59) return e & n | e & r | n & r;
    if (t3 <= 79) return e ^ n ^ r;
  }
  _S(t3, e) {
    return e << t3 | e >>> 32 - t3;
  }
  _block(t3) {
    const e = this, n = e._h, r = Array(80);
    for (let c = 0; c < 16; c++) r[c] = t3[c];
    let s = n[0], i = n[1], a = n[2], o = n[3], f = n[4];
    for (let c = 0; c <= 79; c++) {
      c >= 16 && (r[c] = e._S(1, r[c - 3] ^ r[c - 8] ^ r[c - 14] ^ r[c - 16]));
      const l = e._S(5, s) + e._f(c, i, a, o) + f + r[c] + e._key[Math.floor(c / 20)] | 0;
      f = o, o = a, a = e._S(30, i), i = s, s = l;
    }
    n[0] = n[0] + s | 0, n[1] = n[1] + i | 0, n[2] = n[2] + a | 0, n[3] = n[3] + o | 0, n[4] = n[4] + f | 0;
  }
};
const UD = {};
UD.aes = class {
  constructor(t3) {
    const e = this;
    e._tables = [[[], [], [], [], []], [[], [], [], [], []]], e._tables[0][0][0] || e._precompute();
    const n = e._tables[0][4], r = e._tables[1], s = t3.length;
    let i, a, o, f = 1;
    if (s !== 4 && s !== 6 && s !== 8) throw new Error("invalid aes key size");
    for (e._key = [a = t3.slice(0), o = []], i = s; i < 4 * s + 28; i++) {
      let c = a[i - 1];
      (i % s === 0 || s === 8 && i % s === 4) && (c = n[c >>> 24] << 24 ^ n[c >> 16 & 255] << 16 ^ n[c >> 8 & 255] << 8 ^ n[c & 255], i % s === 0 && (c = c << 8 ^ c >>> 24 ^ f << 24, f = f << 1 ^ (f >> 7) * 283)), a[i] = a[i - s] ^ c;
    }
    for (let c = 0; i; c++, i--) {
      const l = a[c & 3 ? i : i - 4];
      i <= 4 || c < 4 ? o[c] = l : o[c] = r[0][n[l >>> 24]] ^ r[1][n[l >> 16 & 255]] ^ r[2][n[l >> 8 & 255]] ^ r[3][n[l & 255]];
    }
  }
  encrypt(t3) {
    return this._crypt(t3, 0);
  }
  decrypt(t3) {
    return this._crypt(t3, 1);
  }
  _precompute() {
    const t3 = this._tables[0], e = this._tables[1], n = t3[4], r = e[4], s = [], i = [];
    let a, o, f, c;
    for (let l = 0; l < 256; l++) i[(s[l] = l << 1 ^ (l >> 7) * 283) ^ l] = l;
    for (let l = a = 0; !n[l]; l ^= o || 1, a = i[a] || 1) {
      let h = a ^ a << 1 ^ a << 2 ^ a << 3 ^ a << 4;
      h = h >> 8 ^ h & 255 ^ 99, n[l] = h, r[h] = l, c = s[f = s[o = s[l]]];
      let m = c * 16843009 ^ f * 65537 ^ o * 257 ^ l * 16843008, v = s[h] * 257 ^ h * 16843008;
      for (let b = 0; b < 4; b++) t3[b][l] = v = v << 24 ^ v >>> 8, e[b][h] = m = m << 24 ^ m >>> 8;
    }
    for (let l = 0; l < 5; l++) t3[l] = t3[l].slice(0), e[l] = e[l].slice(0);
  }
  _crypt(t3, e) {
    if (t3.length !== 4) throw new Error("invalid aes block size");
    const n = this._key[e], r = n.length / 4 - 2, s = [0, 0, 0, 0], i = this._tables[e], a = i[0], o = i[1], f = i[2], c = i[3], l = i[4];
    let h = t3[0] ^ n[0], m = t3[e ? 3 : 1] ^ n[1], v = t3[2] ^ n[2], b = t3[e ? 1 : 3] ^ n[3], A = 4, _, C, I;
    for (let S = 0; S < r; S++) _ = a[h >>> 24] ^ o[m >> 16 & 255] ^ f[v >> 8 & 255] ^ c[b & 255] ^ n[A], C = a[m >>> 24] ^ o[v >> 16 & 255] ^ f[b >> 8 & 255] ^ c[h & 255] ^ n[A + 1], I = a[v >>> 24] ^ o[b >> 16 & 255] ^ f[h >> 8 & 255] ^ c[m & 255] ^ n[A + 2], b = a[b >>> 24] ^ o[h >> 16 & 255] ^ f[m >> 8 & 255] ^ c[v & 255] ^ n[A + 3], A += 4, h = _, m = C, v = I;
    for (let S = 0; S < 4; S++) s[e ? 3 & -S : S] = l[h >>> 24] << 24 ^ l[m >> 16 & 255] << 16 ^ l[v >> 8 & 255] << 8 ^ l[b & 255] ^ n[A++], _ = h, h = m, m = v, v = b, b = _;
    return s;
  }
};
const $ae = { getRandomValues(t3) {
  const e = new Uint32Array(t3.buffer), n = (r) => {
    let s = 987654321;
    const i = 4294967295;
    return function() {
      return s = 36969 * (s & 65535) + (s >> 16) & i, r = 18e3 * (r & 65535) + (r >> 16) & i, (((s << 16) + r & i) / 4294967296 + 0.5) * (Math.random() > 0.5 ? 1 : -1);
    };
  };
  for (let r = 0, s; r < t3.length; r += 4) {
    const i = n((s || Math.random()) * 4294967296);
    s = i() * 987654071, e[r / 4] = i() * 4294967296 | 0;
  }
  return t3;
} }, LD = {};
LD.ctrGladman = class {
  constructor(t3, e) {
    this._prf = t3, this._initIv = e, this._iv = e;
  }
  reset() {
    this._iv = this._initIv;
  }
  update(t3) {
    return this.calculate(this._prf, t3, this._iv);
  }
  incWord(t3) {
    if ((t3 >> 24 & 255) === 255) {
      let e = t3 >> 16 & 255, n = t3 >> 8 & 255, r = t3 & 255;
      e === 255 ? (e = 0, n === 255 ? (n = 0, r === 255 ? r = 0 : ++r) : ++n) : ++e, t3 = 0, t3 += e << 16, t3 += n << 8, t3 += r;
    } else t3 += 1 << 24;
    return t3;
  }
  incCounter(t3) {
    (t3[0] = this.incWord(t3[0])) === 0 && (t3[1] = this.incWord(t3[1]));
  }
  calculate(t3, e, n) {
    let r;
    if (!(r = e.length)) return [];
    const s = cs.bitLength(e);
    for (let i = 0; i < r; i += 4) {
      this.incCounter(n);
      const a = t3.encrypt(n);
      e[i] ^= a[0], e[i + 1] ^= a[1], e[i + 2] ^= a[2], e[i + 3] ^= a[3];
    }
    return cs.clamp(e, s);
  }
};
const h0 = { importKey(t3) {
  return new h0.hmacSha1(W1.bytes.toBits(t3));
}, pbkdf2(t3, e, n, r) {
  if (n = n || 1e4, r < 0 || n < 0) throw new Error("invalid params to pbkdf2");
  const s = (r >> 5) + 1 << 2;
  let i, a, o, f, c;
  const l = new ArrayBuffer(s), h = new DataView(l);
  let m = 0;
  const v = cs;
  for (e = W1.bytes.toBits(e), c = 1; m < (s || 1); c++) {
    for (i = a = t3.encrypt(v.concat(e, [c])), o = 1; o < n; o++) for (a = t3.encrypt(a), f = 0; f < a.length; f++) i[f] ^= a[f];
    for (o = 0; m < (s || 1) && o < i.length; o++) h.setInt32(m, i[o]), m += 4;
  }
  return l.slice(0, r / 8);
} };
h0.hmacSha1 = class {
  constructor(t3) {
    const e = this, n = e._hash = ND.sha1, r = [[], []];
    e._baseHash = [new n(), new n()];
    const s = e._baseHash[0].blockSize / 32;
    t3.length > s && (t3 = new n().update(t3).finalize());
    for (let i = 0; i < s; i++) r[0][i] = t3[i] ^ 909522486, r[1][i] = t3[i] ^ 1549556828;
    e._baseHash[0].update(r[0]), e._baseHash[1].update(r[1]), e._resultHash = new n(e._baseHash[0]);
  }
  reset() {
    const t3 = this;
    t3._resultHash = new t3._hash(t3._baseHash[0]), t3._updated = false;
  }
  update(t3) {
    const e = this;
    e._updated = true, e._resultHash.update(t3);
  }
  digest() {
    const t3 = this, e = t3._resultHash.finalize(), n = new t3._hash(t3._baseHash[1]).update(e).finalize();
    return t3.reset(), n;
  }
  encrypt(t3) {
    if (this._updated) throw new Error("encrypt on already updated hmac called!");
    return this.update(t3), this.digest(t3);
  }
};
const Tae = typeof crypto != ll && typeof crypto.getRandomValues == E0, OD = "Invalid password", QD = "Invalid signature", C4 = "zipjs-abort-check-password";
function KD(t3) {
  return Tae ? crypto.getRandomValues(t3) : $ae.getRandomValues(t3);
}
const su = 16, Dae = "raw", HD = { name: "PBKDF2" }, Rae = { name: "HMAC" }, Fae = "SHA-1", Pae = Object.assign({ hash: Rae }, HD), kb = Object.assign({ iterations: 1e3, hash: { name: Fae } }, HD), Nae = ["deriveBits"], Lh = [8, 12, 16], Pc = [16, 24, 32], Pf = 10, Uae = [0, 0, 0, 0], vm = typeof crypto != ll, Md = vm && crypto.subtle, qD = vm && typeof Md != ll, wo = W1.bytes, Lae = UD.aes, Oae = LD.ctrGladman, Qae = h0.hmacSha1;
let IE = vm && qD && typeof Md.importKey == E0, SE = vm && qD && typeof Md.deriveBits == E0;
class Kae extends TransformStream {
  constructor({ password: e, rawPassword: n, signed: r, encryptionStrength: s, checkPasswordOnly: i }) {
    super({ start() {
      Object.assign(this, { ready: new Promise((a) => this.resolveReady = a), password: VD(e, n), signed: r, strength: s - 1, pending: new Uint8Array() });
    }, async transform(a, o) {
      const f = this, { password: c, strength: l, resolveReady: h, ready: m } = f;
      c ? (await qae(f, l, c, ea(a, 0, Lh[l] + 2)), a = ea(a, Lh[l] + 2), i ? o.error(new Error(C4)) : h()) : await m;
      const v = new Uint8Array(a.length - Pf - (a.length - Pf) % su);
      o.enqueue(zD(f, a, v, 0, Pf, true));
    }, async flush(a) {
      const { signed: o, ctr: f, hmac: c, pending: l, ready: h } = this;
      if (c && f) {
        await h;
        const m = ea(l, 0, l.length - Pf), v = ea(l, l.length - Pf);
        let b = new Uint8Array();
        if (m.length) {
          const A = Qh(wo, m);
          c.update(A);
          const _ = f.update(A);
          b = Oh(wo, _);
        }
        if (o) {
          const A = ea(Oh(wo, c.digest()), 0, Pf);
          for (let _ = 0; _ < Pf; _++) if (A[_] != v[_]) throw new Error(QD);
        }
        a.enqueue(b);
      }
    } });
  }
}
class Hae extends TransformStream {
  constructor({ password: e, rawPassword: n, encryptionStrength: r }) {
    let s;
    super({ start() {
      Object.assign(this, { ready: new Promise((i) => this.resolveReady = i), password: VD(e, n), strength: r - 1, pending: new Uint8Array() });
    }, async transform(i, a) {
      const o = this, { password: f, strength: c, resolveReady: l, ready: h } = o;
      let m = new Uint8Array();
      f ? (m = await zae(o, c, f), l()) : await h;
      const v = new Uint8Array(m.length + i.length - i.length % su);
      v.set(m, 0), a.enqueue(zD(o, i, v, m.length, 0));
    }, async flush(i) {
      const { ctr: a, hmac: o, pending: f, ready: c } = this;
      if (o && a) {
        await c;
        let l = new Uint8Array();
        if (f.length) {
          const h = a.update(Qh(wo, f));
          o.update(h), l = Oh(wo, h);
        }
        s.signature = Oh(wo, o.digest()).slice(0, Pf), i.enqueue(k4(l, s.signature));
      }
    } }), s = this;
  }
}
function zD(t3, e, n, r, s, i) {
  const { ctr: a, hmac: o, pending: f } = t3, c = e.length - s;
  f.length && (e = k4(f, e), n = Yae(n, c - c % su));
  let l;
  for (l = 0; l <= c - su; l += su) {
    const h = Qh(wo, ea(e, l, l + su));
    i && o.update(h);
    const m = a.update(h);
    i || o.update(m), n.set(Oh(wo, m), l + r);
  }
  return t3.pending = ea(e, l), n;
}
async function qae(t3, e, n, r) {
  const s = await GD(t3, e, n, ea(r, 0, Lh[e])), i = ea(r, Lh[e]);
  if (s[0] != i[0] || s[1] != i[1]) throw new Error(OD);
}
async function zae(t3, e, n) {
  const r = KD(new Uint8Array(Lh[e])), s = await GD(t3, e, n, r);
  return k4(r, s);
}
async function GD(t3, e, n, r) {
  t3.password = null;
  const s = await Gae(Dae, n, Pae, false, Nae), i = await Vae(Object.assign({ salt: r }, kb), s, 8 * (Pc[e] * 2 + 2)), a = new Uint8Array(i), o = Qh(wo, ea(a, 0, Pc[e])), f = Qh(wo, ea(a, Pc[e], Pc[e] * 2)), c = ea(a, Pc[e] * 2);
  return Object.assign(t3, { keys: { key: o, authentication: f, passwordVerification: c }, ctr: new Oae(new Lae(o), Array.from(Uae)), hmac: new Qae(f) }), c;
}
async function Gae(t3, e, n, r, s) {
  if (IE) try {
    return await Md.importKey(t3, e, n, r, s);
  } catch {
    return IE = false, h0.importKey(e);
  }
  else return h0.importKey(e);
}
async function Vae(t3, e, n) {
  if (SE) try {
    return await Md.deriveBits(t3, e, n);
  } catch {
    return SE = false, h0.pbkdf2(e, t3.salt, kb.iterations, n);
  }
  else return h0.pbkdf2(e, t3.salt, kb.iterations, n);
}
function VD(t3, e) {
  return e === lr ? Yp(t3) : e;
}
function k4(t3, e) {
  let n = t3;
  return t3.length + e.length && (n = new Uint8Array(t3.length + e.length), n.set(t3, 0), n.set(e, t3.length)), n;
}
function Yae(t3, e) {
  if (e && e > t3.length) {
    const n = t3;
    t3 = new Uint8Array(e), t3.set(n, 0);
  }
  return t3;
}
function ea(t3, e, n) {
  return t3.subarray(e, n);
}
function Oh(t3, e) {
  return t3.fromBits(e);
}
function Qh(t3, e) {
  return t3.toBits(e);
}
const mh = 12;
class Wae extends TransformStream {
  constructor({ password: e, passwordVerification: n, checkPasswordOnly: r }) {
    super({ start() {
      Object.assign(this, { password: e, passwordVerification: n }), YD(this, e);
    }, transform(s, i) {
      const a = this;
      if (a.password) {
        const o = ME(a, s.subarray(0, mh));
        if (a.password = null, o.at(-1) != a.passwordVerification) throw new Error(OD);
        s = s.subarray(mh);
      }
      r ? i.error(new Error(C4)) : i.enqueue(ME(a, s));
    } });
  }
}
class Jae extends TransformStream {
  constructor({ password: e, passwordVerification: n }) {
    super({ start() {
      Object.assign(this, { password: e, passwordVerification: n }), YD(this, e);
    }, transform(r, s) {
      const i = this;
      let a, o;
      if (i.password) {
        i.password = null;
        const f = KD(new Uint8Array(mh));
        f[mh - 1] = i.passwordVerification, a = new Uint8Array(r.length + f.length), a.set($E(i, f), 0), o = mh;
      } else a = new Uint8Array(r.length), o = 0;
      a.set($E(i, r), o), s.enqueue(a);
    } });
  }
}
function ME(t3, e) {
  const n = new Uint8Array(e.length);
  for (let r = 0; r < e.length; r++) n[r] = WD(t3) ^ e[r], I4(t3, n[r]);
  return n;
}
function $E(t3, e) {
  const n = new Uint8Array(e.length);
  for (let r = 0; r < e.length; r++) n[r] = WD(t3) ^ e[r], I4(t3, e[r]);
  return n;
}
function YD(t3, e) {
  const n = [305419896, 591751049, 878082192];
  Object.assign(t3, { keys: n, crcKey0: new Y1(n[0]), crcKey2: new Y1(n[2]) });
  for (let r = 0; r < e.length; r++) I4(t3, e.charCodeAt(r));
}
function I4(t3, e) {
  let [n, r, s] = t3.keys;
  t3.crcKey0.append([e]), n = ~t3.crcKey0.get(), r = TE(Math.imul(TE(r + JD(n)), 134775813) + 1), t3.crcKey2.append([r >>> 24]), s = ~t3.crcKey2.get(), t3.keys = [n, r, s];
}
function WD(t3) {
  const e = t3.keys[2] | 2;
  return JD(Math.imul(e, e ^ 1) >>> 8);
}
function JD(t3) {
  return t3 & 255;
}
function TE(t3) {
  return t3 & 4294967295;
}
const ZD = "Invalid uncompressed size", Zae = "deflate-raw", jae = "deflate64-raw";
class Xae extends TransformStream {
  constructor(e, { chunkSize: n, CompressionStreamZlib: r, CompressionStream: s }) {
    super({});
    const { compressed: i, encrypted: a, useCompressionStream: o, zipCrypto: f, signed: c, level: l } = e, h = this;
    let m, v, b = super.readable;
    (!a || f) && c && (m = new PD(), b = xo(b, m)), i && (b = XD(b, o, { level: l, chunkSize: n }, s, r, s)), a && (f ? b = xo(b, new Jae(e)) : (v = new Hae(e), b = xo(b, v))), jD(h, b, () => {
      let A;
      a && !f && (A = v.signature), (!a || f) && c && (A = new DataView(m.value.buffer).getUint32(0)), h.signature = A;
    });
  }
}
class eoe extends TransformStream {
  constructor(e, { chunkSize: n, DecompressionStreamZlib: r, DecompressionStream: s }) {
    super({});
    const { zipCrypto: i, encrypted: a, signed: o, signature: f, compressed: c, useCompressionStream: l, deflate64: h } = e;
    let m, v, b = super.readable;
    a && (i ? b = xo(b, new Wae(e)) : (v = new Kae(e), b = xo(b, v))), c && (b = XD(b, l, { chunkSize: n, deflate64: h }, s, r, s)), (!a || i) && o && (m = new PD(), b = xo(b, m)), jD(this, b, () => {
      if ((!a || i) && o) {
        const A = new DataView(m.value.buffer);
        if (f != A.getUint32(0, false)) throw new Error(QD);
      }
    });
  }
}
function jD(t3, e, n) {
  e = xo(e, new TransformStream({ flush: n })), Object.defineProperty(t3, "readable", { get() {
    return e;
  } });
}
function XD(t3, e, n, r, s, i) {
  const a = e && r ? r : s || i, o = n.deflate64 ? jae : Zae;
  try {
    t3 = xo(t3, new a(o, n));
  } catch (f) {
    if (e) if (s) t3 = xo(t3, new s(o, n));
    else if (i) t3 = xo(t3, new i(o, n));
    else throw f;
    else throw f;
  }
  return t3;
}
function xo(t3, e) {
  return t3.pipeThrough(e);
}
const toe = "message", roe = "start", noe = "pull", DE = "data", ioe = "ack", RE = "close", eR = "deflate", tR = "inflate";
class soe extends TransformStream {
  constructor(e, n) {
    super({});
    const r = this, { codecType: s } = e;
    let i;
    s.startsWith(eR) ? i = Xae : s.startsWith(tR) && (i = eoe), r.outputSize = 0;
    let a = 0;
    const o = new i(e, n), f = super.readable, c = new TransformStream({ transform(h, m) {
      h && h.length && (a += h.length, m.enqueue(h));
    }, flush() {
      Object.assign(r, { inputSize: a });
    } }), l = new TransformStream({ transform(h, m) {
      if (h && h.length && (m.enqueue(h), r.outputSize += h.length, e.outputSize !== lr && r.outputSize > e.outputSize)) throw new Error(ZD);
    }, flush() {
      const { signature: h } = o;
      Object.assign(r, { signature: h, inputSize: a });
    } });
    Object.defineProperty(r, "readable", { get() {
      return f.pipeThrough(c).pipeThrough(o).pipeThrough(l);
    } });
  }
}
class aoe extends TransformStream {
  constructor(e) {
    let n;
    super({ transform: r, flush(s) {
      n && n.length && s.enqueue(n);
    } });
    function r(s, i) {
      if (n) {
        const a = new Uint8Array(n.length + s.length);
        a.set(n), a.set(s, n.length), s = a, n = null;
      }
      s.length > e ? (i.enqueue(s.slice(0, e)), r(s.slice(e), i)) : n = s;
    }
  }
}
let rR = typeof Worker != ll, nR = () => {
};
function ooe({ initModule: t3 }) {
  nR = t3;
}
class ny {
  constructor(e, { readable: n, writable: r }, { options: s, config: i, streamOptions: a, useWebWorkers: o, transferStreams: f, workerURI: c }, l) {
    const { signal: h } = a;
    return Object.assign(e, { busy: true, readable: n.pipeThrough(new aoe(i.chunkSize)).pipeThrough(new foe(a), { signal: h }), writable: r, options: Object.assign({}, s), workerURI: c, transferStreams: f, terminate() {
      return new Promise((m) => {
        const { worker: v, busy: b } = e;
        v ? (b ? e.resolveTerminated = m : (v.terminate(), m()), e.interface = null) : m();
      });
    }, onTaskFinished() {
      const { resolveTerminated: m } = e;
      m && (e.resolveTerminated = null, e.terminated = true, e.worker.terminate(), m()), e.busy = false, l(e);
    } }), (o && rR ? loe : iR)(e, i);
  }
}
class foe extends TransformStream {
  constructor({ onstart: e, onprogress: n, size: r, onend: s }) {
    let i = 0;
    super({ async start() {
      e && await iy(e, r);
    }, async transform(a, o) {
      i += a.length, n && await iy(n, i, r), o.enqueue(a);
    }, async flush() {
      s && await iy(s, i);
    } });
  }
}
async function iy(t3, ...e) {
  try {
    await t3(...e);
  } catch {
  }
}
function iR(t3, e) {
  return { run: () => uoe(t3, e) };
}
function loe(t3, e) {
  const { baseURI: n, chunkSize: r } = e;
  let { wasmURI: s } = e;
  if (!t3.interface) {
    typeof s == E0 && (s = s());
    let i;
    try {
      i = doe(t3.workerURI, n, t3);
    } catch {
      return rR = false, iR(t3, e);
    }
    Object.assign(t3, { worker: i, interface: { run: () => coe(t3, { chunkSize: r, wasmURI: s, baseURI: n }) } });
  }
  return t3.interface;
}
async function uoe({ options: t3, readable: e, writable: n, onTaskFinished: r }, s) {
  let i;
  try {
    if (!t3.useCompressionStream) try {
      await nR(s);
    } catch {
      t3.useCompressionStream = true;
    }
    i = new soe(t3, s), await e.pipeThrough(i).pipeTo(n, { preventClose: true, preventAbort: true });
    const { signature: a, inputSize: o, outputSize: f } = i;
    return { signature: a, inputSize: o, outputSize: f };
  } catch (a) {
    throw i && (a.outputSize = i.outputSize), a;
  } finally {
    r();
  }
}
async function coe(t3, e) {
  let n, r;
  const s = new Promise((h, m) => {
    n = h, r = m;
  });
  Object.assign(t3, { reader: null, writer: null, resolveResult: n, rejectResult: r, result: s });
  const { readable: i, options: a } = t3, { writable: o, closed: f } = hoe(t3.writable), c = Wp({ type: roe, options: a, config: e, readable: i, writable: o }, t3);
  c || Object.assign(t3, { reader: i.getReader(), writer: o.getWriter() });
  const l = await s;
  return c || await o.getWriter().close(), await f, l;
}
function hoe(t3) {
  let e;
  const n = new Promise((s) => e = s);
  return { writable: new WritableStream({ async write(s) {
    const i = t3.getWriter();
    await i.ready, await i.write(s), i.releaseLock();
  }, close() {
    e();
  }, abort(s) {
    return t3.getWriter().abort(s);
  } }), closed: n };
}
let FE = true;
function doe(t3, e, n) {
  const r = { type: "module" };
  let s, i;
  if (typeof t3 == E0 && (t3 = t3()), t3.startsWith("data:") || t3.startsWith("blob:")) try {
    i = new Worker(t3);
  } catch {
    i = new Worker(t3, r);
  }
  else {
    try {
      s = new URL(t3, e);
    } catch {
      s = t3;
    }
    i = new Worker(s, r);
  }
  return i.addEventListener(toe, (a) => poe(a, n)), i;
}
function Wp(t3, { worker: e, writer: n, onTaskFinished: r, transferStreams: s }) {
  try {
    const { value: i, readable: a, writable: o } = t3, f = [];
    if (i && (t3.value = i, f.push(t3.value.buffer)), s && FE ? (a && f.push(a), o && f.push(o)) : t3.readable = t3.writable = null, f.length) try {
      return e.postMessage(t3, f), true;
    } catch {
      FE = false, t3.readable = t3.writable = null, e.postMessage(t3);
    }
    else e.postMessage(t3);
  } catch (i) {
    throw n && n.releaseLock(), r(), i;
  }
}
async function poe({ data: t3 }, e) {
  const { type: n, value: r, messageId: s, result: i, error: a } = t3, { reader: o, writer: f, resolveResult: c, rejectResult: l, onTaskFinished: h } = e;
  try {
    if (a) {
      const { message: v, stack: b, code: A, name: _, outputSize: C } = a, I = new Error(v);
      Object.assign(I, { stack: b, code: A, name: _, outputSize: C }), m(I);
    } else {
      if (n == noe) {
        const { value: v, done: b } = await o.read();
        Wp({ type: DE, value: v, done: b, messageId: s }, e);
      }
      n == DE && (await f.ready, await f.write(new Uint8Array(r)), Wp({ type: ioe, messageId: s }, e)), n == RE && m(null, i);
    }
  } catch (v) {
    Wp({ type: RE, messageId: s }, e), m(v);
  }
  function m(v, b) {
    v ? l(v) : c(b), f && f.releaseLock(), h();
  }
}
let Ol = [];
const sy = [];
let PE = 0;
async function sR(t3, e) {
  const { options: n, config: r } = e, { transferStreams: s, useWebWorkers: i, useCompressionStream: a, compressed: o, signed: f, encrypted: c } = n, { workerURI: l, maxWorkers: h } = r;
  e.transferStreams = s || s === lr;
  const m = !o && !f && !c && !e.transferStreams;
  return e.useWebWorkers = !m && (i || i === lr && r.useWebWorkers), e.workerURI = e.useWebWorkers && l ? l : lr, n.useCompressionStream = a || a === lr && r.useCompressionStream, (await v()).run();
  async function v() {
    const A = Ol.find((_) => !_.busy);
    if (A) return NE(A), new ny(A, t3, e, b);
    if (Ol.length < h) {
      const _ = { indexWorker: PE };
      return PE++, Ol.push(_), new ny(_, t3, e, b);
    } else return new Promise((_) => sy.push({ resolve: _, stream: t3, workerOptions: e }));
  }
  function b(A) {
    if (sy.length) {
      const [{ resolve: _, stream: C, workerOptions: I }] = sy.splice(0, 1);
      _(new ny(A, C, I, b));
    } else A.worker ? (NE(A), goe(A, e)) : Ol = Ol.filter((_) => _ != A);
  }
}
function goe(t3, e) {
  const { config: n } = e, { terminateWorkerTimeout: r } = n;
  Number.isFinite(r) && r >= 0 && (t3.terminated ? t3.terminated = false : t3.terminateTimeout = setTimeout(async () => {
    Ol = Ol.filter((s) => s != t3);
    try {
      await t3.terminate();
    } catch {
    }
  }, r));
}
function NE(t3) {
  const { terminateTimeout: e } = t3;
  e && (clearTimeout(e), t3.terminateTimeout = null);
}
const moe = "Writer iterator completed too soon", voe = "Content-Type", yoe = 64 * 1024, aR = "writable";
class S4 {
  constructor() {
    this.size = 0;
  }
  init() {
    this.initialized = true;
  }
}
class oR extends S4 {
  get readable() {
    const e = this, { chunkSize: n = yoe } = e, r = new ReadableStream({ start() {
      this.chunkOffset = 0;
    }, async pull(s) {
      const { offset: i = 0, size: a, diskNumberStart: o } = r, { chunkOffset: f } = this, c = a === lr ? n : Math.min(n, a - f), l = await $i(e, i + f, c, o);
      s.enqueue(l), f + n > a || a === lr && !l.length && c ? s.close() : this.chunkOffset += n;
    } });
    return r;
  }
}
class fR extends oR {
  constructor(e) {
    super(), Object.assign(this, { blob: e, size: e.size });
  }
  async readUint8Array(e, n) {
    const r = this, s = e + n;
    let a = await (e || s < r.size ? r.blob.slice(e, s) : r.blob).arrayBuffer();
    return a.byteLength > n && (a = a.slice(e, s)), new Uint8Array(a);
  }
}
class boe extends S4 {
  constructor(e) {
    super();
    const n = this, r = new TransformStream(), s = [];
    e && s.push([voe, e]), Object.defineProperty(n, aR, { get() {
      return r.writable;
    } }), n.blob = new Response(r.readable, { headers: s }).blob();
  }
  getData() {
    return this.blob;
  }
}
class Aoe extends oR {
  constructor(e) {
    super(), this.readers = e;
  }
  async init() {
    const e = this, { readers: n } = e;
    e.lastDiskNumber = 0, e.lastDiskOffset = 0, await Promise.all(n.map(async (r, s) => {
      await r.init(), s != n.length - 1 && (e.lastDiskOffset += r.size), e.size += r.size;
    })), super.init();
  }
  async readUint8Array(e, n, r = 0) {
    const s = this, { readers: i } = this;
    let a, o = r;
    o == -1 && (o = i.length - 1);
    let f = e;
    for (; i[o] && f >= i[o].size; ) f -= i[o].size, o++;
    const c = i[o];
    if (c) {
      const l = c.size;
      if (f + n <= l) a = await $i(c, f, n);
      else {
        const h = l - f;
        a = new Uint8Array(n);
        const m = await $i(c, f, h);
        a.set(m, 0);
        const v = await s.readUint8Array(e + h, n - h, r);
        a.set(v, h), m.length + v.length < n && (a = a.subarray(0, m.length + v.length));
      }
    } else a = new Uint8Array();
    return s.lastDiskNumber = Math.max(o, s.lastDiskNumber), a;
  }
}
class UE extends S4 {
  constructor(e, n = 4294967295) {
    super();
    const r = this;
    Object.assign(r, { diskNumber: 0, diskOffset: 0, size: 0, maxSize: n, availableSize: n });
    let s, i, a;
    const o = new WritableStream({ async write(l) {
      const { availableSize: h } = r;
      if (a) l.length >= h ? (await f(l.subarray(0, h)), await c(), r.diskOffset += s.size, r.diskNumber++, a = null, await this.write(l.subarray(h))) : await f(l);
      else {
        const { value: m, done: v } = await e.next();
        if (v && !m) throw new Error(moe);
        s = m, s.size = 0, s.maxSize && (r.maxSize = s.maxSize), r.availableSize = r.maxSize, await ul(s), i = m.writable, a = i.getWriter(), await this.write(l);
      }
    }, async close() {
      await a.ready, await c();
    } });
    Object.defineProperty(r, aR, { get() {
      return o;
    } });
    async function f(l) {
      const h = l.length;
      h && (await a.ready, await a.write(l), s.size += h, r.size += h, r.availableSize -= h);
    }
    async function c() {
      await a.close();
    }
  }
}
class M4 {
  constructor(e) {
    return Array.isArray(e) && (e = new Aoe(e)), e instanceof ReadableStream && (e = { readable: e }), e;
  }
}
class lR {
  constructor(e) {
    return e.writable === lr && typeof e.next == E0 && (e = new UE(e)), e instanceof WritableStream && (e = { writable: e }), e.size === lr && (e.size = 0), e instanceof UE || Object.assign(e, { diskNumber: 0, diskOffset: 0, availableSize: 1 / 0, maxSize: 1 / 0 }), e;
  }
}
async function ul(t3, e) {
  if (t3.init && !t3.initialized) await t3.init(e);
  else return Promise.resolve();
}
function $i(t3, e, n, r) {
  return t3.readUint8Array(e, n, r);
}
const uR = "\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0 ".split(""), woe = uR.length == 256;
function xoe(t3) {
  if (woe) {
    let e = "";
    for (let n = 0; n < t3.length; n++) e += uR[t3[n]];
    return e;
  } else return new TextDecoder().decode(t3);
}
function Jp(t3, e) {
  return e && e.trim().toLowerCase() == "cp437" ? xoe(t3) : new TextDecoder(e).decode(t3);
}
const cR = "filename", hR = "rawFilename", $4 = "comment", dR = "rawComment", T4 = "uncompressedSize", pR = "compressedSize", gR = "offset", mR = "diskNumberStart", J1 = "lastModDate", Ib = "rawLastModDate", D4 = "lastAccessDate", _oe = "rawLastAccessDate", R4 = "creationDate", vR = "rawCreationDate", yR = "internalFileAttributes", bR = "externalFileAttributes", AR = "msdosAttributesRaw", wR = "msdosAttributes", xR = "msDosCompatible", F4 = "zip64", _R = "encrypted", ER = "version", BR = "versionMadeBy", CR = "zipCrypto", Zp = "directory", kR = "executable", IR = "compressionMethod", SR = "signature", MR = "extraField", Eoe = "extraFieldInfoZip", Boe = "extraFieldUnix", $R = "uid", TR = "gid", DR = "unixMode", RR = "setuid", FR = "setgid", PR = "sticky", Coe = "bitFlag", koe = "filenameUTF8", Ioe = "commentUTF8", Soe = "rawExtraField", Moe = "extraFieldZip64", $oe = "extraFieldUnicodePath", Toe = "extraFieldUnicodeComment", Doe = "extraFieldAES", Roe = "extraFieldNTFS", Foe = "extraFieldExtendedTimestamp", Poe = [cR, hR, T4, pR, J1, Ib, $4, dR, D4, R4, vR, gR, mR, yR, bR, AR, wR, xR, F4, _R, ER, BR, CR, Zp, kR, IR, SR, MR, Boe, Eoe, $R, TR, DR, RR, FR, PR, Coe, koe, Ioe, Soe, Moe, $oe, Toe, Doe, Roe, Foe];
class Z1 {
  constructor(e) {
    Poe.forEach((n) => this[n] = e[n]);
  }
}
const Noe = "filenameEncoding", Uoe = "commentEncoding", Loe = "decodeText", Ooe = "extractPrependedData", Qoe = "extractAppendedData", NR = "password", UR = "rawPassword", LR = "passThrough", OR = "signal", Koe = "checkPasswordOnly", Hoe = "checkOverlappingEntryOnly", qoe = "checkOverlappingEntry", zoe = "checkSignature", QR = "useWebWorkers", KR = "useCompressionStream", Goe = "transferStreams", HR = "preventClose", Voe = "encryptionStrength", Yoe = "extendedTimestamp", Woe = "keepOrder", Joe = "level", Zoe = "bufferedWrite", joe = "dataDescriptorSignature", Xoe = "useUnicodeFileNames", efe = "dataDescriptor", qR = "supportZip64SplitFile", tfe = "encodeText", LE = "offset", zR = "usdz", rfe = "unixExtraFieldType", ay = "File format is not recognized", nfe = "End of central directory not found", ife = "End of Zip64 central directory locator not found", sfe = "Central directory header not found", afe = "Local file header not found", ofe = "Zip64 extra field not found", ffe = "File contains encrypted entry", lfe = "Encryption method not supported", OE = "Compression method not supported", QE = "Split zip file", ufe = "Overlapping entry found", KE = "utf-8", cfe = "UTF8", HE = "cp437", hfe = [[T4, kn], [pR, kn], [gR, kn], [mR, an]], dfe = { [an]: { getValue: _n, bytes: 4 }, [kn]: { getValue: pu, bytes: 8 } };
class pfe {
  constructor(e, n = {}) {
    Object.assign(this, { reader: new M4(e), options: n, config: DD(), readRanges: [] });
  }
  async *getEntriesGenerator(e = {}) {
    const n = this;
    let { reader: r } = n;
    const { config: s } = n;
    if (await ul(r), (r.size === lr || !r.readUint8Array) && (r = new fR(await new Response(r.readable).blob()), await ul(r)), r.size < Yo) throw new Error(ay);
    r.chunkSize = RD(s);
    const i = await wfe(r, AD, r.size, Yo, an * 16);
    if (!i) {
      const L = await $i(r, 0, 4), B = Bn(L);
      throw _n(B) == _4 ? new Error(QE) : new Error(nfe);
    }
    const a = Bn(i);
    let o = _n(a, 12), f = _n(a, 16);
    const c = i.offset, l = Ai(a, 20), h = c + Yo + l;
    let m = Ai(a, 4);
    const v = r.lastDiskNumber || 0;
    let b = Ai(a, 6), A = Ai(a, 8), _ = 0, C = 0;
    if (f == kn || o == kn || A == an || b == an) {
      const L = await $i(r, i.offset - hh, hh), B = Bn(L);
      if (_n(B, 0) == wD) {
        f = pu(B, 8);
        let u = await $i(r, f, dh, -1), p = Bn(u);
        const d = i.offset - hh - dh;
        if (_n(p, 0) != bb && f != d) {
          const y = f;
          f = d, f > y && (_ = f - y), u = await $i(r, f, dh, -1), p = Bn(u);
        }
        if (_n(p, 0) != bb) throw new Error(ife);
        m == an && (m = _n(p, 16)), b == an && (b = _n(p, 20)), A == an && (A = pu(p, 32)), o == kn && (o = pu(p, 40)), f -= o;
      }
    }
    if (f >= r.size && (_ = r.size - f - o - Yo, f = r.size - o - Yo), v != m) throw new Error(QE);
    if (f < 0) throw new Error(ay);
    let I = 0, S = await $i(r, f, o, b), $ = Bn(S);
    if (o) {
      const L = i.offset - o;
      if (_n($, I) != yb && f != L) {
        const B = f;
        f = L, f > B && (_ += f - B), S = await $i(r, f, o, b), $ = Bn(S);
      }
    }
    const F = i.offset - f - (r.lastDiskOffset || 0);
    if (o != F && F >= 0 && (o = F, S = await $i(r, f, o, b), $ = Bn(S)), f < 0 || f >= r.size) throw new Error(ay);
    const U = Mi(n, e, Noe), Q = Mi(n, e, Uoe);
    for (let L = 0; L < A; L++) {
      const B = new gfe(r, s, n.options);
      if (_n($, I) != yb) throw new Error(sfe);
      GR(B, $, I + 6);
      const u = !!B.bitFlag.languageEncodingFlag, p = I + 46, d = p + B.filenameLength, y = d + B.extraFieldLength, w = Ai($, I + 4), E = w >> 8 == 0, M = w >> 8 == 3, x = S.subarray(p, d), g = Ai($, I + 32), k = y + g, T = S.subarray(y, k), O = u, K = u, Y = _n($, I + 38), J = Y & ho, G = { readOnly: !!(J & _b), hidden: !!(J & Eb), system: !!(J & Bb), directory: !!(J & q1), archive: !!(J & Cb) }, X = _n($, I + 42) + _, ie = Mi(n, e, Loe) || Jp, de = O ? KE : U || HE, se = K ? KE : Q || HE;
      let te = ie(x, de);
      te === lr && (te = Jp(x, de));
      let le = ie(T, se);
      le === lr && (le = Jp(T, se)), Object.assign(B, { versionMadeBy: w, msDosCompatible: E, compressedSize: 0, uncompressedSize: 0, commentLength: g, offset: X, diskNumberStart: Ai($, I + 34), internalFileAttributes: Ai($, I + 36), externalFileAttributes: Y, msdosAttributesRaw: J, msdosAttributes: G, rawFilename: x, filenameUTF8: O, commentUTF8: K, rawExtraField: S.subarray(d, y), rawComment: T, filename: te, comment: le }), C = Math.max(X, C), VR(B, B, $, I + 6);
      const Z = B.externalFileAttributes >> 16 & an;
      B.unixMode === lr && Z & (Gp | gh | ph) && (B.unixMode = Z);
      const ve = !!(B.unixMode & z1), he = !!(B.unixMode & G1), me = !!(B.unixMode & V1), ce = B.unixMode !== lr ? (B.unixMode & gh) != 0 : M && (Z & gh) != 0, ye = B.unixMode !== lr && (B.unixMode & _E) == ph, Oe = (Z & _E) == ph;
      Object.assign(B, { setuid: ve, setgid: he, sticky: me, unixExternalUpper: Z, internalFileAttribute: B.internalFileAttributes, externalFileAttribute: B.externalFileAttributes, executable: ce, directory: ye || Oe || E && G.directory || te.endsWith(Vp) && !B.uncompressedSize, zipCrypto: B.encrypted && !B.extraFieldAES });
      const Se = new Z1(B);
      Se.getData = (Ne, $e) => B.getData(Ne, Se, n.readRanges, $e), Se.arrayBuffer = async (Ne) => {
        const $e = new TransformStream(), [Re] = await Promise.all([new Response($e.readable).arrayBuffer(), B.getData($e, Se, n.readRanges, Ne)]);
        return Re;
      }, I = k;
      const { onprogress: Ce } = e;
      if (Ce) try {
        await Ce(L + 1, A, new Z1(B));
      } catch {
      }
      yield Se;
    }
    const P = Mi(n, e, Ooe), N = Mi(n, e, Qoe);
    return P && (n.prependedData = C > 0 ? await $i(r, 0, C) : new Uint8Array()), n.comment = l ? await $i(r, c + Yo, l) : new Uint8Array(), N && (n.appendedData = h < r.size ? await $i(r, h, r.size - h) : new Uint8Array()), true;
  }
  async getEntries(e = {}) {
    const n = [];
    for await (const r of this.getEntriesGenerator(e)) n.push(r);
    return n;
  }
  async close() {
  }
}
class gfe {
  constructor(e, n, r) {
    Object.assign(this, { reader: e, config: n, options: r });
  }
  async getData(e, n, r, s = {}) {
    const i = this, { reader: a, offset: o, diskNumberStart: f, extraFieldAES: c, extraFieldZip64: l, compressionMethod: h, config: m, bitFlag: v, signature: b, rawLastModDate: A, uncompressedSize: _, compressedSize: C } = i, { dataDescriptor: I } = v, S = n.localDirectory = {}, $ = await $i(a, o, r0, f), F = Bn($);
    let U = Mi(i, s, NR), Q = Mi(i, s, UR);
    const P = Mi(i, s, LR);
    if (U = U && U.length && U, Q = Q && Q.length && Q, c && c.originalCompressionMethod != vD) throw new Error(OE);
    if (h != mD && h != x4 && h != vb && !P) throw new Error(OE);
    if (_n(F, 0) != yD) throw new Error(afe);
    GR(S, F, 4);
    const { extraFieldLength: N, filenameLength: L, lastAccessDate: B, creationDate: u } = S;
    S.rawExtraField = N ? await $i(a, o + r0 + L, N, f) : new Uint8Array(), VR(i, S, F, 4, true), Object.assign(n, { lastAccessDate: B, creationDate: u });
    const p = i.encrypted && S.encrypted && !P, d = p && !c;
    if (P || (n.zipCrypto = d), p) {
      if (!d && c.strength === lr) throw new Error(lfe);
      if (!U && !Q) throw new Error(ffe);
    }
    const y = o + r0 + L + N, w = C, E = a.readable;
    Object.assign(E, { diskNumberStart: f, offset: y, size: w });
    const M = Mi(i, s, OR), x = Mi(i, s, Koe);
    let g = Mi(i, s, qoe);
    const k = Mi(i, s, Hoe);
    k && (g = true);
    const { onstart: T, onprogress: O, onend: K } = s, Y = h == vb;
    let J = Mi(i, s, KR);
    Y && (J = false);
    const G = { options: { codecType: tR, password: U, rawPassword: Q, zipCrypto: d, encryptionStrength: c && c.strength, signed: Mi(i, s, zoe) && !P, passwordVerification: d && (I ? A >>> 8 & ho : b >>> 24 & ho), outputSize: P ? C : _, signature: b, compressed: h != 0 && !P, encrypted: i.encrypted && !P, useWebWorkers: Mi(i, s, QR), useCompressionStream: J, transferStreams: Mi(i, s, Goe), deflate64: Y, checkPasswordOnly: x }, config: m, streamOptions: { signal: M, size: w, onstart: T, onprogress: O, onend: K } };
    g && await Afe({ reader: a, fileEntry: n, offset: o, diskNumberStart: f, signature: b, compressedSize: C, uncompressedSize: _, dataOffset: y, dataDescriptor: I || S.bitFlag.dataDescriptor, extraFieldZip64: l || S.extraFieldZip64, readRanges: r });
    let X;
    try {
      if (!k) {
        x && (e = new WritableStream()), e = new lR(e), await ul(e, P ? C : _), { writable: X } = e;
        const { outputSize: ie } = await sR({ readable: E, writable: X }, G);
        if (e.size += ie, ie != (P ? C : _)) throw new Error(ZD);
      }
    } catch (ie) {
      if (ie.outputSize !== lr && (e.size += ie.outputSize), !x || ie.message != C4) throw ie;
    } finally {
      !Mi(i, s, HR) && X && !X.locked && await X.getWriter().close();
    }
    return x || k ? lr : e.getData ? e.getData() : X;
  }
}
function GR(t3, e, n) {
  const r = t3.rawBitFlag = Ai(e, n + 2), s = (r & Ab) == Ab, i = _n(e, n + 6);
  Object.assign(t3, { encrypted: s, version: Ai(e, n), bitFlag: { level: (r & xae) >> 1, dataDescriptor: (r & wb) == wb, languageEncodingFlag: (r & xb) == xb }, rawLastModDate: i, lastModDate: xfe(i), filenameLength: Ai(e, n + 22), extraFieldLength: Ai(e, n + 24) });
}
function VR(t3, e, n, r, s) {
  const { rawExtraField: i } = e, a = e.extraField = /* @__PURE__ */ new Map(), o = Bn(new Uint8Array(i));
  let f = 0;
  try {
    for (; f < i.length; ) {
      const I = Ai(o, f), S = Ai(o, f + 2);
      a.set(I, { type: I, data: i.slice(f + 4, f + 4 + S) }), f += 4 + S;
    }
  } catch {
  }
  const c = Ai(n, r + 4);
  Object.assign(e, { signature: _n(n, r + B4), compressedSize: _n(n, r + uc), uncompressedSize: _n(n, r + cc) });
  const l = a.get(ED);
  l && (mfe(l, e), e.extraFieldZip64 = l);
  const h = a.get(Aae);
  h && (qE(h, cR, hR, e, t3), e.extraFieldUnicodePath = h);
  const m = a.get(wae);
  m && (qE(m, $4, dR, e, t3), e.extraFieldUnicodeComment = m);
  const v = a.get(BD);
  v ? (vfe(v, e, c), e.extraFieldAES = v) : e.compressionMethod = c;
  const b = a.get(CD);
  b && (yfe(b, e), e.extraFieldNTFS = b);
  const A = a.get(MD);
  if (A) zE(A, e, false), e.extraFieldUnix = A;
  else {
    const I = a.get(SD);
    I && (zE(I, e, true), e.extraFieldInfoZip = I);
  }
  const _ = a.get(E4);
  _ && (bfe(_, e, s), e.extraFieldExtendedTimestamp = _);
  const C = a.get(ID);
  C && (e.extraFieldUSDZ = C);
}
function mfe(t3, e) {
  e.zip64 = true;
  const n = Bn(t3.data), r = hfe.filter(([s, i]) => e[s] == i);
  for (let s = 0, i = 0; s < r.length; s++) {
    const [a, o] = r[s];
    if (e[a] == o) {
      const f = dfe[o];
      e[a] = t3[a] = f.getValue(n, i), i += f.bytes;
    } else if (t3[a]) throw new Error(ofe);
  }
}
function qE(t3, e, n, r, s) {
  const i = Bn(t3.data), a = new Y1();
  a.append(s[n]);
  const o = Bn(new Uint8Array(4));
  o.setUint32(0, a.get(), true);
  const f = _n(i, 1);
  Object.assign(t3, { version: rl(i, 0), [e]: Jp(t3.data.subarray(5)), valid: !s.bitFlag.languageEncodingFlag && f == _n(o, 0) }), t3.valid && (r[e] = t3[e], r[e + cfe] = true);
}
function vfe(t3, e, n) {
  const r = Bn(t3.data), s = rl(r, 4);
  Object.assign(t3, { vendorVersion: rl(r, 0), vendorId: rl(r, 2), strength: s, originalCompressionMethod: n, compressionMethod: Ai(r, 5) }), e.compressionMethod = t3.compressionMethod;
}
function yfe(t3, e) {
  const n = Bn(t3.data);
  let r = 4, s;
  try {
    for (; r < t3.data.length && !s; ) {
      const i = Ai(n, r), a = Ai(n, r + 2);
      i == kD && (s = t3.data.slice(r + 4, r + 4 + a)), r += 4 + a;
    }
  } catch {
  }
  try {
    if (s && s.length == 24) {
      const i = Bn(s), a = i.getBigUint64(0, true), o = i.getBigUint64(8, true), f = i.getBigUint64(16, true);
      Object.assign(t3, { rawLastModDate: a, rawLastAccessDate: o, rawCreationDate: f });
      const c = oy(a), l = oy(o), h = oy(f), m = { lastModDate: c, lastAccessDate: l, creationDate: h };
      Object.assign(t3, m), Object.assign(e, m);
    }
  } catch {
  }
}
function zE(t3, e, n) {
  try {
    const r = Bn(new Uint8Array(t3.data));
    let s = 0;
    const i = rl(r, s++), a = rl(r, s++), o = t3.data.subarray(s, s + a);
    s += a;
    const f = GE(o), c = rl(r, s++), l = t3.data.subarray(s, s + c);
    s += c;
    const h = GE(l);
    let m = lr;
    if (!n && s + 2 <= t3.data.length) {
      const v = t3.data;
      m = new DataView(v.buffer, v.byteOffset + s, 2).getUint16(0, true);
    }
    Object.assign(t3, { version: i, uid: f, gid: h, unixMode: m }), f !== lr && (e.uid = f), h !== lr && (e.gid = h), m !== lr && (e.unixMode = m);
  } catch {
  }
}
function GE(t3) {
  const e = new Uint8Array(4);
  return e.set(t3, 0), new DataView(e.buffer, e.byteOffset, 4).getUint32(0, true);
}
function bfe(t3, e, n) {
  const r = Bn(t3.data), s = rl(r, 0), i = [], a = [];
  n ? ((s & 1) == 1 && (i.push(J1), a.push(Ib)), (s & 2) == 2 && (i.push(D4), a.push(_oe)), (s & 4) == 4 && (i.push(R4), a.push(vR))) : t3.data.length >= 5 && (i.push(J1), a.push(Ib));
  let o = 1;
  i.forEach((f, c) => {
    if (t3.data.length >= o + 4) {
      const l = _n(r, o);
      e[f] = t3[f] = new Date(l * 1e3);
      const h = a[c];
      t3[h] = l;
    }
    o += 4;
  });
}
async function Afe({ reader: t3, fileEntry: e, offset: n, diskNumberStart: r, signature: s, compressedSize: i, uncompressedSize: a, dataOffset: o, dataDescriptor: f, extraFieldZip64: c, readRanges: l }) {
  let h = 0;
  if (r) for (let b = 0; b < r; b++) {
    const A = t3.readers[b];
    h += A.size;
  }
  let m = 0;
  if (f && (c ? m = _D : m = xD), m) {
    const b = await $i(t3, o + i, m + H1, r);
    if (_n(Bn(b), 0) == bD) {
      const _ = _n(Bn(b), 4);
      let C, I;
      c ? (C = pu(Bn(b), 8), I = pu(Bn(b), 16)) : (C = _n(Bn(b), 8), I = _n(Bn(b), 12)), (e.encrypted && !e.zipCrypto || _ == s) && C == i && I == a && (m += H1);
    }
  }
  const v = { start: h + n, end: h + o + i + m, fileEntry: e };
  for (const b of l) if (b.fileEntry != e && v.start >= b.start && v.start < b.end) {
    const A = new Error(ufe);
    throw A.overlappingEntry = b.fileEntry, A;
  }
  l.push(v);
}
async function wfe(t3, e, n, r, s) {
  const i = new Uint8Array(4), a = Bn(i);
  _fe(a, 0, e);
  const o = r + s;
  return await f(r) || await f(Math.min(o, n));
  async function f(c) {
    const l = n - c, h = await $i(t3, l, c);
    for (let m = h.length - r; m >= 0; m--) if (h[m] == i[0] && h[m + 1] == i[1] && h[m + 2] == i[2] && h[m + 3] == i[3]) return { offset: l + m, buffer: h.slice(m, m + r).buffer };
  }
}
function Mi(t3, e, n) {
  return e[n] === lr ? t3.options[n] : e[n];
}
function xfe(t3) {
  const e = (t3 & 4294901760) >> 16, n = t3 & an;
  try {
    return new Date(1980 + ((e & 65024) >> 9), ((e & 480) >> 5) - 1, e & 31, (n & 63488) >> 11, (n & 2016) >> 5, (n & 31) * 2, 0);
  } catch {
  }
}
function oy(t3) {
  return new Date(Number(t3 / BigInt(1e4) - BigInt(116444736e5)));
}
function rl(t3, e) {
  return t3.getUint8(e);
}
function Ai(t3, e) {
  return t3.getUint16(e, true);
}
function _n(t3, e) {
  return t3.getUint32(e, true);
}
function pu(t3, e) {
  return Number(t3.getBigUint64(e, true));
}
function _fe(t3, e, n) {
  t3.setUint32(e, n, true);
}
function Bn(t3) {
  return new DataView(t3.buffer);
}
const Efe = "File already exists", Bfe = "Zip file comment exceeds 64KB", Cfe = "File entry comment exceeds 64KB", kfe = "File entry name exceeds 64KB", VE = "Version exceeds 65535", Ife = "The strength must equal 1, 2, or 3", Sfe = "Extra field type exceeds 65535", Mfe = "Extra field data exceeds 64KB", P4 = "Zip64 is not supported (make sure 'keepOrder' is set to 'true')", $fe = "Undefined uncompressed size", Tfe = "Zip file not empty", Dfe = "Invalid uid (must be integer 0..2^32-1)", Rfe = "Invalid gid (must be integer 0..2^32-1)", Ffe = "Invalid UNIX mode (must be integer 0..65535)", Pfe = "Invalid unixExtraFieldType (must be 'infozip' or 'unix')", Nfe = "Invalid msdosAttributesRaw (must be integer 0..255)", Ufe = "Invalid msdosAttributes (must be an object with boolean flags)", YE = new Uint8Array([7, 0, 2, 0, 65, 69, 3, 0, 0]), YR = "infozip", WR = "unix";
let fy = 0;
const WE = [];
class Lfe {
  constructor(e, n = {}) {
    e = new lR(e);
    const r = e.availableSize !== lr && e.availableSize > 0 && e.availableSize !== 1 / 0 && e.maxSize !== lr && e.maxSize > 0 && e.maxSize !== 1 / 0;
    Object.assign(this, { writer: e, addSplitZipSignature: r, options: n, config: DD(), files: /* @__PURE__ */ new Map(), filenames: /* @__PURE__ */ new Set(), offset: n[LE] === lr ? e.size || e.writable.size || 0 : n[LE], pendingEntriesSize: 0, pendingAddFileCalls: /* @__PURE__ */ new Set(), bufferedWrites: 0 });
  }
  async prependZip(e) {
    if (this.filenames.size) throw new Error(Tfe);
    e = new M4(e);
    const n = new pfe(e.readable), r = await n.getEntries();
    await n.close(), await e.readable.pipeTo(this.writer.writable, { preventClose: true, preventAbort: true }), this.writer.size = this.offset = e.size, this.filenames = new Set(r.map((s) => s.filename)), this.files = new Map(r.map((s) => {
      const { version: i, compressionMethod: a, lastModDate: o, lastAccessDate: f, creationDate: c, rawFilename: l, bitFlag: h, encrypted: m, uncompressedSize: v, compressedSize: b, diskOffset: A, diskNumber: _, zip64: C } = s;
      let { rawExtraFieldZip64: I, rawExtraFieldAES: S, rawExtraFieldExtendedTimestamp: $, rawExtraFieldNTFS: F, rawExtraFieldUnix: U, rawExtraField: Q } = s;
      const { level: P, languageEncodingFlag: N, dataDescriptor: L } = h;
      I = I || new Uint8Array(), S = S || new Uint8Array(), $ = $ || new Uint8Array(), F = F || new Uint8Array(), U = s.rawExtraFieldUnix || new Uint8Array(), Q = Q || new Uint8Array();
      const B = Fr(I, S, $, F, U, Q), u = C && v > kn, p = C && b > kn, { headerArray: d, headerView: y } = JR({ version: i, bitFlag: ZR(P, N, L, m, a), compressionMethod: a, uncompressedSize: v, compressedSize: b, lastModDate: o, rawFilename: l, zip64CompressedSize: p, zip64UncompressedSize: u, extraFieldLength: B });
      return Object.assign(s, { zip64UncompressedSize: u, zip64CompressedSize: p, zip64Offset: C && this.offset - A > kn, zip64DiskNumberStart: C && _ > an, rawExtraFieldZip64: I, rawExtraFieldAES: S, rawExtraFieldExtendedTimestamp: $, rawExtraFieldNTFS: F, rawExtraFieldUnix: U, rawExtraField: Q, extendedTimestamp: $.length > 0 || F.length > 0, extraFieldExtendedTimestampFlag: 1 + (f ? 2 : 0) + (c ? 4 : 0), headerArray: d, headerView: y }), [s.filename, s];
    }));
  }
  async add(e = "", n, r = {}) {
    const s = this, { pendingAddFileCalls: i, config: a } = s;
    fy < a.maxWorkers ? fy++ : await new Promise((f) => WE.push(f));
    let o;
    try {
      if (e = e.trim(), s.filenames.has(e)) throw new Error(Efe);
      return s.filenames.add(e), o = Ofe(s, e, n, r), i.add(o), await o;
    } catch (f) {
      throw s.filenames.delete(e), f;
    } finally {
      i.delete(o);
      const f = WE.shift();
      f ? f() : fy--;
    }
  }
  remove(e) {
    const { filenames: n, files: r } = this;
    if (typeof e == "string" && (e = r.get(e)), e && e.filename !== lr) {
      const { filename: s } = e;
      if (n.has(s) && r.has(s)) return n.delete(s), r.delete(s), true;
    }
    return false;
  }
  async close(e = new Uint8Array(), n = {}) {
    const r = this, { pendingAddFileCalls: s, writer: i } = this, { writable: a } = i;
    for (; s.size; ) await Promise.allSettled(Array.from(s));
    return await Wfe(r, e, n), Sr(r, n, HR) || await a.getWriter().close(), i.getData ? i.getData() : a;
  }
}
async function Ofe(t3, e, n, r) {
  e = e.trim();
  let s = Sr(t3, r, xR), i = Sr(t3, r, BR, s ? 20 : 768);
  const a = Sr(t3, r, kR), o = Sr(t3, r, $R), f = Sr(t3, r, TR);
  let c = Sr(t3, r, DR);
  const l = Sr(t3, r, rfe);
  let h = Sr(t3, r, RR), m = Sr(t3, r, FR), v = Sr(t3, r, PR);
  if (o !== lr && (o < 0 || o > kn)) throw new Error(Dfe);
  if (f !== lr && (f < 0 || f > kn)) throw new Error(Rfe);
  if (c !== lr && (c < 0 || c > an)) throw new Error(Ffe);
  if (l !== lr && l !== YR && l !== WR) throw new Error(Pfe);
  let b = Sr(t3, r, AR), A = Sr(t3, r, wR);
  const _ = o !== lr || f !== lr || c !== lr || l, C = b !== lr || A !== lr;
  if (_ ? (s = false, i = i & an | 768) : C && (s = true, i = i & ho), b !== lr && (b < 0 || b > ho)) throw new Error(Nfe);
  if (A && typeof A !== kae) throw new Error(Ufe);
  if (i > an) throw new Error(VE);
  let I = Sr(t3, r, bR, 0);
  !r[Zp] && e.endsWith(Vp) && (r[Zp] = true);
  const S = Sr(t3, r, Zp);
  S ? (e.endsWith(Vp) || (e += Vp), I === 0 && (I = q1, s || (I |= (ph | gh | Gp) << 16))) : !s && I === 0 && (a ? I = (gh | Gp) << 16 : I = Gp << 16);
  let $;
  s || ($ = I >> 16 & an, c = c === lr ? $ : c & an, h ? c |= z1 : h = !!(c & z1), m ? c |= G1 : m = !!(c & G1), v ? c |= V1 : v = !!(c & V1), S && (c |= ph), I = (c & an) << 16 | I & ho), { msdosAttributesRaw: b, msdosAttributes: A } = zfe(b, A), C && (I = I & kn | b & ho);
  const F = Sr(t3, r, tfe, Yp);
  let U = F(e);
  if (U === lr && (U = Yp(e)), Fr(U) > an) throw new Error(kfe);
  const Q = r[$4] || "";
  let P = F(Q);
  if (P === lr && (P = Yp(Q)), Fr(P) > an) throw new Error(Cfe);
  const N = Sr(t3, r, ER, Cae);
  if (N > an) throw new Error(VE);
  const L = Sr(t3, r, J1, /* @__PURE__ */ new Date()), B = Sr(t3, r, D4), u = Sr(t3, r, R4), p = Sr(t3, r, yR, 0), d = Sr(t3, r, LR);
  let y, w;
  d || (y = Sr(t3, r, NR), w = Sr(t3, r, UR));
  const E = Sr(t3, r, Voe, 3), M = Sr(t3, r, CR), x = Sr(t3, r, Yoe, true), g = Sr(t3, r, Woe, true), k = Sr(t3, r, QR), T = Sr(t3, r, Zoe), O = Sr(t3, r, joe, false), K = Sr(t3, r, OR), Y = Sr(t3, r, Xoe, true), J = Sr(t3, r, IR);
  let G = Sr(t3, r, Joe), X = Sr(t3, r, KR), ie = Sr(t3, r, efe);
  T && ie === lr && (ie = false), (ie === lr || M) && (ie = true), G !== lr && G != 6 && (X = false), !X && t3.config.CompressionStream === lr && t3.config.CompressionStreamZlib === lr && (G = 0);
  let de = Sr(t3, r, F4);
  if (!M && (y !== lr || w !== lr) && !(E >= 1 && E <= 3)) throw new Error(Ife);
  let se = new Uint8Array();
  const te = r[MR];
  if (te) {
    let pe = 0, re = 0;
    te.forEach((ue) => pe += 4 + Fr(ue)), se = new Uint8Array(pe), te.forEach((ue, xe) => {
      if (xe > an) throw new Error(Sfe);
      if (Fr(ue) > an) throw new Error(Mfe);
      yn(se, new Uint16Array([xe]), re), yn(se, new Uint16Array([Fr(ue)]), re + 2), yn(se, ue, re + 4), re += 4 + Fr(ue);
    });
  }
  let le = 0, Z = 0, ve = 0;
  if (d && (ve = r[T4], ve === lr)) throw new Error($fe);
  const he = de === true;
  n && (n = new M4(n), await ul(n), d ? (r.uncompressedSize = ve, le = jE(ve)) : n.size === lr ? (ie = true, (de || de === lr) && (de = true, ve = le = kn + 1)) : (r.uncompressedSize = ve = n.size, le = jE(ve)));
  const { diskOffset: me, diskNumber: ce, maxSize: ye } = t3.writer, Oe = he || ve > kn, Se = he || le > kn, Ce = he || t3.offset + t3.pendingEntriesSize - me > kn, $e = Sr(t3, r, qR, true) && he || ce + Math.ceil(t3.pendingEntriesSize / ye) > an;
  if (Ce || Oe || Se || $e) {
    if (de === false || !g) throw new Error(P4);
    de = true;
  }
  de = de || false;
  const Re = Sr(t3, r, _R);
  r = Object.assign({}, r, { rawFilename: U, rawComment: P, version: N, versionMadeBy: i, lastModDate: L, lastAccessDate: B, creationDate: u, rawExtraField: se, zip64: de, zip64UncompressedSize: Oe, zip64CompressedSize: Se, zip64Offset: Ce, zip64DiskNumberStart: $e, password: y, rawPassword: w, level: G, useWebWorkers: k, encryptionStrength: E, extendedTimestamp: x, zipCrypto: M, bufferedWrite: T, keepOrder: g, useUnicodeFileNames: Y, dataDescriptor: ie, dataDescriptorSignature: O, signal: K, msDosCompatible: s, internalFileAttribute: p, internalFileAttributes: p, externalFileAttribute: I, externalFileAttributes: I, useCompressionStream: X, passThrough: d, encrypted: !!(y && Fr(y) || w && Fr(w)) || d && Re, signature: r[SR], compressionMethod: J, uncompressedSize: ve, offset: t3.offset - me, diskNumberStart: ce, uid: o, gid: f, setuid: h, setgid: m, sticky: v, unixMode: c, msdosAttributesRaw: b, msdosAttributes: A, unixExternalUpper: $ });
  const Ge = Hfe(r), Fe = Gfe(r), Ue = Fr(Ge.localHeaderArray, Fe.dataDescriptorArray);
  Z = Ue + le, t3.options[zR] && (Z += Z + 64), t3.pendingEntriesSize += Z;
  let kt;
  try {
    kt = await Qfe(t3, e, n, { headerInfo: Ge, dataDescriptorInfo: Fe, metadataSize: Ue }, r);
  } finally {
    t3.pendingEntriesSize -= Z;
  }
  return Object.assign(kt, { name: e, comment: Q, extraField: te }), new Z1(kt);
}
async function Qfe(t3, e, n, r, s) {
  const { files: i, writer: a } = t3, { keepOrder: o, dataDescriptor: f, signal: c } = s, { headerInfo: l } = r, h = t3.options[zR], m = Array.from(i.values()).pop();
  let v = {}, b, A, _, C, I, S, $;
  i.set(e, v);
  try {
    let P;
    o && (P = m && m.lock, F()), (s.bufferedWrite || t3.writerLocked || t3.bufferedWrites && o || !f) && !h ? (S = new TransformStream(), S.size = 0, b = true, t3.bufferedWrites++, await ul(a)) : (S = a, await U()), await ul(S);
    const { writable: N, diskOffset: L } = a;
    if (t3.addSplitZipSignature) {
      delete t3.addSplitZipSignature;
      const y = new Uint8Array(4), w = ci(y);
      Kr(w, 0, _4), await Xo(a, y), t3.offset += 4;
    }
    h && qfe(r, t3.offset - L);
    const { localHeaderView: B, localHeaderArray: u } = l;
    b || (await P, await Q(N));
    const { diskNumber: p } = a;
    I = true, v.diskNumberStart = p, b ? $ = new Response(S.readable).blob() : await Xo(S, u), v = await Kfe(n, S, v, r, t3.config, s);
    const { zip64: d } = v;
    if (I = false, i.set(e, v), v.filename = e, b) {
      const [y] = await Promise.all([$, S.writable.getWriter().close(), P]);
      await U(), C = true, v.diskNumberStart = a.diskNumber, v.offset = t3.offset - a.diskOffset, d && ZE(v), Yfe(v, B, s), await Q(N), await Xo(a, u), await y.stream().pipeTo(N, { preventClose: true, preventAbort: true, signal: c }), a.size += S.size, C = false;
    } else v.offset = t3.offset - L, d && ZE(v);
    if (v.offset > kn && !d) throw new Error(P4);
    return t3.offset += v.size, v;
  } catch (P) {
    if (b && C || !b && I) {
      if (t3.hasCorruptedEntries = true, P) try {
        P.corruptedEntry = true;
      } catch {
      }
      b ? t3.offset += S.size : t3.offset = S.size;
    }
    throw i.delete(e), P;
  } finally {
    b && t3.bufferedWrites--, _ && _(), A && A();
  }
  function F() {
    v.lock = new Promise((P) => _ = P);
  }
  async function U() {
    t3.writerLocked = true;
    const { lockWriter: P } = t3;
    t3.lockWriter = new Promise((N) => A = () => {
      t3.writerLocked = false, N();
    }), await P;
  }
  async function Q(P) {
    Fr(l.localHeaderArray) > a.availableSize && (a.availableSize = 0, await Xo(P, new Uint8Array()));
  }
}
async function Kfe(t3, e, { diskNumberStart: n, lock: r }, s, i, a) {
  const { headerInfo: o, dataDescriptorInfo: f, metadataSize: c } = s, { headerArray: l, headerView: h, lastModDate: m, rawLastModDate: v, encrypted: b, compressed: A, version: _, compressionMethod: C, rawExtraFieldZip64: I, localExtraFieldZip64Length: S, rawExtraFieldExtendedTimestamp: $, extraFieldExtendedTimestampFlag: F, rawExtraFieldNTFS: U, rawExtraFieldUnix: Q, rawExtraFieldAES: P } = o, { dataDescriptorArray: N } = f, { rawFilename: L, lastAccessDate: B, creationDate: u, password: p, rawPassword: d, level: y, zip64: w, zip64UncompressedSize: E, zip64CompressedSize: M, zip64Offset: x, zip64DiskNumberStart: g, zipCrypto: k, dataDescriptor: T, directory: O, executable: K, versionMadeBy: Y, rawComment: J, rawExtraField: G, useWebWorkers: X, onstart: ie, onprogress: de, onend: se, signal: te, encryptionStrength: le, extendedTimestamp: Z, msDosCompatible: ve, internalFileAttributes: he, externalFileAttributes: me, uid: ce, gid: ye, unixMode: Oe, setuid: Se, setgid: Ce, sticky: Ne, unixExternalUpper: $e, msdosAttributesRaw: Re, msdosAttributes: Ge, useCompressionStream: Fe, passThrough: Ue } = a, kt = { lock: r, versionMadeBy: Y, zip64: w, directory: !!O, executable: !!K, filenameUTF8: true, rawFilename: L, commentUTF8: true, rawComment: J, rawExtraFieldZip64: I, localExtraFieldZip64Length: S, rawExtraFieldExtendedTimestamp: $, rawExtraFieldNTFS: U, rawExtraFieldUnix: Q, rawExtraFieldAES: P, rawExtraField: G, extendedTimestamp: Z, msDosCompatible: ve, internalFileAttributes: he, externalFileAttributes: me, diskNumberStart: n, uid: ce, gid: ye, unixMode: Oe, setuid: Se, setgid: Ce, sticky: Ne, unixExternalUpper: $e, msdosAttributesRaw: Re, msdosAttributes: Ge };
  let { signature: pe, uncompressedSize: re } = a, ue = 0;
  Ue || (re = 0);
  const { writable: xe } = e;
  if (t3) {
    t3.chunkSize = RD(i);
    const Me = t3.readable, We = t3.size, De = { options: { codecType: eR, level: y, rawPassword: d, password: p, encryptionStrength: le, zipCrypto: b && k, passwordVerification: b && k && v >> 8 & ho, signed: !Ue, compressed: A && !Ue, encrypted: b && !Ue, useWebWorkers: X, useCompressionStream: Fe, transferStreams: false }, config: i, streamOptions: { signal: te, size: We, onstart: ie, onprogress: de, onend: se } };
    try {
      const je = await sR({ readable: Me, writable: xe }, De);
      ue = je.outputSize, e.size += ue, Ue || (re = je.inputSize, pe = je.signature);
    } catch (je) {
      throw je.outputSize !== lr && (e.size += je.outputSize), je;
    }
  }
  return Vfe({ signature: pe, compressedSize: ue, uncompressedSize: re, headerInfo: o, dataDescriptorInfo: f }, a), T && await Xo(e, N), Object.assign(kt, { uncompressedSize: re, compressedSize: ue, lastModDate: m, rawLastModDate: v, creationDate: u, lastAccessDate: B, encrypted: b, zipCrypto: k, size: c + ue, compressionMethod: C, version: _, headerArray: l, headerView: h, signature: pe, extraFieldExtendedTimestampFlag: F, zip64UncompressedSize: E, zip64CompressedSize: M, zip64Offset: x, zip64DiskNumberStart: g }), kt;
}
function Hfe(t3) {
  const { rawFilename: e, lastModDate: n, lastAccessDate: r, creationDate: s, level: i, zip64: a, zipCrypto: o, useUnicodeFileNames: f, dataDescriptor: c, directory: l, rawExtraField: h, encryptionStrength: m, extendedTimestamp: v, passThrough: b, encrypted: A, zip64UncompressedSize: _, zip64CompressedSize: C, zip64Offset: I, zip64DiskNumberStart: S, uncompressedSize: $, offset: F, diskNumberStart: U } = t3;
  let { version: Q, compressionMethod: P } = t3;
  const N = !l && (i > 0 || i === lr && P !== 0);
  let L;
  const B = b || !N, u = a && (t3.bufferedWrite || !_ && !C || B);
  if (a) {
    let J = 4;
    _ && (J += 8), C && (J += 8), I && (J += 8), S && (J += 4), L = new Uint8Array(J);
    const G = ci(L);
    if (Yr(G, 0, ED), Yr(G, 2, Fr(L) - 4), u) {
      const X = ci(L);
      let ie = 4;
      _ && (ri(X, ie, BigInt($)), ie += 8), C && B && (ri(X, ie, BigInt($)), ie += 8), I && (ri(X, ie, BigInt(F)), ie += 8), S && (Kr(X, ie, U), ie += 4);
    }
  } else L = new Uint8Array();
  let p;
  if (A && !o) {
    p = new Uint8Array(Fr(YE) + 2);
    const J = ci(p);
    Yr(J, 0, BD), yn(p, YE, 2), G0(J, 8, m);
  } else p = new Uint8Array();
  let d, y, w;
  if (v) {
    y = new Uint8Array(9 + (r ? 4 : 0) + (s ? 4 : 0));
    const J = ci(y);
    Yr(J, 0, E4), Yr(J, 2, Fr(y) - 4), w = 1 + (r ? 2 : 0) + (s ? 4 : 0), G0(J, 4, w);
    let G = 5;
    Kr(J, G, Math.floor(n.getTime() / 1e3)), G += 4, r && (Kr(J, G, Math.floor(r.getTime() / 1e3)), G += 4), s && Kr(J, G, Math.floor(s.getTime() / 1e3));
    try {
      d = new Uint8Array(36);
      const X = ci(d), ie = ly(n);
      Yr(X, 0, CD), Yr(X, 2, 32), Yr(X, 8, kD), Yr(X, 10, 24), ri(X, 12, ie), ri(X, 20, ly(r) || ie), ri(X, 28, ly(s) || ie);
    } catch {
      d = new Uint8Array();
    }
  } else d = y = new Uint8Array();
  let E;
  try {
    const { uid: J, gid: G, unixMode: X, setuid: ie, setgid: de, sticky: se, unixExtraFieldType: te } = t3;
    if (te && (J !== lr || G !== lr || X !== lr)) {
      const le = JE(J), Z = JE(G);
      let ve = new Uint8Array();
      if (te == WR && X !== lr) {
        let ye = X & an;
        ie && (ye |= z1), de && (ye |= G1), se && (ye |= V1), ve = new Uint8Array(2), new DataView(ve.buffer).setUint16(0, ye, true);
      }
      const he = 3 + le.length + Z.length + ve.length;
      E = new Uint8Array(4 + he);
      const me = ci(E);
      Yr(me, 0, te == YR ? SD : MD), Yr(me, 2, he), G0(me, 4, 1), G0(me, 5, le.length);
      let ce = 6;
      yn(E, le, ce), ce += le.length, G0(me, ce, Z.length), ce++, yn(E, Z, ce), ce += Z.length, yn(E, ve, ce);
    } else E = new Uint8Array();
  } catch {
    E = new Uint8Array();
  }
  P === lr && (P = N ? x4 : mD), a && (Q = Q > EE ? Q : EE), A && !o && (Q = Q > BE ? Q : BE, p[9] = P, P = vD);
  const M = u ? Fr(L) : 0, x = M + Fr(p, y, d, E, h), { headerArray: g, headerView: k, rawLastModDate: T } = JR({ version: Q, bitFlag: ZR(i, f, c, A, P), compressionMethod: P, uncompressedSize: $, lastModDate: n < kE ? kE : n > CE ? CE : n, rawFilename: e, zip64CompressedSize: C, zip64UncompressedSize: _, extraFieldLength: x });
  let O = r0;
  const K = new Uint8Array(O + Fr(e) + x), Y = ci(K);
  return Kr(Y, 0, yD), yn(K, g, 4), yn(K, e, O), O += Fr(e), u && yn(K, L, O), O += M, yn(K, p, O), O += Fr(p), yn(K, y, O), O += Fr(y), yn(K, d, O), O += Fr(d), yn(K, E, O), O += Fr(E), yn(K, h, O), c && (Kr(Y, uc + 4, 0), Kr(Y, cc + 4, 0)), { localHeaderArray: K, localHeaderView: Y, headerArray: g, headerView: k, lastModDate: n, rawLastModDate: T, encrypted: A, compressed: N, version: Q, compressionMethod: P, extraFieldExtendedTimestampFlag: w, rawExtraFieldZip64: L, localExtraFieldZip64Length: M, rawExtraFieldExtendedTimestamp: y, rawExtraFieldNTFS: d, rawExtraFieldUnix: E, rawExtraFieldAES: p, extraFieldLength: x };
}
function qfe(t3, e) {
  const { headerInfo: n } = t3;
  let { localHeaderArray: r, extraFieldLength: s } = n, i = ci(r), a = 64 - (e + Fr(r)) % 64;
  a < 4 && (a += 64);
  const o = new Uint8Array(a), f = ci(o);
  Yr(f, 0, ID), Yr(f, 2, a - 2);
  const c = r;
  n.localHeaderArray = r = new Uint8Array(Fr(c) + a), yn(r, c), yn(r, o, Fr(c)), i = ci(r), Yr(i, 28, s + a), t3.metadataSize += a;
}
function JE(t3) {
  if (t3 === lr) return new Uint8Array();
  {
    const e = new Uint8Array(4);
    ci(e).setUint32(0, t3, true);
    let r = 4;
    for (; r > 1 && e[r - 1] === 0; ) r--;
    return e.subarray(0, r);
  }
}
function zfe(t3, e) {
  if (t3 !== lr) t3 = t3 & ho;
  else if (e !== lr) {
    const { readOnly: n, hidden: r, system: s, directory: i, archive: a } = e;
    let o = 0;
    n && (o |= _b), r && (o |= Eb), s && (o |= Bb), i && (o |= q1), a && (o |= Cb), t3 = o & ho;
  }
  return e === lr && (e = { readOnly: !!(t3 & _b), hidden: !!(t3 & Eb), system: !!(t3 & Bb), directory: !!(t3 & q1), archive: !!(t3 & Cb) }), { msdosAttributesRaw: t3, msdosAttributes: e };
}
function Gfe({ zip64: t3, dataDescriptor: e, dataDescriptorSignature: n }) {
  let r = new Uint8Array(), s, i = 0, a = t3 ? _D : xD;
  return n && (a += H1), e && (r = new Uint8Array(a), s = ci(r), n && (i = H1, Kr(s, 0, bD))), { dataDescriptorArray: r, dataDescriptorView: s, dataDescriptorOffset: i };
}
function Vfe({ signature: t3, compressedSize: e, uncompressedSize: n, headerInfo: r, dataDescriptorInfo: s }, { zip64: i, zipCrypto: a, dataDescriptor: o }) {
  const { headerView: f, encrypted: c } = r, { dataDescriptorView: l, dataDescriptorOffset: h } = s;
  (!c || a) && t3 !== lr && (Kr(f, B4, t3), o && Kr(l, h, t3)), i ? o && (ri(l, h + 4, BigInt(e)), ri(l, h + 12, BigInt(n))) : (Kr(f, uc, e), Kr(f, cc, n), o && (Kr(l, h + 4, e), Kr(l, h + 8, n)));
}
function Yfe({ rawFilename: t3, encrypted: e, zip64: n, localExtraFieldZip64Length: r, signature: s, compressedSize: i, uncompressedSize: a, offset: o, diskNumberStart: f, zip64UncompressedSize: c, zip64CompressedSize: l, zip64Offset: h, zip64DiskNumberStart: m }, v, { dataDescriptor: b }) {
  if (b || (e || Kr(v, B4 + 4, s), n || (Kr(v, uc + 4, i), Kr(v, cc + 4, a))), n && r) {
    let A = r0 + Fr(t3) + 4;
    c && (ri(v, A, BigInt(a)), A += 8), l && (ri(v, A, BigInt(i)), A += 8), h && (ri(v, A, BigInt(o)), A += 8), m && Kr(v, A, f);
  }
}
function ZE({ compressedSize: t3, uncompressedSize: e, offset: n, diskNumberStart: r, zip64UncompressedSize: s, zip64CompressedSize: i, zip64Offset: a, zip64DiskNumberStart: o, rawExtraFieldZip64: f }) {
  const c = ci(f);
  let l = 4;
  s && (ri(c, l, BigInt(e)), l += 8), i && (ri(c, l, BigInt(t3)), l += 8), a && (ri(c, l, BigInt(n)), l += 8), o && Kr(c, l, r);
}
async function Wfe(t3, e, n) {
  const { files: r, writer: s } = t3, { diskOffset: i } = s;
  let { diskNumber: a } = s, o = 0, f = 0, c = t3.offset - i, l = r.size;
  for (const [, $] of r) {
    const { rawFilename: F, rawExtraFieldZip64: U, rawExtraFieldAES: Q, rawComment: P, rawExtraFieldNTFS: N, rawExtraFieldUnix: L, rawExtraField: B, extendedTimestamp: u, extraFieldExtendedTimestampFlag: p, lastModDate: d } = $;
    let y;
    if (u) {
      y = new Uint8Array(9);
      const w = ci(y);
      Yr(w, 0, E4), Yr(w, 2, 5), G0(w, 4, p), Kr(w, 5, Math.floor(d.getTime() / 1e3));
    } else y = new Uint8Array();
    $.rawExtraFieldExtendedTimestamp = y, f += 46 + Fr(F, P, U, Q, N, L, y, B);
  }
  const h = new Uint8Array(f), m = ci(h);
  await ul(s);
  let v = 0;
  for (const [$, F] of Array.from(r.values()).entries()) {
    const { offset: U, rawFilename: Q, rawExtraFieldZip64: P, rawExtraFieldAES: N, rawExtraFieldExtendedTimestamp: L, rawExtraFieldNTFS: B, rawExtraFieldUnix: u, rawExtraField: p, rawComment: d, versionMadeBy: y, headerArray: w, headerView: E, zip64: M, zip64UncompressedSize: x, zip64CompressedSize: g, zip64DiskNumberStart: k, zip64Offset: T, internalFileAttributes: O, externalFileAttributes: K, diskNumberStart: Y, uncompressedSize: J, compressedSize: G } = F, X = Fr(P, N, L, B, u, p);
    Kr(m, o, yb), Yr(m, o + 4, y), x || Kr(E, cc, J), g || Kr(E, uc, G), yn(h, w, o + 6);
    let ie = o + r0;
    if (Yr(m, ie, X), ie += 2, Yr(m, ie, Fr(d)), ie += 2, Yr(m, ie, M && k ? an : Y), ie += 2, Yr(m, ie, O), ie += 2, K && Kr(m, ie, K), ie += 4, Kr(m, ie, M && T ? kn : U), ie += 4, yn(h, Q, ie), ie += Fr(Q), yn(h, P, ie), ie += Fr(P), yn(h, N, ie), ie += Fr(N), yn(h, L, ie), ie += Fr(L), yn(h, B, ie), ie += Fr(B), yn(h, u, ie), ie += Fr(u), yn(h, p, ie), ie += Fr(p), yn(h, d, ie), ie += Fr(d), o - v > s.availableSize && (s.availableSize = 0, await Xo(s, h.slice(v, o)), v = o), o = ie, n.onprogress) try {
      await n.onprogress($ + 1, r.size, new Z1(F));
    } catch {
    }
  }
  await Xo(s, v ? h.slice(v) : h);
  let b = s.diskNumber;
  const { availableSize: A } = s;
  A < Yo && b++;
  let _ = Sr(t3, n, F4);
  if (c > kn || f > kn || l > an || b > an) {
    if (_ === false) throw new Error(P4);
    _ = true;
  }
  const C = new Uint8Array(_ ? bae : Yo), I = ci(C);
  o = 0, _ && (Kr(I, 0, bb), ri(I, 4, BigInt(44)), Yr(I, 12, 45), Yr(I, 14, 45), Kr(I, 16, b), Kr(I, 20, a), ri(I, 24, BigInt(l)), ri(I, 32, BigInt(l)), ri(I, 40, BigInt(f)), ri(I, 48, BigInt(c)), Kr(I, 56, wD), ri(I, 64, BigInt(c) + BigInt(f)), Kr(I, 72, b + 1), Sr(t3, n, qR, true) && (b = an, a = an), l = an, c = kn, f = kn, o += dh + hh), Kr(I, o, AD), Yr(I, o + 4, b), Yr(I, o + 6, a), Yr(I, o + 8, l), Yr(I, o + 10, l), Kr(I, o + 12, f), Kr(I, o + 16, c);
  const S = Fr(e);
  if (S) if (S <= an) Yr(I, o + 20, S);
  else throw new Error(Bfe);
  await Xo(s, C), S && await Xo(s, e);
}
async function Xo(t3, e) {
  const { writable: n } = t3, r = n.getWriter();
  try {
    await r.ready, t3.size += Fr(e), await r.write(e);
  } finally {
    r.releaseLock();
  }
}
function ly(t3) {
  if (t3) return (BigInt(t3.getTime()) + BigInt(116444736e5)) * BigInt(1e4);
}
function Sr(t3, e, n, r) {
  const s = e[n] === lr ? t3.options[n] : e[n];
  return s === lr ? r : s;
}
function jE(t3) {
  return t3 + 5 * (Math.floor(t3 / 16383) + 1);
}
function G0(t3, e, n) {
  t3.setUint8(e, n);
}
function Yr(t3, e, n) {
  t3.setUint16(e, n, true);
}
function Kr(t3, e, n) {
  t3.setUint32(e, n, true);
}
function ri(t3, e, n) {
  t3.setBigUint64(e, n, true);
}
function yn(t3, e, n) {
  t3.set(e, n);
}
function ci(t3) {
  return new DataView(t3.buffer);
}
function Fr(...t3) {
  let e = 0;
  return t3.forEach((n) => n && (e += n.length)), e;
}
function JR({ version: t3, bitFlag: e, compressionMethod: n, uncompressedSize: r, compressedSize: s, lastModDate: i, rawFilename: a, zip64CompressedSize: o, zip64UncompressedSize: f, extraFieldLength: c }) {
  const l = new Uint8Array(r0 - 4), h = ci(l);
  Yr(h, 0, t3), Yr(h, 2, e), Yr(h, 4, n);
  const m = new Uint32Array(1), v = ci(m);
  Yr(v, 0, (i.getHours() << 6 | i.getMinutes()) << 5 | i.getSeconds() / 2), Yr(v, 2, (i.getFullYear() - 1980 << 4 | i.getMonth() + 1) << 5 | i.getDate());
  const b = m[0];
  return Kr(h, 6, b), (o || s !== lr) && Kr(h, uc, o ? kn : s), (f || r !== lr) && Kr(h, cc, f ? kn : r), Yr(h, 22, Fr(a)), Yr(h, 24, c), { headerArray: l, headerView: h, rawLastModDate: b };
}
function ZR(t3, e, n, r, s) {
  let i = 0;
  return e && (i = i | xb), n && (i = i | wb), (s == x4 || s == vb) && (t3 >= 0 && t3 <= 3 && (i = i | Bae), t3 > 3 && t3 <= 5 && (i = i | Eae), t3 == 9 && (i = i | _ae)), r && (i = i | Ab), i;
}
try {
  Sd({ baseURI: import.meta.url });
} catch {
}
const Ts = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
function Jfe(t3) {
  let e;
  t3({ wasmURI: () => (e || (e = "data:application/wasm;base64," + ((n) => {
    n = ((a) => {
      const o = (a = (a + "").replace(/[^A-Za-z0-9+/=]/g, "")).length, f = [];
      for (let c = 0; o > c; c += 4) {
        const l = Ts.indexOf(a[c]) << 18 | Ts.indexOf(a[c + 1]) << 12 | (63 & Ts.indexOf(a[c + 2])) << 6 | 63 & Ts.indexOf(a[c + 3]);
        f.push(l >> 16 & 255), a[c + 2] !== "=" && f.push(l >> 8 & 255), a[c + 3] !== "=" && f.push(255 & l);
      }
      return new Uint8Array(f);
    })(n);
    let r = new Uint8Array(1024), s = 0;
    for (let a = 0; a < n.length; ) {
      const o = n[a++];
      if (128 & o) {
        const f = 3 + (127 & o), c = n[a++] << 8 | n[a++], l = s - c;
        i(s + f);
        for (let h = 0; f > h; h++) r[s++] = r[l + h];
      } else {
        const f = o;
        i(s + f);
        for (let c = 0; f > c && a < n.length; c++) r[s++] = n[a++];
      }
    }
    return ((a) => {
      let o = "";
      const f = a.length;
      let c = 0;
      for (; f > c + 2; c += 3) {
        const h = a[c] << 16 | a[c + 1] << 8 | a[c + 2];
        o += Ts[h >> 18 & 63] + Ts[h >> 12 & 63] + Ts[h >> 6 & 63] + Ts[63 & h];
      }
      const l = f - c;
      if (l === 1) {
        const h = a[c] << 16;
        o += Ts[h >> 18 & 63] + Ts[h >> 12 & 63] + "==";
      } else if (l === 2) {
        const h = a[c] << 16 | a[c + 1] << 8;
        o += Ts[h >> 18 & 63] + Ts[h >> 12 & 63] + Ts[h >> 6 & 63] + "=";
      }
      return o;
    })(new Uint8Array(r.buffer.slice(0, s)));
    function i(a) {
      if (r.length < a) {
        let o = 2 * r.length;
        for (; a > o; ) o *= 2;
        const f = new Uint8Array(o);
        f.set(r.subarray(0, s)), r = f;
      }
    }
  })("FQBhc20BAAAAAUULYAF/AX9gAn9/AIEABYAACwIDf4IABwEBgAARAQaAAAuDAA6BABUDAGAAgAADgAANAQSBABUDAGAHgwAegAAfEgNCQQcABAEABAgIAAIABQIKAIAAB4EAAwEFgQAHAgICgQAHEAEDAAUGAAMDBQQJBAQJAQaAAAEeAAIEAwIEAgIBBAcDAwQFAXABDQ0FBgEBggKCAgYIgACYIkHQ1QQLB4oEHAZtZW1vcnkCAAxpbmZsYXRlOV9uZXcABw2GAA8HaW5pdAAIEYoAEAdfcmF3AAoQhgAUCXByb2Nlc3MAC4cARgZlbmQADhaGAA8QbGFzdF9jb25zdW1lZAARC4QAGYMAbYUANoMAbAEShQBYhwBrARSFAH+DABMHZ3ppcAAVD4UAFIUAfgEWhgBWgQB9AhgVhQAOjQB8AmRliQB8hQAOggB8AhoQiQAPggB8AhsRigATggB8AhwPhQAUhQB8AR2GAFaBAHwJHwRmcmVlAAIVhQAVjACDCgZtYWxsb2MAAQuCAFUKaWFsaXplAAAZX4AADxZkaXJlY3RfZnVuY3Rpb25fdGFibGUBgAAcG2Vtc2NyaXB0ZW5fc3RhY2tfcmVzdG9yZQAFHI4AGwJnZYAAbw51cnJlbnQABiJfX2N4YYAAWwRjcmVtgAASBl9leGNlcIIAXQZyZWZjb3WAACUtPQkSAQBBAQsMACEiDA8XGR4+NTg7CqHlAkECAAu/JwELfyMAQRBrIgokAAJAjwACEiAAQfQBTQRAQaQnKAIAIgNBEIAAEgYLakH4A3GBAAkQSRsiBkEDdiIAdiIBQQNxBIEAMgYBQX9zQQGAAB8GaiICQQN0gAAZDMwnaiIAIAEoAtQnIoAABgQIIgVGggBSCSADQX4gAndxNoACphEBCyAFIAA2AgwgACAFNgIIC4AASAMIaiGAADcBIIIARoAABQRyNgIEgQAPA2oiAYEATQMEQQGBABIHDAsLIAZBrIIAnwMITQ2AABuBAIYEQQIgAIEANQUAIAJrcoAANQQAdHFogQCjA3QiAIIAj4AAH4IAj4AABosAjwUBd3EiA4YAkQECgQCRAQKEAJEBAIAAaIMAhYAACgJqIoAAjIIA3wUgBmsiBYMAjIAAGQIBaoEALgoAIAgEQCAIQXhxgQBuBCEBQbiBAKAEIQICf4AAZQEBgAAZBwN2dCIHcUWEAHgCIAeAAD6AADyBAHWBASEDCyEDgQDpgAB2gAAchACEAQGDAAeAAJyBAIuCARyAAFYCIASAADmAAP6CAHWAAQsCQaiCAQkCC0WAAQkFC2hBAnSAAOYDKSICgQEuAnhxgACqByEEIAIhAQOCAagFKAIQIgCAAIOBAAoBFIAACgENgAB+gAEQhAAqgADZgQFuBQRJIgEbgAA2gAFJASCAAAmAATgBIYEApwILIIAAVAMYIQmAABaAAAkEDCIAR4AASIAACgEIgAA3hAHGgACxAwgMCoIAKQUUIgEEf4AByAIUaoABU4EAdwMBRQ2AANkOQRBqCyEFA0AgBSEHIAGAAZoDFGohgAIFggAwAg0AgADlARCEABCAADEGDQALIAdBgABbCAAMCQtBfyEGgAAfA79/S4IAJwELgAISgAC1AiEGhAD+CAdFDQBBHyEIgAH+ggDygALEA///B4ACxoABwQEmgQJYBnZnIgBrdoICpQpBAXRrQT5qIQgLhALxAQiFATUBAYEBngIAIYECCoEAB4AAPAEZgAAdAwF2a4AAVwgIQR9HG3QhAoUBSYUBNAQDIARPgACTAQGAALcDAyIEgACGAQCAAH8BAYAARAEDgQI/ggFoAQOAAdOBAtQGHXZBBHFqggDcAkYbgAAdAgMbgABkAQKAAI+AAWSBAO6BADECBXKDAIQBBYACzwEIgQK7gADugALPAgdxgQGuAwMgAIUB4QEhgAEdggHAgAFMiAHCAQKAAb4BIYAAbIEByYMBxAEFgQAJhQFTgAGTAQGDAW8DCyIAggByAQWAATkCIASDA02AAEGBAMsBBYEB5wEIgAA5gAAJhAHngAAKjQHngAKTgAAWgwHnAQWCAeeAAA+EAecBBYIB54ABK4ACeoAA+4MB54IDgIgB54IAEIQB5wEDgwHnAQeHA9gBBYEEgoMDQ4AEpoAAjYECnwNBEE+AAI2CA4uAATKGA4ECBWqBAJOAAFeFA66BA1WAABeGA7sBBYsEQIABX4AEJwEhgAHlgANGgQA6gQNWgAN0gQCZgQNlgAJvgABKAbCCAIgCAkmAAIgBsIAAH4IAgYEALAK8J4AAA4EAG4MAiIEAN4kAjYYEMYUAS4QCSgEvgAQ/BQJ/QfwqgAA7gABTAoQrgAAIgQJoBYgrQn83gABXBoArQoCggIAAAQEEgQAOEfwqIApBDGpBcHFB2KrVqgVzgQB6ApArggEnA0HgKoMACAaAIAsiAWqABaKAAZMBa4AEXIEEmQVNDQhB3IEAZAIiBYAAZgHUggAKAQiABKMFIgkgCE2AAUcFCUlyDQmAAvmAAEUDLQAAgAKQgAJvhQX6hADYgQA5BOQqIQCDAlqBAD+BAY2AADwBCIICagNqSQ2BAtuBAhKCAkMEQQAQBIAFdwJ/RoAB+QMBIQOAAMmCAR0BQYAAk4AD+4AGIYEC/AFrgQVTAWqCAs0DcWohgABAAQOBAKsBA4QAq4EBEYMAq4ADRQNqIgeAAHGAAUoBB4AAqwEEgAAqgABfgAFjBUcNAQwFgQA4gABMgADrgQAWggJCgABTgQCVAUaABP4BAoIDFYEAioABCQVBMGogA4EAuIAB7QMMBAuDAXGBAyADIANrgQCJBwJrcSICEASDAC6ABWWAAJaCACuAAJyAAM0ERw0CC4EBaAHggQCWAkEEgQWsgAWohADpggDygQBoAXKBBSQDTXINgANTgABQgAPoCAZBKGpNDQULgADOgwDRgQDPggGsAdiCAA4BAIECTgLYKoEDSQEAgQGFgwFxAQSHAXGDANOBA2uAANUCIgWAANeCABKDAWuBAMcBtIMCe4EBSoAAewEbgQQtAbSDAr2CAmkDQegqgQYwAQCAAFCCABUFQcQnQX+BAAgCyCeDAnuBAAwB8IMCQIEB4IMGz4MHsIAGUAHUgAMQgQZYAtgngQUngAC7A0EgR4AAeYEDAQQDQShrgAAQAXiAAOkBQYECa4AB3oMDDoQHoIIGzoADdIUDCAQCakEogQNsBMAnQYyBAXuBA+CAAc6AAYEBTYEGZAJLcoMA2gQMQQhxgQAKgAHZAgVqgQAwgABRgATNAiAEggBmgAhRggN0ArAngwOPgQFPgAAtgACJgwBvgAClggBvgABWkABvAQOCARMCDAaDAAeFAT0DIAJLiAE1gwH7AQWCAYACAkCBBpmEAYKBBPeEAXoDAQwCgQWcAi0AgQCtgATgAQuEAa6BCSyDAa4BBIECaYEHPIICjAMiBUmEB1kBCIIGTJQBQAEHkAFAAQeZAUCAAGICBUGAB/iBAEEDakEvgABPgAAoAQSABUyACZQDAUEbggksCUHsKikCADcCEIAACwHkgwALAQiAABSCCVuBAHCNAiCEAgyAACABGIAEr4ICE4AAmIMEv4AABQEEgQmQgADPgQL+AyAERoEG6YMFSQF+gAnDAQSDCC+ABnaEALaCCMEBAIAI8gMCQf+BCkOAAAiECQ+AABWEClCABSqBCd+ACQ0BAoUJDYAAEYIJDYIJgoEBNgELgAbDgADagQkNgABggAZ1AkEMgAWyAQiBBS8BH4IHMwH/hAfdAQKAB92AABmQB92AALGAAMUGNgIcIARCggEPAQCABzkDQdQpgAmaggTrgwg3gAKvgQo1AQOCAIoBqIEJlwEFgwmXggllgQCPAQKACAOAAFWCCAOACGKBCAOCB9aAB6KBAi2BCt2CB3wBAoIDqoAH44EHbIEH04MDDoAH8AIiA4EG5wEFggbngQBXARCBAJqAAe8DGEEIgAcEAgQigAgsAkEMhQoHgAHTgQDwgwCBAQiDAMOACNWAACMBGIABAgEMgAA7hAbsgQLygwRHhAapgAZkAU2ACH6AAmqBB8ixBquAAyEEoCdBMIEAOYEDMIIIwIMHFoIC14ADKIIDa4UCwwFqgAYZhQBCgAmMgAaDggAVgAUFAiAIgAbsA2shB4UE4QIgA4ELboED2YoDzAEHgwUbgQDlhAvYgAHgggfzgwAxhwrrhAifjgAxgQIlgwEGgQFAgAFogQWXBANxQQGAAD+AACSACiABCYEAFoACPYIM14MClIAAEYEIzAECgwwCgwKWgAwGgAA5AXaDDJgBAoEC7IcLg4ECd4EANQMYIQaAAEaABC+BBBqCAEWCAR+BACaBAaWAACaAAB+AABiAC1iACRMBA4IJE4IB+4EJp4AAEIEJE4ALh4IKKoAGiYEJE4IEMIAAMIADV4ELGoEJuYIAMYECLAEFgwkTggqKgACSAQaACaiDAGABHIAA5AECgAW2gQoGggEpgAF+gALYgwGrAwINAYACyIMC3oEA1YUA0oEAOwIgBoAAXYEAMAEGgQAsARCBANeCAAoBFIAC5oIMCoAI5IACl4QAtYEDXoEA2YADOoEAJQEYggEEggw0gQJFgAAZARSGABkEByAJaoALzwEDgAAHgQLtAQSBA32AB02GBCSFBNWAAAoCaiCBBPaAABKDAYwBB5MEIAEHrQQggwMpgQAHhAGxgAQoAQKBAGaEBCgBB4AEKAEHkgQogAFbgALUiAQogA8mgwQogg8dhAQoggS1A3QiBYUEKIAD24MAkoYEKAEHgAQogAUHggQoAQKEDCuCBh6DAfSBDnaCBCgBB4EEKIEMC4EB7YML+4EFfYEEKIMLQIIB/IYEKIAA1gEYgAAHhADkgQDyhQEEgQZ2gwuPgwQqgQIvgQAriAEIAQuADLWCA9qCAgABCIMCQoAAZgEcgADQgADOgAJsgAJCgQ8KgACKgQJCggNdgAbvgQDiAQeEDxmBAa+DAECACgCEAkCACgiEAkCCAAqAAkCEDkoCIAiBAISDAMiCC6mAAIaABomCAMaFDC+BAkCCABkBFIUAGYAAXAMEQQ+DCmMBBIEEqYADi4cLuYMEfYYEIYEMCoQAH4AACoEEb4QAHIEFXQFqggGPgAASgwJegQFxkAJeAQSiAl6BD3aAAByAAAcBDIECzYMAB4cCXoIAZoQCXgEEgAJeAQSVBoaCADwDHCADkQaGgQMaghC1hQJYgAK0hAaAgQelgwBxARiBAJgBBJYGh4MCX4UP74AHo4QGh4IJHYEAJoEF8oECXwEHhw9VgQBeARCDEGiBA9iFAOWBAPOCBvSDBN2CABaDEH+DDaGABBuDBPKCANSBDgGDAl+CBPoBCYMCX4AAPIQCX4AB74ACX4EFZ4AAKI0CXwELgwJfhgJdAwIgCYQCXQEJhgJdggAKiAJdAQmBAIKDEEyPAl2DEHOZAl2BC/uKAl2ACXaNAl2ABQKEAB+AAAqAA5KGAl2AAm6EAl2KEeaBDjqCAYWAAmGGEeQBIIMIT4gR5ogCW4ABO4ICRoMB3IEH6YICW4IB8QEIgQb/ghHXgQ6ZgQBugQiAgQFjAQuADg4DEGokgABKBgveCwEIf4EGz4IA7AJBCIEMd4AJqAFrgwLeAXiBCzQCIQWCE5QCAXGBCa8BQYACXYEGgIEFv4AAIoAAL4MLB4AKo4ISvIME6IAE6oQHeoQG3oAHNIAAPIQJxoMG7wEEgA0ViQcygBMMhAcygQ2YggchigcfiwdFgQ3KhRAwiAcdghAwgwcdAQSAAsoBBIISF4IHHYABhIUQMIIHHYIAEIsSF4AIo4ACZoAJQ4EH9QIDR4AOUIABOIICZ4AQ9oQGf4EBHoMBxIIUbQIAD4QF8YEAmYIFUIAN6Y4HYoICwQEEhwdiAQSWB2KJAsWrB2KBAsWCARyBAsWIB2KCAsWCABmBAsWFA6MBBYQRmoEA7QEBgAHShhW7gwHigglggQHAghTZgAlrggvlhglrgA1IggEXhwENAQODAfACRw2BEXGDEE8BuIMACAEPhAmFgQ/4hAmHggBNhgmHjwBNgQ2YhQFdgQKEgAAjgQw3iwJGghJEgAF7jAl4igJGiwGagAIzghKMgQJXAQWIEoeJAleDAgOREoeAADS0AleAAg2RAkCGAOaDDlmHAjOHB1ODAjOCB1OjAjOABsSjAjOGB1WMAjOHB1WOAjOOALiAABQBCIAPz4UDJYABrYULFIELLIMWt4YHKoAE+oILFIAUhIUEz4AG9I0WtYQGq4AICIUGRYIE1oMGIYACSoEJh4AAZYQHKQEAgAcpgASzgAcpAQGDBymAAsyGCYeCBlyGBymGCYeAEzWAAucBf4sJiYMXSIIJiYMFYoABqIECpIENJYMJIpEJj4ABnoAVnYECD4YNtwEAhgmPgQzagxWKgAG7hgcwgBXRhQcwgQBdgAu9gAfpgQD3AgMihgEGgALVggD8gwEKgAAngADjgRRhAQuAAnWBEF6DBjiEARqCAY2CD/qAEZoBxIICEoAFlIASTQIgAIAPwYATTwSMCwEHgAANgQWagAXHgxBjgRJ3ggXOgAEWggXOghB3gACOhAhIgQAmgRKBhAaPhBC7AQyABm2FD4mAAZGRBcOBD4mGA32AACKBA2yEBgSCADCCB/6BAc+BGJmBA5CCDLABBIADbIEV04QWVgEEghaZiBXzAQeAAWGBBeOAATCCBNKAAUWCBeODABCFAVWLBcOAAIqHBcOCDuKAFD2EA4OBBsaFBcOBABuCBcOEAJmHBcOAAEqEA5CAAJYBHIAAUYYDkAEAhwOQgwlXiwOQhBqPggOQgA8VhgOQgQH1gwOQgAAKgAOQAQOCA5CABeWBA5CCAPoBAoIBWoEDuIMJKIADd4IBIYADuoEB8YEDx4UAGYYFr4QA7pEFtIIFhoYFtIATf4QW1oYPsqkFtIIAH4YFtJAATYEauIQBToERp4ICTYMFtIcCN4QFtIIPj5UCN4sBi4cFtIAGtIYFtIsCSIUFtIECSIgFtIACSIUFtK8CSIIFtI8CMYYA5oMFtIcCJIIFtIgCJIgFtJ0CJIkFtJoCJIIA1pACJIIA/ZACJJEAuIENVYQFtIQBrYUHUIEHaYIFtIAcY4YdrIEVzIEFtIAII4UM3oEK0IAEHoUL2YEM3oMQsoUKfIQQx4MKmIIFtIAErIYFtAEBhhtAAQKDBbSBBSeCBbSCEiGAALkDHCAAgwW0AQOFBbSAEW+GDzuBBkiAFmWGBbKAEAWDAJGEDBCCBq+CBUuABbOAAMGCBbMBA4MFs4ABH4EFs4ICDoEBqIIFswEBgQWzAQOBBbOBAAeABbOAAnqAAJWGBbMBAoMFs4QQu4AClYIBWYQA6oMGl4EGCoYa0IMTZIADXYIM4oQTgIMBDQMLC0mBBxEBkIMGe4EVGwFqgQtiAQKCCzWAAHSCA1CCF4UDIAA/gAUCAXSAHo2HE0UBf4ABTAGQhAqQAwELBoAALQYkAAsEACOAE7MCAQGABtUEQcQAEIAQGYMLyAIEa4EZj4AMOoIADoAGHgMA/AuBGM6CBWuAASMBJIEHjQU2AiAgAIASGQMLCxGAACaBAVEBfoIHxQsQEAkL2QIBA39BeoAHMARAQZQIgQBNATGBAjgBfoEcBYQAVYQEuAEggwJ8gAAKASSEAAgKKEEBQdg3IAIRA4AGVoEAVwF8gQBXgweQgADmAzYCOIUBrwQCQb/+gAAJgABlBCAAECODFg8GQR91IgNzgBlXgQKAgBQFgBYugwLSASiDDnwCdkGCGfoEAUEAToAeWYEfa4ABYIIAPYIAXAM0IAKBAj8BLIkAFIAA54EAB4ABloEAG4AI1YIN8YAAX4ADhgEwgALIgQAWATyDACsBJIAAB4AbNYIOHAFCgRtAAXCCCD8BQoAAqAE3gQ3IAkKBgwAUAcyAAOCAACsCtAqCCr4BcIMA0QFUgwAHAlBBggkNgAEJgxmBAyQRAYQBMQEcgAIsjAFtAXCAAW0BEoIB+oEA5oIXlAgEEA0L/SQBIoQhWQIUJIEBeAEZhgEkgQeMAiIShAFsAwQhE4QbV4ECNwETgARnAwAhE4IAfYEEkAHcgAs6AR+AAKcF9AVqIRWAAAgB2IAAEAEbgAAIAfCAAAgBGoMAvwIhFoEAIIAAEAMRQZyBGBkEIRxBmIIACAQdQZQrgAH4AiEegQM2A0AhCoEABwE8gQr5AUGAGDIIAkkhIEF9IQ2AAA4GBkchISATgQIYgQMvAxchEIEY+JEiCpIAAoEJjpEiNoEQgoAiGoABdxdrDhMEBQYHCAkDAgwNARkAGw8iIhQhIoIEfwVMIQYMGYYACoAW0IAACgFsgR5MgQAIASKAC9YDKAJggh8wAwxJG4AAIQQGCyAggR/agABWgAZSBA4hDQyAAZGBBMYCDQ+ADxICCHKAFeABCIEEAIIXjQMKQQKCBrQDRQ0OgRqIAWuBH5KAARADIAp0gBR4gRSggBrSgAAtAwkhCoMgzoERfoACUAMIQcGAAF6AAtKGAMuAABgBdoIWRwZrDgMAAQKABOgBHoENdIIfmAUIA0BBkIAKBoAP7QGQghokARGBICIFdGpBCDuAAjSAAAuAIFiBAF+AACcCgAKAH0YBBIAAB4MAJ4AFCYAAJwEJgQAngAALgArZhAAnApgCggBOAZiEACeDAE4BB40AToAANAGgigBJggBwhwBJgSB3gAIIA0GgK4EEewKgPIMACQMgFEGAETYBDIAFgwERgAA/gAAXgAARBwxqIBUQJBqCAFMBIIkAUgEFjABSAZyAAE4BPIECqgEcgwBKgBCZAQyAIJYDEUEgigBJgAJ2A0EBOoAEcASgKyEdgQFXAR2AA1GAA3gBiYADeAHQgAOEAViAABOAAEKAA2sCQceCBDwCQQGAAqMBIYAKNAQKQQNrgAKngRXuAiEHgQAdgQg2gSB6gAERgQHsBB8LQcSBAZuDC9ECwguBGTQB0YEAEYIcR4AASoERF4gAQ4UAPQIMGoEAGYAX/gEFgAYIAQqAGJaAAByBGa0CQR+CE66CB+mAAh+AAXaBAh8BBYQCH4MBboMS1AMFDAKABWeAAVKBAhsBBoAAVAEKggCRAR2ABZOBCHID//8DgB6CgAAJgCT3AhB2ggsuAkHdgxKfgQChggqqgAJmBBoLQcKCAEABAoEACIMSVoAE/gFEgABagAi2gABUgQOMgAQWgQBbgACzAwJBw4IAJoIC4gNEIgOCCDmCFNiAG+ACAyCBE7EBEIEACoECiYAAKoQDEYAAOQESgBWIAwMQJYMjmQFEgAWJgABkgAAtBBJqIRKBADYCayGBADuAANaBGlCAAA4CBAyBEzCEBckCDBeACNOCAz0CDUuADFmNAR2FAzyEAR2AA3QBaoMDP4IBHoEBnoMAhoEAUoABEAEfgAEXA0GBAoAaKQFkggAQAgV2gAATgAA7AzYCaIIAEAUKdkEPcYAcVQEigAkgAWCAAE4BDoMBvQEOggG9AkEegiHeAkGhigFKgAChgAAMAcWDAjoCACGABCOBBZgBbIADE4ADqgMGIAyBCpsBE4AACQcGQRNNGyEJgADLAwYgCYIN1oAAE4EhHoAALYAC44AADAV0LwGwDoIC6gEAgQLqAQOABGABAIEHZJgESQEKowRJgANhgBrygwBpgAAMhgBpgADbAgdxgQBsiwKnAQSAAMaFAquDAEEBFoMGi4AAB4AGmYEdgYEDNYAADoAGmYADcAUTIBogG4EDbAIiDoIBIQG/ghdnhgEhARaBASEBxoQCYYIBHYABKAEOgQ6AggJKA2QiD4EABwRoaiEMgADcAQuABVqAATKAHaMEKAJYdIACwQEhghVUA1AhIoABAQEJgACbgAOXggEFASKAAzwCGHGACdIHaiIjLQABIoADBoAfOIEK4YEWDoABFYABAYkDPwEJgQEVAQmFAz+AANeAAZ8GIy8BAiIIhRV/gAj3hgEmgAAMgAEfggTEgSPbgQEcAiAGgwEcAQuBFlABf4UGaIACegQQaw4CgAWHgSOUgAl6gg/AhgCMgBAwoQCMigBlAwUgC4IJsgJBh4sDswEJgAGTAQOAAvmAJpuBBmeAAgaBADOAJYmBAJiAJE2ADqCBJp2BALsDIBFqgAAeAi8Bgg7AgBYzjQCXARuoAJeEAhuAAJqACyyDAiCAAjaAAFSCDFiACnOMAFwBGqkAXAEHiABcAQeDAFwD/wBxgCc/gCeGgQIiAwQgDIAAKQILaoACFJYBEYAD3YEFPoIGKoMBuAEEgQG4gQHPgAJigwMhhALIgAWjAWyAF7mEADiCABQELwH0BIMBbwKUCooCtwEVgQK3gABxhQLrhAMAgQasAiAPjALyAaOLAvKCADuABEMBXIME8wFwgAM+gQaZggLuggChgQLwgABDAR+IAEMB8Y0AQ4QGcYYGloADNIQFkYAACwENgwBkAciFBZGBA1cC0DeJAzeCA1UBUIADyosDNwEMgAFugATjgQM3AQuLAzeBJuahAbgBC4ADNQIhD4AC+oAAQIAp14ELUwX/AXFBDoEARwMGIQyAAJ0BBoECGgMMIA+BAGYCIRiAAJUBBoABwoIAlYIBqQIgGIAAhAELgCgPAXaCAIcBD4EAhwEMgBjPgQHkgACIgAR8pwMzgQdCggOYgABGAQCAAe4BD4IAnYEB6wEPgQZlgAVkAiAMgAXeAtA3gAAvAQyDAmwBDIEALwELgQC0gA/SgQP5AkHNgwFzARGBGscBIIEmEYUGfYAACYAknQLQN4MAGwLAAIEAHAMAQdWBB+mHAaqAABwDAkHJhQdAgBnNAXGBBj4BTIUCZoIP0oAGoYoBhoAAvIQA7oAIUqIA7oICSYAAxwEGgwDOhAdLgAfiAiAGgQFagA5dAQyBAPGLBK2FAumAKDABEIMKHwEQgQDthAcUARKBB5qBAEeACR2GAkwCIBCBAI8DECASgQCCAhIMgh3lggebAQqBHJiAAdABCoIHWoAFz4QARoYAIoIAGIAHCIQAGIITBYUAGIIAEgEOlABMgAE8hAA0AQ2AAk6AAAeBC3cCQdCDAI+GCSGDCTIBCoQrvwJEIYIik5IAUIAAyYQAUIAA+AMCQcqFAZuAASEC1DeAK6mBAEABXIMCj4EACwFUkgMkAQuDAySCAp2HAySAB2miAa6CAoeBBmKBApcCIg+DKhiCAcGCB5SAAGIBC4gDHQEPgwMdAQ+GAx0BD4YDHYIDpIgDHaUCL4sDHYUCO4ACGoEDtYAEHIIDxYAAiAEhgAzCgQMlAQqFAyWJAj8BD4YC8wHxigLzhgJYgCsQAwJBy4UBYAEPhgL7ggVpAUiHAwKIAV8DIAYEgybGhQMBgRnrtQMBAUiJAwGBAHKSAv+BAKUBzIQFKYYDB4AAEYQCJQEGgAfOggBNgArEAhcggA8fAQmAAe2CGy4BCYEcvIAAGgEwgCS5gQAIAsw3gxCpAfyLBikBB4QAQQE0gCrEAQOBANaAAAyAEJEBKIAQM4MARAFrggcrggAWgAAiAWuBBtyBE1qBC0WBFIcDBkkbgQAgARKBCvyCLo2AABeBHYmBAZiHC1cBCYILNgMJIQOAAT4DEiAFgAEtgQO3gwOngQblgQf7gQFKAiIDgRJgARCAAHmAA8aBAE2AAWKFA92BFP6SAzOAAcSEAQ6BDLSFABuJA9mAA0aEACKACFKIB0GIBA6BABaEDIqBEZ4BEIMS4QEShiIFgRQ2gAblgRF9gAFBgQlygApJATyHD58BLIABXQQQIBdGgAhVgAP9gCmBgRG8gBgSgSYJgAARgCsIhBCHgBVdATiDBbyCGDeAEh6BFXACKHSBGhKAEj+BEiaAAG8COCCBFbGCHLUDLCIFggAugRGXATCCMO+CADCBKiICLAuDAfWAALuBA6QBBIEBXANrIAWADK6CIFMBNIMemQEsgBHXgwRwgAANgAHoAWqBDNSAACeBAd+AASWBASkGSSIJGyIEgAA4AQmBAGqBAeyBDPeAKH0DBGsggQAXghaAjABPggANATSAIhiACoWAARyDAKsCCUeAGWmAACmAAniAAJYBCYEdWIENZ4EpH4ASW4IRpAIIIIIRpAEEgABcgAAWgRrdAReDES2AEuSCLQUBFIAAF4EVt4ABVgEgggA6gBKxghF2gAPSgRpygABDBBtqQYCAEdyDERiCEMIBRoEAE4ASrYIUOIEOEoEwBYEIfoAAGYABKQcgDUF7IA0bginVAQ2AAJMBF4AAHwENgACZAROAAAiAAagERhshGYMokQHSgwiwAnwhgBFJARSDIBcGGQuUCQEMgBQrhhKngAEhgAjQgAAHgBMngAM0gANCAQ6CB40BEIIatwMCQUCAAY6HJ++CC3OAM+kBAoEz6YEozoEz6IAEwAEOgSBggCGaAQSABWSABh4BDYEFcoEUpYAASgELgADJgSBEAQuADc8CIA2BC+IBCYAEEwQNIAtrgy1rgAmIAU2BLUWCF5sDCSANgAx/gQjUgwArgQAngAGUARCBAEEBCYAAFQEPgBFgAnJBgSOIgAT9gAjNgCFFgCFNggAPAwwgDIYho4AEeQMIEAOBI4GDGTmCDf2DGS4DDWoigABVgABykwBQAQiDAHOEJoqBKSaFK36BAzKBAFKDIP+CAFKDGTOAAFIFCCALSQ2BKDyAAAmBAD2CBmeSAGABDYYm5YACU4EAOYIm5wEIgSUzhCssgyLSgQA5AiAIhQA7ggAsAgcggBa3hzCagRAagAeogBnCAQ2EIgmCJYOBBtWBAYiAMqwBcYABNYEigoEAooALkoEBRIAABwFrgASngAAiAwwhCoINNYMYJIAAEQEIgABhAQqMGcCBIqmGKOyAAB+BBEOABdaEI/+AADUBGIEUFYAAEwEMgRDchQBFigAmgAAfgAAYAxQiB4AWoQEMghnEgAAPARCBM4gBAYAAEIEZxAENgAVJAQ2ABLMDByIKgRnEgAEiggAwgANvgSLMgAAQAQqCADGBBU6AA56EAYaAERaBBkWCGaOAAFEBHIEA8IAYPYIZo4EBnIABZ4EZo4AAjIAAR4sZowEIiBmjAwwgEIQZowEQgQAsghmjggAKgBmjAQqCGaMBCoEFQAEYhAC1gAAoggDZARCDAQ2AEM2DANyBBo+CABkBFIYAGQESgw7OhAHKARGHAgUBEYsByoMB75ICigEShALajgA0gAIQAhIQggX/gAf5AgcLggCYgCi2gQbegQRJgBgtgSVlAxpBfIArbgEOhCPzgBBTAnEbgilIgQBMgRD2AwdLG4IAOgYJIA4gB/yAOmaAA8cBEIADFwILIoEEAocX2wE8gAAHAQ6ABceABA6AAC6ADPwCIAKDAC6CBk2BBluDF6qBACyBBluBBFODGbKACAYBEYEk9YEAHIIFKIAHO4EF24EFI4AMrYAaOYEf2gUYdHILCIEE6gUFEBALS4AZSIEXDgQEf0F+gh43gCExgQZmgQB7jRd4gAAdgDOcgwAXggZyiBePgRj8AR2JF48DIAERgAengQCcgADkBQAQAgsQhAAehBfSAUCMF74FDxATC9KBGSuHJUObGRiBCQyhGRgBtIcZGAEmgQ5DgC0QgAEFgApqgAYFA0giBIATuANBD0uCGwwDQYH+gAVDAXKIGSaCGR6CGSgBIIEAKYMZIYAARo4ZIYYAFI4ZIYAZXZ0ZJIEbaYsZJIAAtIoZJAHEtBkkAkF+jAFmAXGAAWaLABIBH4AAEowZNgEGgBk2BIBEASOEGTYBEIIZNgEXhQFCgxk2AQyEAYqEGS+BAm2GCKeCB1oBA4IHWoIOVAHAgwcYgAAHgRybgRj2AiEdgAAXgRlTgBkTghlTgAe0khlTgRlrghlTgxk7gBAWgxk7gggFARyFGSsDDiESiRjzgRSCgBlTgiGmpRknwwACgAHmgAG7A2sOH4IZZxszNDU2CgsMDQ4PEBEDAhQVASQAJhcYBD4/QEGEGWoDCwwkhgAKgSRZgBlsgw5aghl2ghopgxl2AQqBB/aBDkmAABIBDIAMGQEygwAKghZ0hgFiAgwzgRBnAQaDBQmACgQBN4oWMgEGixYyAQaBDGKBELGBEP+AIPWABKsEn5YCR4E45oEAWwEogwBZgBBNASiBBf2ABMKAHPyAAAICECeBAwcBHIAPLoAALgI7AYEpLwEQgABKBEECECeCIJ8BtYgXUIAEFYAAYgEzggCrASSBNr6AAlyAEFeAAwSABT0DdEGAgANugi39BWpBH3BFggMhggjBAwBBuYsMaIAAQgEHgRafAQiDF9EBh4AO0I0AHgIEdoEDxwNxIgmCDTiADUYCB02CAMYCIgqABwcBCoAMXYEpvgIoIIAhFgQFT3ENgBaXgAWmgjq4Aa6LDeEBA4AUYwEyiwFGATakAUaCC9aABpCCEhWTAKuAAbYEB0GAwIE9nYAAHQHYixL5gwHTASSEGF+BARiCBDKBNo+BADaAOBGBBGSBNOyDAAuAAXcDOgAIgAc+gQArAjoAhDv/gQGagwGPgh0kAwJBtoUTRYEIwAEGgwDbgxlvA0UNNaUA24gAmIEOToEMtwMtABWCJPSLAJSCCIaKAIoBBIYAigG3kACKhQFlgAwMrgCKgAD3gyK8ggFzgSAWmQCYgQKskwEiAbiLAJiBACSAPBsDQYAIgQGnAQeCERmFAKmBAASLAKiABLyAL4CKAKiDGqKCFq4BNoIamIICfYATlIEAvIENJYAP34EI8YIDV4AAaIEAo4AFvIUArgEogACugBvykQCuAgwohQECgQAngg2oARCAABSKAdQBMqcCr4AICoECWoADh4ADj4A8y4ECc4QDlQQYdnJygwPpgghuATCAAScBvo8BJ4EQVYMIrYEIloAC7I8O8YARF4UO8QRBAiEXgAEShgRKASiMAGGDFHsDCyAdgB8UAg0vhB5PgRohjBoGgBhuhBoGAQ+KGgaFAOyGGgaHAOmkHk+BHkeABjsCpDyAAE+BDG+BHWWCD+7/HlyXHlwFqDxBsDyCJqEBzYAABIEACoACM4keXYAAGIAAEoAeFQMUECmgHl4BrIAAUAHNggfagikfARCJHl+KAEuAASiCHmCBAdIBqIEBK48eX4AAQoceX4MXxYE7jIAR8AEGjR4bATKfHlSTADkBKoEAGYQeVIAZlrceVIAATgMGDDCpHkoBBoEAfZMeRAEGhBizAgwtnh5AAQ6AAAoBDoIeQAINLIANIZIeMwEMgA+mgQApAWuAEDyLHjOBBBOFHjMBJ4MEC4IPyoAECwErqAQLkh4hgTmHjx4jgAGbAWCAAD+AHiOBAYyCHiMEBUEeSYEl+wFNhQfBix4qASeKHiqACNeIHiqAFZqDHiqAGWGCHiqDGCcBC4MeKoIcm4QeKoEa440eKoBFTIEeKpgEJIAbR6EEJAEKgQBpgAS0gQBpgAAMjx4qiwJ9AQiAAMaLHioBFYMLkYAAB4geKoAADoALnwIhDYgeLoADOgIiFoIBJYweLgEmkR4ugR5DiR4qgQHhgBGrgT0piBrzARODGvMBGIYWcAEGggEFgRdSARODF88BGYEXT4AdNIQXz4AAvaQeKgEZgR4qhjOpAQ2IASaAAAyFHHIDBSAKggEcAiAKgwEcAQ2LHiqAPQqFHiqAHbyAAn2CAeIBCIQXCIEUcaMX2ocAZQMFIA2eHiqAFOGAAgaBADOMHioBBIIAu4oeKoAgB40AlwEkqACXhAIbgACagBEXgwIghx4qgBnHjQBcASOpAFyAHiqGAFyCHiqAEkSEHiqAA04BC4AA8oEVnwENmx4qggglgQUNhQG4ggZKgQHPgBHwgwQmhALIgBLdph4qASWIHiqBAuuEAwCIHiqHAu6MHiqCADugHioBHogAQ4weKoIAQ4YeJAEWhx4kAwUMK4keJAQEQQZJgBGXA4ICSYIM3aYIsIAFjAIOaoAFFAFrgBo3gQV9AhJrgSgDgRaRgQ7CghaJAxwiDYEXF4ADkoEWwQQgaiEhgAOXgAAMgxtmASKDAA2DA6QBI4EACwFUgAOkgAAHA1AhGYEABwFAgQLIgQ7QAQOBAAeBFheAAAcDMCEkgga/AQ6BA3KFBrSAMJuAAAuBPrgCCGqAGKGCRckBcoIKeYEDTwILIIAroQIgI4ID6oE9DIRBLwEGgQP0gAzngRl0AgR2gQQWgRuUggHKgBtZAy0AAoEZSIEjIoAcU4ADBIADpoEK8QEGgRshAQmAEhWCHdGCAC6CBO2CA9OBEB+CAJiBIYCBAt2CBk0BCogAqIIAnAIIaoAAT4IAeYABAgEEghqmgTyKgBoEgACJgTF+hADfAQqGAv+BAAuGAN+BHPOAANiBIeOBAOYBC4IEyQEihADfhwDbAQiDG+kBCIEDFIIA24AWuIFK9wF/gACWgQC7hEUegRt/ggOIiQNsgQXvghDsgD8SAQOAGuYBGoMAgQEDhAAfgS7tgQA4gACHgQNhgAC3gwBsgwFHgAEighuAgwDaAWqABVgDDCAfgBjwgxs/gBo+gRkcASSBGzyAAdABxIEbPIAbOoAGaoEdGYEXa4EBVAMOICCAACiDB4KAAIkBC4EFmQMOICGDABSBABGAAESBIhaBGQiBLWeCAbKCGvqDAbKCJUSCBpCBQrGBFawBDoEaioEAfIAUzgIiB4AXcaIANoAWOoEEYIAANANrIQmBFnYBDoEET4EAhYAAB4AUuYEZh6sASYABKwEJgQRuAwlBA4EXlogAOoIBtwE6gAFnhQJ/gBT9gQU7AQmAAFWAAjqBAFWAAAeDB5KAFVGAIMKGADwCCUGAQciAFsuDAq6AAJyCAG+BI4ABDIAcS4AAqYQAKIAADIQAZIIACoIAZIIAVoAuT4MF/IEAcoAQJwECgEqvggBmgAJNgQAqgAA+gAWPAUGCC26AEB2EAGaAAOEFLQAEOgCAOqGAFASAABSAAo0BCIMeHYAeG4EBAIId3QMIDB+BHsCBAhmBAqWCAh2AEOGAAh2DArSAANKCCKeCIUuBAf4BGYcALIcDI4YALAELgQnQgiGTAw0cGoAhdoAAFQEbgQDyhgE/gQMegCAsgBsOAU+AJNKAInGBRAiDKKqABPMByJEjD4ADpIoIHIEeLIQjDwENgQNNgAZtqwgcAiANhSMPgABAAgAigAZLiCMPAQuCHV+BJjGAAGmDIw8BE4AAlYAANYMf8oEYgwEFgBvMgBqYA3EgC4gjD4AKDoUf8qUAiIAKLIMDnQELhiMPAQ2PIw+BAFmBARuMCKwBDYIjD4IUw4YjD4Ao2AEIkSMPAsg3gwAblCMPgikPhiMPggSDgAAhiCMPgE4JgQqjiQGGgAC8hADuggqTpSAOgADHhADOiCMPAQuFBI6DIw+AARWBAOaCARWFB86AAjQBDoEPNoItz4si/oAK7YEMXIQDYYABqoIUX4EePoIHUQEKixBlASSkDFqAHwYCIA6CPQmMHZuBRLMBIIJFh4AZO4EHXAFGggecgBHOgSDHgRD4giJGgRGLgQJPgAG/AQODFGGCAJaAADeABK2AAl2DABkBKIEWV4MUcoQQToID2oARQoERQIAZyZwQ6YIAZwIbRoAAMQMAQeeKCOKABVUBEoEs7oMmkIAAEoEWqAGAgAS3AXSDACaTEMkCvf6CHleCE+wCAHGBR/+BDhUCDB6GIISABHKCIGkBBoEBaYMAFIAAZo8AHpEAMoAtyo4AFIISxwHOhSQ4hA8Fgw8WAQaCLAKBJDgBCoM3joMOnYAA2IEANAHPgwK7gRZ7hyQvgAECAcyLJC+CAZIBVIADV4sCvoAcOgIgCogkL4cERKQqioMDp4EdGIwkLwLIN4MHGYAcjIgEPYokL4EEPYAZxYQEPYEHvoEeaIUEPaUAgYsEPYUDW4ABIYEILoAFPAEKggChgB0vggN7gSfPhARFiQNfniQvggFgiyQvggQbgQ53gRBpkiQ0gAFkAiALhCQ0hQQmqic1jAQmgyQ0hAQmgyQ0iQDFgQ03gACEiSQ0AQ6BNTWAKX6AAMCHJCqCA9GBAeiCJCoBBYwkKoII7o8kKgEShiQqgAoUjSQqgQBEiCQqgAAiiiQqgSIugCD1gyY+hyQqAQuDJCqBAB6FEUGJJCqAD/eLCLGOJCoBDoEkKgEOggBNgAUThiQqhie/iANggSkGjQAUhyghhwAUgAA8hQHzggT9gThtgQEDgSvPgA1nggFVhgx4gRJ+AgN2gCFugx28gAWWAWuBEYEBIoQMngETgCNogAh0gROFgQA9AQWBTJyAE4qBA3aBCDMBBYIByIEMposbGYAABwEEgQR9AUeBBP+EBraAQr+BEt+DJKcBBoFUmoMVwQJBuYcSlwEUgAkUgxbyggFegUXxgSzagBKWggHqghZ2gB+hgB93gRtxAQ2EAAoBGIABnoAABwEUgQHEAQWBAgOADNGADKuAAZaAJEyBGriAHTkDC0sbgRLQgAAmgAoYgUSQkBjMhBbrgRL7hBeWhRL/gQD0AUSEEuyEEvqAAF2AUSqAAL8BuogRLQFEhhf9gQDFgQa0gQaohA93AWqBA80BA4UAx4EfrIFE1gEcgVWbggK2AUSACHiAABEBIIEkc4MSC4EAdYEIMwIgA4IU4YFRyoECQYEBGAJJG4ACPpYYaoYAygEFhADKgQB/ghOugA40gADCgCDkgimehBfGgR4Ygh2qgADGAbuSAM+BDNOFAM+CFNmVAM8BJI0AzwEo5ADPgzYliQDPgRzVAkG8iQJdAQWBAfWCBM2HGfSBLvSgCEWDAJyFAJGAAuIDLwEcgU7wAwBBmosJgYIXwIcYnYQaKAFBgDowgCb7gADwAQmDG1GAEhiMHMyMGIKBBGqAFDmCBGgBFIAACIoI+oJGeqAI+oEIpIEjc4IDkgEggVLLAwBB0IoFFYIApYAF6YQXyYIAuYMHo4AAGwEWgRaWgQCpgywOgSwfgUAJpRC7hBN5gQVhgTTHgAlfgVNMgySngShjhyhiAQiBCvaAABCJKGKCCw+WKGKAAG4BOIFKtIUoYoMokI0oYoAAmwEsgQG7ggYvgAbRgQfZAQiABZaFKBWQKGSCKAcENCIGaoAAJwEJgAAngU8ugCWJgSWNAUmBIagBCIAAOIESw4IoZIAAI4AFIYAQBIAmeYEoZIAAlpMoZIFO84AC74IowYsoZIIPXIsoZIAE3IMnnQEEgQGFhChzgEyChShuggDOlShphQKmhwrPgSEqgACmgwq4ARyBWaKDBweBCtSBEQ0DCBAngySPgQALAigLgQFbgQKOgAAHgijxgQXauSi4AQWAKLgBBYMouAEFggCVARuCS8kBHIYouAEXgwJkgyi4AQuAKLmADMQBEIMouQEXgyQjAQeHJCMBJsEkIwEKg0DqAw8QP4UACwFxhwALAR+AAAuMIosBCIAiiwLXJIApQoEhuoFPOAIQNIEiQYArJAIAGoIC44EBY4QiiwEcg03ZgFWegwCZg0qfgQDqgwE0BQRBmgVHgCtdgRpgAYeBA4uFKZGAJteCAx6ADEiAAHmABDCAAXiHA0KBAa0DABA2ggApgwcfgAIdgwE5gAdfASiFRpUBBIBWdYFFNgJBd4MkNQJLG4EP3IQAEAcDQQRKG2pKgAC2gBBCmCI/AwRBKoEQgYIAqoNEToAEcwELgTCxgAB3ARiDDqYB8YIEpIMwDgMwQQyAIUgB8IEY4IEEOIMAsQGIgACHAUqDBgoChAGAGdYCAkiAEoEBwIEIAgEDgBUKgAAMgAJHAcCBUPkBBoACA4MbX4BPNoAAKQIgcoMJdAFsgSUUAh9wgEChBEEfcxCCCGIBbIIX/wQALwEygQAQgQAJAzAQPIEBSYQNAoMFQIIAm4IBLYEBOIQEc4EAYwMEQTmDUfqEBXiCAC+DBhqBGYqBA0uCAHqAFVsBH4IOl5MAHAGLgRxvlQAdgCEOhkzogyMXkwAoggoV7AAcgB77gkjPggGQAQmAAeMBQYBGy4MDzIIBroE2lwICSIQBjpEARgEggBKFlgBigQfVjgF+ggLUgwKigALmgATxASSBCv6BAyaADEWBHtiAC/OABRKBCq+BBPaBAvqECgeCAF2CALKABLGCAH2ABpwCR0GBBGYDCBtyggC4AQOAAAiCXdOAAAgBEIEITQIbcoIAhIAAX4IG1IUATYMcQIAKH4QASYMAqp4AJoIi0YMAKQMvAQagAE8CLQCBE4mcACa9AX2CALeCRYWcAI6CVlmBTU6BCvShAQyZACaIAQyAAcABC4ABs4IYxIAEG4ADQ4EGn4EAN4IDUoIdZYcKQwEgglsygwOBggRbAcWAJpkGBQIJCQkDghSLAduAMFmBUaUB54EMLIJaAoICLoIoTocAxoAHbwIvAYAG6YAG54EOLYEAbYEEaIFD+YImgIJPvAFPgwPrgAoXghm4gADSgjGCASCAAL+BFpGGHtCAEbuCBzaCACMCLEWBBHgBT4QZlIcA0IAARIAGpgFrhQDTggBJhBIwhgLcgRWlgQwTAQaBBPaDDvKDAuuDQLmQAIkBBoUAhAEUglKdigCHgAClAU2RAIeBAL2GAVqBAVKCE+KGCbyAAD0BHIMGEQEUgiBzgQAThAEjgU1PgADvgkaLhADqAQePAGOAGPeAABiFAGOGBTeCAfuAAEqEChWBIPmBC4SDAQqEAiGAEzyDDAaBBb6EAjOGALeBAjCBDuOEBQ6BAIGDBg+BYPKAGBqBB2OKAIaAABaPAOkB24IA6YYARIIre+MA7IArFq4A7LEA6gHniQHLgQNXgQDIhADUgBdjgh1RhQCpgRPDg0tnATCXAImGAB6aA8uJBwaBAIeNBbiBKUeCAs2CNmaCAAqCD66CAAqADAaEAAqDAI6CK3aAADgBdIFF84FJqIED8oAIP4E0NYQIV4IKc4EE/YMHFQMBEDWCMCeFCOCABQQBAoUfnwMCQZSBESaDRHaFAFcDAhA5iABihBUJArQtgwxCgQmrgAAdAVyBYO0BToFkWYELnQIDaoE8xIEADAFsgAOmBEEBEC6DACYBbIId8IAGfQMQNkGABXSCAAuAA6MBG4MA1oAAVgFggwBAgQArhgHzgAANAqAtgUiugAFNAqAtgUhTBCgCmC2JB3SwAB+DAbCBEg+BFD6ADCuAIAmAACSBHxWCADSADPGAEk0BdIQAt4EPK4I/IIIAToEABgKkLZsA+4EQsYAB448A+IUA9IJhNYIBIwKgLYIObJ4BRpkAToACNYMBRIEBv4IjWIMhfYIAy4BF/QKDAoIVWYYBYwFsgyVogQHaAgFFhwAlAklxgA+VgDioiwAqgSFHgQ4ygQCVgBbHggInhgICgi3iwAICgQLsgwEMhCrJuAEMAQeEEWKAAK6AD7OCET+CAO+BWueAMvQBAYFJ0oANxoEV44IPA4Id/IYACoBi0YEzCgGCgRtkgAkGgBFoiQACgAT8gBvygBE6gR4vAQiDWXWAAAyAADWAGfSBAAqBTyuDAAqAAx6BMjqAAAqAC82BY6WAAAqAIKKAXYaBAAoCB0eBPR2BGMCBHoSAE+mBFdOBE7YFA0H6AUmBHreCEVuCP8iAFd6BBAOAIsiBAAqBLMWBHMwBCYJN1IEcrAEJgk26gRyigh3DgC/CgQAKgRDHgSJ8gQENgAnLgBRfgADUgl4Hgjl7gQcFggHjgAMggQMJAQOANLCAL3eCAHCCAyyCAyqBZB2HC3aBACuFAB+CBNeOA2qOAB+BAFqACAOCBaiBG20ELQCQIYADdYASjQJBhIEffYoDe4Au74IuRoMCfoER6wKIE4IAHAGIgCTjggKogicSgQOYgwyqgwOYggKUgQB/gRYUgQHmgQQ8gQNUgwnJhgDMAQOMAK2GAB+CAE2OAMyOAB8CIAWBAB+CAYmoBDaEAJyFBDeEACy0BDeAHeiBAO2BTj8GQQxsQZgggGi3AQCAM/UBC4AATwF+gBmMgzFyAZqACWiBV9gCQX2ANpSBNKSCADwBBoExVoYJ5IAA3oAExIUGCYALCYAKHgUAAQEBAoJU3IABewK4LYMDoQG8gAEKBXRyIgY7gAASghDCAwNBDoEy1JQLLQEGlwyqgREjArktgwyugFXkhQBdAmt2hABdBANBDWuCEbuAAt+AANEBNoAAHoQAcQEKvwBxgCgygQDAgQBzAkEJhABnAgdqgBRDgQBlAhAtggUQhAeaASuBT62CAaqAMZuBD8SCZkSAAA2AFxmFKHuBIluBDQqCTg6BAfyFNAKABRiCAAiAAbuDKOeGED6CACKCB7yDEJiBJK6CBVcBGIECDARMDQMagwhCgQHcgWdXlQDVggOQhAAqlQAjhQhsgA+ymAAmggAjAy0AM50AI4AAC7sAI4cAjwEKnwCPg1EKlgAjghUlgh/cgGp4AXaLEJCDAyoBGIFniAFKgwbIgGaVhlyIAkULgjTzAfqBJyQEQXsLHIBP7og1CwEQgAxhhzavArsBgDaMgRJwixL3gQ63glZcmBL+gAAgAUScACABQJwAILATXgF9ghJoAfGAE/0BC4FQ1AEBgADEAQmCE0sCbBCBcHOAACcBbYET6gcQQAu6CQEVgTXcAUCAJWSCBtICBkGBOZODDdYCIAeBEoICCkGADTSCZvYCdGqCBOWABPCAScuHBPCAABqAFvmCDXuCV76AF9cCIQmAbgwBDoEj+oFA3YIAQoAQTYIAQIEKeoAADIEkY4EAMoEkJ4AABIFOSoAW2YEZpYAlu4EsBgEQgB8JgiomgAA8gi8UgAA8gjtVgi8UgSNEgCG/gQAdgUo2hAOKgySKhABYgRuOBAhLGyGAOd6ADFEBAYImL4A8H4EA04EAzIE67YIAuYIAQYIeXwIgaoEAZQFrgAkAAgBOhGhRgAALgAIXgQCxAkdygBkegjGogCLQATuAI7KDAFKAAO2AAK6HAS6HASkBIoEJPgEKgwCfhAExgABagwEzgWEhgixSgAANgS5jhQFBAkETgUDJgE+KARWEBYwDAA4CgAuPgT3IDCESQe4IIRVBrgghFIE6bQF/gAARAvANgAARA7ANIYAyQQEBgBatBA9BCUuBaXuAZVyBYOABAoAU7QFxgGnDgARZAw90IoAHPQNrIReDEfCAKZOCDWSABIOBCiOBY84DdCEYgAosAX+BEcECIBaFAMKARQOAFDEBGoAyhgISTIRCNAHggjznARSBRSOACimBACaAQWMDBiAVgQdoAwshGoEk7oAIXwIiDoEBYIApw4BGaoMkzAIgGIIOLYEeZIA9EwEHgyyKAiAQgAFJgCUCAQ6BJMsDGSAagQP1gSZCgl+oAwFrdIMBYoE+EgF2glxhAQeAWWCJAhOGAoiAAbSEAoqAbMWAIcyBUswBB4FxF4AAy4FRjQEGgh9cgijBgEx5gwGwghzNAQyDChSCRUkDAiAXgCBFgRpQgwElgQAYBSAPIgkhgDdshwDLgQRQgQC2gBlMgQC2gRVPgRPWgD8kiACygWIHglmngD4JgmzwgwCYAQCCbV6AAJiCAqODX+8CIBOBAFaDWyCAJKGBAmMBDoEJ4oApA4YBiYQAB4Ifk4AApYEg3gFGgADKAQ+AbNeBPZqDGRkBS4Il/wQgDBsigEflAQeAALIBGIIBegERgQFNgQGTBAZ0IRCCL2eBA3EBDIAvvIEhoYA9cYEBToJKM4IC/IAFUAFKgW2bgDzfggJUgQJNggIgAyATaoACRAPTBkuEAlsFE0HRBEuAAl+CFEqAAtqAJUCCRa0CIA+BAReAAtWDCSCAM7WAUtkBdoEBMoAhOoED0oEAbIECNIMDrIEDyQEAgwMPgT5vg04QgwMdhwOTgAAYAQ2BAAiBAzyFJ0EDDgsrgAFfggHLgATbhB/hgQSTgVzwgQAHgmW8gGr4gW8AgwT1A2BB1IIE9QLEA4JxZYQ8goFV5QHVgRgkgRcbAdWABnSCAAeDUS8BAYEdcoMAHoMlpYAQVIEmy4ADNIEOkoFRBYAcz4EoKoEMDYM364AOYYAIxQdBoIbi7X5zgiASAgFxgXHngzBohBwSgAoagAoQAcCAb+6BABaCIaqBAGiBHKKDbyABc4Agu4FrpIAuKAF/gwKuggDlAyADc4InW4FyYYAAPoEQSIAAKokA8YUCXYAAQ4AYjJQAM4ACoQIIdoEAHoACwYkAHocAGYAC4ZMAGYAcDZMAGYAQuJMAGYAHMpMAGYADIZMAGYA71YoAGYIA4oAdUIEA4oAbRIIA4gMLvQWCB5aCA9qAACGAPKCEXiGBCviAADGAAPuBA60E8f8Da4ER+wRB8P8DgCDEgWqOgXKlgXaGA4CAPIAKF4AAW4IAGwMgAHKBWbqCdRKBHpiEAXaDAVSGAFGBZsKBdD2CAXGDBvSBAGMBcIAAUoEHc4EAbYFjLIIAUoAAUIACKQLbAoEMgANBsCuBD3iAbEmCDjeBAmeDAE2DAA2BMtuEAAuBDZmEAAuAb0qFAAuAALaFAAuADiGFAAuBFMCEAAuADtCFAAuBDUyEAAuBae6EAAuADqqFAAuAQOOFAAuABAmFAAuABZiFAAsBDocACwEPgQALgnWugC0IgiAsgCGJgQR3gwD4ggLZggAJgQGkArArgwGlArArhQKIAQKAAr+BAVIBEIcCyKQBUoYAWoEj/4QBzoJsS4ICuIAADYQAC4FmI4QAC4FxyYQAC4ABMIUAC4FooYQAC4FmXIQAC4FsqYQAC4ABMIUAC4ABMIUAC4E/YYQAC4ABMIUAC4ABMIUAC4ABMIUAC4ABMIUAC4UBMIACZIMBDAEQhAELgRezgS9aAnRygAFEAwsLkYkJeoARooMInocJfAEGiAl8ggUQhQl8gCjFhwl8iAjyhwl8ggBCgTpeigl5gUV3hwl4hGZsgXA+giR1BEHAAjaBDMySABeCTJKBFZGPCa2CB0+BJFCjCa2CCR2DCa2ICjeHCa2ALDyCAFyAbpiECo2CdCiABh2BCYyFLmiAEDOICa+ACMoBToEINYBbzAEggENVgWGnhAmyAg0CgFXfgSjkhgmzgQiEgD5BjAFnhwFihURoiAFqgQh/hAm1ggAXASCBCGuFAI6CBbkBFIAGzwUFIhMhFIwJtQKBAoAJMQmgDyEUQeAOIROBCbWBCUICoBCBABEBD4BaUYAHWAENkgmzAgQagQAbAnQigEraAWuAMiCECbQBDYIXHIEJtIBUJYAAIYAH0QEWhAm0gACAAiAVhQDDgCvAAWqALtMBGoAf6IADdoEGqgEOhAm3AROBABOAE4OFCboBDoABdgEUiQm6BA9rIheBAWuBCO8BD4MJugEHgCKBggs7gijzgAbZgQfmAxggDoEH0gMYIBeBB+0BGIMJugEGiQm6ggFpgQfJgilNAiAGjQm6hQLGgAG/hALIggkiAQaBCSIBBoEJuoAAz4FB9IM5f4UJuoF2v4gA64oJGAEZgClKgEaAgAAoAQ2NCRgBD4AITAQPGyIPgRq3ARGACVaHCRiAAPGACvuADKqCCRiAKcCAUESDMYCCAKyBVimDAmWAUdSBCRgBB4AkUoJldYIJFoAj9AISaoABpgHUhgkWAxJB0IIJFgEHgFQCgkX7g07lgE6/AQ2EMO6DMP8BEYAYfYQJFwELgAp+gAM8gQBrgAGRhAMWggkXgAM1ggyqgSzbgQAYgQKKgAKAhwL8giXJhwkYgQVugTXXgjBOhwqoggGkhAqohgp2ARKECnaCNjGCCncDCwuqgBHygQdSgRY6gTIzAwFBnoISRQQAQYgTgAASgAJJgmzJAkEegwAVAfyBYfaGABUBE4J8a4AACYAAWIMD4YgF0oABMAM7AZSAbC2BDqACsC2DRRIBqIAACIEAEAKgLYEToJIAOZYAGQMLrwKCAKyBD++BEi6BDwKAEkABBIASnYA8xYAAEoF04gEEgxKdgg8ugRnIgxBAgkQpgBBAghPBlAAcgAb4gxIsgmLNhABdgBKdihKbgTJGgxI0AgAQgEX5gwBKhxCmgwBKgjValQAchRELlQAfgAL7AXODFTCUAKiGHhODECKEJI+BD+oBEIA3E4MANYBtRIFAYwGngBPQgkdRggDMAwFBCYgBG4EBWIRtkIUA/wG4hAD/lQAgggEfgxK9gBKvmQAqggBKgiIggwGZgQCAgm76gAH7gQE8ghRwgTkkgQA6BMAtC6aFAKmBAeCEAK2CSie8AK2FAIKCTUqBClABSIJtXp4AVIEAP4cAuoAKgIIB9AQLC/wKgGgFgwarhQX4gRtcgxJugQwyASKAKw8BLIETvoEKnYEDVAcJQf+A/59/gjSsAQaDP3qBDB2BB0CBGVmDBzaCIyOABTaBGWyGBmKABxWCAuoBAYFwOgMvAbyEAAgByIAACAJBIINYfIAMh4E9KIAcroAMW4EAOoAhtIIRcIUWKIEYFIQpGoAOX4ANaoIpAIEBFwWYFmoQL4IACgGkhgAKgACwgQDFBJwWEDCCABCABAKBABABqIUAEAGwgwAqAkH+gYAdAkESgQYjgAECgDVggQZyAQKDL7OCN50B8IBBxIMA2oMF5oYyD4EATgEtgQAygBe6AwVBEYABgIEEEQYoAqwtQQqAIsmAWQ6ACm2AJteAAAqCLFCAABuAHKCBeOCCEYaADXyBHpKBGrSBTt6Aeq2DHmiCJjECECuBAICCBByDdcGAAnOAGA2EACGAFVOABCeANWsCciKARriSBC2NAhGJA8eXAmGBOC2FArSEBC0BAY8ELQJBoIBBjAMaEDGCAoeBJhCEAI2CdwKGAIeEAJq5AI+EAz0BDYEqpIEAmoAAlIIKi4Q3AIRMRoEAk4EB6YEt9gH+gls+ggHogUlaggEXAQyEAJCBIYuHATK4AJgBBYIH04kBKoJuggELggEohABngWwKgAKxgH88gwChgACKAQGHAIqAYzDCAIqDCF2WAIqCAGeCABKHAIoEBkH9/4MBJYIAkwENhwEdwwCTkQEfASKAPaKCAksBDIIAmYcAb4UAGAEEgACfgwHKggQ0AQqGA5iAA+uCE3UBCoJCtoEcbooDk4F/a4YAR58DBYEnV6AAwYEZz48AvIgDB4kArIYEDoEEcoAAkAMJEDKFBHCAZ84BB4IADoEgqQExgReWgH0YgiGJBywLC5YLARKBDT8EIGsiD4AqpIJ1Z4BhrYIXj4INCYEX5oElogEAgk1NAtDHgAhxAdCCRymBAAQBSoKDbwNB2CiDDtoC3BaBVeMBf4MVFIIMF4Fqa4ESWoBXbwEogW3ZgBT/ggDagQCkgFd8ASiAAUuFOeCBLzyBFG+AJjmBVP+CcE6BQtiAH0mAgh2ACPiBAMGAfvuDEqGDBPeCHB2ABO+BNG8CCRuBFoSCbjKDBP+CE5+ANG2AACMBrIEajAELgXQrgwBSgB4bgAG3hQGiAdCALZSAChWEAJCCFVSEcM2GAHCAa6GCLFeCCgyBBgWBCduCAXOAAV2DJiCABmyCAPSAB8iDBrkC0CiCABGCAO+AAISAAF2AABUB4IAMBoICQoIAh4JF4gLgFoAAEYAfRAIQM4MAjwHUgACPgjGlAdSFADKCHwiCAJeABm2EAP2JACaFAB6EATSCIYKGAOoBBYMK4YMMcYEA94INhYN4QoAMKIEfuYEWFAEEggAKgBokgR7JgADfhCHNgQr7gC1NgwsCgBw/iACthEPxhgHcgCshhAaQgwCcgACOggCcgwHhggDKgw8MAbyAAieARc2BGfqAcEqBAmYBCYYCcgEQg3wZAQiDW1ABBINOpoJD74I0hIAKRoI8T4IsCIUcOIYUEYIx1YEMrYMAhIMBYYUK94AxP4IJ7wHUgACtgACUBrwETBshEoIHboIBzoEjGIAv1IAx+IEvNoQAPIEktYAX84A0QoAB6IBSZYQ8YoFDwYEANYEHJQVMIgIbIoIXgIGD9oEqEYEFdAIgDIIV/oIX34se14IU8YA+jYEEIIBIMIFWRIMAbINsZIMHzoAAaYAAfIABpQMQamyDB9GANB+HAtmAQN2AFkeAAIaAAcOBACCDAt+AAMqChuKBRyiAAHaCRNkBAYICg4AB4IEK84KAvYE8noIO3oEI0YAASIE6poIOOoNIvIEBHIEArAECggImgl+igQ5egg+4A0ECSoEABYAtGoAAO4EAXYEAlIQAboEOP4IC/4ID8IM4LIEtKYQBR4EBEIE+HYIJWIAfxIEBQoAFfIMFT4MA9IAAFIEIVQIFa4QA8oAR+4UDbIUTBYEK4oAMuIIWuAMAQbqAAkeBAU+BEJCEAhyBGvEBf4I6nwIASIECxYIEioINWIQbhIMNBoMAgIEFBAEPgwJJgS/RggXIhgGkgoIfgQB8AXGABdiBDj2CAmgBS4QD6IQ4NIITv4JD+IIAnIUNpgEPgA5XASSAFa+DAF2AhreBHHGAbuWBA3yBABGABt6JAraBhVKAA62AA1KHAOsFC7YCAQmABxmBOSyCgmyCAsaABtECOwGAP0sBQYACQoAE7gRBB0GKgGbHARuALHGDDkaBHC4BCoE6ZoEEhoMBAYJ1voEK2ICGroADHoNCyIIaBYAZooF5K4IW7oGMzIQC2IAv24EET4EFjgFLgRBtgAbOgAVegSe5gAQHggE9gxotgALtggDHgh/2ghYqggcdhQAlgHDohgLzggLYgAtugRCLATuAAAeDQvqBCuYBCYJ1KoEAHQHAgwAdAsAVgweagAASAcSDABIBxIBivoARWAIKQYA7hIEEtgRGIgMbhQD3gCTwgAMlARuEAQ+CATgC0AiAATiDDESAJPqBAF6CCr2CCY2ACr2BAHqDBpCAIryAEYeBQNGCekOCB7YBL4EFDIEANYFDOIIikIMBgIIAkIEOsoIcfIQHlYEhwYIPJIAHp4AzgwIDSIcH8Y0OgokPI40AHIgH8YATp4UAXIAH8YMPgIEFqIAU+4EMeoEAC4MK7IAk7AKQIYFBcgJ0IoEWpAQvAYYIiwCmAoQIgDawgwBLAQeAAKeAAjaDCJmDAKsBB4gAq4EHeIEAj4JUAIUtQ58Aq4BY14UAYIAAq4MAYIEkJoEAq4QmF4UInwYJQRxrQWyBF7WCf1YCkB6BOnCDAIyAAA8BoIA0hYA0mYMAkoAaCoIJSYBJAocJ/40AhoIuOoQAHJYQcIwJ/QEEgAqSgzSVhAChhABqhAAVhQCrgACCgQB6gQq0gQ1jgCbRgUgggA4SgR8eBIECSRuAAXgBI4MBeIAW94AC4YANoYMAt4ECGYBEpokRN4AAfQEGhgDakgCupBE6hwFsgADHhABggQe6hgFsAQaGI9oDCUEEgVsjgAjFgAFpAR+ADLCAADuAAAsDoBwigACLhAKigTSwgQK8hAIVgwB/hytZqgIHgYAYiwFnjwCghwByhQLShgCwgRzFgBhsgiF/AqAtgUNygALeAy8BgoGGLYJ82AMvAYCBcryBAD2EAhSDXbubA2+iAiKBETCFALiAgMuEAQ2AiIqDALaBeM2DEKEFswsBCn+DBWuBBY8BIoAfEIEw7YAs9wEbghsvhAV5iwV1gI/CghzcgA6LgQcVgALygU2VgTgkg00Xgj+EgmoygIMmgStDggWEgwVxgQs4gj3SgBVJghVjgABmggTFggDEgATFgR1CggSagQJ9gAFbgQJ9gD2OjAElgAHyAQWIASWNAeKJASWNAByIASWAXOCEASUBBYAB3YMAYIGCjYQBJ4EACwELgQqGgSXyhR4ngRXehxA4hBRUgXrdgRA6gQX4gAD0gRTlgh2whQDmASKCSSaDix6DIeSCA0+CAqaAHluCAfWZA02iArKCI/mBBWCBAMCCEhuBbjSABByDAfOBG0GGD86CfFeBBraDAIqBKraBAQwELwG+FYB2H4YEs4kDRsAAlIEEeo0AlIAF/IAAJ4IBZAEFhQ83gB1chFsFgSoXjQ8zgQ4TgQBtggasjA8zgQJrgi9njwHtjAU2gHcFgyfhgVCZgA/HgQaFhgBxhAAagCs/gQAagkrKgDwQhHuAgQfQjQE3AcL6ATcB/oUBN4QPmeIBN4APrJABM4NOxIIBJgHEjgEmAcb6ASYB9oUBJoIqHeQBJoMqOo0BJoAIQYN+WYIj/4IDkYIKA4At4gFGgA1zgQWPAQiBBYqBCgOAAA+ALiGBBY8BCIQKBwL/AYCX+4MQmoEJsYEQmoGRooUMkIBNOoAMC4FKnYMNKIMOBYCNHYEAnYAOzgEEgAyugkONAQSAHRKCGyuAAWKABV+FAECCBLKBBKWBelmEMPOBABiALt6DABgBDYM9nQENgSpzgATvgQ9cghCPgAAIgj4agAuPgw1cgBraigBCggBjggBagXhbgQDtgQy3gQA/hA+tgXl3gQEpgg9Vg39uhA0ehQAVgCmLAwALg4EahIANGYKMDoQ7zoF2X4EACIVf84ApfoEACoEPggEggS+3gRYHgz0KAduAG6oEAUEWTYAru4AGs4BfxgSggAJxgCe4gQBNgzb1AQGAm8aCC9oDQSpGgUA4AgVGgV/lAwBBOYEtAYEG+YACXwML3AmCAYaBkPqAQs6CAhQBLIEr9oAG34Byv4EAD4AAA4BUXoIruoMpOYMXo4J74YJ64YMCLgJBKoAWwAJ1IoB5b4EBtYACSIEAFwFsgwg5AVyAJaiAAYiBi42BmLaABI6BAGuAAtyBYhyDFJsBT4ASTwFLgRbjgBwAAUWAZfIFIARHcnKBZFuCLJyEPNCADFuAanOALKmBArqCAs6AW2qAHU2EFgOFABOAIpmGGnCHABaBk/WAJCqEGmWHABiAHY6GNKSDLnaAHKKEgHOBARiBAAgBOIIAxoFD5IEAt4AfvoI33oIBBIBEMoEAJYE3q4KLFIE3fYEvroALx4EADYAD8YIDboIAXQFcggANgVH9gDfGgQF/hRk/ghyqgDWFAhA3gi0NhwARggBWggANgQdeg4kngTlhhBrqgn4/ggFjgBCcghjugQMTgn/Tg35DgQGEggJ8gRB6gYGUggSbAiwigjMagnvKgRyjgi+MgQJjgQEkgQDZhAAlgi3XggPbAWyDAEOAABeAY6iBAdiAAWQBBIKY/IAAkYEuKIE0KIEASIEDw4FFAIQBIAGwgARGAUGDg9SCCUGBAHCCALCAAEKBAAcCtC2BQI2CErcBtIMAGYEwFoQBe4ADUYNBOIIAkAFsgSTPgQCLgglSgQChgwBBgWkGgQq/AgVJgDrTgABhggBIgQC0AVyBBT+AACMCxC2BHueCABMCxC2CDtUBBIM0JwEBgAMkgZ9RhAFCgTZXgSIAgQL+gQGtgBpkhgD0gi8LhAAlggCygQLVggmMgEILgCo5gQBfgpJ7gwCggTnLgQHphAESgomvggFZmAESgEgVhBOsAWyDA1SFARyCAYeCBo6CAnCCP+yBBYqBMs2BG1iDATaADQEBA4ICP4MBLIGUmoMAjIIAOIUBLIAAo4QAPIABToMAWJABJIQBAYAMkoAKeIQDy4IDCIUD54EBDoAy2IIDt4QCUoFG+IAD0IMhhoAQtAFFhQO0AQaAYV6ElV6CAWODgx6DAKgBOIAFMYIMfINHdoGAO4ID7IAE6gEagzHAgwGWARqCOzWAGJmBA/yDA0qBAwGCAWGBA7KBEucBQYBa0AEDgorSAUGAQkuAHV6AJIUBi4Muz4JjnwEQgAqkgy9fghfJgGs+gRqTgZSshAVsgjkFgBo7hQJxgBT5ggN/gi+VgAAYgAANgUSGgQQ2ggANhAPVgRptg4FPggBdgWVqgwAcgjVdggAWgACQBBALC4SBHe6BADKAZCeCBEiBJ6WCBAOCA0SCXCyCANGBAiuHHWiAOaYBGIEyp4M4rIIAcwEwgh73gUB/hBGLhQAThDpohABGgACkhAf2gAS4gAANgSI8BQuECQEPgQd3gSDogRk+gR2ugiSDhwByA3RBhYJaSAEAgTcpggARgAKzAoYCgjy1gzCEgzmvgTU8hABuAVSDAriDAoyABwSCAe8BSIEABQNYdHOAgKOBS3qAAA2EAq4BNIAfAoMWcIBQpYMU04EHUIAJTIIDR4IStYQBlQEsgAB5gUUWAgNrgQdtggQrAhA6gjXFggD7gjU7ggT1g1N4ggA0gDTFgwNagTR/gQARgTTFggMWgAAFAXCABQSGCQ6SACqBjzybACKCNd2CBnaBhJqGNd2AEVyBNd2EFZ+DJUqBb16BUiSBXVmBDn+EEKyBRMCAF8QCkCOBCDCCDVyKADaCAHsBdIIA34EE34ABP4IADQKkLYEUSIEAlYFFVoABgIMD3QKAAYUeEoIV04AN6wFgggGIgRz7ggEkAUiDB7EBbIMEXwE0gBfTgQGMgCyFgQGCg0X7AVSATfeBAa6BLTmBAEmCAPaEBdeBFIqECR8DEHRzgE6AgXH3AUiCbhYBDIMByoAlXoIBx4EWIYJfWYELGIMKUoUAkYIpSYI1A4QAV4AksIA4K4ILfoM2+ocEuoQAd4IEIYAAD4FUqYQCQ4MCbIFU7oMBjoECXoEAGYIATYILMoIANYEASYQ7S5YBxogaprAAH4ML3IFSwJQBvYQ3FYMA1YcBTII3FIIBy4Kb1IFEoIQGToALSoE3GYIAwAECgzcZgQQXgjcZgwBGiATxgQAHgztQgpoMgaJtgwY4gAFgAU+AR+2HOqeEAF6CaZKEAF4BAYQ6V4GXJIE6pI0AXoI6pIQAYgEbg0YtAqAtgzpRnQBPmQCtgUaZgAdfgSH2Awu+BYARsoID4IALqYAD4oMKa4Kg0IEACYI03oIEUQFqgRSLggAdASyAA5qCBJaBB1SBEaaBlb6AGIyFBa8BcIAKVoFeh4QCR4AKY4I8vYQGL4EAHAFcgwR+ArQtgj7kgQuahAh0AUSBAAUBTIEd6YMRy4FEIoEAioABCIIG6oMQ7IAADIJD/gQgCE8bhCWjgAuDhAmAgwyeghqkghjOpQA7gBe5gA3PhAhogIXWgkb8gQJEgwV5gwFiAgRqgAcmAhA3ggASggfYAXSDADCBB9GBExCABYmEAneBCG6CAP+BQoGAHleCHDuHAzqBDQ2BAzyCBA8BWIAxKIAFnIAf7YBRFoEQJoEStYAAfoKUb4NAfoEqL4AD8gEIhAAmggDogAAFgEpLiAXCggE3ASKAUjSCA/uAHNyDAwWCGs6CAWSFHIeCHayCWIOBGjMBhYEACoQCHIE/0IUJbIMJaQHEgB9TgiMLgyUbggEJgCM+gAJlgWAGAYKCOwqBpCIBAYAADIAIhYEjHICKGIVKgIEDQoEISoI4p4Gc0YIPTII8CoAAQoGlpIECroGKCIEAB4QM74AHjIAUI4UAQQEBgp+Wg4b2gQCPgA0CgABDgRRxgAkhAwurBIAflIEAGQF8gRlHgCjfgQAMAXiDAX0CjAGFDTuECuUCLGuAAuOBGcCBBUoBA4Bh7YIFgAGQgJACggDbgAGVgAxUgAA0ggWQATiAHMmBoHWBURaABZQBB4I9k4Eq9YEu9oEE04NYIoEACoIAmgE0gB2AgQGYgx0pgQrWgF3AgQv/gwAvgBnzgk6gggAyAiALggiTgQAKgVo7hAANgANKgz4KgT34gxIwiGYwhj3/gACAggAtgQV9gT3QgAANgAHRgj4FgAv0gTEugAANgDpAgAKSgTEigAANgAnHgABQgTEWgAANgD4OgASegTEKgAANgD4RgAGDgTD+gAANghRqgQVKgQc8gBAMgg9KgC6rgT4XgAeMgSC4gz4egACfhD4egRB8g4WQgF9PgQAKgkAHgB3cAQaDRdOAETUBBoOhO4JbW4Ico4AA14IU84IeS4Ja5oBt5oMCFIAC7oMn2YAC5oBKAQEggiLrAQODTo2BAPmDAXeALCiCAAqAABSBTpcBDIBNGIBf84IDCYED5gEBgQuugS53AiIJgQLOgRlLgQAEBUkbC6ALgRwpgwlzgSoZhAlzhQl1ggIFiQlzAUWDAheBCXSAQJyAAV2AQuKCBX2RCXOCAmKaCXODB/WTCXOCCWyAApWFHAOCCHEDNgJ4hAVTgGUYgAIVgSJAgABPAWCBToiFAFABgIIA74EC3YIJoYQEdIUJpAEEgAmkgwf2gEy2hibRgh5MgAulgAH9AUGAAUODADWBAGeAVAMBIIEA2YgAbIIC3AF4gqObgwjoAQWFYMiAABiJB5GCBjeBA0KAAAmFCeiDCogBZIAP7oACT5sHx4BQvccJ7YEo3LQJ7QF4gR3fggkrhAF8gD9QgAeegACMgCjkgRsVglojgQDdgwahAaSCAPoCoC2OCa6AHeWEHbKEAiOBBQyCNMyJAh6ABZiVBc+DIGSLCcqCGiOECcsBeIQJy4MCE4IJvAFohQnZgQ5zgZHUhgl5AVyBUIeGCCoBBIUIKoCjT5oI14Kk+IAACgFohQWOggX+hAT38gnUhwm4iAlVkAmzggLUlAm2hANigQoOhgiahgoohgD6AQSCobKDAVWUAC6ABJiCqZ//ASGHASGCAgjoCouGAmG4CouBBF6AjxYDAAs/gg+agQAejxcghj/GlAAfgAAcglI2AgRAgAGUAQOAAA0CgweBN1qFP2KAENOAIiWBLjyATW2Al8aCULCOdeuFDu+BFfgBQYAjsIAAMAF/gFCoAQaCpL0CAEiAP46BE52BFj+CMuiAVRiCesqCBTGBNXiBF4mCBtyAF3qCkRUCCEmBIbwCS3KAFfOAUuKCBRCBdj8ByIAJjYFUz4MAcINePYNXjIEFY4KaDQJBKoEQioABX4IWuQRC//+BgmzZAVSAAAwDgICCgFF3ATeAW8SATlOBAWaACXmCVmiCFoOBAAyBWtqBCt2DVJiBAHWBI8+CAOSAAHeBVUSEABaBT4aJABmCAseCABcBTIcAF4JCFIAAHQHEgR6TgABegFkbgDjKgAAJAZyEMQgBKIEAD4AYXoQAMIEEgIFkuIAARgGcgSwPAQKAXrGAe+eDFRQBOIJXqYAE84QACAFEgks1gpMgg0Q6gAGRAYCCZ2yAQRSAeNaCB/2BAH4BiIEjhIALRQGEgQCOgCoZgGkkggpUATaCRV2BQzUBbIAFngE2gAQbg5DfAhA0ggHdgACMgBN2incXgACngY9Wg19ShRIZg0G7gAUngRpRgQokgWVJg0G9BEE5QSqBJY+AAdSCp0+CK4mBAv6DS0qCNWeDUoqACpeAS++BAGaAE6ODCCuEQ/oGQYgRNgK4gI+lgAALgB8IgBRvgo+xgHpvAayDABWACJaAALyBABUB4IAAFQGggwAVgAijgADfgQAVAX6CeBOAKpCDAL2BAK4BLIAGIoRbhIVEKIIoEgFEgDgahDK+ghZehQuBhkQhgiqgAiA3gQbcgQCrgG1ihQAShEQ3AUiDAReAMFsCDGyAGOQClCCBCVoBNoALK4EDbwJBkIQADwGMgwAPAZKEAA8BgIMADwGWhAAPAXyBDmACC0ODGVyBWjCXGVyCDWuBOE2CGVyBAAqAATmAeSgBSYIEGgMLC+OAjWKAAhQEC6EEaYCzYAVmZmljaYCy5QEgg7TZEwAxLjMuMS4xLW1vdGxleQBpbnaAs20VZCBsaXRlcmFsL2xlbmd0aHMgc2V0hgAcBWNvZGUgiQAZD3Vua25vd24gaGVhZGVyIICz0wFniwAyAmRpgLN3AW6AtAmKABYDYml0hABHECByZXBlYXQAdG9vIG1hbnmFABcHc3ltYm9sc44AGAJvcoYAU4YAJIUAVoKz9IAAXYC0QAFrhQCmAgBigAD4gACaDGVycm9yAHN0cmVhbYQADYoA1QstLSBtaXNzaW5nIIC0pwQtb2YtggBHgAAlAmNvgLQtAmN0hQDjA2NoZYoAF4QAmI0AFwRkYXRhhgAViwELASCBANQFZmFyIGKAtJABAIUAVwJyY4EAgQVtYXRjaIYAMgF3gLT0BG93IHOBtQOGATuCAN4DdHlwhwATiwGyggDQjwB1ggAWhQGvBGNvbXCAtSQBc4C06YACDgR0aG9kgDInEwwLpQIDAAQABQAGAAcACAAJAAqAKQcNDQAPABEAEwAXABsAH4CVbhYrADMAOwBDAFMAYwBzAIMAowDDAOMAgAY4ggABAYCMAAIBgYQAAgGChAACAYOEAAIBhIQAAgGFhAACBZAASQDIghjMgK1JggCEAQeAAIABDYAAegEZgCkpATGAA4wBYYAARgHBgEjqAYGBSOyAQBYEAQYBCIApDAMQARiABbwJMAFAAWABgAHAiQB4hQBwhQBoAYaAAAIBh4AAAgGIgAACAYmAAAIBioAAAgGLgAACAYyAAAIBjYAAAgGOgAACARCAAHIBEoAAiAEIggCAAQaAAQIBBYABBAMEAAyAAJaAHJwCAA6AAKIBD4CwMwQOC7cMtQEsgBzVggABARCMAAIBEYQAAgEShAACAROEAAIBFIQAAgEVhAACARDAASyJAICFAHSFAGyBAGQBFoAAAgEXgAACARiAAAIBGYAAAgEagAACARuAAAIBHIAAAgEdgAACAUCAAAIGoAgAAKANgACIgADQAR6AAAQBD4AAVAEggAAQAiAOgwDgAR6AAASBABSBAAEBoIQAFAETgAAEAQeEABQBDIABOAGMgAAEAUyAAAQBzIAABAEsgAAEAayAAAQBbIAABAHsgAAEARyAAAQBnIAABAFcgAAEAdyAAAQBPIAABAG8gAAEAXyAAAQB/IAABAECgAAEAYKAAAQBQoAABAHCgAAEASKAAAQBooAABAFigAAEAeKAAAQBEoAABAGSgAAEAVKAAAQB0oAABAEygAAEAbKAAAQBcoAABAHygAAEAQqAAAQBioAABAFKgAAEAcqAAAQBKoAABAGqgAAEAWqAAAQB6oAABAEagAAEAZqAAAQBWoAABAHagAAEgHm4AgC6gAAEAXqAAAQB+oAABAEGgAAEAYaAAAQBRoAABAHGgAAEASaAAAQBpoAABAFmgAAEAeaAAAQBFoAABAGWgAAEAVaAAAQB1oAABAE2gAAEAbaAAAQBdoAABAH2gAAEAQ6AAAQBjoAABAFOgAAEAc6AAAQBLoAABAGugAAEAW6AAAQB7oAABAEegAAEAZ6AAAQBXoAABAHegAAEAT6AAAQBvoAABAF+gAAEAf6AAAQBAYAABAGBgAAEAUGAAAQBwYAABAEhgAAEAaGAAAQBYYAABAHhgAAEARGAAAQBkYAABAFRgAAEAdGAAAQBMYAABAGxgAAEAXGAAAQB8YAABAEJgAAEAYmAAAQBSYAABAHJgAAEASmAAAQBqYAABAFpgAAEAemAAAQBGYAABAGZgAAEAVmAAAQB2YAABAE5gAAEAbmAAAQBeYAABAH5gAAEAQWAAAQBhYAABAFFgAAEAcWAAAQBJYAABAGlgAAEAWWAAAQB5YAABAEVgAAEAZWAAAQBVYAABAHVgAAEATWAAAQBtYAABAF1gAAEAfWAAAQBDYAABAGNgAAEAU2AAAQBzYAABIARMwIArYAABAFtgAAEAe2AAAQBHYAABAGdgAAEAV2AAAQB3YAABAE9gAAEAb2AAAQBfYAABAH9gAAEAROAAMIFEwEJAJOAAAgBk4AACAFTgAAIAVOAAAgB04AACAHTgAAIATOAAAgBM4AACAGzgAAIAbOAAAgBc4AACAFzgAAIAfOAAAgB84AACAELgAAIgBDagAQCgAAEgAAIAUuAAAgBS4AACAHLgAAIAcuAAAgBK4AACAErgAAIAauAAAgBq4AACAFrgAAIAWuAAAgB64AACAHrgAAIARuAAAgBG4AACAGbgAAIAZuAAAgBW4AACAFbgAAIAduAAAgB24AACAE7gAAIATuAAAgBu4AACAG7gAAIAXuAAAgBe4AACAH7gAAIAfuAAAiBA7YBB4AACAGHgAAIAYeAAAgBR4AACAFHgAAIAceAAAgBx4AACAEngAAIASeAAAgBp4AACAGngAAIAWeAAAgBZ4AACAHngAAIAeeAAAgBF4AACAEXgAAIAZeAAAgBl4AACAFXgAAIAVeAAAgB14AACAHXgAAIATeAAAgBN4AACAG3gAAIAbeAAAgBd4AACAF3gAAIAfeAAAgB94AACAEPgAAIAQ+AAAgBj4AACAGPgAAIAU+AAAgBT4AACAHPgAAIAc+AAAgBL4AACAEvgAAIAa+AAAgBr4AACAFvgAAIAW+AAAgB74AACAHvgAAIAR+AAAgBH4AACAGfgAAIAZ+AAAgBX4AACAFfgAAIAd+AAAgB34AACAE/gAAIAT+AAAgBv4AACAG/gAAIAX+AAAgBf4AACAH/gAAIAf+AAAiBBAoBQIAABAEggAAEAWCAAAQBEIAABAFQgAAEATCAAAQBcIIFVgMHAEiAAAQBKIAABAFogAAEARiAAAQBWIAABAE4gAAEAXiAAAQBBIAABAFEgAAEASSAAAQBZIAABAEUgAAEAVSAAAQBNIAABAF0gAAEAQOAAEIBg4AABAFDgAAEAcOAAAQBI4AABAGjgAAEAWOAAAQB44AABIC+K4AAdIECxgEFgABcAQWCBUoBFIAABAEMgAAEARyAAASAvlaABEQBBYIGBAEaggXqAQWAA9QBBYADuAEFgAOcgE92gAAEARGAAAQBCYAABAEZgAAEgQACARWAAAQBDYAABAEdgAAEgL59gAKkgQZAAQWAAiyBBaYBBYABtAEFgD3fAxsLTYMfuYcABIC+rooABIEHUYkABAEEjAAEAQWKAAQEQbAcC4C9CosAS40AO4UALwEGhAAEgQWIgQAEgQEKgQAEgQGSgQAEgIS2ggAEAQuEAAQBDIQABIAF24FHeQTgHQsjhQBfhQXLAhARgAVtBgcJBgoFC4A6uAQNAg4BgAclBJQeC2mFAJCFAIiFAICFAHiBAGiBAFyBBh8BEIAABAEUgAAEARiAAAQBHIAABAEggAAEASiAAAQBMIAABAE4gAAEAUCAAAQBUIAABIEGvQFwgAAEAYCAAAQBoIAABAHAgAAEAeCAAG8DHwtyjQBvgQBrgQBngQBjgQBfgQBbgQBXgQBTgQBPgQBLgQBHgQBDgQE8AYCvAEGAUc0CC22BAMcBBIAAAgEIgAAEgQEzgQJLARCAAA6DAAyBnqyAqmuEACSBB3OBAE8BCIAACIEAGIUADIEIt4MADAEggQCUgDKEgQBrAYCBCC8BBIMADIA/SAoBABAMAEGRIQv/gCUfgMDAgIKxBQgJCQoKgEk3gAABAQ2AAAEBDoAAAQEPgAABARCEAAEBEYQAAQEShAABAROEAAEBFIwAAQEVjAABARaMAAEBF4wAAQEYnAABARmcAAEBGpwAAQEbmwABARyBffsEBAQFBYHB1QEHgAABAQiEAAGAXSqCAAEBCowAAYAnsooAAYEBMJkAAYEBTJkAAYEBaLkAAYEBpLkAAYIDdYABzoUBvI0BqJ0BkLwBgAIbHLwAAQEdvAABgA9PgH05A9AqAQ==")), e) });
}
let qn, gu, Fs, vh;
function Zfe(t3) {
  if (qn = t3, { malloc: gu, free: Fs, memory: vh } = qn, typeof gu != "function" || typeof Fs != "function" || !vh) throw qn = gu = Fs = vh = null, new Error("Invalid WASM module");
}
function jR(t3, e, n = {}) {
  const r = typeof n.level == "number" ? n.level : -1, s = typeof n.outBuffer == "number" ? n.outBuffer : 64 * 1024, i = typeof n.inBufferSize == "number" ? n.inBufferSize : 64 * 1024;
  return new TransformStream({ start() {
    let a;
    if (this.out = gu(s), this.in = gu(i), this.inBufferSize = i, this._scratch = new Uint8Array(s), t3 ? (this._process = qn.deflate_process, this._last_consumed = qn.deflate_last_consumed, this._end = qn.deflate_end, this.streamHandle = qn.deflate_new(), e === "gzip" ? a = qn.deflate_init_gzip(this.streamHandle, r) : e === "deflate-raw" ? a = qn.deflate_init_raw(this.streamHandle, r) : a = qn.deflate_init(this.streamHandle, r)) : e === "deflate64-raw" ? (this._process = qn.inflate9_process, this._last_consumed = qn.inflate9_last_consumed, this._end = qn.inflate9_end, this.streamHandle = qn.inflate9_new(), a = qn.inflate9_init_raw(this.streamHandle)) : (this._process = qn.inflate_process, this._last_consumed = qn.inflate_last_consumed, this._end = qn.inflate_end, this.streamHandle = qn.inflate_new(), e === "deflate-raw" ? a = qn.inflate_init_raw(this.streamHandle) : e === "gzip" ? a = qn.inflate_init_gzip(this.streamHandle) : a = qn.inflate_init(this.streamHandle)), a !== 0) throw new Error("init failed:" + a);
  }, transform(a, o) {
    try {
      const f = a, c = new Uint8Array(vh.buffer), l = this._process, h = this._last_consumed, m = this.out, v = this._scratch;
      let b = 0;
      for (; b < f.length; ) {
        const A = Math.min(f.length - b, 32768);
        (!this.in || this.inBufferSize < A) && (this.in && Fs && Fs(this.in), this.in = gu(A), this.inBufferSize = A), c.set(f.subarray(b, b + A), this.in);
        const _ = l(this.streamHandle, this.in, A, m, s, 0), C = _ & 16777215;
        if (C && (v.set(c.subarray(m, m + C), 0), o.enqueue(v.slice(0, C))), !t3) {
          const S = _ >> 24 & 255, $ = S & 128 ? S - 256 : S;
          if ($ < 0) throw new Error("process error:" + $);
        }
        const I = h(this.streamHandle);
        if (I === 0) break;
        b += I;
      }
    } catch (f) {
      this._end && this.streamHandle && this._end(this.streamHandle), this.in && Fs && Fs(this.in), this.out && Fs && Fs(this.out), o.error(f);
    }
  }, flush(a) {
    try {
      const o = new Uint8Array(vh.buffer), f = this._process, c = this.out, l = this._scratch;
      for (; ; ) {
        const h = f(this.streamHandle, 0, 0, c, s, 4), m = h & 16777215, v = h >> 24 & 255;
        if (!t3) {
          const b = v & 128 ? v - 256 : v;
          if (b < 0) throw new Error("process error:" + b);
        }
        if (m && (l.set(o.subarray(c, c + m), 0), a.enqueue(l.slice(0, m))), v === 1 || m === 0) break;
      }
    } catch (o) {
      a.error(o);
    } finally {
      if (this._end && this.streamHandle) {
        const o = this._end(this.streamHandle);
        o !== 0 && a.error(new Error("end error:" + o));
      }
      this.in && Fs && Fs(this.in), this.out && Fs && Fs(this.out);
    }
  } });
}
class jfe {
  constructor(e = "deflate", n) {
    return jR(true, e, n);
  }
}
class Xfe {
  constructor(e = "deflate", n) {
    return jR(false, e, n);
  }
}
let XE = false;
async function ele(t3, { baseURI: e }) {
  if (!XE) {
    let n, r;
    try {
      try {
        r = new URL(t3, e);
      } catch {
      }
      n = await (await fetch(r)).arrayBuffer();
    } catch (i) {
      if (t3.startsWith("data:application/wasm;base64,")) n = tle(t3);
      else throw i;
    }
    const s = await WebAssembly.instantiate(n);
    Zfe(s.instance.exports), XE = true;
  }
}
function tle(t3) {
  const e = t3.split(",")[1], n = atob(e), r = n.length, s = new Uint8Array(r);
  for (let i = 0; i < r; ++i) s[i] = n.charCodeAt(i);
  return s.buffer;
}
let uy;
Jfe(Sd);
ooe({ initModule: (t3) => {
  if (!uy) {
    let { wasmURI: e } = t3;
    typeof e == E0 && (e = e()), uy = ele(e, t3);
  }
  return uy;
} });
Sd({ CompressionStreamZlib: jfe, DecompressionStreamZlib: Xfe });
const cy = { application: { "andrew-inset": "ez", annodex: "anx", "atom+xml": "atom", "atomcat+xml": "atomcat", "atomserv+xml": "atomsrv", bbolin: "lin", "cu-seeme": "cu", "davmount+xml": "davmount", dsptype: "tsp", ecmascript: ["es", "ecma"], futuresplash: "spl", hta: "hta", "java-archive": "jar", "java-serialized-object": "ser", "java-vm": "class", m3g: "m3g", "mac-binhex40": "hqx", mathematica: ["nb", "ma", "mb"], msaccess: "mdb", msword: ["doc", "dot", "wiz"], mxf: "mxf", oda: "oda", ogg: "ogx", pdf: "pdf", "pgp-keys": "key", "pgp-signature": ["asc", "sig"], "pics-rules": "prf", postscript: ["ps", "ai", "eps", "epsi", "epsf", "eps2", "eps3"], rar: "rar", "rdf+xml": "rdf", "rss+xml": "rss", rtf: "rtf", "xhtml+xml": ["xhtml", "xht"], xml: ["xml", "xsl", "xsd", "xpdl"], "xspf+xml": "xspf", zip: "zip", "vnd.android.package-archive": "apk", "vnd.cinderella": "cdy", "vnd.google-earth.kml+xml": "kml", "vnd.google-earth.kmz": "kmz", "vnd.mozilla.xul+xml": "xul", "vnd.ms-excel": ["xls", "xlb", "xlt", "xlm", "xla", "xlc", "xlw"], "vnd.ms-pki.seccat": "cat", "vnd.ms-pki.stl": "stl", "vnd.ms-powerpoint": ["ppt", "pps", "pot", "ppa", "pwz"], "vnd.oasis.opendocument.chart": "odc", "vnd.oasis.opendocument.database": "odb", "vnd.oasis.opendocument.formula": "odf", "vnd.oasis.opendocument.graphics": "odg", "vnd.oasis.opendocument.graphics-template": "otg", "vnd.oasis.opendocument.image": "odi", "vnd.oasis.opendocument.presentation": "odp", "vnd.oasis.opendocument.presentation-template": "otp", "vnd.oasis.opendocument.spreadsheet": "ods", "vnd.oasis.opendocument.spreadsheet-template": "ots", "vnd.oasis.opendocument.text": "odt", "vnd.oasis.opendocument.text-master": ["odm", "otm"], "vnd.oasis.opendocument.text-template": "ott", "vnd.oasis.opendocument.text-web": "oth", "vnd.openxmlformats-officedocument.spreadsheetml.sheet": "xlsx", "vnd.openxmlformats-officedocument.spreadsheetml.template": "xltx", "vnd.openxmlformats-officedocument.presentationml.presentation": "pptx", "vnd.openxmlformats-officedocument.presentationml.slideshow": "ppsx", "vnd.openxmlformats-officedocument.presentationml.template": "potx", "vnd.openxmlformats-officedocument.wordprocessingml.document": "docx", "vnd.openxmlformats-officedocument.wordprocessingml.template": "dotx", "vnd.smaf": "mmf", "vnd.stardivision.calc": "sdc", "vnd.stardivision.chart": "sds", "vnd.stardivision.draw": "sda", "vnd.stardivision.impress": "sdd", "vnd.stardivision.math": ["sdf", "smf"], "vnd.stardivision.writer": ["sdw", "vor"], "vnd.stardivision.writer-global": "sgl", "vnd.sun.xml.calc": "sxc", "vnd.sun.xml.calc.template": "stc", "vnd.sun.xml.draw": "sxd", "vnd.sun.xml.draw.template": "std", "vnd.sun.xml.impress": "sxi", "vnd.sun.xml.impress.template": "sti", "vnd.sun.xml.math": "sxm", "vnd.sun.xml.writer": "sxw", "vnd.sun.xml.writer.global": "sxg", "vnd.sun.xml.writer.template": "stw", "vnd.symbian.install": ["sis", "sisx"], "vnd.visio": ["vsd", "vst", "vss", "vsw", "vsdx", "vssx", "vstx", "vssm", "vstm"], "vnd.wap.wbxml": "wbxml", "vnd.wap.wmlc": "wmlc", "vnd.wap.wmlscriptc": "wmlsc", "vnd.wordperfect": "wpd", "vnd.wordperfect5.1": "wp5", "x-123": "wk", "x-7z-compressed": "7z", "x-abiword": "abw", "x-apple-diskimage": "dmg", "x-bcpio": "bcpio", "x-bittorrent": "torrent", "x-cbr": ["cbr", "cba", "cbt", "cb7"], "x-cbz": "cbz", "x-cdf": ["cdf", "cda"], "x-cdlink": "vcd", "x-chess-pgn": "pgn", "x-cpio": "cpio", "x-csh": "csh", "x-director": ["dir", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"], "x-dms": "dms", "x-doom": "wad", "x-dvi": "dvi", "x-httpd-eruby": "rhtml", "x-font": "pcf.Z", "x-freemind": "mm", "x-gnumeric": "gnumeric", "x-go-sgf": "sgf", "x-graphing-calculator": "gcf", "x-gtar": ["gtar", "taz"], "x-hdf": "hdf", "x-httpd-php": ["phtml", "pht", "php"], "x-httpd-php-source": "phps", "x-httpd-php3": "php3", "x-httpd-php3-preprocessed": "php3p", "x-httpd-php4": "php4", "x-httpd-php5": "php5", "x-ica": "ica", "x-info": "info", "x-internet-signup": ["ins", "isp"], "x-iphone": "iii", "x-iso9660-image": "iso", "x-java-jnlp-file": "jnlp", "x-jmol": "jmz", "x-killustrator": "kil", "x-latex": "latex", "x-lyx": "lyx", "x-lzx": "lzx", "x-maker": ["frm", "fb", "fbdoc"], "x-ms-wmd": "wmd", "x-msdos-program": ["com", "exe", "bat", "dll"], "x-netcdf": ["nc"], "x-ns-proxy-autoconfig": ["pac", "dat"], "x-nwc": "nwc", "x-object": "o", "x-oz-application": "oza", "x-pkcs7-certreqresp": "p7r", "x-python-code": ["pyc", "pyo"], "x-qgis": ["qgs", "shp", "shx"], "x-quicktimeplayer": "qtl", "x-redhat-package-manager": ["rpm", "rpa"], "x-ruby": "rb", "x-sh": "sh", "x-shar": "shar", "x-shockwave-flash": ["swf", "swfl"], "x-silverlight": "scr", "x-stuffit": "sit", "x-sv4cpio": "sv4cpio", "x-sv4crc": "sv4crc", "x-tar": "tar", "x-tex-gf": "gf", "x-tex-pk": "pk", "x-texinfo": ["texinfo", "texi"], "x-trash": ["~", "%", "bak", "old", "sik"], "x-ustar": "ustar", "x-wais-source": "src", "x-wingz": "wz", "x-x509-ca-cert": ["crt", "der", "cer"], "x-xcf": "xcf", "x-xfig": "fig", "x-xpinstall": "xpi", applixware: "aw", "atomsvc+xml": "atomsvc", "ccxml+xml": "ccxml", "cdmi-capability": "cdmia", "cdmi-container": "cdmic", "cdmi-domain": "cdmid", "cdmi-object": "cdmio", "cdmi-queue": "cdmiq", "docbook+xml": "dbk", "dssc+der": "dssc", "dssc+xml": "xdssc", "emma+xml": "emma", "epub+zip": "epub", exi: "exi", "font-tdpfr": "pfr", "gml+xml": "gml", "gpx+xml": "gpx", gxf: "gxf", hyperstudio: "stk", "inkml+xml": ["ink", "inkml"], ipfix: "ipfix", "jsonml+json": "jsonml", "lost+xml": "lostxml", "mads+xml": "mads", marc: "mrc", "marcxml+xml": "mrcx", "mathml+xml": ["mathml", "mml"], mbox: "mbox", "mediaservercontrol+xml": "mscml", "metalink+xml": "metalink", "metalink4+xml": "meta4", "mets+xml": "mets", "mods+xml": "mods", mp21: ["m21", "mp21"], mp4: "mp4s", "oebps-package+xml": "opf", "omdoc+xml": "omdoc", onenote: ["onetoc", "onetoc2", "onetmp", "onepkg"], oxps: "oxps", "patch-ops-error+xml": "xer", "pgp-encrypted": "pgp", pkcs10: "p10", "pkcs7-mime": ["p7m", "p7c"], "pkcs7-signature": "p7s", pkcs8: "p8", "pkix-attr-cert": "ac", "pkix-crl": "crl", "pkix-pkipath": "pkipath", pkixcmp: "pki", "pls+xml": "pls", "prs.cww": "cww", "pskc+xml": "pskcxml", "reginfo+xml": "rif", "relax-ng-compact-syntax": "rnc", "resource-lists+xml": "rl", "resource-lists-diff+xml": "rld", "rls-services+xml": "rs", "rpki-ghostbusters": "gbr", "rpki-manifest": "mft", "rpki-roa": "roa", "rsd+xml": "rsd", "sbml+xml": "sbml", "scvp-cv-request": "scq", "scvp-cv-response": "scs", "scvp-vp-request": "spq", "scvp-vp-response": "spp", sdp: "sdp", "set-payment-initiation": "setpay", "set-registration-initiation": "setreg", "shf+xml": "shf", "sparql-query": "rq", "sparql-results+xml": "srx", srgs: "gram", "srgs+xml": "grxml", "sru+xml": "sru", "ssdl+xml": "ssdl", "ssml+xml": "ssml", "tei+xml": ["tei", "teicorpus"], "thraud+xml": "tfi", "timestamped-data": "tsd", "vnd.3gpp.pic-bw-large": "plb", "vnd.3gpp.pic-bw-small": "psb", "vnd.3gpp.pic-bw-var": "pvb", "vnd.3gpp2.tcap": "tcap", "vnd.3m.post-it-notes": "pwn", "vnd.accpac.simply.aso": "aso", "vnd.accpac.simply.imp": "imp", "vnd.acucobol": "acu", "vnd.acucorp": ["atc", "acutc"], "vnd.adobe.air-application-installer-package+zip": "air", "vnd.adobe.formscentral.fcdt": "fcdt", "vnd.adobe.fxp": ["fxp", "fxpl"], "vnd.adobe.xdp+xml": "xdp", "vnd.adobe.xfdf": "xfdf", "vnd.ahead.space": "ahead", "vnd.airzip.filesecure.azf": "azf", "vnd.airzip.filesecure.azs": "azs", "vnd.amazon.ebook": "azw", "vnd.americandynamics.acc": "acc", "vnd.amiga.ami": "ami", "vnd.anser-web-certificate-issue-initiation": "cii", "vnd.anser-web-funds-transfer-initiation": "fti", "vnd.antix.game-component": "atx", "vnd.apple.installer+xml": "mpkg", "vnd.apple.mpegurl": "m3u8", "vnd.aristanetworks.swi": "swi", "vnd.astraea-software.iota": "iota", "vnd.audiograph": "aep", "vnd.blueice.multipass": "mpm", "vnd.bmi": "bmi", "vnd.businessobjects": "rep", "vnd.chemdraw+xml": "cdxml", "vnd.chipnuts.karaoke-mmd": "mmd", "vnd.claymore": "cla", "vnd.cloanto.rp9": "rp9", "vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"], "vnd.cluetrust.cartomobile-config": "c11amc", "vnd.cluetrust.cartomobile-config-pkg": "c11amz", "vnd.commonspace": "csp", "vnd.contact.cmsg": "cdbcmsg", "vnd.cosmocaller": "cmc", "vnd.crick.clicker": "clkx", "vnd.crick.clicker.keyboard": "clkk", "vnd.crick.clicker.palette": "clkp", "vnd.crick.clicker.template": "clkt", "vnd.crick.clicker.wordbank": "clkw", "vnd.criticaltools.wbs+xml": "wbs", "vnd.ctc-posml": "pml", "vnd.cups-ppd": "ppd", "vnd.curl.car": "car", "vnd.curl.pcurl": "pcurl", "vnd.dart": "dart", "vnd.data-vision.rdz": "rdz", "vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"], "vnd.dece.ttml+xml": ["uvt", "uvvt"], "vnd.dece.unspecified": ["uvx", "uvvx"], "vnd.dece.zip": ["uvz", "uvvz"], "vnd.denovo.fcselayout-link": "fe_launch", "vnd.dna": "dna", "vnd.dolby.mlp": "mlp", "vnd.dpgraph": "dpg", "vnd.dreamfactory": "dfac", "vnd.ds-keypoint": "kpxx", "vnd.dvb.ait": "ait", "vnd.dvb.service": "svc", "vnd.dynageo": "geo", "vnd.ecowin.chart": "mag", "vnd.enliven": "nml", "vnd.epson.esf": "esf", "vnd.epson.msf": "msf", "vnd.epson.quickanime": "qam", "vnd.epson.salt": "slt", "vnd.epson.ssf": "ssf", "vnd.eszigno3+xml": ["es3", "et3"], "vnd.ezpix-album": "ez2", "vnd.ezpix-package": "ez3", "vnd.fdf": "fdf", "vnd.fdsn.mseed": "mseed", "vnd.fdsn.seed": ["seed", "dataless"], "vnd.flographit": "gph", "vnd.fluxtime.clip": "ftc", "vnd.framemaker": ["fm", "frame", "maker", "book"], "vnd.frogans.fnc": "fnc", "vnd.frogans.ltf": "ltf", "vnd.fsc.weblaunch": "fsc", "vnd.fujitsu.oasys": "oas", "vnd.fujitsu.oasys2": "oa2", "vnd.fujitsu.oasys3": "oa3", "vnd.fujitsu.oasysgp": "fg5", "vnd.fujitsu.oasysprs": "bh2", "vnd.fujixerox.ddd": "ddd", "vnd.fujixerox.docuworks": "xdw", "vnd.fujixerox.docuworks.binder": "xbd", "vnd.fuzzysheet": "fzs", "vnd.genomatix.tuxedo": "txd", "vnd.geogebra.file": "ggb", "vnd.geogebra.tool": "ggt", "vnd.geometry-explorer": ["gex", "gre"], "vnd.geonext": "gxt", "vnd.geoplan": "g2w", "vnd.geospace": "g3w", "vnd.gmx": "gmx", "vnd.grafeq": ["gqf", "gqs"], "vnd.groove-account": "gac", "vnd.groove-help": "ghf", "vnd.groove-identity-message": "gim", "vnd.groove-injector": "grv", "vnd.groove-tool-message": "gtm", "vnd.groove-tool-template": "tpl", "vnd.groove-vcard": "vcg", "vnd.hal+xml": "hal", "vnd.handheld-entertainment+xml": "zmm", "vnd.hbci": "hbci", "vnd.hhe.lesson-player": "les", "vnd.hp-hpgl": "hpgl", "vnd.hp-hpid": "hpid", "vnd.hp-hps": "hps", "vnd.hp-jlyt": "jlt", "vnd.hp-pcl": "pcl", "vnd.hp-pclxl": "pclxl", "vnd.hydrostatix.sof-data": "sfd-hdstx", "vnd.ibm.minipay": "mpy", "vnd.ibm.modcap": ["afp", "listafp", "list3820"], "vnd.ibm.rights-management": "irm", "vnd.ibm.secure-container": "sc", "vnd.iccprofile": ["icc", "icm"], "vnd.igloader": "igl", "vnd.immervision-ivp": "ivp", "vnd.immervision-ivu": "ivu", "vnd.insors.igm": "igm", "vnd.intercon.formnet": ["xpw", "xpx"], "vnd.intergeo": "i2g", "vnd.intu.qbo": "qbo", "vnd.intu.qfx": "qfx", "vnd.ipunplugged.rcprofile": "rcprofile", "vnd.irepository.package+xml": "irp", "vnd.is-xpr": "xpr", "vnd.isac.fcs": "fcs", "vnd.jam": "jam", "vnd.jcp.javame.midlet-rms": "rms", "vnd.jisp": "jisp", "vnd.joost.joda-archive": "joda", "vnd.kahootz": ["ktz", "ktr"], "vnd.kde.karbon": "karbon", "vnd.kde.kchart": "chrt", "vnd.kde.kformula": "kfo", "vnd.kde.kivio": "flw", "vnd.kde.kontour": "kon", "vnd.kde.kpresenter": ["kpr", "kpt"], "vnd.kde.kspread": "ksp", "vnd.kde.kword": ["kwd", "kwt"], "vnd.kenameaapp": "htke", "vnd.kidspiration": "kia", "vnd.kinar": ["kne", "knp"], "vnd.koan": ["skp", "skd", "skt", "skm"], "vnd.kodak-descriptor": "sse", "vnd.las.las+xml": "lasxml", "vnd.llamagraphics.life-balance.desktop": "lbd", "vnd.llamagraphics.life-balance.exchange+xml": "lbe", "vnd.lotus-1-2-3": "123", "vnd.lotus-approach": "apr", "vnd.lotus-freelance": "pre", "vnd.lotus-notes": "nsf", "vnd.lotus-organizer": "org", "vnd.lotus-screencam": "scm", "vnd.lotus-wordpro": "lwp", "vnd.macports.portpkg": "portpkg", "vnd.mcd": "mcd", "vnd.medcalcdata": "mc1", "vnd.mediastation.cdkey": "cdkey", "vnd.mfer": "mwf", "vnd.mfmp": "mfm", "vnd.micrografx.flo": "flo", "vnd.micrografx.igx": "igx", "vnd.mif": "mif", "vnd.mobius.daf": "daf", "vnd.mobius.dis": "dis", "vnd.mobius.mbk": "mbk", "vnd.mobius.mqy": "mqy", "vnd.mobius.msl": "msl", "vnd.mobius.plc": "plc", "vnd.mobius.txf": "txf", "vnd.mophun.application": "mpn", "vnd.mophun.certificate": "mpc", "vnd.ms-artgalry": "cil", "vnd.ms-cab-compressed": "cab", "vnd.ms-excel.addin.macroenabled.12": "xlam", "vnd.ms-excel.sheet.binary.macroenabled.12": "xlsb", "vnd.ms-excel.sheet.macroenabled.12": "xlsm", "vnd.ms-excel.template.macroenabled.12": "xltm", "vnd.ms-fontobject": "eot", "vnd.ms-htmlhelp": "chm", "vnd.ms-ims": "ims", "vnd.ms-lrm": "lrm", "vnd.ms-officetheme": "thmx", "vnd.ms-powerpoint.addin.macroenabled.12": "ppam", "vnd.ms-powerpoint.presentation.macroenabled.12": "pptm", "vnd.ms-powerpoint.slide.macroenabled.12": "sldm", "vnd.ms-powerpoint.slideshow.macroenabled.12": "ppsm", "vnd.ms-powerpoint.template.macroenabled.12": "potm", "vnd.ms-project": ["mpp", "mpt"], "vnd.ms-word.document.macroenabled.12": "docm", "vnd.ms-word.template.macroenabled.12": "dotm", "vnd.ms-works": ["wps", "wks", "wcm", "wdb"], "vnd.ms-wpl": "wpl", "vnd.ms-xpsdocument": "xps", "vnd.mseq": "mseq", "vnd.musician": "mus", "vnd.muvee.style": "msty", "vnd.mynfc": "taglet", "vnd.neurolanguage.nlu": "nlu", "vnd.nitf": ["ntf", "nitf"], "vnd.noblenet-directory": "nnd", "vnd.noblenet-sealer": "nns", "vnd.noblenet-web": "nnw", "vnd.nokia.n-gage.data": "ngdat", "vnd.nokia.n-gage.symbian.install": "n-gage", "vnd.nokia.radio-preset": "rpst", "vnd.nokia.radio-presets": "rpss", "vnd.novadigm.edm": "edm", "vnd.novadigm.edx": "edx", "vnd.novadigm.ext": "ext", "vnd.oasis.opendocument.chart-template": "otc", "vnd.oasis.opendocument.formula-template": "odft", "vnd.oasis.opendocument.image-template": "oti", "vnd.olpc-sugar": "xo", "vnd.oma.dd2+xml": "dd2", "vnd.openofficeorg.extension": "oxt", "vnd.openxmlformats-officedocument.presentationml.slide": "sldx", "vnd.osgeo.mapguide.package": "mgp", "vnd.osgi.dp": "dp", "vnd.osgi.subsystem": "esa", "vnd.palm": ["pdb", "pqa", "oprc"], "vnd.pawaafile": "paw", "vnd.pg.format": "str", "vnd.pg.osasli": "ei6", "vnd.picsel": "efif", "vnd.pmi.widget": "wg", "vnd.pocketlearn": "plf", "vnd.powerbuilder6": "pbd", "vnd.previewsystems.box": "box", "vnd.proteus.magazine": "mgz", "vnd.publishare-delta-tree": "qps", "vnd.pvi.ptid1": "ptid", "vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"], "vnd.realvnc.bed": "bed", "vnd.recordare.musicxml": "mxl", "vnd.recordare.musicxml+xml": "musicxml", "vnd.rig.cryptonote": "cryptonote", "vnd.rn-realmedia": "rm", "vnd.rn-realmedia-vbr": "rmvb", "vnd.route66.link66+xml": "link66", "vnd.sailingtracker.track": "st", "vnd.seemail": "see", "vnd.sema": "sema", "vnd.semd": "semd", "vnd.semf": "semf", "vnd.shana.informed.formdata": "ifm", "vnd.shana.informed.formtemplate": "itp", "vnd.shana.informed.interchange": "iif", "vnd.shana.informed.package": "ipk", "vnd.simtech-mindmapper": ["twd", "twds"], "vnd.smart.teacher": "teacher", "vnd.solent.sdkm+xml": ["sdkm", "sdkd"], "vnd.spotfire.dxp": "dxp", "vnd.spotfire.sfs": "sfs", "vnd.stepmania.package": "smzip", "vnd.stepmania.stepchart": "sm", "vnd.sus-calendar": ["sus", "susp"], "vnd.svd": "svd", "vnd.syncml+xml": "xsm", "vnd.syncml.dm+wbxml": "bdm", "vnd.syncml.dm+xml": "xdm", "vnd.tao.intent-module-archive": "tao", "vnd.tcpdump.pcap": ["pcap", "cap", "dmp"], "vnd.tmobile-livetv": "tmo", "vnd.trid.tpt": "tpt", "vnd.triscape.mxs": "mxs", "vnd.trueapp": "tra", "vnd.ufdl": ["ufd", "ufdl"], "vnd.uiq.theme": "utz", "vnd.umajin": "umj", "vnd.unity": "unityweb", "vnd.uoml+xml": "uoml", "vnd.vcx": "vcx", "vnd.visionary": "vis", "vnd.vsf": "vsf", "vnd.webturbo": "wtb", "vnd.wolfram.player": "nbp", "vnd.wqd": "wqd", "vnd.wt.stf": "stf", "vnd.xara": "xar", "vnd.xfdl": "xfdl", "vnd.yamaha.hv-dic": "hvd", "vnd.yamaha.hv-script": "hvs", "vnd.yamaha.hv-voice": "hvp", "vnd.yamaha.openscoreformat": "osf", "vnd.yamaha.openscoreformat.osfpvg+xml": "osfpvg", "vnd.yamaha.smaf-audio": "saf", "vnd.yamaha.smaf-phrase": "spf", "vnd.yellowriver-custom-menu": "cmp", "vnd.zul": ["zir", "zirz"], "vnd.zzazz.deck+xml": "zaz", "voicexml+xml": "vxml", widget: "wgt", winhlp: "hlp", "wsdl+xml": "wsdl", "wspolicy+xml": "wspolicy", "x-ace-compressed": "ace", "x-authorware-bin": ["aab", "x32", "u32", "vox"], "x-authorware-map": "aam", "x-authorware-seg": "aas", "x-blorb": ["blb", "blorb"], "x-bzip": "bz", "x-bzip2": ["bz2", "boz"], "x-cfs-compressed": "cfs", "x-chat": "chat", "x-conference": "nsc", "x-dgc-compressed": "dgc", "x-dtbncx+xml": "ncx", "x-dtbook+xml": "dtb", "x-dtbresource+xml": "res", "x-eva": "eva", "x-font-bdf": "bdf", "x-font-ghostscript": "gsf", "x-font-linux-psf": "psf", "x-font-pcf": "pcf", "x-font-snf": "snf", "x-font-ttf": ["ttf", "ttc"], "x-font-type1": ["pfa", "pfb", "pfm", "afm"], "x-freearc": "arc", "x-gca-compressed": "gca", "x-glulx": "ulx", "x-gramps-xml": "gramps", "x-install-instructions": "install", "x-lzh-compressed": ["lzh", "lha"], "x-mie": "mie", "x-mobipocket-ebook": ["prc", "mobi"], "x-ms-application": "application", "x-ms-shortcut": "lnk", "x-ms-xbap": "xbap", "x-msbinder": "obd", "x-mscardfile": "crd", "x-msclip": "clp", "application/x-ms-installer": "msi", "x-msmediaview": ["mvb", "m13", "m14"], "x-msmetafile": ["wmf", "wmz", "emf", "emz"], "x-msmoney": "mny", "x-mspublisher": "pub", "x-msschedule": "scd", "x-msterminal": "trm", "x-mswrite": "wri", "x-nzb": "nzb", "x-pkcs12": ["p12", "pfx"], "x-pkcs7-certificates": ["p7b", "spc"], "x-research-info-systems": "ris", "x-silverlight-app": "xap", "x-sql": "sql", "x-stuffitx": "sitx", "x-subrip": "srt", "x-t3vm-image": "t3", "x-tex-tfm": "tfm", "x-tgif": "obj", "x-xliff+xml": "xlf", "x-xz": "xz", "x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"], "xaml+xml": "xaml", "xcap-diff+xml": "xdf", "xenc+xml": "xenc", "xml-dtd": "dtd", "xop+xml": "xop", "xproc+xml": "xpl", "xslt+xml": "xslt", "xv+xml": ["mxml", "xhvml", "xvml", "xvm"], yang: "yang", "yin+xml": "yin", envoy: "evy", fractals: "fif", "internet-property-stream": "acx", olescript: "axs", "vnd.ms-outlook": "msg", "vnd.ms-pkicertstore": "sst", "x-compress": "z", "x-perfmon": ["pma", "pmc", "pmr", "pmw"], "ynd.ms-pkipko": "pko", gzip: ["gz", "tgz"], "smil+xml": ["smi", "smil"], "vnd.debian.binary-package": ["deb", "udeb"], "vnd.hzn-3d-crossword": "x3d", "vnd.sqlite3": ["db", "sqlite", "sqlite3", "db-wal", "sqlite-wal", "db-shm", "sqlite-shm"], "vnd.wap.sic": "sic", "vnd.wap.slc": "slc", "x-krita": ["kra", "krz"], "x-perl": ["pm", "pl"], yaml: ["yaml", "yml"] }, audio: { amr: "amr", "amr-wb": "awb", annodex: "axa", basic: ["au", "snd"], flac: "flac", midi: ["mid", "midi", "kar", "rmi"], mpeg: ["mpga", "mpega", "mp3", "m4a", "mp2a", "m2a", "m3a"], mpegurl: "m3u", ogg: ["oga", "ogg", "spx"], "prs.sid": "sid", "x-aiff": "aifc", "x-gsm": "gsm", "x-ms-wma": "wma", "x-ms-wax": "wax", "x-pn-realaudio": "ram", "x-realaudio": "ra", "x-sd2": "sd2", adpcm: "adp", mp4: "mp4a", s3m: "s3m", silk: "sil", "vnd.dece.audio": ["uva", "uvva"], "vnd.digital-winds": "eol", "vnd.dra": "dra", "vnd.dts": "dts", "vnd.dts.hd": "dtshd", "vnd.lucent.voice": "lvp", "vnd.ms-playready.media.pya": "pya", "vnd.nuera.ecelp4800": "ecelp4800", "vnd.nuera.ecelp7470": "ecelp7470", "vnd.nuera.ecelp9600": "ecelp9600", "vnd.rip": "rip", webm: "weba", "x-caf": "caf", "x-matroska": "mka", "x-pn-realaudio-plugin": "rmp", xm: "xm", aac: "aac", aiff: ["aiff", "aif", "aff"], opus: "opus", wav: "wav" }, chemical: { "x-alchemy": "alc", "x-cache": ["cac", "cache"], "x-cache-csf": "csf", "x-cactvs-binary": ["cbin", "cascii", "ctab"], "x-cdx": "cdx", "x-chem3d": "c3d", "x-cif": "cif", "x-cmdf": "cmdf", "x-cml": "cml", "x-compass": "cpa", "x-crossfire": "bsd", "x-csml": ["csml", "csm"], "x-ctx": "ctx", "x-cxf": ["cxf", "cef"], "x-embl-dl-nucleotide": ["emb", "embl"], "x-gamess-input": ["inp", "gam", "gamin"], "x-gaussian-checkpoint": ["fch", "fchk"], "x-gaussian-cube": "cub", "x-gaussian-input": ["gau", "gjc", "gjf"], "x-gaussian-log": "gal", "x-gcg8-sequence": "gcg", "x-genbank": "gen", "x-hin": "hin", "x-isostar": ["istr", "ist"], "x-jcamp-dx": ["jdx", "dx"], "x-kinemage": "kin", "x-macmolecule": "mcm", "x-macromodel-input": "mmod", "x-mdl-molfile": "mol", "x-mdl-rdfile": "rd", "x-mdl-rxnfile": "rxn", "x-mdl-sdfile": "sd", "x-mdl-tgf": "tgf", "x-mmcif": "mcif", "x-mol2": "mol2", "x-molconn-Z": "b", "x-mopac-graph": "gpt", "x-mopac-input": ["mop", "mopcrt", "zmt"], "x-mopac-out": "moo", "x-ncbi-asn1": "asn", "x-ncbi-asn1-ascii": ["prt", "ent"], "x-ncbi-asn1-binary": "val", "x-rosdal": "ros", "x-swissprot": "sw", "x-vamas-iso14976": "vms", "x-vmd": "vmd", "x-xtel": "xtel", "x-xyz": "xyz" }, font: { otf: "otf", woff: "woff", woff2: "woff2" }, image: { gif: "gif", ief: "ief", jpeg: ["jpeg", "jpg", "jpe", "jfif", "jfif-tbnl", "jif"], pcx: "pcx", png: "png", "svg+xml": ["svg", "svgz"], tiff: ["tiff", "tif"], "vnd.djvu": ["djvu", "djv"], "vnd.wap.wbmp": "wbmp", "x-canon-cr2": "cr2", "x-canon-crw": "crw", "x-cmu-raster": "ras", "x-coreldraw": "cdr", "x-coreldrawpattern": "pat", "x-coreldrawtemplate": "cdt", "x-corelphotopaint": "cpt", "x-epson-erf": "erf", "x-icon": "ico", "x-jg": "art", "x-jng": "jng", "x-nikon-nef": "nef", "x-olympus-orf": "orf", "x-portable-anymap": "pnm", "x-portable-bitmap": "pbm", "x-portable-graymap": "pgm", "x-portable-pixmap": "ppm", "x-rgb": "rgb", "x-xbitmap": "xbm", "x-xpixmap": "xpm", "x-xwindowdump": "xwd", bmp: "bmp", cgm: "cgm", g3fax: "g3", ktx: "ktx", "prs.btif": "btif", sgi: "sgi", "vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"], "vnd.dwg": "dwg", "vnd.dxf": "dxf", "vnd.fastbidsheet": "fbs", "vnd.fpx": "fpx", "vnd.fst": "fst", "vnd.fujixerox.edmics-mmr": "mmr", "vnd.fujixerox.edmics-rlc": "rlc", "vnd.ms-modi": "mdi", "vnd.ms-photo": "wdp", "vnd.net-fpx": "npx", "vnd.xiff": "xif", webp: "webp", "x-3ds": "3ds", "x-cmx": "cmx", "x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"], "x-pict": ["pic", "pct"], "x-tga": "tga", "cis-cod": "cod", avif: "avifs", heic: ["heif", "heic"], pjpeg: ["pjpg"], "vnd.adobe.photoshop": "psd", "x-adobe-dng": "dng", "x-fuji-raf": "raf", "x-icns": "icns", "x-kodak-dcr": "dcr", "x-kodak-k25": "k25", "x-kodak-kdc": "kdc", "x-minolta-mrw": "mrw", "x-panasonic-raw": ["raw", "rw2", "rwl"], "x-pentax-pef": ["pef", "ptx"], "x-sigma-x3f": "x3f", "x-sony-arw": "arw", "x-sony-sr2": "sr2", "x-sony-srf": "srf" }, message: { rfc822: ["eml", "mime", "mht", "mhtml", "nws"] }, model: { iges: ["igs", "iges"], mesh: ["msh", "mesh", "silo"], vrml: ["wrl", "vrml"], "x3d+vrml": ["x3dv", "x3dvz"], "x3d+xml": "x3dz", "x3d+binary": ["x3db", "x3dbz"], "vnd.collada+xml": "dae", "vnd.dwf": "dwf", "vnd.gdl": "gdl", "vnd.gtw": "gtw", "vnd.mts": "mts", "vnd.usdz+zip": "usdz", "vnd.vtu": "vtu" }, text: { "cache-manifest": ["manifest", "appcache"], calendar: ["ics", "icz", "ifb"], css: "css", csv: "csv", h323: "323", html: ["html", "htm", "shtml", "stm"], iuls: "uls", plain: ["txt", "text", "brf", "conf", "def", "list", "log", "in", "bas", "diff", "ksh"], richtext: "rtx", scriptlet: ["sct", "wsc"], texmacs: "tm", "tab-separated-values": "tsv", "vnd.sun.j2me.app-descriptor": "jad", "vnd.wap.wml": "wml", "vnd.wap.wmlscript": "wmls", "x-bibtex": "bib", "x-boo": "boo", "x-c++hdr": ["h++", "hpp", "hxx", "hh"], "x-c++src": ["c++", "cpp", "cxx", "cc"], "x-component": "htc", "x-dsrc": "d", "x-diff": "patch", "x-haskell": "hs", "x-java": "java", "x-literate-haskell": "lhs", "x-moc": "moc", "x-pascal": ["p", "pas", "pp", "inc"], "x-pcs-gcd": "gcd", "x-python": "py", "x-scala": "scala", "x-setext": "etx", "x-tcl": ["tcl", "tk"], "x-tex": ["tex", "ltx", "sty", "cls"], "x-vcalendar": "vcs", "x-vcard": "vcf", n3: "n3", "prs.lines.tag": "dsc", sgml: ["sgml", "sgm"], troff: ["t", "tr", "roff", "man", "me", "ms"], turtle: "ttl", "uri-list": ["uri", "uris", "urls"], vcard: "vcard", "vnd.curl": "curl", "vnd.curl.dcurl": "dcurl", "vnd.curl.scurl": "scurl", "vnd.curl.mcurl": "mcurl", "vnd.dvb.subtitle": "sub", "vnd.fly": "fly", "vnd.fmi.flexstor": "flx", "vnd.graphviz": "gv", "vnd.in3d.3dml": "3dml", "vnd.in3d.spot": "spot", "x-asm": ["s", "asm"], "x-c": ["c", "h", "dic"], "x-fortran": ["f", "for", "f77", "f90"], "x-opml": "opml", "x-nfo": "nfo", "x-sfv": "sfv", "x-uuencode": "uu", webviewhtml: "htt", javascript: "js", json: "json", markdown: ["md", "markdown", "mdown", "markdn"], "vnd.wap.si": "si", "vnd.wap.sl": "sl" }, video: { avif: "avif", "3gpp": "3gp", annodex: "axv", dl: "dl", dv: ["dif", "dv"], fli: "fli", gl: "gl", mpeg: ["mpeg", "mpg", "mpe", "m1v", "m2v", "mp2", "mpa", "mpv2"], mp4: ["mp4", "mp4v", "mpg4"], quicktime: ["qt", "mov"], ogg: "ogv", "vnd.mpegurl": ["mxu", "m4u"], "x-flv": "flv", "x-la-asf": ["lsf", "lsx"], "x-mng": "mng", "x-ms-asf": ["asf", "asx", "asr"], "x-ms-wm": "wm", "x-ms-wmv": "wmv", "x-ms-wmx": "wmx", "x-ms-wvx": "wvx", "x-msvideo": "avi", "x-sgi-movie": "movie", "x-matroska": ["mpv", "mkv", "mk3d", "mks"], "3gpp2": "3g2", h261: "h261", h263: "h263", h264: "h264", jpeg: "jpgv", jpm: ["jpm", "jpgm"], mj2: ["mj2", "mjp2"], "vnd.dece.hd": ["uvh", "uvvh"], "vnd.dece.mobile": ["uvm", "uvvm"], "vnd.dece.pd": ["uvp", "uvvp"], "vnd.dece.sd": ["uvs", "uvvs"], "vnd.dece.video": ["uvv", "uvvv"], "vnd.dvb.file": "dvb", "vnd.fvt": "fvt", "vnd.ms-playready.media.pyv": "pyv", "vnd.uvvu.mp4": ["uvu", "uvvu"], "vnd.vivo": "viv", webm: "webm", "x-f4v": "f4v", "x-m4v": "m4v", "x-ms-vob": "vob", "x-smv": "smv", mp2t: "ts" }, "x-conference": { "x-cooltalk": "ice" }, "x-world": { "x-vrml": ["vrm", "flr", "wrz", "xaf", "xof"] } };
(() => {
  const t3 = {};
  for (const e of Object.keys(cy)) for (const n of Object.keys(cy[e])) {
    const r = cy[e][n];
    if (typeof r == "string") t3[r] = e + "/" + n;
    else for (let s = 0; s < r.length; s++) t3[r[s]] = e + "/" + n;
  }
  return t3;
})();
Mae(Sd);
async function rle(t3, e) {
  if (!t3 || t3.length === 0) throw new Error("No files selected.");
  if (!e) throw new Error("Password is required.");
  Sd({ useWebWorkers: true });
  const n = new boe("application/zip"), r = new Lfe(n, { password: e, encryptionStrength: 3 });
  try {
    for (const s of t3) {
      const i = s.webkitRelativePath || s.name;
      await r.add(i, new fR(s));
    }
    return await r.close(), await n.getData();
  } catch (s) {
    throw new Error("Zip Creation Failed: " + s.message);
  }
}
function nle(t3) {
  let e, n;
  return e = new la({ props: { multiple: true, label: "Select Files to Zip" } }), e.$on("change", t3[7]), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p: dt, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function ile(t3) {
  let e, n;
  return e = new la({ props: { directory: true, label: "Select Folder to Zip" } }), e.$on("change", t3[7]), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p: dt, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function e7(t3) {
  let e, n, r, s = t3[1].length + "", i, a;
  return { c() {
    e = H("div"), n = we("\u2705 "), r = H("strong"), i = we(s), a = we(" item(s) ready to zip"), V(e, "class", "file-status svelte-2iu6el");
  }, m(o, f) {
    R(o, e, f), q(e, n), q(e, r), q(r, i), q(e, a);
  }, p(o, f) {
    f & 2 && s !== (s = o[1].length + "") && Ze(i, s);
  }, d(o) {
    o && D(e);
  } };
}
function sle(t3) {
  let e;
  return { c() {
    e = we("Download Encrypted ZIP");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function ale(t3) {
  let e;
  return { c() {
    e = we("Compressing & Encrypting...");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function ole(t3) {
  let e;
  function n(i, a) {
    return i[3] ? ale : sle;
  }
  let r = n(t3), s = r(t3);
  return { c() {
    s.c(), e = Lt();
  }, m(i, a) {
    s.m(i, a), R(i, e, a);
  }, p(i, a) {
    r !== (r = n(i)) && (s.d(1), s = r(i), s && (s.c(), s.m(e.parentNode, e)));
  }, d(i) {
    i && D(e), s.d(i);
  } };
}
function t7(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[4]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 16 && Ze(n, r[4]);
  }, d(r) {
    r && D(e);
  } };
}
function r7(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[5]), V(e, "class", "msg success svelte-2iu6el");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 32 && Ze(n, r[5]);
  }, d(r) {
    r && D(e);
  } };
}
function fle(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I;
  const S = [ile, nle], $ = [];
  function F(p, d) {
    return p[0] === "folder" ? 0 : 1;
  }
  n = F(t3), r = $[n] = S[n](t3);
  let U = t3[1] && e7(t3);
  function Q(p) {
    t3[10](p);
  }
  let P = { label: "Mode:", options: t3[6] };
  t3[0] !== void 0 && (P.value = t3[0]), o = new Ht({ props: P }), Qe.push(() => ze(o, "value", Q));
  function N(p) {
    t3[11](p);
  }
  let L = { label: "Set Password:", placeholder: "Enter strong password...", type: "password" };
  t3[2] !== void 0 && (L.value = t3[2]), l = new et({ props: L }), Qe.push(() => ze(l, "value", N)), b = new ut({ props: { disabled: t3[3], $$slots: { default: [ole] }, $$scope: { ctx: t3 } } }), b.$on("click", t3[8]);
  let B = t3[4] && t7(t3), u = t3[5] && r7(t3);
  return { c() {
    e = H("div"), r.c(), s = z(), U && U.c(), i = z(), a = H("div"), fe(o.$$.fragment), c = z(), fe(l.$$.fragment), m = z(), v = H("div"), fe(b.$$.fragment), A = z(), B && B.c(), _ = z(), u && u.c(), C = Lt(), V(e, "class", "drop-area-container"), V(a, "class", "controls-row"), V(v, "class", "button-row"), St(v, "margin", "auto");
  }, m(p, d) {
    R(p, e, d), $[n].m(e, null), R(p, s, d), U && U.m(p, d), R(p, i, d), R(p, a, d), ae(o, a, null), q(a, c), ae(l, a, null), R(p, m, d), R(p, v, d), ae(b, v, null), R(p, A, d), B && B.m(p, d), R(p, _, d), u && u.m(p, d), R(p, C, d), I = true;
  }, p(p, d) {
    let y = n;
    n = F(p), n === y ? $[n].p(p, d) : (Xt(), j($[y], 1, 1, () => {
      $[y] = null;
    }), er(), r = $[n], r ? r.p(p, d) : (r = $[n] = S[n](p), r.c()), W(r, 1), r.m(e, null)), p[1] ? U ? U.p(p, d) : (U = e7(p), U.c(), U.m(i.parentNode, i)) : U && (U.d(1), U = null);
    const w = {};
    !f && d & 1 && (f = true, w.value = p[0], qe(() => f = false)), o.$set(w);
    const E = {};
    !h && d & 4 && (h = true, E.value = p[2], qe(() => h = false)), l.$set(E);
    const M = {};
    d & 8 && (M.disabled = p[3]), d & 4104 && (M.$$scope = { dirty: d, ctx: p }), b.$set(M), p[4] ? B ? B.p(p, d) : (B = t7(p), B.c(), B.m(_.parentNode, _)) : B && (B.d(1), B = null), p[5] ? u ? u.p(p, d) : (u = r7(p), u.c(), u.m(C.parentNode, C)) : u && (u.d(1), u = null);
  }, i(p) {
    I || (W(r), W(o.$$.fragment, p), W(l.$$.fragment, p), W(b.$$.fragment, p), I = true);
  }, o(p) {
    j(r), j(o.$$.fragment, p), j(l.$$.fragment, p), j(b.$$.fragment, p), I = false;
  }, d(p) {
    p && (D(e), D(s), D(i), D(a), D(m), D(v), D(A), D(_), D(C)), $[n].d(), U && U.d(p), oe(o), oe(l), oe(b), B && B.d(p), u && u.d(p);
  } };
}
function lle(t3) {
  let e, n, r, s, i;
  return { c() {
    e = H("p"), e.innerHTML = "This tool allows you to create <strong>AES-256 Encrypted ZIP files</strong> directly in your browser.", n = z(), r = H("ul"), r.innerHTML = "<li>Select a file and bundle it into an archive.</li> <li>Select a folder to preserve the directory structure inside the ZIP.</li> <li>Uses AES-256 encryption.</li>", s = z(), i = H("p"), i.innerHTML = "<em><b>Note:</b> NO FILES OR FOLDERS are sent to any server. Uploading happens only in your browser.</em>";
  }, m(a, o) {
    R(a, e, o), R(a, n, o), R(a, r, o), R(a, s, o), R(a, i, o);
  }, p: dt, d(a) {
    a && (D(e), D(n), D(r), D(s), D(i));
  } };
}
function ule(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Zip with Password", $$slots: { default: [fle] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Secure Zip", links: t3[9], $$slots: { default: [lle] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 4159 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 4096 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function cle(t3, e, n) {
  let r = "files", s = null, i = "", a = false, o = "", f = "";
  const c = [{ value: "files", label: "Select Files" }, { value: "folder", label: "Select Folder" }];
  function l(A) {
    const _ = A.detail;
    _ && _.length > 0 && (n(1, s = _), n(4, o = ""), n(5, f = ""));
  }
  async function h() {
    if (n(4, o = ""), n(5, f = ""), !s || s.length === 0) {
      n(4, o = "Please select files or a folder first.");
      return;
    }
    if (!i) {
      n(4, o = "Please enter a password.");
      return;
    }
    n(3, a = true);
    try {
      const A = await rle(s, i), _ = URL.createObjectURL(A), C = document.createElement("a");
      C.href = _;
      let I = "encrypted_archive";
      s.length > 0 && s[0].name && (I = s[0].name.split(".")[0]), C.download = `${I}_encrypted.zip`, document.body.appendChild(C), C.click(), document.body.removeChild(C), URL.revokeObjectURL(_), n(5, f = "ZIP file created and downloaded successfully."), n(2, i = ""), n(1, s = null);
    } catch (A) {
      n(4, o = A.message);
    } finally {
      n(3, a = false);
    }
  }
  const m = [{ text: "ZIP (file format) - Wikipedia", url: "https://en.wikipedia.org/wiki/ZIP_(file_format)" }, { text: "ZIP (file format) - Wikiwand", url: "https://www.wikiwand.com/en/articles/ZIP_(file_format)" }, { text: "NPM package", url: "https://www.npmjs.com/package/@zip.js/zip.js/v/2.6.40" }];
  function v(A) {
    r = A, n(0, r);
  }
  function b(A) {
    i = A, n(2, i);
  }
  return [r, s, i, a, o, f, c, l, h, m, v, b];
}
class hle extends xt {
  constructor(e) {
    super(), wt(this, e, cle, ule, At, {});
  }
}
async function dle(t3) {
  if (!t3) throw new Error("No file provided.");
  const e = performance.now();
  try {
    const [n, r, s] = await Promise.all([hy(t3, "SHA-1"), hy(t3, "SHA-256"), hy(t3, "SHA-512")]), i = await ple(t3), o = ((performance.now() - e) / 1e3).toFixed(2);
    return { fileName: t3.name, fileSize: t3.size, hashes: { md5: i, sha1: n, sha256: r, sha512: s }, timeTaken: o };
  } catch (n) {
    throw new Error("Hashing Failed: " + n.message);
  }
}
async function hy(t3, e) {
  const n = await t3.arrayBuffer(), r = await crypto.subtle.digest(e, n);
  return Array.from(new Uint8Array(r)).map((i) => i.toString(16).padStart(2, "0")).join("");
}
function ple(t3) {
  return new Promise((e, n) => {
    const r = new FileReader();
    r.onload = (s) => {
      const i = ur.lib.WordArray.create(s.target.result), a = ur.MD5(i).toString();
      e(a);
    }, r.onerror = (s) => n(s), r.readAsArrayBuffer(t3);
  });
}
function n7(t3) {
  let e, n, r, s = t3[0].name + "", i, a, o = (t3[0].size / 1024).toFixed(2) + "", f, c;
  return { c() {
    e = H("div"), n = we("\u{1F4C4} "), r = H("strong"), i = we(s), a = we(" ("), f = we(o), c = we(" KB)"), V(e, "class", "file-status svelte-15ocdg6");
  }, m(l, h) {
    R(l, e, h), q(e, n), q(e, r), q(r, i), q(e, a), q(e, f), q(e, c);
  }, p(l, h) {
    h & 1 && s !== (s = l[0].name + "") && Ze(i, s), h & 1 && o !== (o = (l[0].size / 1024).toFixed(2) + "") && Ze(f, o);
  }, d(l) {
    l && D(e);
  } };
}
function gle(t3) {
  let e;
  return { c() {
    e = we("Generate Hashes");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function mle(t3) {
  let e;
  return { c() {
    e = we("Calculating Hashes...");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function vle(t3) {
  let e;
  function n(i, a) {
    return i[3] ? mle : gle;
  }
  let r = n(t3), s = r(t3);
  return { c() {
    s.c(), e = Lt();
  }, m(i, a) {
    s.m(i, a), R(i, e, a);
  }, p(i, a) {
    r !== (r = n(i)) && (s.d(1), s = r(i), s && (s.c(), s.m(e.parentNode, e)));
  }, d(i) {
    i && D(e), s.d(i);
  } };
}
function i7(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[2]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 4 && Ze(n, r[2]);
  }, d(r) {
    r && D(e);
  } };
}
function s7(t3) {
  let e, n, r, s, i = t3[1].timeTaken + "", a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U, Q, P, N, L, B, u, p, d, y, w, E, M, x;
  return { c() {
    e = H("div"), n = H("div"), r = H("span"), s = we("Time: "), a = we(i), o = we("s"), f = z(), c = H("button"), c.textContent = "Download Report", l = z(), h = H("div"), m = H("label"), m.textContent = "MD5", v = z(), b = H("input"), _ = z(), C = H("div"), I = H("label"), I.textContent = "SHA-1", S = z(), $ = H("input"), U = z(), Q = H("div"), P = H("label"), P.textContent = "SHA-256", N = z(), L = H("input"), u = z(), p = H("div"), d = H("label"), d.textContent = "SHA-512", y = z(), w = H("textarea"), V(c, "class", "link-btn svelte-15ocdg6"), V(n, "class", "meta-info svelte-15ocdg6"), V(m, "class", "svelte-15ocdg6"), V(b, "type", "text"), b.readOnly = true, b.value = A = t3[1].hashes.md5, V(b, "class", "svelte-15ocdg6"), V(h, "class", "hash-group svelte-15ocdg6"), V(I, "class", "svelte-15ocdg6"), V($, "type", "text"), $.readOnly = true, $.value = F = t3[1].hashes.sha1, V($, "class", "svelte-15ocdg6"), V(C, "class", "hash-group svelte-15ocdg6"), V(P, "class", "svelte-15ocdg6"), V(L, "type", "text"), L.readOnly = true, L.value = B = t3[1].hashes.sha256, V(L, "class", "svelte-15ocdg6"), V(Q, "class", "hash-group svelte-15ocdg6"), V(d, "class", "svelte-15ocdg6"), w.readOnly = true, V(w, "rows", "2"), w.value = E = t3[1].hashes.sha512, V(w, "class", "svelte-15ocdg6"), V(p, "class", "hash-group svelte-15ocdg6"), V(e, "class", "results-area svelte-15ocdg6");
  }, m(g, k) {
    R(g, e, k), q(e, n), q(n, r), q(r, s), q(r, a), q(r, o), q(n, f), q(n, c), q(e, l), q(e, h), q(h, m), q(h, v), q(h, b), q(e, _), q(e, C), q(C, I), q(C, S), q(C, $), q(e, U), q(e, Q), q(Q, P), q(Q, N), q(Q, L), q(e, u), q(e, p), q(p, d), q(p, y), q(p, w), M || (x = [Kt(c, "click", t3[6]), Kt(b, "click", wle), Kt($, "click", xle), Kt(L, "click", _le), Kt(w, "click", Ele)], M = true);
  }, p(g, k) {
    k & 2 && i !== (i = g[1].timeTaken + "") && Ze(a, i), k & 2 && A !== (A = g[1].hashes.md5) && b.value !== A && (b.value = A), k & 2 && F !== (F = g[1].hashes.sha1) && $.value !== F && ($.value = F), k & 2 && B !== (B = g[1].hashes.sha256) && L.value !== B && (L.value = B), k & 2 && E !== (E = g[1].hashes.sha512) && (w.value = E);
  }, d(g) {
    g && D(e), M = false, Mn(x);
  } };
}
function yle(t3) {
  let e, n, r, s, i, a, o, f, c, l;
  n = new la({ props: { label: "Select File to Hash" } }), n.$on("change", t3[4]);
  let h = t3[0] && n7(t3);
  a = new ut({ props: { disabled: t3[3] || !t3[0], $$slots: { default: [vle] }, $$scope: { ctx: t3 } } }), a.$on("click", t3[5]);
  let m = t3[2] && i7(t3), v = t3[1] && s7(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), r = z(), h && h.c(), s = z(), i = H("div"), fe(a.$$.fragment), o = z(), m && m.c(), f = z(), v && v.c(), c = Lt(), V(e, "class", "drop-container svelte-15ocdg6"), V(i, "class", "button-row"), St(i, "justify-content", "center");
  }, m(b, A) {
    R(b, e, A), ae(n, e, null), R(b, r, A), h && h.m(b, A), R(b, s, A), R(b, i, A), ae(a, i, null), R(b, o, A), m && m.m(b, A), R(b, f, A), v && v.m(b, A), R(b, c, A), l = true;
  }, p(b, A) {
    b[0] ? h ? h.p(b, A) : (h = n7(b), h.c(), h.m(s.parentNode, s)) : h && (h.d(1), h = null);
    const _ = {};
    A & 9 && (_.disabled = b[3] || !b[0]), A & 264 && (_.$$scope = { dirty: A, ctx: b }), a.$set(_), b[2] ? m ? m.p(b, A) : (m = i7(b), m.c(), m.m(f.parentNode, f)) : m && (m.d(1), m = null), b[1] ? v ? v.p(b, A) : (v = s7(b), v.c(), v.m(c.parentNode, c)) : v && (v.d(1), v = null);
  }, i(b) {
    l || (W(n.$$.fragment, b), W(a.$$.fragment, b), l = true);
  }, o(b) {
    j(n.$$.fragment, b), j(a.$$.fragment, b), l = false;
  }, d(b) {
    b && (D(e), D(r), D(s), D(i), D(o), D(f), D(c)), oe(n), h && h.d(b), oe(a), m && m.d(b), v && v.d(b);
  } };
}
function ble(t3) {
  let e, n, r, s, i, a, o;
  return { c() {
    e = H("p"), e.innerHTML = `The <b>File Hash Generator</b> calculates cryptographic hash values 
        for any file. Hashes are unique digital fingerprints used to verify 
        file integrity and detect tampering.
    Use this tool to confirm that files are identical or unaltered after download, transfer, or modification.`, n = z(), r = H("h3"), r.textContent = "Supported Algorithms:", s = z(), i = H("ul"), i.innerHTML = "<li><b>MD5</b>: Fast, legacy checksum</li> <li><b>SHA-1</b>: Commonly used for file verification</li> <li><b>SHA-256</b>: Modern secure hash standard</li> <li><b>SHA-512</b>: High-strength variant for sensitive data</li>", a = z(), o = H("p"), o.innerHTML = "<em><b>Note:</b> NO FILES OR FOLDERS are sent to any server. Uploading happens only in your browser.</em>";
  }, m(f, c) {
    R(f, e, c), R(f, n, c), R(f, r, c), R(f, s, c), R(f, i, c), R(f, a, c), R(f, o, c);
  }, p: dt, d(f) {
    f && (D(e), D(n), D(r), D(s), D(i), D(a), D(o));
  } };
}
function Ale(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "File Hash Generator", $$slots: { default: [yle] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About File Hashes", links: t3[7], $$slots: { default: [ble] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 271 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 256 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
const wle = (t3) => t3.target.select(), xle = (t3) => t3.target.select(), _le = (t3) => t3.target.select(), Ele = (t3) => t3.target.select();
function Ble(t3, e, n) {
  let r = null, s = null, i = "", a = false;
  function o(h) {
    const m = h.detail;
    m && m.length > 0 && (n(0, r = m[0]), n(1, s = null), n(2, i = ""));
  }
  async function f() {
    if (!r) {
      n(2, i = "Please select a file first.");
      return;
    }
    n(3, a = true), n(2, i = ""), n(1, s = null);
    try {
      await new Promise((h) => setTimeout(h, 50)), n(1, s = await dle(r));
    } catch (h) {
      n(2, i = h.message);
    } finally {
      n(3, a = false);
    }
  }
  function c() {
    if (!s) return;
    const h = `FILE HASH REPORT
        ------------------------------------------------
        File:      ${s.fileName}
        Size:      ${s.fileSize} bytes
        Time:      ${s.timeTaken} seconds
        Generated: ${(/* @__PURE__ */ new Date()).toLocaleString()}

        MD5:
        ${s.hashes.md5}

        SHA-1:
        ${s.hashes.sha1}

        SHA-256:
        ${s.hashes.sha256}

        SHA-512:
        ${s.hashes.sha512}
        ------------------------------------------------`, m = new Blob([h], { type: "text/plain" }), v = URL.createObjectURL(m), b = document.createElement("a");
    b.href = v, b.download = `${s.fileName}_hashes.txt`, document.body.appendChild(b), b.click(), document.body.removeChild(b);
  }
  return [r, s, i, a, o, f, c, [{ text: "File Verification - Wikipedia", url: "https://en.wikipedia.org/wiki/File_verification" }]];
}
class Cle extends xt {
  constructor(e) {
    super(), wt(this, e, Ble, Ale, At, {});
  }
}
var ym = {}, dy = {}, Rl = {}, Cn = {};
Object.defineProperty(Cn, "__esModule", { value: true });
Cn.isHeicSignatureIncluded = Cn.isAvifStringIncluded = Cn.isFileContaineJfiforExifHeader = Cn.isFlvStringIncluded = Cn.isftypStringIncluded = Cn.findMatroskaDocTypeElements = Cn.fetchFromObject = Cn.getFileChunk = void 0;
function kle(t3, e = 32) {
  const n = t3 instanceof ArrayBuffer ? new Uint8Array(t3) : t3;
  let r = [];
  if (Array.isArray(t3) && Rle(t3) || t3 instanceof ArrayBuffer || t3 instanceof Uint8Array) r = Array.from(n.slice(0, e));
  else throw new TypeError(`Expected the \`file\` argument to be of type \`Array<number>\`, \`Uint8Array\`, or \`ArrayBuffer\`, got \`${typeof t3}\``);
  if (!Ile(r)) throw new TypeError("File content contains illegal values");
  return r;
}
Cn.getFileChunk = kle;
function Ile(t3) {
  return t3.every((e) => typeof e == "number" && !isNaN(e));
}
function XR(t3, e) {
  const n = e.indexOf(".");
  return n > -1 ? XR(t3[e.slice(0, n)], e.slice(n + 1)) : t3[e];
}
Cn.fetchFromObject = XR;
function Sle(t3) {
  const e = "webm", n = "matroska", r = t3.map((s) => String.fromCharCode(s)).join("");
  if (r.includes(e)) return "webm";
  if (r.includes(n)) return "mkv";
}
Cn.findMatroskaDocTypeElements = Sle;
function Mle(t3) {
  const e = [102, 116, 121, 112];
  for (let n = 0; n < t3.length - e.length; n++) {
    let r = true;
    for (let s = 0; s < e.length; s++) if (t3[n + s] !== e[s]) {
      r = false;
      break;
    }
    if (r) return true;
  }
  return false;
}
Cn.isftypStringIncluded = Mle;
function $le(t3) {
  const e = t3.slice(0, 3);
  return new TextDecoder().decode(new Uint8Array(e)).includes("FLV");
}
Cn.isFlvStringIncluded = $le;
function Tle(t3) {
  const e = t3[3];
  return e === 224 || e === 225;
}
Cn.isFileContaineJfiforExifHeader = Tle;
function Dle(t3) {
  return t3.slice(4, 12).map((n) => String.fromCharCode(n)).join("") === "ftypavif";
}
Cn.isAvifStringIncluded = Dle;
function Rle(t3) {
  return t3.every((e) => typeof e == "number");
}
function Fle(t3) {
  const e = t3.map((r) => String.fromCharCode(r)).join("");
  return ["ftypheic", "ftyphevc", "ftypmif1", "ftypmsf1"].some((r) => e.includes(r));
}
Cn.isHeicSignatureIncluded = Fle;
var bm = {};
Object.defineProperty(bm, "__esModule", { value: true });
bm.AudioTypes = void 0;
class B0 {
}
bm.AudioTypes = B0;
B0.AAC = { extension: "aac", mimeType: "audio/aac", description: "Advanced Audio Coding (AAC) is an audio coding standard for lossy digital audio compression", signatures: [{ sequence: [255, 241], description: "MPEG-4 Advanced Audio Coding (AAC) Low Complexity (LC) audio file" }, { sequence: [255, 249], description: "MPEG-2 Advanced Audio Coding (AAC) Low Complexity (LC) audio file" }] };
B0.AMR = { extension: "amr", mimeType: "audio/amr", description: "Adaptive Multi-Rate ACELP (Algebraic Code Excited Linear Prediction) Codec, commonly audio format with GSM cell phones", signatures: [{ sequence: [35, 33, 65, 77, 82] }] };
B0.FLAC = { extension: "flac", mimeType: "audio/x-flac", description: "Free Lossless Audio Codec file", signatures: [{ sequence: [102, 76, 97, 67, 0, 0, 0, 34] }] };
B0.M4A = { extension: "m4a", mimeType: "audio/x-m4a", description: "Apple Lossless Audio Codec file", signatures: [{ sequence: [102, 116, 121, 112, 77, 52, 65, 32], offset: 4, compatibleExtensions: ["aac"] }] };
B0.MP3 = { extension: "mp3", mimeType: "audio/mpeg", description: "A digital audio file format that uses compression to reduce file size while maintaining high quality sound", signatures: [{ sequence: [255, 251], description: "MPEG-1 Layer 3 file without an ID3 tag or with an ID3v1 tag (which is appended at the end of the file)" }, { sequence: [255, 243], description: "MPEG-1 Layer 3 file without an ID3 tag or with an ID3v1 tag (which is appended at the end of the file)" }, { sequence: [255, 242], description: "MPEG-1 Layer 3 file without an ID3 tag or with an ID3v1 tag (which is appended at the end of the file)" }, { sequence: [73, 68, 51], description: "MP3 file with an ID3v2 container" }] };
B0.WAV = { extension: "wav", mimeType: "audio/wav", description: "Waveform Audio File Format", signatures: [{ sequence: [82, 73, 70, 70, 87, 65, 86, 69, 102, 109, 116, 32], skippedBytes: [4, 5, 6, 7] }] };
var Am = {};
Object.defineProperty(Am, "__esModule", { value: true });
Am.CompressedTypes = void 0;
class $d {
}
Am.CompressedTypes = $d;
$d._7Z = { extension: "7z", mimeType: "application/x-7z-compressed", description: "7-Zip compressed file", signatures: [{ sequence: [55, 122, 188, 175, 39, 28] }] };
$d.LZH = { extension: "lzh", mimeType: "application/x-lzh-compressed", description: "Compressed file using Lempel-Ziv and Haruyasu (LZH) compression algorithm", signatures: [{ sequence: [45, 104, 108, 48, 45], description: "Lempel Ziv Huffman archive file Method 0 (No compression)", compatibleExtensions: ["lha"] }, { sequence: [45, 104, 108, 53, 45], description: "Lempel Ziv Huffman archive file Method 5 (8KiB sliding window)", compatibleExtensions: ["lha"] }] };
$d.RAR = { extension: "rar", mimeType: "application/x-rar-compressed", description: "Roshal ARchive compressed archive file", signatures: [{ sequence: [82, 97, 114, 33, 26, 7, 0], description: "Compressed archive v5.00 onwards" }, { sequence: [82, 97, 114, 33, 26, 7, 1, 0], description: "Compressed archive v1.50 onwards" }] };
$d.ZIP = { extension: "zip", mimeType: "application/zip", description: "Compressed archive file", signatures: [{ sequence: [87, 105, 110, 90, 105, 112], offset: 29152, description: "WinZip compressed archive" }, { sequence: [80, 75, 3, 4, 20, 0, 1, 0, 99, 0, 0, 0, 0, 0], description: "ZLock Pro encrypted ZIP" }, { sequence: [80, 75, 76, 73, 84, 69], offset: 30, description: "PKLITE compressed ZIP archive (see also PKZIP)" }, { sequence: [80, 75, 83, 112, 88], offset: 526, description: "PKSFX self-extracting executable compressed file (see also PKZIP)" }, { sequence: [80, 75, 3, 4], description: "PKZIP archive file - zip file format and multiple formats based on it", compatibleExtensions: ["aar", "apk", "docx", "epub", "ipa", "jar", "kmz", "maff", "msix", "odp", "ods", "odt", "pk3", "pk4", "pptx", "usdz", "vsdx", "xlsx", "xpi"] }, { sequence: [80, 75, 5, 6], description: "PKZIP empty archive file - zip file format and multiple formats based on it", compatibleExtensions: ["aar", "apk", "docx", "epub", "ipa", "jar", "kmz", "maff", "msix", "odp", "ods", "odt", "pk3", "pk4", "pptx", "usdz", "vsdx", "xlsx", "xpi"] }, { sequence: [80, 75, 7, 8], description: "PKZIP multivolume archive file - zip file format and multiple formats based on it", compatibleExtensions: ["aar", "apk", "docx", "epub", "ipa", "jar", "kmz", "maff", "msix", "odp", "ods", "odt", "pk3", "pk4", "pptx", "usdz", "vsdx", "xlsx", "xpi"] }] };
var wm = {};
Object.defineProperty(wm, "__esModule", { value: true });
wm.OtherTypes = void 0;
class is {
}
wm.OtherTypes = is;
is.BLEND = { extension: "blend", mimeType: "application/x-blender", description: "Blender File Format", signatures: [{ sequence: [66, 76, 69, 78, 68, 69, 82] }] };
is.DOC = { extension: "doc", mimeType: "application/msword", description: "Old Microsoft Word documents", signatures: [{ sequence: [208, 207, 17, 224, 161, 177, 26, 225], compatibleExtensions: ["xls", "ppt", "msi", "msg", "dot", "pps", "xla", "wiz"], description: "An Object Linking and Embedding (OLE) Compound File (CF) (i.e., OLECF) file format, known as Compound Binary File format by Microsoft, used by Microsoft Office 97-2003 applications" }, { sequence: [219, 165, 45, 0], description: "Microsoft Word 2.0 file format" }] };
is.ELF = { extension: "elf", mimeType: "application/x-executable", description: "Executable and Linking Format executable file (Linux/Unix)", signatures: [{ sequence: [127, 69, 76, 70] }] };
is.EXE = { extension: "exe", mimeType: "application/x-msdownload", description: "Windows/DOS executable file and its descendants", signatures: [{ sequence: [77, 90], compatibleExtensions: ["acm", "ax", "cpl", "com", "dll", "drv", "efi", "fon", "iec", "ime", "mui", "ocx", "olb", "pif", "qts", "qtx", "rs", "sys", "scr", "tsp", "vbx", "vxd"] }, { sequence: [90, 77], description: "DOS ZM executable (rare)" }] };
is.INDD = { extension: "indd", mimeType: "application/x-indesign", description: "Adobe InDesign document", signatures: [{ sequence: [6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29], compatibleExtensions: ["indt"] }] };
is.MACHO = { extension: "macho", mimeType: "application/x-mach-binary", description: "Apple OS X ABI Mach-O binary file", signatures: [{ sequence: [254, 237, 250, 206], description: "32-bit" }, { sequence: [206, 250, 237, 254], description: "32-bit, where target system has reverse byte ordering from host running compiler" }, { sequence: [254, 237, 250, 207], description: "64-bit" }, { sequence: [207, 250, 237, 254], description: "64-bit, where target system has reverse byte ordering from host running compiler" }, { sequence: [202, 254, 186, 190], description: "Mach-O Fat Binary" }] };
is.PDF = { extension: "pdf", mimeType: "application/pdf", description: "Portable Document Format", signatures: [{ sequence: [37, 80, 68, 70, 45] }] };
is.ORC = { extension: "orc", mimeType: "application/x-orc", description: "Apache ORC (Optimized Row Columnar) file format for columnar storage", signatures: [{ sequence: [79, 82, 67] }] };
is.PARQUET = { extension: "parquet", mimeType: "application/vnd.apache.parquet", description: "Apache Parquet file format for columnar storage", signatures: [{ sequence: [80, 65, 82, 49] }] };
is.PS = { extension: "ps", mimeType: "application/postscript", description: "PostScript document", signatures: [{ sequence: [37, 33, 80, 83] }] };
is.RTF = { extension: "rtf", mimeType: "application/rtf", description: "Rich Text Format word processing file", signatures: [{ sequence: [123, 92, 114, 116, 102, 49] }] };
is.SQLITE = { extension: "sqlite", mimeType: "application/x-sqlite3", description: "SQLite database file", signatures: [{ sequence: [83, 81, 76, 105, 116, 101, 32, 102, 111, 114, 109, 97, 116, 32, 51, 0] }] };
is.STL = { extension: "stl", mimeType: "application/sla", description: "ASCII STL (STereoLithography) file for 3D printing", signatures: [{ sequence: [115, 111, 108, 105, 100] }] };
is.TTF = { extension: "ttf", mimeType: "application/x-font-ttf", description: "TrueType font file", signatures: [{ sequence: [116, 114, 117, 101, 0] }, { sequence: [0, 1, 0, 0, 0], compatibleExtensions: ["tte, dfont"] }] };
is.PCAP = { extension: "pcap", mimeType: "application/vnd.tcpdump.pcap", description: "Libpcap File Format", signatures: [{ sequence: [212, 195, 178, 161] }, { sequence: [77, 60, 178, 161], description: "Nanosecond resolution" }] };
var xm = {};
Object.defineProperty(xm, "__esModule", { value: true });
xm.ImageTypes = void 0;
class Qi {
}
xm.ImageTypes = Qi;
Qi.AVIF = { extension: "avif", mimeType: "image/avif", description: "Alliance for Open Media (AOMedia) Video 1 (AV1) Image File", signatures: [{ sequence: [0, 0, 0] }] };
Qi.BMP = { extension: "bmp", mimeType: "image/bmp", description: "A bitmap format used mostly in Windows", signatures: [{ sequence: [66, 77], compatibleExtensions: ["dib"] }] };
Qi.BPG = { extension: "bpg", mimeType: "image/bpg", description: "Better Portable Graphics image format", signatures: [{ sequence: [66, 80, 71, 251] }] };
Qi.CR2 = { extension: "cr2", mimeType: "image/x-canon-cr2", description: "Canon digital camera RAW file", signatures: [{ sequence: [73, 73, 42, 0, 16, 0, 0, 0, 67, 82] }] };
Qi.EXR = { extension: "exr", mimeType: "image/x-exr", description: "OpenEXR bitmap image format", signatures: [{ sequence: [118, 47, 49, 1] }] };
Qi.GIF = { extension: "gif", mimeType: "image/gif", description: "Image file encoded in the Graphics Interchange Format (GIF)", signatures: [{ sequence: [71, 73, 70, 56, 55, 97] }, { sequence: [71, 73, 70, 56, 57, 97] }] };
Qi.HEIC = { extension: "heic", mimeType: "image/heic", description: "A variant of the HEIF (High Efficiency Image Format) that store images on the latest Apple devices.", signatures: [{ sequence: [102, 116, 121, 112, 104, 101, 105, 99], offset: 4 }, { sequence: [102, 116, 121, 112, 109], offset: 4 }] };
Qi.ICO = { extension: "ico", mimeType: "image/x-icon", description: "Computer icon encoded in ICO file format", signatures: [{ sequence: [0, 0, 1, 0], compatibleExtensions: ["spl"] }] };
Qi.JPEG = { extension: "jpeg", mimeType: "image/jpeg", description: "JPEG (Joint Photographic Experts Group) is a widely used lossy image compression format.", signatures: [{ sequence: [255, 216, 255, 225, 69, 120, 105, 102, 0], skippedBytes: [4, 5], description: "Digital camera JPG using Exchangeable Image File Format (EXIF)" }, { sequence: [255, 216, 255, 232, 83, 80, 73, 70, 70, 0], skippedBytes: [4, 5], description: "Still Picture Interchange File Format (SPIFF)" }, { sequence: [255, 216, 255, 224, 0, 16, 74, 70, 73, 70, 0, 0], description: "JPEG raw or in the JFIF or Exif file format" }, { sequence: [255, 216, 255, 238], description: "JPEG raw or in the JFIF or Exif file format" }, { sequence: [255, 216, 255, 225, 69, 120, 105, 102, 0, 0], skippedBytes: [4, 5], description: "JPEG raw or in the JFIF or Exif file format" }, { sequence: [255, 216, 255, 224, 74, 70, 73, 70, 0], skippedBytes: [4, 5], description: "JPEG/JFIF graphics file", compatibleExtensions: ["jfif", "jpe"] }, { sequence: [255, 216, 255, 224], description: "JPEG raw or in the JFIF or Exif file format" }, { sequence: [255, 216], description: "Generic JPEGimage file", compatibleExtensions: ["jpe"] }] };
Qi.PBM = { extension: "pbm", mimeType: "image/x-portable-bitmap", description: "PBM (Portable Bitmap) is a simple monochrome bitmap image format that uses plain text ASCII characters to represent binary image data", signatures: [{ sequence: [80, 49, 10], description: "Portable bitmap ASCII" }, { sequence: [80, 52, 10], description: "Portable bitmap binary" }] };
Qi.PGM = { extension: "pgm", mimeType: "image/x-portable-graymap", description: "PGM (Portable Graymap) is a simple grayscale image format that uses ASCII text characters to represent binary image data.", signatures: [{ sequence: [80, 50, 10], description: "Portable Gray Map ASCII" }, { sequence: [80, 53, 10], description: "Portable Gray Map binary" }] };
Qi.PNG = { extension: "png", mimeType: "image/png", description: "PNG (Portable Network Graphics) is a lossless image compression format that supports a wide range of color depths and transparency and is widely used for high-quality graphics.", signatures: [{ sequence: [137, 80, 78, 71, 13, 10, 26, 10] }] };
Qi.PPM = { extension: "ppm", mimeType: "image/x-portable-pixmap", description: "PPM (Portable Pixmap) is a simple color image format in the Portable Network Graphics (PNG) suite.", signatures: [{ sequence: [80, 51, 10], description: "Portable Pixmap ASCII" }, { sequence: [80, 54, 10], description: "Portable Pixmap binary" }] };
Qi.PSD = { extension: "psd", mimeType: "image/vnd.adobe.photoshop", description: "PSD (Photoshop Document) is an Adobe Photoshop image file format", signatures: [{ sequence: [56, 66, 80, 83] }] };
Qi.TIFF = { extension: "tiff", mimeType: "image/tiff", description: "TIFF is a raster image format used for high-quality scanning, publishing, and photography", signatures: [{ sequence: [73, 73, 42, 0], compatibleExtensions: ["tif"] }, { sequence: [77, 77, 0, 42], compatibleExtensions: ["tif"] }, { sequence: [73, 73, 43, 0], compatibleExtensions: ["tif"], description: "BigTIFF files. Tagged Image File Format files > 4 GB" }, { sequence: [77, 77, 0, 43], compatibleExtensions: ["tif"], description: "BigTIFF files. Tagged Image File Format files > 4 GB" }] };
Qi.WEBP = { extension: "webp", mimeType: "image/webp", description: "A modern image format that provides superior lossless and lossy compression for images on the web", signatures: [{ sequence: [82, 73, 70, 70, 87, 69, 66, 80], skippedBytes: [4, 5, 6, 7] }] };
var _m = {};
Object.defineProperty(_m, "__esModule", { value: true });
_m.VideoTypes = void 0;
class To {
}
_m.VideoTypes = To;
To.AVI = { extension: "avi", mimeType: "video/x-msvideo", description: "Audio Video Interleave video format", signatures: [{ sequence: [82, 73, 70, 70, 65, 86, 73, 32, 76, 73, 83, 84], skippedBytes: [4, 5, 6, 7] }] };
To.FLV = { extension: "flv", mimeType: "video/x-flv", description: "Flash Video file", signatures: [{ sequence: [70, 76, 86, 1] }, { sequence: [102, 116, 121, 112, 77, 52, 86, 32], description: "ISO Media, MPEG v4 system, or iTunes AVC-LC file", offset: 4, compatibleExtensions: ["mp4", "m4v"] }] };
To.M4V = { extension: "m4v", mimeType: "video/x-m4v", description: "Apple's video container format, very similar to MP4", signatures: [{ sequence: [102, 116, 121, 112, 109, 112, 52, 50], description: "MPEG-4 video | QuickTime file", offset: 4, compatibleExtensions: ["mp4"] }, { sequence: [102, 116, 121, 112, 77, 52, 86, 32], description: "ISO Media, MPEG v4 system, or iTunes AVC-LC file", offset: 4, compatibleExtensions: ["mp4", "flv"] }] };
To.MKV = { extension: "mkv", mimeType: "video/x-matroska", description: "MKV (Matroska Video) is a flexible, open-source media container format that supports multiple audio, video, and subtitle streams in a single file", signatures: [{ sequence: [26, 69, 223, 163], description: "EBML identifier", compatibleExtensions: ["webm", "mka", "mks", "mk3d"] }] };
To.MOV = { extension: "mov", mimeType: "video/quicktime", description: "QuickTime movie file", signatures: [{ sequence: [102, 116, 121, 112, 113, 116, 32, 32], offset: 4 }, { sequence: [109, 111, 111, 118], offset: 4 }] };
To.MP4 = { extension: "mp4", mimeType: "video/mp4", description: "A multimedia container format widely used for storing audio, video, and other data, and is known for its high compression efficiency and compatibility with many devices", signatures: [{ sequence: [102, 116, 121, 112, 77, 83, 78, 86], description: "MPEG-4 video file", offset: 4 }, { sequence: [102, 116, 121, 112, 105, 115, 111, 109], description: "ISO Base Media file (MPEG-4) v1", offset: 4 }, { sequence: [102, 116, 121, 112, 77, 52, 86, 32], description: "ISO Media, MPEG v4 system, or iTunes AVC-LC file", offset: 4, compatibleExtensions: ["m4v", "flv"] }] };
To.OGG = { extension: "ogg", mimeType: "video/ogg", description: "Ogg Vorbis Codec compressed Multimedia file", signatures: [{ sequence: [79, 103, 103, 83, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], compatibleExtensions: ["oga", "ogv", "ogx"] }] };
To.SWF = { extension: "swf", mimeType: "application/x-shockwave-flash", description: "SWF (Shockwave Flash) is a file format for multimedia, vector graphics, and ActionScript, used for creating and delivering animations, games, and other interactive web-based content", signatures: [{ sequence: [67, 87, 83], description: "Macromedia Shockwave Flash player file (zlib compressed, SWF 6 and later)" }, { sequence: [70, 87, 83], description: "Macromedia Shockwave Flash player file (uncompressed)" }, { sequence: [90, 87, 83], description: "Macromedia Shockwave Flash player file (uncompressed)" }] };
To.WEBM = { extension: "webm", mimeType: "video/webm", description: "WebM is a royalty-free, open-source media file format optimized for web delivery, using efficient VP8 video and Vorbis audio codecs", signatures: [{ sequence: [26, 69, 223, 163], description: "EBML identifier", compatibleExtensions: ["mkv"] }] };
var py = {}, ss = {}, a7;
function Ple() {
  if (a7) return ss;
  a7 = 1, Object.defineProperty(ss, "__esModule", { value: true }), ss.isWAV = ss.isMP3 = ss.isM4A = ss.isFLAC = ss.isAMR = ss.isAAC = void 0;
  const t3 = C0(), e = Cn;
  function n(f, c) {
    const l = (0, e.getFileChunk)(f);
    return t3.FileTypes.checkByFileType(l, "aac") ? true : (c == null ? void 0 : c.excludeSimilarTypes) ? false : i(l);
  }
  ss.isAAC = n;
  function r(f) {
    const c = (0, e.getFileChunk)(f);
    return t3.FileTypes.checkByFileType(c, "amr");
  }
  ss.isAMR = r;
  function s(f) {
    const c = (0, e.getFileChunk)(f);
    return t3.FileTypes.checkByFileType(c, "flac");
  }
  ss.isFLAC = s;
  function i(f) {
    const c = (0, e.getFileChunk)(f);
    return t3.FileTypes.checkByFileType(c, "m4a");
  }
  ss.isM4A = i;
  function a(f) {
    const c = (0, e.getFileChunk)(f);
    return t3.FileTypes.checkByFileType(c, "mp3");
  }
  ss.isMP3 = a;
  function o(f) {
    const c = (0, e.getFileChunk)(f);
    return t3.FileTypes.checkByFileType(c, "wav");
  }
  return ss.isWAV = o, ss;
}
var ba = {}, o7;
function Nle() {
  if (o7) return ba;
  o7 = 1, Object.defineProperty(ba, "__esModule", { value: true }), ba.isZIP = ba.isRAR = ba.isLZH = ba.is7Z = void 0;
  const t3 = C0(), e = Cn;
  function n(a) {
    const o = (0, e.getFileChunk)(a);
    return t3.FileTypes.checkByFileType(o, "_7z");
  }
  ba.is7Z = n;
  function r(a) {
    const o = (0, e.getFileChunk)(a);
    return t3.FileTypes.checkByFileType(o, "lzh");
  }
  ba.isLZH = r;
  function s(a) {
    const o = (0, e.getFileChunk)(a);
    return t3.FileTypes.checkByFileType(o, "rar");
  }
  ba.isRAR = s;
  function i(a, o) {
    const f = (0, e.getFileChunk)(a, (o == null ? void 0 : o.chunkSize) || 64);
    return t3.FileTypes.checkByFileType(f, "zip");
  }
  return ba.isZIP = i, ba;
}
var Vr = {}, f7;
function Ule() {
  if (f7) return Vr;
  f7 = 1, Object.defineProperty(Vr, "__esModule", { value: true }), Vr.isWEBP = Vr.isTIFF = Vr.isPSD = Vr.isPPM = Vr.isPNG = Vr.isPGM = Vr.isPBM = Vr.isJPEG = Vr.isICO = Vr.isHEIC = Vr.isGIF = Vr.isEXR = Vr.isCR2 = Vr.isBPG = Vr.isBMP = Vr.isAVIF = void 0;
  const t3 = C0(), e = Cn;
  function n(I) {
    const S = (0, e.getFileChunk)(I);
    return t3.FileTypes.checkByFileType(S, "avif") ? (0, e.isAvifStringIncluded)(S) : false;
  }
  Vr.isAVIF = n;
  function r(I) {
    const S = (0, e.getFileChunk)(I);
    return t3.FileTypes.checkByFileType(S, "bmp");
  }
  Vr.isBMP = r;
  function s(I) {
    const S = (0, e.getFileChunk)(I);
    return t3.FileTypes.checkByFileType(S, "bpg");
  }
  Vr.isBPG = s;
  function i(I) {
    const S = (0, e.getFileChunk)(I);
    return t3.FileTypes.checkByFileType(S, "cr2");
  }
  Vr.isCR2 = i;
  function a(I) {
    const S = (0, e.getFileChunk)(I);
    return t3.FileTypes.checkByFileType(S, "exr");
  }
  Vr.isEXR = a;
  function o(I) {
    const S = (0, e.getFileChunk)(I);
    return t3.FileTypes.checkByFileType(S, "gif");
  }
  Vr.isGIF = o;
  function f(I) {
    const S = (0, e.getFileChunk)(I);
    return t3.FileTypes.checkByFileType(S, "avif") ? (0, e.isHeicSignatureIncluded)(S) : false;
  }
  Vr.isHEIC = f;
  function c(I) {
    const S = (0, e.getFileChunk)(I);
    return t3.FileTypes.checkByFileType(S, "ico");
  }
  Vr.isICO = c;
  function l(I) {
    const S = (0, e.getFileChunk)(I);
    return t3.FileTypes.checkByFileType(S, "jpeg");
  }
  Vr.isJPEG = l;
  function h(I) {
    const S = (0, e.getFileChunk)(I);
    return t3.FileTypes.checkByFileType(S, "pbm");
  }
  Vr.isPBM = h;
  function m(I) {
    const S = (0, e.getFileChunk)(I);
    return t3.FileTypes.checkByFileType(S, "pgm");
  }
  Vr.isPGM = m;
  function v(I) {
    const S = (0, e.getFileChunk)(I);
    return t3.FileTypes.checkByFileType(S, "png");
  }
  Vr.isPNG = v;
  function b(I) {
    const S = (0, e.getFileChunk)(I);
    return t3.FileTypes.checkByFileType(S, "ppm");
  }
  Vr.isPPM = b;
  function A(I) {
    const S = (0, e.getFileChunk)(I);
    return t3.FileTypes.checkByFileType(S, "psd");
  }
  Vr.isPSD = A;
  function _(I) {
    const S = (0, e.getFileChunk)(I);
    return t3.FileTypes.checkByFileType(S, "tiff");
  }
  Vr.isTIFF = _;
  function C(I) {
    const S = (0, e.getFileChunk)(I);
    return t3.FileTypes.checkByFileType(S, "webp");
  }
  return Vr.isWEBP = C, Vr;
}
var rn = {}, l7;
function Lle() {
  if (l7) return rn;
  l7 = 1, Object.defineProperty(rn, "__esModule", { value: true }), rn.isPCAP = rn.isDOC = rn.isTTF = rn.isSTL = rn.isSQLITE = rn.isRTF = rn.isPS = rn.isPDF = rn.isPARQUET = rn.isORC = rn.isINDD = rn.isMACHO = rn.isEXE = rn.isELF = rn.isBLEND = void 0;
  const t3 = C0(), e = Cn;
  function n(C) {
    const I = (0, e.getFileChunk)(C);
    return t3.FileTypes.checkByFileType(I, "blend");
  }
  rn.isBLEND = n;
  function r(C) {
    const I = (0, e.getFileChunk)(C);
    return t3.FileTypes.checkByFileType(I, "elf");
  }
  rn.isELF = r;
  function s(C) {
    const I = (0, e.getFileChunk)(C);
    return t3.FileTypes.checkByFileType(I, "exe");
  }
  rn.isEXE = s;
  function i(C) {
    const I = (0, e.getFileChunk)(C);
    return t3.FileTypes.checkByFileType(I, "macho");
  }
  rn.isMACHO = i;
  function a(C) {
    const I = (0, e.getFileChunk)(C);
    return t3.FileTypes.checkByFileType(I, "indd");
  }
  rn.isINDD = a;
  function o(C) {
    const I = (0, e.getFileChunk)(C);
    return t3.FileTypes.checkByFileType(I, "orc");
  }
  rn.isORC = o;
  function f(C) {
    const I = (0, e.getFileChunk)(C);
    return t3.FileTypes.checkByFileType(I, "parquet");
  }
  rn.isPARQUET = f;
  function c(C) {
    const I = (0, e.getFileChunk)(C);
    return t3.FileTypes.checkByFileType(I, "pdf");
  }
  rn.isPDF = c;
  function l(C) {
    const I = (0, e.getFileChunk)(C);
    return t3.FileTypes.checkByFileType(I, "ps");
  }
  rn.isPS = l;
  function h(C) {
    const I = (0, e.getFileChunk)(C);
    return t3.FileTypes.checkByFileType(I, "rtf");
  }
  rn.isRTF = h;
  function m(C) {
    const I = (0, e.getFileChunk)(C);
    return t3.FileTypes.checkByFileType(I, "sqlite");
  }
  rn.isSQLITE = m;
  function v(C) {
    const I = (0, e.getFileChunk)(C);
    return t3.FileTypes.checkByFileType(I, "stl");
  }
  rn.isSTL = v;
  function b(C) {
    const I = (0, e.getFileChunk)(C);
    return t3.FileTypes.checkByFileType(I, "ttf");
  }
  rn.isTTF = b;
  function A(C) {
    const I = (0, e.getFileChunk)(C);
    return t3.FileTypes.checkByFileType(I, "doc");
  }
  rn.isDOC = A;
  function _(C) {
    const I = (0, e.getFileChunk)(C);
    return t3.FileTypes.checkByFileType(I, "pcap");
  }
  return rn.isPCAP = _, rn;
}
var Yn = {}, u7;
function Ole() {
  if (u7) return Yn;
  u7 = 1, Object.defineProperty(Yn, "__esModule", { value: true }), Yn.isWEBM = Yn.isSWF = Yn.isOGG = Yn.isMP4 = Yn.isMOV = Yn.isMKV = Yn.isM4V = Yn.isFLV = Yn.isAVI = void 0;
  const t3 = C0(), e = Cn;
  function n(h) {
    const m = (0, e.getFileChunk)(h);
    return t3.FileTypes.checkByFileType(m, "avi");
  }
  Yn.isAVI = n;
  function r(h) {
    const m = (0, e.getFileChunk)(h);
    return t3.FileTypes.checkByFileType(m, "flv") ? (0, e.isFlvStringIncluded)(m) : false;
  }
  Yn.isFLV = r;
  function s(h) {
    const m = (0, e.getFileChunk)(h);
    return t3.FileTypes.checkByFileType(m, "m4v") ? (0, e.isftypStringIncluded)(m) : false;
  }
  Yn.isM4V = s;
  function i(h) {
    const m = (0, e.getFileChunk)(h, 64);
    return t3.FileTypes.checkByFileType(m, "mkv") ? (0, e.findMatroskaDocTypeElements)(m) === "mkv" : false;
  }
  Yn.isMKV = i;
  function a(h) {
    const m = (0, e.getFileChunk)(h);
    return t3.FileTypes.checkByFileType(m, "mov");
  }
  Yn.isMOV = a;
  function o(h, m) {
    const v = (0, e.getFileChunk)(h);
    return t3.FileTypes.checkByFileType(v, "mp4") ? true : (m == null ? void 0 : m.excludeSimilarTypes) ? false : s(v);
  }
  Yn.isMP4 = o;
  function f(h) {
    const m = (0, e.getFileChunk)(h);
    return t3.FileTypes.checkByFileType(m, "ogg");
  }
  Yn.isOGG = f;
  function c(h) {
    const m = (0, e.getFileChunk)(h);
    return t3.FileTypes.checkByFileType(m, "swf");
  }
  Yn.isSWF = c;
  function l(h) {
    const m = (0, e.getFileChunk)(h, 64);
    return t3.FileTypes.checkByFileType(m, "webm") ? (0, e.findMatroskaDocTypeElements)(m) === "webm" : false;
  }
  return Yn.isWEBM = l, Yn;
}
var c7;
function eF() {
  return c7 || (c7 = 1, function(t3) {
    var e = mt && mt.__createBinding || (Object.create ? function(o, f, c, l) {
      l === void 0 && (l = c);
      var h = Object.getOwnPropertyDescriptor(f, c);
      (!h || ("get" in h ? !f.__esModule : h.writable || h.configurable)) && (h = { enumerable: true, get: function() {
        return f[c];
      } }), Object.defineProperty(o, l, h);
    } : function(o, f, c, l) {
      l === void 0 && (l = c), o[l] = f[c];
    }), n = mt && mt.__exportStar || function(o, f) {
      for (var c in o) c !== "default" && !Object.prototype.hasOwnProperty.call(f, c) && e(f, o, c);
    };
    Object.defineProperty(t3, "__esModule", { value: true }), t3.validateFileType = void 0;
    const r = C0(), s = Cn;
    n(Ple(), t3), n(Nle(), t3), n(Ule(), t3), n(Lle(), t3), n(Ole(), t3);
    function i(o, f, c) {
      var l;
      let h = [];
      const m = [...new Set(f.map((C) => {
        const I = C.split(".").join("").toUpperCase();
        return I === "7Z" ? `_${I}` : I;
      }))];
      for (const C of m) {
        if (!Object.prototype.hasOwnProperty.call(r.FileTypes, C)) throw new TypeError(`Type \`${C.toLowerCase()}\` is not supported. Please make sure that \`types\` list conatins only supported files`);
        h.push(C);
      }
      if (c && Object.prototype.hasOwnProperty.call(c, "chunkSize") && ((l = c == null ? void 0 : c.chunkSize) !== null && l !== void 0 ? l : 0) <= 0) throw new RangeError("chunkSize must be bigger than zero");
      if (!c || !(c == null ? void 0 : c.excludeSimilarTypes)) {
        const C = a(h);
        C.length > 0 && (h = h.concat(C));
      }
      let v = [];
      const b = [];
      for (const C of h) {
        const I = r.FileTypes.getSignaturesByName(C);
        v = v.concat(I), r.FILE_TYPES_REQUIRED_ADDITIONAL_CHECK.includes(C.toLowerCase()) && b.push(r.FileTypes.getInfoByName(C));
      }
      const A = (0, s.getFileChunk)(o, (c == null ? void 0 : c.chunkSize) || 64), _ = r.FileTypes.detectSignature(A, v);
      if (!_) return false;
      if (b.length > 0) {
        const C = b.filter((I) => I.signatures.includes(_));
        if (C.length > 0) {
          const I = r.FileTypes.detectTypeByAdditionalCheck(A, C);
          return I ? h.some((S) => S.toLowerCase() === I) : false;
        }
      }
      return true;
    }
    t3.validateFileType = i;
    function a(o) {
      return o.some((f) => f === "MP4") ? ["M4V"] : o.some((f) => f === "AAC") ? ["M4A"] : [];
    }
  }(py)), py;
}
var h7;
function Qle() {
  if (h7) return Rl;
  h7 = 1, Object.defineProperty(Rl, "__esModule", { value: true }), Rl.FileTypes = Rl.FILE_TYPES_REQUIRED_ADDITIONAL_CHECK = void 0;
  const t3 = Cn, e = bm, n = Am, r = wm, s = xm, i = _m, a = eF();
  Rl.FILE_TYPES_REQUIRED_ADDITIONAL_CHECK = ["m4v", "flv", "mp4", "mkv", "webm", "avif", "heic"];
  class o {
    static getInfoByName(c) {
      return (0, t3.fetchFromObject)(o, c.toUpperCase());
    }
    static getSignaturesByName(c) {
      const { signatures: l } = (0, t3.fetchFromObject)(o, c.toUpperCase());
      return l;
    }
    static detectSignature(c, l) {
      for (const h of l) {
        let m = true;
        const v = h.offset || 0;
        let b = 0;
        for (let A = 0; A < h.sequence.length; A++) {
          if (h.skippedBytes && h.skippedBytes.includes(A)) {
            b++;
            continue;
          }
          if (c[v + A] !== h.sequence[A - b]) {
            m = false;
            break;
          }
        }
        if (m) return h;
      }
    }
    static detectTypeByAdditionalCheck(c, l) {
      const h = l.map((m) => m.extension);
      if (h.some((m) => ["m4v", "flv", "mp4", "heic"].includes(m))) return h.includes("heic") && (0, a.isHEIC)(c) ? "heic" : (0, a.isFLV)(c) ? "flv" : (0, a.isM4V)(c) && !(0, a.isHEIC)(c) ? "m4v" : "mp4";
      if (h.some((m) => ["mkv", "webm"].includes(m))) {
        const m = (0, t3.findMatroskaDocTypeElements)(c);
        return m === "mkv" && (0, a.isMKV)(c) ? "mkv" : m === "webm" && (0, a.isWEBM)(c) ? "webm" : void 0;
      } else if (h.some((m) => ["avif"].includes(m)) && (0, t3.isAvifStringIncluded)(c)) return "avif";
    }
    static detectbBySignatures(c, l) {
      for (const h of l) {
        let m = 0, v = true;
        const b = h.offset || 0, A = (h == null ? void 0 : h.skippedBytes) ? h.sequence.length + h.skippedBytes.length : h.sequence.length;
        for (let _ = 0; _ < A; _++) {
          if (h.skippedBytes && h.skippedBytes.includes(_)) {
            m++;
            continue;
          }
          if (c[b + _] !== h.sequence[_ - m]) {
            v = false;
            break;
          }
        }
        if (v) return h;
      }
    }
    static checkByFileType(c, l) {
      if (Object.prototype.hasOwnProperty.call(o, l.toUpperCase())) {
        const h = o.getSignaturesByName(l.toUpperCase());
        if (o.detectSignature(c, h)) return true;
      }
      return false;
    }
  }
  return Rl.FileTypes = o, o.AAC = e.AudioTypes.AAC, o.AMR = e.AudioTypes.AMR, o.FLAC = e.AudioTypes.FLAC, o.M4A = e.AudioTypes.M4A, o.MP3 = e.AudioTypes.MP3, o.WAV = e.AudioTypes.WAV, o.AVIF = s.ImageTypes.AVIF, o.BMP = s.ImageTypes.BMP, o.BPG = s.ImageTypes.BPG, o.CR2 = s.ImageTypes.CR2, o.EXR = s.ImageTypes.EXR, o.GIF = s.ImageTypes.GIF, o.HEIC = s.ImageTypes.HEIC, o.ICO = s.ImageTypes.ICO, o.JPEG = s.ImageTypes.JPEG, o.PBM = s.ImageTypes.PBM, o.PGM = s.ImageTypes.PGM, o.PNG = s.ImageTypes.PNG, o.PPM = s.ImageTypes.PPM, o.PSD = s.ImageTypes.PSD, o.TIFF = s.ImageTypes.TIFF, o.WEBP = s.ImageTypes.WEBP, o.AVI = i.VideoTypes.AVI, o.FLV = i.VideoTypes.FLV, o.M4V = i.VideoTypes.M4V, o.MKV = i.VideoTypes.MKV, o.MOV = i.VideoTypes.MOV, o.MP4 = i.VideoTypes.MP4, o.OGG = i.VideoTypes.OGG, o.SWF = i.VideoTypes.SWF, o.WEBM = i.VideoTypes.WEBM, o._7Z = n.CompressedTypes._7Z, o.LZH = n.CompressedTypes.LZH, o.RAR = n.CompressedTypes.RAR, o.ZIP = n.CompressedTypes.ZIP, o.BLEND = r.OtherTypes.BLEND, o.DOC = r.OtherTypes.DOC, o.ELF = r.OtherTypes.ELF, o.EXE = r.OtherTypes.EXE, o.INDD = r.OtherTypes.INDD, o.MACHO = r.OtherTypes.MACHO, o.ORC = r.OtherTypes.ORC, o.PARQUET = r.OtherTypes.PARQUET, o.PCAP = r.OtherTypes.PCAP, o.PDF = r.OtherTypes.PDF, o.PS = r.OtherTypes.PS, o.RTF = r.OtherTypes.RTF, o.SQLITE = r.OtherTypes.SQLITE, o.STL = r.OtherTypes.STL, o.TTF = r.OtherTypes.TTF, Rl;
}
var tF = {}, rF = {}, nF = {};
Object.defineProperty(nF, "__esModule", { value: true });
(function(t3) {
  var e = mt && mt.__createBinding || (Object.create ? function(r, s, i, a) {
    a === void 0 && (a = i);
    var o = Object.getOwnPropertyDescriptor(s, i);
    (!o || ("get" in o ? !s.__esModule : o.writable || o.configurable)) && (o = { enumerable: true, get: function() {
      return s[i];
    } }), Object.defineProperty(r, a, o);
  } : function(r, s, i, a) {
    a === void 0 && (a = i), r[a] = s[i];
  }), n = mt && mt.__exportStar || function(r, s) {
    for (var i in r) i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, r, i);
  };
  Object.defineProperty(t3, "__esModule", { value: true }), n(nF, t3);
})(rF);
var iF = {}, sF = {};
Object.defineProperty(sF, "__esModule", { value: true });
var aF = {};
Object.defineProperty(aF, "__esModule", { value: true });
var oF = {};
Object.defineProperty(oF, "__esModule", { value: true });
var fF = {};
Object.defineProperty(fF, "__esModule", { value: true });
(function(t3) {
  var e = mt && mt.__createBinding || (Object.create ? function(r, s, i, a) {
    a === void 0 && (a = i);
    var o = Object.getOwnPropertyDescriptor(s, i);
    (!o || ("get" in o ? !s.__esModule : o.writable || o.configurable)) && (o = { enumerable: true, get: function() {
      return s[i];
    } }), Object.defineProperty(r, a, o);
  } : function(r, s, i, a) {
    a === void 0 && (a = i), r[a] = s[i];
  }), n = mt && mt.__exportStar || function(r, s) {
    for (var i in r) i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, r, i);
  };
  Object.defineProperty(t3, "__esModule", { value: true }), n(sF, t3), n(aF, t3), n(oF, t3), n(fF, t3);
})(iF);
(function(t3) {
  var e = mt && mt.__createBinding || (Object.create ? function(r, s, i, a) {
    a === void 0 && (a = i);
    var o = Object.getOwnPropertyDescriptor(s, i);
    (!o || ("get" in o ? !s.__esModule : o.writable || o.configurable)) && (o = { enumerable: true, get: function() {
      return s[i];
    } }), Object.defineProperty(r, a, o);
  } : function(r, s, i, a) {
    a === void 0 && (a = i), r[a] = s[i];
  }), n = mt && mt.__exportStar || function(r, s) {
    for (var i in r) i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, r, i);
  };
  Object.defineProperty(t3, "__esModule", { value: true }), n(rF, t3), n(iF, t3);
})(tF);
var lF = {}, uF = {};
Object.defineProperty(uF, "__esModule", { value: true });
var cF = {};
Object.defineProperty(cF, "__esModule", { value: true });
(function(t3) {
  var e = mt && mt.__createBinding || (Object.create ? function(r, s, i, a) {
    a === void 0 && (a = i);
    var o = Object.getOwnPropertyDescriptor(s, i);
    (!o || ("get" in o ? !s.__esModule : o.writable || o.configurable)) && (o = { enumerable: true, get: function() {
      return s[i];
    } }), Object.defineProperty(r, a, o);
  } : function(r, s, i, a) {
    a === void 0 && (a = i), r[a] = s[i];
  }), n = mt && mt.__exportStar || function(r, s) {
    for (var i in r) i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, r, i);
  };
  Object.defineProperty(t3, "__esModule", { value: true }), n(uF, t3), n(cF, t3);
})(lF);
var d7;
function C0() {
  return d7 || (d7 = 1, function(t3) {
    var e = mt && mt.__createBinding || (Object.create ? function(r, s, i, a) {
      a === void 0 && (a = i);
      var o = Object.getOwnPropertyDescriptor(s, i);
      (!o || ("get" in o ? !s.__esModule : o.writable || o.configurable)) && (o = { enumerable: true, get: function() {
        return s[i];
      } }), Object.defineProperty(r, a, o);
    } : function(r, s, i, a) {
      a === void 0 && (a = i), r[a] = s[i];
    }), n = mt && mt.__exportStar || function(r, s) {
      for (var i in r) i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, r, i);
    };
    Object.defineProperty(t3, "__esModule", { value: true }), n(Qle(), t3), n(tF, t3), n(lF, t3);
  }(dy)), dy;
}
Object.defineProperty(ym, "__esModule", { value: true });
ym.detectFile = void 0;
const Fl = C0(), Kle = Cn;
function Hle(t3, e) {
  var n;
  if (e && Object.prototype.hasOwnProperty.call(e, "chunkSize") && ((n = e == null ? void 0 : e.chunkSize) !== null && n !== void 0 ? n : 0) <= 0) throw new RangeError("chunkSize must be bigger than zero");
  const r = (0, Kle.getFileChunk)(t3, (e == null ? void 0 : e.chunkSize) || 64);
  if (r.length === 0) return;
  const s = [], i = [];
  for (const o in Fl.FileTypes) if (Object.prototype.hasOwnProperty.call(Fl.FileTypes, o)) {
    const f = Fl.FileTypes.getSignaturesByName(o), c = Fl.FileTypes.detectbBySignatures(r, f);
    if (c) {
      const l = Fl.FileTypes.getInfoByName(o);
      Fl.FILE_TYPES_REQUIRED_ADDITIONAL_CHECK.includes(l.extension) && i.push(l.extension);
      const h = { extension: l.extension, mimeType: l.mimeType, description: l.description, signature: Object.assign(Object.assign({}, c), { sequence: c.sequence.map((m) => m.toString(16)) }) };
      s.push(h);
    }
  }
  if (s.length === 0) return;
  if (s.length === 1 && i.length === 0) return s[0];
  const a = Fl.FileTypes.detectTypeByAdditionalCheck(r, s);
  if (a) return s.find((o) => o.extension === a);
}
ym.detectFile = Hle;
var qle = mt && mt.__createBinding || (Object.create ? function(t3, e, n, r) {
  r === void 0 && (r = n);
  var s = Object.getOwnPropertyDescriptor(e, n);
  (!s || ("get" in s ? !e.__esModule : s.writable || s.configurable)) && (s = { enumerable: true, get: function() {
    return e[n];
  } }), Object.defineProperty(t3, r, s);
} : function(t3, e, n, r) {
  r === void 0 && (r = n), t3[r] = e[n];
}), zle = mt && mt.__setModuleDefault || (Object.create ? function(t3, e) {
  Object.defineProperty(t3, "default", { enumerable: true, value: e });
} : function(t3, e) {
  t3.default = e;
}), hF = mt && mt.__importStar || function(t3) {
  if (t3 && t3.__esModule) return t3;
  var e = {};
  if (t3 != null) for (var n in t3) n !== "default" && Object.prototype.hasOwnProperty.call(t3, n) && qle(e, t3, n);
  return zle(e, t3), e;
};
const Gle = hF(ym), Vle = hF(eF()), Yle = Object.assign(Object.assign({}, Gle), Vle);
var Wle = Yle;
async function Jle(t3) {
  if (!t3) throw new Error("No file provided.");
  const e = await dF(t3, 3e4), n = Wle.detectFile(e), r = { fileName: t3.name, actualSize: t3.size, claimedType: t3.type || "Unknown", matches: [] };
  return n && r.matches.push({ name: n.description || `${n.extension.toUpperCase()} File`, ext: `.${n.extension}`, mime: n.mimeType }), r;
}
function dF(t3, e) {
  return new Promise((n, r) => {
    const s = new FileReader();
    s.onload = () => n(s.result), s.onerror = () => r(s.error);
    const i = t3.slice(0, e);
    s.readAsArrayBuffer(i);
  });
}
async function Zle(t3) {
  const e = await dF(t3, 16), n = new Uint8Array(e);
  return Array.from(n).map((r) => r.toString(16).toUpperCase().padStart(2, "0")).join(" ");
}
function p7(t3, e, n) {
  const r = t3.slice();
  return r[10] = e[n], r;
}
function g7(t3) {
  let e, n, r = t3[0].name + "", s, i, a = (t3[0].size / 1024).toFixed(2) + "", o, f;
  return { c() {
    e = H("div"), n = we("\u{1F4C4} "), s = we(r), i = we(" ("), o = we(a), f = we(" KB)"), V(e, "class", "file-badge svelte-1d9khhy");
  }, m(c, l) {
    R(c, e, l), q(e, n), q(e, s), q(e, i), q(e, o), q(e, f);
  }, p(c, l) {
    l & 1 && r !== (r = c[0].name + "") && Ze(s, r), l & 1 && a !== (a = (c[0].size / 1024).toFixed(2) + "") && Ze(o, a);
  }, d(c) {
    c && D(e);
  } };
}
function jle(t3) {
  let e;
  return { c() {
    e = we("Detect File Type");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function Xle(t3) {
  let e;
  return { c() {
    e = we("Analyzing...");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function e0e(t3) {
  let e;
  function n(i, a) {
    return i[4] ? Xle : jle;
  }
  let r = n(t3), s = r(t3);
  return { c() {
    s.c(), e = Lt();
  }, m(i, a) {
    s.m(i, a), R(i, e, a);
  }, p(i, a) {
    r !== (r = n(i)) && (s.d(1), s = r(i), s && (s.c(), s.m(e.parentNode, e)));
  }, d(i) {
    i && D(e), s.d(i);
  } };
}
function t0e(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function m7(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[3]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 8 && Ze(n, r[3]);
  }, d(r) {
    r && D(e);
  } };
}
function v7(t3) {
  let e, n, r, s, i, a, o, f, c, l, h = t3[1].matches.length > 0 && !t3[1].fileName.toLowerCase().endsWith(t3[1].matches[0].ext.toLowerCase()), m, v, b, A, _ = (t3[1].claimedType || "n/a") + "", C;
  function I(U, Q) {
    return U[1].matches.length > 0 ? n0e : r0e;
  }
  let S = I(t3), $ = S(t3), F = h && b7(t3);
  return { c() {
    e = H("div"), n = H("div"), n.textContent = "Magic Bytes (First 16 bytes):", r = z(), s = H("div"), i = we(t3[2]), a = we(" ..."), o = z(), f = H("div"), f.textContent = "Analysis Results:", c = z(), $.c(), l = z(), F && F.c(), m = z(), v = H("div"), b = H("strong"), b.textContent = "Browser detected:", A = z(), C = we(_), V(n, "class", "section-label svelte-1d9khhy"), V(s, "class", "hex-box svelte-1d9khhy"), V(f, "class", "section-label svelte-1d9khhy"), V(v, "class", "browser-hint"), V(e, "class", "results-area");
  }, m(U, Q) {
    R(U, e, Q), q(e, n), q(e, r), q(e, s), q(s, i), q(s, a), q(e, o), q(e, f), q(e, c), $.m(e, null), q(e, l), F && F.m(e, null), q(e, m), q(e, v), q(v, b), q(v, A), q(v, C);
  }, p(U, Q) {
    Q & 4 && Ze(i, U[2]), S === (S = I(U)) && $ ? $.p(U, Q) : ($.d(1), $ = S(U), $ && ($.c(), $.m(e, l))), Q & 2 && (h = U[1].matches.length > 0 && !U[1].fileName.toLowerCase().endsWith(U[1].matches[0].ext.toLowerCase())), h ? F ? F.p(U, Q) : (F = b7(U), F.c(), F.m(e, m)) : F && (F.d(1), F = null), Q & 2 && _ !== (_ = (U[1].claimedType || "n/a") + "") && Ze(C, _);
  }, d(U) {
    U && D(e), $.d(), F && F.d();
  } };
}
function r0e(t3) {
  let e;
  return { c() {
    e = H("div"), e.innerHTML = "<strong>Unknown Format</strong> <p>The file signature did not match any known types in our database. It might be a plain text file or a proprietary binary format.</p>", V(e, "class", "no-match svelte-1d9khhy");
  }, m(n, r) {
    R(n, e, r);
  }, p: dt, d(n) {
    n && D(e);
  } };
}
function n0e(t3) {
  let e, n = Mr(t3[1].matches), r = [];
  for (let s = 0; s < n.length; s += 1) r[s] = y7(p7(t3, n, s));
  return { c() {
    e = H("div");
    for (let s = 0; s < r.length; s += 1) r[s].c();
    V(e, "class", "match-list");
  }, m(s, i) {
    R(s, e, i);
    for (let a = 0; a < r.length; a += 1) r[a] && r[a].m(e, null);
  }, p(s, i) {
    if (i & 2) {
      n = Mr(s[1].matches);
      let a;
      for (a = 0; a < n.length; a += 1) {
        const o = p7(s, n, a);
        r[a] ? r[a].p(o, i) : (r[a] = y7(o), r[a].c(), r[a].m(e, null));
      }
      for (; a < r.length; a += 1) r[a].d(1);
      r.length = n.length;
    }
  }, d(s) {
    s && D(e), jn(r, s);
  } };
}
function y7(t3) {
  let e, n, r, s = t3[10].name + "", i, a, o, f = t3[10].ext + "", c, l, h, m, v, b = t3[10].mime + "", A, _;
  return { c() {
    e = H("div"), n = H("div"), r = H("span"), i = we(s), a = z(), o = H("span"), c = we(f), l = z(), h = H("div"), m = H("span"), m.textContent = "MIME Type:", v = z(), A = we(b), _ = z(), V(r, "class", "match-name svelte-1d9khhy"), V(o, "class", "match-ext"), V(n, "class", "match-header"), V(m, "class", "label svelte-1d9khhy"), V(h, "class", "match-detail svelte-1d9khhy"), V(e, "class", "match-card svelte-1d9khhy");
  }, m(C, I) {
    R(C, e, I), q(e, n), q(n, r), q(r, i), q(n, a), q(n, o), q(o, c), q(e, l), q(e, h), q(h, m), q(h, v), q(h, A), q(e, _);
  }, p(C, I) {
    I & 2 && s !== (s = C[10].name + "") && Ze(i, s), I & 2 && f !== (f = C[10].ext + "") && Ze(c, f), I & 2 && b !== (b = C[10].mime + "") && Ze(A, b);
  }, d(C) {
    C && D(e);
  } };
}
function b7(t3) {
  let e, n, r, s, i = t3[1].fileName.split(".").pop() + "", a, o, f, c = t3[1].matches[0].ext + "", l, h;
  return { c() {
    e = H("div"), n = H("strong"), n.textContent = "Mismatch Detected:", r = we(" This file has a "), s = H("code"), a = we(i), o = we(" extension, but the magic bytes indicate it is a "), f = H("strong"), l = we(c), h = we(" file."), V(e, "class", "warning-box svelte-1d9khhy");
  }, m(m, v) {
    R(m, e, v), q(e, n), q(e, r), q(e, s), q(s, a), q(e, o), q(e, f), q(f, l), q(e, h);
  }, p(m, v) {
    v & 2 && i !== (i = m[1].fileName.split(".").pop() + "") && Ze(a, i), v & 2 && c !== (c = m[1].matches[0].ext + "") && Ze(l, c);
  }, d(m) {
    m && D(e);
  } };
}
function i0e(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m;
  n = new la({ props: { label: "Select File to Analyze" } }), n.$on("change", t3[5]);
  let v = t3[0] && g7(t3);
  a = new ut({ props: { disabled: t3[4] || !t3[0], $$slots: { default: [e0e] }, $$scope: { ctx: t3 } } }), a.$on("click", t3[7]), f = new ut({ props: { variant: "secondary", $$slots: { default: [t0e] }, $$scope: { ctx: t3 } } }), f.$on("click", t3[9]);
  let b = t3[3] && m7(t3), A = t3[1] && v7(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), r = z(), v && v.c(), s = z(), i = H("div"), fe(a.$$.fragment), o = z(), fe(f.$$.fragment), c = z(), b && b.c(), l = z(), A && A.c(), h = Lt(), V(e, "class", "drop-container"), V(i, "class", "button-row");
  }, m(_, C) {
    R(_, e, C), ae(n, e, null), R(_, r, C), v && v.m(_, C), R(_, s, C), R(_, i, C), ae(a, i, null), q(i, o), ae(f, i, null), R(_, c, C), b && b.m(_, C), R(_, l, C), A && A.m(_, C), R(_, h, C), m = true;
  }, p(_, C) {
    _[0] ? v ? v.p(_, C) : (v = g7(_), v.c(), v.m(s.parentNode, s)) : v && (v.d(1), v = null);
    const I = {};
    C & 17 && (I.disabled = _[4] || !_[0]), C & 8208 && (I.$$scope = { dirty: C, ctx: _ }), a.$set(I);
    const S = {};
    C & 8192 && (S.$$scope = { dirty: C, ctx: _ }), f.$set(S), _[3] ? b ? b.p(_, C) : (b = m7(_), b.c(), b.m(l.parentNode, l)) : b && (b.d(1), b = null), _[1] ? A ? A.p(_, C) : (A = v7(_), A.c(), A.m(h.parentNode, h)) : A && (A.d(1), A = null);
  }, i(_) {
    m || (W(n.$$.fragment, _), W(a.$$.fragment, _), W(f.$$.fragment, _), m = true);
  }, o(_) {
    j(n.$$.fragment, _), j(a.$$.fragment, _), j(f.$$.fragment, _), m = false;
  }, d(_) {
    _ && (D(e), D(r), D(s), D(i), D(c), D(l), D(h)), oe(n), v && v.d(_), oe(a), oe(f), b && b.d(_), A && A.d(_);
  } };
}
function s0e(t3) {
  let e, n, r, s, i, a, o;
  return { c() {
    e = we("The "), n = H("b"), n.textContent = "File Type Detector Tool", r = we(` is a utility designed to identify the possible file type 
    of any selected file by analyzing its binary signature, also known as `), s = H("i"), s.textContent = "magic bytes", i = we(`.
    It uses the robust `), a = H("a"), a.textContent = "file-type-checker", o = we(" library."), V(a, "href", "https://www.npmjs.com/package/file-type-checker"), V(a, "target", "_blank"), V(a, "rel", "noreferrer");
  }, m(f, c) {
    R(f, e, c), R(f, n, c), R(f, r, c), R(f, s, c), R(f, i, c), R(f, a, c), R(f, o, c);
  }, p: dt, d(f) {
    f && (D(e), D(n), D(r), D(s), D(i), D(a), D(o));
  } };
}
function a0e(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "File Type Detector", $$slots: { default: [i0e] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Magic Bytes", links: t3[8], $$slots: { default: [s0e] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 8223 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 8192 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function o0e(t3, e, n) {
  let r = null, s = null, i = "", a = "", o = false;
  function f(v) {
    v.detail && v.detail.length > 0 && (n(0, r = v.detail[0]), c());
  }
  function c() {
    n(1, s = null), n(2, i = ""), n(3, a = "");
  }
  async function l() {
    if (!r) {
      n(3, a = "Please select a file first.");
      return;
    }
    n(4, o = true), c();
    try {
      await new Promise((A) => setTimeout(A, 50));
      const [v, b] = await Promise.all([Jle(r), Zle(r)]);
      n(1, s = v), n(2, i = b);
    } catch (v) {
      n(3, a = v.message);
    } finally {
      n(4, o = false);
    }
  }
  return [r, s, i, a, o, f, c, l, [{ text: "List of file signatures (magic bytes) - Wikipedia", url: "https://en.wikipedia.org/wiki/List_of_file_signatures" }], () => {
    n(0, r = null), c();
  }];
}
class f0e extends xt {
  constructor(e) {
    super(), wt(this, e, o0e, a0e, At, {});
  }
}
function l0e(t3) {
  if (!t3) throw new Error("Log file is empty.");
  const e = /\b(INFO|ERROR|WARN|WARNING|DEBUG|FATAL|CRITICAL)\b/i, n = /\b(?:\d{1,3}\.){3}\d{1,3}\b/, r = /\b\d{4}-\d{2}-\d{2}[ T]\d{2}:\d{2}:\d{2}\b/, s = { levels: {}, ips: {}, timestamps: {}, totalLines: 0 }, i = t3.split(/\r?\n/);
  s.totalLines = i.length;
  for (const a of i) {
    if (!a.trim()) continue;
    const o = a.match(e);
    if (o) {
      let l = o[0].toUpperCase();
      l === "WARN" && (l = "WARNING"), s.levels[l] = (s.levels[l] || 0) + 1;
    }
    const f = a.match(n);
    if (f) {
      const l = f[0];
      s.ips[l] = (s.ips[l] || 0) + 1;
    }
    const c = a.match(r);
    if (c) {
      const l = c[0];
      s.timestamps[l] = (s.timestamps[l] || 0) + 1;
    }
  }
  return s;
}
function gy(t3, e = 10) {
  return Object.entries(t3).sort((n, r) => r[1] - n[1]).slice(0, e).map(([n, r]) => ({ key: n, count: r }));
}
function u0e(t3) {
  const e = t3.reduce((s, i) => s + i.count, 0);
  let n = 0;
  const r = [];
  return t3.forEach((s) => {
    const i = s.count / e * 360;
    r.push(`${s.color} ${n}deg ${n + i}deg`), n += i;
  }), `conic-gradient(${r.join(", ")})`;
}
function A7(t3, e, n) {
  const r = t3.slice();
  return r[13] = e[n], r;
}
function w7(t3, e, n) {
  const r = t3.slice();
  return r[16] = e[n], r;
}
function x7(t3, e, n) {
  const r = t3.slice();
  return r[19] = e[n], r;
}
function _7(t3) {
  let e, n, r = t3[0].name + "", s, i, a = (t3[0].size / 1024).toFixed(1) + "", o, f;
  return { c() {
    e = H("div"), n = we("\u{1F4C4} "), s = we(r), i = we(" ("), o = we(a), f = we(" KB)"), V(e, "class", "file-badge svelte-efa9gy");
  }, m(c, l) {
    R(c, e, l), q(e, n), q(e, s), q(e, i), q(e, o), q(e, f);
  }, p(c, l) {
    l & 1 && r !== (r = c[0].name + "") && Ze(s, r), l & 1 && a !== (a = (c[0].size / 1024).toFixed(1) + "") && Ze(o, a);
  }, d(c) {
    c && D(e);
  } };
}
function c0e(t3) {
  let e;
  return { c() {
    e = we("Analyze Log");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function h0e(t3) {
  let e;
  return { c() {
    e = we("Analyzing...");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function d0e(t3) {
  let e;
  function n(i, a) {
    return i[3] ? h0e : c0e;
  }
  let r = n(t3), s = r(t3);
  return { c() {
    s.c(), e = Lt();
  }, m(i, a) {
    s.m(i, a), R(i, e, a);
  }, p(i, a) {
    r !== (r = n(i)) && (s.d(1), s = r(i), s && (s.c(), s.m(e.parentNode, e)));
  }, d(i) {
    i && D(e), s.d(i);
  } };
}
function p0e(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function E7(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[2]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 4 && Ze(n, r[2]);
  }, d(r) {
    r && D(e);
  } };
}
function B7(t3) {
  let e, n, r, s, i = t3[1].totalLines + "", a, o, f, c, l, h, m = Object.keys(t3[1].ips).length + "", v, b, A, _, C, I, S = Object.keys(t3[1].levels).length + "", $, F, U, Q, P, N, L = t3[5].length > 0 && C7(t3), B = t3[6].length > 0 && I7(t3), u = t3[7].length > 0 && M7(t3);
  return { c() {
    e = H("div"), n = H("div"), r = H("div"), s = H("span"), a = we(i), o = z(), f = H("span"), f.textContent = "Total Lines", c = z(), l = H("div"), h = H("span"), v = we(m), b = z(), A = H("span"), A.textContent = "Unique IPs", _ = z(), C = H("div"), I = H("span"), $ = we(S), F = z(), U = H("span"), U.textContent = "Event Types", Q = z(), L && L.c(), P = z(), B && B.c(), N = z(), u && u.c(), V(s, "class", "stat-val svelte-efa9gy"), V(f, "class", "stat-label svelte-efa9gy"), V(r, "class", "stat-card svelte-efa9gy"), V(h, "class", "stat-val svelte-efa9gy"), V(A, "class", "stat-label svelte-efa9gy"), V(l, "class", "stat-card svelte-efa9gy"), V(I, "class", "stat-val svelte-efa9gy"), V(U, "class", "stat-label svelte-efa9gy"), V(C, "class", "stat-card svelte-efa9gy"), V(n, "class", "stats-row svelte-efa9gy"), V(e, "class", "dashboard svelte-efa9gy");
  }, m(p, d) {
    R(p, e, d), q(e, n), q(n, r), q(r, s), q(s, a), q(r, o), q(r, f), q(n, c), q(n, l), q(l, h), q(h, v), q(l, b), q(l, A), q(n, _), q(n, C), q(C, I), q(I, $), q(C, F), q(C, U), q(e, Q), L && L.m(e, null), q(e, P), B && B.m(e, null), q(e, N), u && u.m(e, null);
  }, p(p, d) {
    d & 2 && i !== (i = p[1].totalLines + "") && Ze(a, i), d & 2 && m !== (m = Object.keys(p[1].ips).length + "") && Ze(v, m), d & 2 && S !== (S = Object.keys(p[1].levels).length + "") && Ze($, S), p[5].length > 0 ? L ? L.p(p, d) : (L = C7(p), L.c(), L.m(e, P)) : L && (L.d(1), L = null), p[6].length > 0 ? B ? B.p(p, d) : (B = I7(p), B.c(), B.m(e, N)) : B && (B.d(1), B = null), p[7].length > 0 ? u ? u.p(p, d) : (u = M7(p), u.c(), u.m(e, null)) : u && (u.d(1), u = null);
  }, d(p) {
    p && D(e), L && L.d(), B && B.d(), u && u.d();
  } };
}
function C7(t3) {
  let e, n, r, s, i, a, o, f = Mr(t3[5]), c = [];
  for (let l = 0; l < f.length; l += 1) c[l] = k7(x7(t3, f, l));
  return { c() {
    e = H("div"), n = H("h3"), n.textContent = "Log Level Distribution", r = z(), s = H("div"), i = H("div"), a = z(), o = H("div");
    for (let l = 0; l < c.length; l += 1) c[l].c();
    V(n, "class", "svelte-efa9gy"), V(i, "class", "pie-chart svelte-efa9gy"), St(i, "background", t3[4]), V(o, "class", "legend"), V(s, "class", "chart-layout svelte-efa9gy"), V(e, "class", "section svelte-efa9gy");
  }, m(l, h) {
    R(l, e, h), q(e, n), q(e, r), q(e, s), q(s, i), q(s, a), q(s, o);
    for (let m = 0; m < c.length; m += 1) c[m] && c[m].m(o, null);
  }, p(l, h) {
    if (h & 16 && St(i, "background", l[4]), h & 32) {
      f = Mr(l[5]);
      let m;
      for (m = 0; m < f.length; m += 1) {
        const v = x7(l, f, m);
        c[m] ? c[m].p(v, h) : (c[m] = k7(v), c[m].c(), c[m].m(o, null));
      }
      for (; m < c.length; m += 1) c[m].d(1);
      c.length = f.length;
    }
  }, d(l) {
    l && D(e), jn(c, l);
  } };
}
function k7(t3) {
  let e, n, r, s, i = t3[19].label + "", a, o, f, c = t3[19].count + "", l, h;
  return { c() {
    e = H("div"), n = H("span"), r = z(), s = H("span"), a = we(i), o = z(), f = H("span"), l = we(c), h = z(), V(n, "class", "dot svelte-efa9gy"), St(n, "background", t3[19].color), V(s, "class", "l-name svelte-efa9gy"), V(f, "class", "l-count svelte-efa9gy"), V(e, "class", "legend-item svelte-efa9gy");
  }, m(m, v) {
    R(m, e, v), q(e, n), q(e, r), q(e, s), q(s, a), q(e, o), q(e, f), q(f, l), q(e, h);
  }, p(m, v) {
    v & 32 && St(n, "background", m[19].color), v & 32 && i !== (i = m[19].label + "") && Ze(a, i), v & 32 && c !== (c = m[19].count + "") && Ze(l, c);
  }, d(m) {
    m && D(e);
  } };
}
function I7(t3) {
  let e, n, r, s, i = Mr(t3[6]), a = [];
  for (let o = 0; o < i.length; o += 1) a[o] = S7(w7(t3, i, o));
  return { c() {
    e = H("div"), n = H("h3"), n.textContent = "Top Active IP Addresses", r = z(), s = H("div");
    for (let o = 0; o < a.length; o += 1) a[o].c();
    V(n, "class", "svelte-efa9gy"), V(s, "class", "bar-chart"), V(e, "class", "section svelte-efa9gy");
  }, m(o, f) {
    R(o, e, f), q(e, n), q(e, r), q(e, s);
    for (let c = 0; c < a.length; c += 1) a[c] && a[c].m(s, null);
  }, p(o, f) {
    if (f & 64) {
      i = Mr(o[6]);
      let c;
      for (c = 0; c < i.length; c += 1) {
        const l = w7(o, i, c);
        a[c] ? a[c].p(l, f) : (a[c] = S7(l), a[c].c(), a[c].m(s, null));
      }
      for (; c < a.length; c += 1) a[c].d(1);
      a.length = i.length;
    }
  }, d(o) {
    o && D(e), jn(a, o);
  } };
}
function S7(t3) {
  let e, n, r = t3[16].key + "", s, i, a, o, f = t3[16].count + "", c, l;
  return { c() {
    e = H("div"), n = H("div"), s = we(r), i = z(), a = H("div"), o = H("div"), c = we(f), l = z(), V(n, "class", "bar-label svelte-efa9gy"), V(o, "class", "bar-fill svelte-efa9gy"), St(o, "width", t3[16].count / t3[6][0].count * 100 + "%"), V(a, "class", "bar-track svelte-efa9gy"), V(e, "class", "bar-row svelte-efa9gy");
  }, m(h, m) {
    R(h, e, m), q(e, n), q(n, s), q(e, i), q(e, a), q(a, o), q(o, c), q(e, l);
  }, p(h, m) {
    m & 64 && r !== (r = h[16].key + "") && Ze(s, r), m & 64 && f !== (f = h[16].count + "") && Ze(c, f), m & 64 && St(o, "width", h[16].count / h[6][0].count * 100 + "%");
  }, d(h) {
    h && D(e);
  } };
}
function M7(t3) {
  let e, n, r, s, i, a, o, f = Mr(t3[7]), c = [];
  for (let l = 0; l < f.length; l += 1) c[l] = $7(A7(t3, f, l));
  return { c() {
    e = H("div"), n = H("h3"), n.textContent = "Peak Activity Times", r = z(), s = H("table"), i = H("thead"), i.innerHTML = '<tr><th class="svelte-efa9gy">Timestamp</th><th class="svelte-efa9gy">Events</th></tr>', a = z(), o = H("tbody");
    for (let l = 0; l < c.length; l += 1) c[l].c();
    V(n, "class", "svelte-efa9gy"), V(s, "class", "simple-table svelte-efa9gy"), V(e, "class", "section svelte-efa9gy");
  }, m(l, h) {
    R(l, e, h), q(e, n), q(e, r), q(e, s), q(s, i), q(s, a), q(s, o);
    for (let m = 0; m < c.length; m += 1) c[m] && c[m].m(o, null);
  }, p(l, h) {
    if (h & 128) {
      f = Mr(l[7]);
      let m;
      for (m = 0; m < f.length; m += 1) {
        const v = A7(l, f, m);
        c[m] ? c[m].p(v, h) : (c[m] = $7(v), c[m].c(), c[m].m(o, null));
      }
      for (; m < c.length; m += 1) c[m].d(1);
      c.length = f.length;
    }
  }, d(l) {
    l && D(e), jn(c, l);
  } };
}
function $7(t3) {
  let e, n, r = t3[13].key + "", s, i, a, o = t3[13].count + "", f, c;
  return { c() {
    e = H("tr"), n = H("td"), s = we(r), i = z(), a = H("td"), f = we(o), c = z(), V(n, "class", "svelte-efa9gy"), V(a, "class", "svelte-efa9gy");
  }, m(l, h) {
    R(l, e, h), q(e, n), q(n, s), q(e, i), q(e, a), q(a, f), q(e, c);
  }, p(l, h) {
    h & 128 && r !== (r = l[13].key + "") && Ze(s, r), h & 128 && o !== (o = l[13].count + "") && Ze(f, o);
  }, d(l) {
    l && D(e);
  } };
}
function g0e(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m;
  n = new la({ props: { label: "Select Log File (.log, .txt, .json)" } }), n.$on("change", t3[8]);
  let v = t3[0] && _7(t3);
  a = new ut({ props: { disabled: t3[3] || !t3[0], $$slots: { default: [d0e] }, $$scope: { ctx: t3 } } }), a.$on("click", t3[9]), f = new ut({ props: { variant: "secondary", $$slots: { default: [p0e] }, $$scope: { ctx: t3 } } }), f.$on("click", t3[11]);
  let b = t3[2] && E7(t3), A = t3[1] && B7(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), r = z(), v && v.c(), s = z(), i = H("div"), fe(a.$$.fragment), o = z(), fe(f.$$.fragment), c = z(), b && b.c(), l = z(), A && A.c(), h = Lt(), V(e, "class", "drop-container svelte-efa9gy"), V(i, "class", "button-row svelte-efa9gy");
  }, m(_, C) {
    R(_, e, C), ae(n, e, null), R(_, r, C), v && v.m(_, C), R(_, s, C), R(_, i, C), ae(a, i, null), q(i, o), ae(f, i, null), R(_, c, C), b && b.m(_, C), R(_, l, C), A && A.m(_, C), R(_, h, C), m = true;
  }, p(_, C) {
    _[0] ? v ? v.p(_, C) : (v = _7(_), v.c(), v.m(s.parentNode, s)) : v && (v.d(1), v = null);
    const I = {};
    C & 9 && (I.disabled = _[3] || !_[0]), C & 4194312 && (I.$$scope = { dirty: C, ctx: _ }), a.$set(I);
    const S = {};
    C & 4194304 && (S.$$scope = { dirty: C, ctx: _ }), f.$set(S), _[2] ? b ? b.p(_, C) : (b = E7(_), b.c(), b.m(l.parentNode, l)) : b && (b.d(1), b = null), _[1] ? A ? A.p(_, C) : (A = B7(_), A.c(), A.m(h.parentNode, h)) : A && (A.d(1), A = null);
  }, i(_) {
    m || (W(n.$$.fragment, _), W(a.$$.fragment, _), W(f.$$.fragment, _), m = true);
  }, o(_) {
    j(n.$$.fragment, _), j(a.$$.fragment, _), j(f.$$.fragment, _), m = false;
  }, d(_) {
    _ && (D(e), D(r), D(s), D(i), D(c), D(l), D(h)), oe(n), v && v.d(_), oe(a), oe(f), b && b.d(_), A && A.d(_);
  } };
}
function m0e(t3) {
  let e, n, r, s, i;
  return { c() {
    e = H("p"), e.innerHTML = `<strong>Log Analysis</strong> helps debug systems and detect security threats by parsing unstructured text logs.
    This tool is designed to analyze log files and extract useful insights from them.
        Instead of reading thousands of log entries manually, the tool summarizes important information such as:`, n = z(), r = H("ul"), r.innerHTML = "<li><strong>Levels:</strong> Tracks <code>ERROR</code> vs <code>INFO</code> to gauge system health.</li> <li><strong>IPs:</strong> Identifies frequent visitors or potential attackers (e.g., a single IP hitting an endpoint 1000 times).</li> <li><strong>Timeline:</strong> Shows when the system was busiest.</li>", s = z(), i = H("p"), i.textContent = `The tool supports various log formats including JSON, Windows Event Logs, Common Event Format, 
        NCSA Common Log Format, Extended Log Format, and W3C Extended Log Format. It helps with debugging, 
        security analysis, system monitoring, and troubleshooting.`;
  }, m(a, o) {
    R(a, e, o), R(a, n, o), R(a, r, o), R(a, s, o), R(a, i, o);
  }, p: dt, d(a) {
    a && (D(e), D(n), D(r), D(s), D(i));
  } };
}
function v0e(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Log Analyzer", $$slots: { default: [g0e] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Log Analysis", links: t3[10], $$slots: { default: [m0e] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 4194559 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 4194304 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function y0e(t3, e, n) {
  let r = null, s = null, i = "", a = false, o = "", f = [], c = [], l = [];
  const h = { INFO: "#22c55e", DEBUG: "#3b82f6", WARNING: "#f59e0b", ERROR: "#ef4444", CRITICAL: "#7f1d1d", FATAL: "#7f1d1d" };
  function m(_) {
    _.detail && _.detail.length > 0 && (n(0, r = _.detail[0]), n(1, s = null), n(2, i = ""));
  }
  async function v() {
    if (!r) {
      n(2, i = "Please select a log file.");
      return;
    }
    n(3, a = true), n(2, i = ""), n(1, s = null);
    try {
      const _ = await r.text();
      await new Promise((S) => setTimeout(S, 50));
      const C = l0e(_);
      n(1, s = C);
      const I = gy(C.levels, 10);
      n(5, f = I.map((S) => ({ label: S.key, count: S.count, color: h[S.key] || "#94a3b8" }))), n(4, o = u0e(f)), n(6, c = gy(C.ips, 10)), n(7, l = gy(C.timestamps, 10));
    } catch (_) {
      n(2, i = "Analysis Failed: " + _.message);
    } finally {
      n(3, a = false);
    }
  }
  return [r, s, i, a, o, f, c, l, m, v, [{ text: "Logging - Wikipedia", url: "https://en.wikipedia.org/wiki/Logging_(computing)" }, { text: "What are log files? - AWS", url: "https://aws.amazon.com/what-is/log-files/" }], () => {
    n(0, r = null), n(1, s = null);
  }];
}
class b0e extends xt {
  constructor(e) {
    super(), wt(this, e, y0e, v0e, At, {});
  }
}
async function T7(t3) {
  if (!t3) throw new Error("File not provided.");
  const [e, n] = await Promise.all([D7(t3, "SHA-1"), D7(t3, "SHA-256")]);
  return { md5: await w0e(t3), sha1: e, sha256: n };
}
async function A0e(t3, e) {
  if (!t3 || !e) throw new Error("Please select two files to compare.");
  const n = performance.now(), [r, s] = await Promise.all([T7(t3), T7(e)]), a = ((performance.now() - n) / 1e3).toFixed(2), o = r.md5 === s.md5 && r.sha1 === s.sha1 && r.sha256 === s.sha256;
  return { file1: { name: t3.name, size: t3.size, hashes: r }, file2: { name: e.name, size: e.size, hashes: s }, isIdentical: o, timeTaken: a };
}
async function D7(t3, e) {
  const n = await t3.arrayBuffer(), r = await crypto.subtle.digest(e, n);
  return Array.from(new Uint8Array(r)).map((i) => i.toString(16).padStart(2, "0")).join("");
}
function w0e(t3) {
  return new Promise((e, n) => {
    const r = new FileReader();
    r.onload = (s) => {
      const i = ur.lib.WordArray.create(s.target.result), a = ur.MD5(i).toString();
      e(a);
    }, r.onerror = (s) => n(s), r.readAsArrayBuffer(t3);
  });
}
function R7(t3) {
  let e, n, r = t3[0].name + "", s;
  return { c() {
    e = H("div"), n = we("\u{1F4C4} "), s = we(r), V(e, "class", "file-badge svelte-y4iohg");
  }, m(i, a) {
    R(i, e, a), q(e, n), q(e, s);
  }, p(i, a) {
    a & 1 && r !== (r = i[0].name + "") && Ze(s, r);
  }, d(i) {
    i && D(e);
  } };
}
function F7(t3) {
  let e, n, r = t3[1].name + "", s;
  return { c() {
    e = H("div"), n = we("\u{1F4C4} "), s = we(r), V(e, "class", "file-badge svelte-y4iohg");
  }, m(i, a) {
    R(i, e, a), q(e, n), q(e, s);
  }, p(i, a) {
    a & 2 && r !== (r = i[1].name + "") && Ze(s, r);
  }, d(i) {
    i && D(e);
  } };
}
function x0e(t3) {
  let e;
  return { c() {
    e = we("Compare Files");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function _0e(t3) {
  let e;
  return { c() {
    e = we("Comparing...");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function E0e(t3) {
  let e;
  function n(i, a) {
    return i[4] ? _0e : x0e;
  }
  let r = n(t3), s = r(t3);
  return { c() {
    s.c(), e = Lt();
  }, m(i, a) {
    s.m(i, a), R(i, e, a);
  }, p(i, a) {
    r !== (r = n(i)) && (s.d(1), s = r(i), s && (s.c(), s.m(e.parentNode, e)));
  }, d(i) {
    i && D(e), s.d(i);
  } };
}
function B0e(t3) {
  let e;
  return { c() {
    e = we("Reset");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function P7(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[3]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 8 && Ze(n, r[3]);
  }, d(r) {
    r && D(e);
  } };
}
function N7(t3) {
  let e, n, r = t3[2].isIdentical ? "FILES ARE IDENTICAL" : "FILES DIFFER", s, i, a, o, f = t3[2].timeTaken + "", c, l, h, m, v, b, A, _, C, I, S, $ = t3[2].file1.hashes.md5 + "", F, U, Q, P = t3[2].file2.hashes.md5 + "", N, L, B, u, p, d, y = t3[2].file1.hashes.sha1 + "", w, E, M, x = t3[2].file2.hashes.sha1 + "", g, k, T, O, K, Y, J = t3[2].file1.hashes.sha256 + "", G, X, ie, de = t3[2].file2.hashes.sha256 + "", se;
  return { c() {
    e = H("div"), n = H("div"), s = we(r), i = z(), a = H("div"), o = we("Comparison Time: "), c = we(f), l = we("s"), h = z(), m = H("table"), v = H("thead"), v.innerHTML = '<tr><th class="svelte-y4iohg">Algorithm</th> <th class="svelte-y4iohg">File 1 Hash</th> <th class="svelte-y4iohg">File 2 Hash</th></tr>', b = z(), A = H("tbody"), _ = H("tr"), C = H("td"), C.textContent = "MD5", I = z(), S = H("td"), F = we($), U = z(), Q = H("td"), N = we(P), L = z(), B = H("tr"), u = H("td"), u.textContent = "SHA-1", p = z(), d = H("td"), w = we(y), E = z(), M = H("td"), g = we(x), k = z(), T = H("tr"), O = H("td"), O.textContent = "SHA-256", K = z(), Y = H("td"), G = we(J), X = z(), ie = H("td"), se = we(de), V(n, "class", "verdict svelte-y4iohg"), Zt(n, "match", t3[2].isIdentical), Zt(n, "mismatch", !t3[2].isIdentical), V(a, "class", "meta svelte-y4iohg"), V(C, "class", "svelte-y4iohg"), V(S, "class", "hash-cell svelte-y4iohg"), V(Q, "class", "hash-cell svelte-y4iohg"), V(_, "class", "svelte-y4iohg"), Zt(_, "diff", t3[2].file1.hashes.md5 !== t3[2].file2.hashes.md5), V(u, "class", "svelte-y4iohg"), V(d, "class", "hash-cell svelte-y4iohg"), V(M, "class", "hash-cell svelte-y4iohg"), V(B, "class", "svelte-y4iohg"), Zt(B, "diff", t3[2].file1.hashes.sha1 !== t3[2].file2.hashes.sha1), V(O, "class", "svelte-y4iohg"), V(Y, "class", "hash-cell svelte-y4iohg"), V(ie, "class", "hash-cell svelte-y4iohg"), V(T, "class", "svelte-y4iohg"), Zt(T, "diff", t3[2].file1.hashes.sha256 !== t3[2].file2.hashes.sha256), V(m, "class", "hash-table svelte-y4iohg"), V(e, "class", "results-area svelte-y4iohg");
  }, m(te, le) {
    R(te, e, le), q(e, n), q(n, s), q(e, i), q(e, a), q(a, o), q(a, c), q(a, l), q(e, h), q(e, m), q(m, v), q(m, b), q(m, A), q(A, _), q(_, C), q(_, I), q(_, S), q(S, F), q(_, U), q(_, Q), q(Q, N), q(A, L), q(A, B), q(B, u), q(B, p), q(B, d), q(d, w), q(B, E), q(B, M), q(M, g), q(A, k), q(A, T), q(T, O), q(T, K), q(T, Y), q(Y, G), q(T, X), q(T, ie), q(ie, se);
  }, p(te, le) {
    le & 4 && r !== (r = te[2].isIdentical ? "FILES ARE IDENTICAL" : "FILES DIFFER") && Ze(s, r), le & 4 && Zt(n, "match", te[2].isIdentical), le & 4 && Zt(n, "mismatch", !te[2].isIdentical), le & 4 && f !== (f = te[2].timeTaken + "") && Ze(c, f), le & 4 && $ !== ($ = te[2].file1.hashes.md5 + "") && Ze(F, $), le & 4 && P !== (P = te[2].file2.hashes.md5 + "") && Ze(N, P), le & 4 && Zt(_, "diff", te[2].file1.hashes.md5 !== te[2].file2.hashes.md5), le & 4 && y !== (y = te[2].file1.hashes.sha1 + "") && Ze(w, y), le & 4 && x !== (x = te[2].file2.hashes.sha1 + "") && Ze(g, x), le & 4 && Zt(B, "diff", te[2].file1.hashes.sha1 !== te[2].file2.hashes.sha1), le & 4 && J !== (J = te[2].file1.hashes.sha256 + "") && Ze(G, J), le & 4 && de !== (de = te[2].file2.hashes.sha256 + "") && Ze(se, de), le & 4 && Zt(T, "diff", te[2].file1.hashes.sha256 !== te[2].file2.hashes.sha256);
  }, d(te) {
    te && D(e);
  } };
}
function C0e(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C;
  r = new la({ props: { label: "Select File 1" } }), r.$on("change", t3[5]);
  let I = t3[0] && R7(t3);
  o = new la({ props: { label: "Select File 2" } }), o.$on("change", t3[6]);
  let S = t3[1] && F7(t3);
  h = new ut({ props: { disabled: t3[4] || !t3[0] || !t3[1], $$slots: { default: [E0e] }, $$scope: { ctx: t3 } } }), h.$on("click", t3[7]), v = new ut({ props: { variant: "secondary", $$slots: { default: [B0e] }, $$scope: { ctx: t3 } } }), v.$on("click", t3[9]);
  let $ = t3[3] && P7(t3), F = t3[2] && N7(t3);
  return { c() {
    e = H("div"), n = H("div"), fe(r.$$.fragment), s = z(), I && I.c(), i = z(), a = H("div"), fe(o.$$.fragment), f = z(), S && S.c(), c = z(), l = H("div"), fe(h.$$.fragment), m = z(), fe(v.$$.fragment), b = z(), $ && $.c(), A = z(), F && F.c(), _ = Lt(), V(n, "class", "file-col"), V(a, "class", "file-col"), V(e, "class", "comparison-grid svelte-y4iohg"), V(l, "class", "button-row svelte-y4iohg");
  }, m(U, Q) {
    R(U, e, Q), q(e, n), ae(r, n, null), q(n, s), I && I.m(n, null), q(e, i), q(e, a), ae(o, a, null), q(a, f), S && S.m(a, null), R(U, c, Q), R(U, l, Q), ae(h, l, null), q(l, m), ae(v, l, null), R(U, b, Q), $ && $.m(U, Q), R(U, A, Q), F && F.m(U, Q), R(U, _, Q), C = true;
  }, p(U, Q) {
    U[0] ? I ? I.p(U, Q) : (I = R7(U), I.c(), I.m(n, null)) : I && (I.d(1), I = null), U[1] ? S ? S.p(U, Q) : (S = F7(U), S.c(), S.m(a, null)) : S && (S.d(1), S = null);
    const P = {};
    Q & 19 && (P.disabled = U[4] || !U[0] || !U[1]), Q & 1040 && (P.$$scope = { dirty: Q, ctx: U }), h.$set(P);
    const N = {};
    Q & 1024 && (N.$$scope = { dirty: Q, ctx: U }), v.$set(N), U[3] ? $ ? $.p(U, Q) : ($ = P7(U), $.c(), $.m(A.parentNode, A)) : $ && ($.d(1), $ = null), U[2] ? F ? F.p(U, Q) : (F = N7(U), F.c(), F.m(_.parentNode, _)) : F && (F.d(1), F = null);
  }, i(U) {
    C || (W(r.$$.fragment, U), W(o.$$.fragment, U), W(h.$$.fragment, U), W(v.$$.fragment, U), C = true);
  }, o(U) {
    j(r.$$.fragment, U), j(o.$$.fragment, U), j(h.$$.fragment, U), j(v.$$.fragment, U), C = false;
  }, d(U) {
    U && (D(e), D(c), D(l), D(b), D(A), D(_)), oe(r), I && I.d(), oe(o), S && S.d(), oe(h), oe(v), $ && $.d(U), F && F.d(U);
  } };
}
function k0e(t3) {
  let e, n, r, s, i, a, o, f, c;
  return { c() {
    e = H("p"), e.innerHTML = `<strong>File Hash Comparison</strong> is the most reliable way to verify if two files are identical 
        by computing and comparing their cryptographic hash values.`, n = z(), r = H("p"), r.textContent = `Even if two files have the same name and size, their contents might differ (due to corruption, partial download, or tampering).
    Comparing their cryptographic hashes (like SHA-256) ensures bit-for-bit integrity.`, s = z(), i = H("h3"), i.textContent = "Supported Algorithms:", a = z(), o = H("ul"), o.innerHTML = "<li><b>MD5</b> \u2013 Fast checksum comparison</li> <li><b>SHA-1</b> \u2013 Common integrity verification hash</li> <li><b>SHA-256</b> \u2013 Modern secure standard for binary equality</li>", f = z(), c = H("p"), c.textContent = `If all hashes match, the files are guaranteed to be identical.  
        This is useful for checking if backups, transfers, or downloads are unmodified.`;
  }, m(l, h) {
    R(l, e, h), R(l, n, h), R(l, r, h), R(l, s, h), R(l, i, h), R(l, a, h), R(l, o, h), R(l, f, h), R(l, c, h);
  }, p: dt, d(l) {
    l && (D(e), D(n), D(r), D(s), D(i), D(a), D(o), D(f), D(c));
  } };
}
function I0e(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Compare File Hashes", $$slots: { default: [C0e] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Hash Comparison", links: t3[8], $$slots: { default: [k0e] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 1055 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 1024 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function S0e(t3, e, n) {
  let r = null, s = null, i = null, a = "", o = false;
  function f(v) {
    v.detail && v.detail.length > 0 && n(0, r = v.detail[0]), n(2, i = null);
  }
  function c(v) {
    v.detail && v.detail.length > 0 && n(1, s = v.detail[0]), n(2, i = null);
  }
  async function l() {
    if (!r || !s) {
      n(3, a = "Please select both files.");
      return;
    }
    n(4, o = true), n(3, a = ""), n(2, i = null);
    try {
      await new Promise((v) => setTimeout(v, 50)), n(2, i = await A0e(r, s));
    } catch (v) {
      n(3, a = v.message);
    } finally {
      n(4, o = false);
    }
  }
  return [r, s, i, a, o, f, c, l, [{ text: "File verification - Wikipedia", url: "https://en.wikipedia.org/wiki/File_verification" }], () => {
    n(0, r = null), n(1, s = null), n(2, i = null);
  }];
}
class M0e extends xt {
  constructor(e) {
    super(), wt(this, e, S0e, I0e, At, {});
  }
}
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function $0e(t3) {
  return t3 instanceof Uint8Array || ArrayBuffer.isView(t3) && t3.constructor.name === "Uint8Array";
}
function cl(t3) {
  if (!Number.isSafeInteger(t3) || t3 < 0) throw new Error("positive integer expected, got " + t3);
}
function Ra(t3, ...e) {
  if (!$0e(t3)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t3.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + t3.length);
}
function T0e(t3) {
  if (typeof t3 != "function" || typeof t3.create != "function") throw new Error("Hash should be wrapped by utils.createHasher");
  cl(t3.outputLen), cl(t3.blockLen);
}
function lf(t3, e = true) {
  if (t3.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && t3.finished) throw new Error("Hash#digest() has already been called");
}
function Em(t3, e) {
  Ra(t3);
  const n = e.outputLen;
  if (t3.length < n) throw new Error("digestInto() expects output buffer of length at least " + n);
}
function D0e(t3) {
  return new Uint8Array(t3.buffer, t3.byteOffset, t3.byteLength);
}
function uf(t3) {
  return new Uint32Array(t3.buffer, t3.byteOffset, Math.floor(t3.byteLength / 4));
}
function Li(...t3) {
  for (let e = 0; e < t3.length; e++) t3[e].fill(0);
}
function my(t3) {
  return new DataView(t3.buffer, t3.byteOffset, t3.byteLength);
}
function As(t3, e) {
  return t3 << 32 - e | t3 >>> e;
}
function up(t3, e) {
  return t3 << e | t3 >>> 32 - e >>> 0;
}
const pF = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function gF(t3) {
  return t3 << 24 & 4278190080 | t3 << 8 & 16711680 | t3 >>> 8 & 65280 | t3 >>> 24 & 255;
}
const Ns = pF ? (t3) => t3 : (t3) => gF(t3);
function R0e(t3) {
  for (let e = 0; e < t3.length; e++) t3[e] = gF(t3[e]);
  return t3;
}
const ls = pF ? (t3) => t3 : R0e, mF = typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function", F0e = Array.from({ length: 256 }, (t3, e) => e.toString(16).padStart(2, "0"));
function Al(t3) {
  if (Ra(t3), mF) return t3.toHex();
  let e = "";
  for (let n = 0; n < t3.length; n++) e += F0e[t3[n]];
  return e;
}
const Oo = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function U7(t3) {
  if (t3 >= Oo._0 && t3 <= Oo._9) return t3 - Oo._0;
  if (t3 >= Oo.A && t3 <= Oo.F) return t3 - (Oo.A - 10);
  if (t3 >= Oo.a && t3 <= Oo.f) return t3 - (Oo.a - 10);
}
function P0e(t3) {
  if (typeof t3 != "string") throw new Error("hex string expected, got " + typeof t3);
  if (mF) return Uint8Array.fromHex(t3);
  const e = t3.length, n = e / 2;
  if (e % 2) throw new Error("hex string expected, got unpadded hex of length " + e);
  const r = new Uint8Array(n);
  for (let s = 0, i = 0; s < n; s++, i += 2) {
    const a = U7(t3.charCodeAt(i)), o = U7(t3.charCodeAt(i + 1));
    if (a === void 0 || o === void 0) {
      const f = t3[i] + t3[i + 1];
      throw new Error('hex string expected, got non-hex character "' + f + '" at index ' + i);
    }
    r[s] = a * 16 + o;
  }
  return r;
}
function N0e(t3) {
  if (typeof t3 != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t3));
}
function rs(t3) {
  return typeof t3 == "string" && (t3 = N0e(t3)), Ra(t3), t3;
}
class Bm {
}
function hc(t3) {
  const e = (r) => t3().update(rs(r)).digest(), n = t3();
  return e.outputLen = n.outputLen, e.blockLen = n.blockLen, e.create = () => t3(), e;
}
function vF(t3) {
  const e = (r, s) => t3(s).update(rs(r)).digest(), n = t3({});
  return e.outputLen = n.outputLen, e.blockLen = n.blockLen, e.create = (r) => t3(r), e;
}
function N4(t3) {
  const e = (r, s) => t3(s).update(rs(r)).digest(), n = t3({});
  return e.outputLen = n.outputLen, e.blockLen = n.blockLen, e.create = (r) => t3(r), e;
}
const vy = {};
function U0e(t3) {
  if (vy[t3]) return vy[t3];
  const e = {}, n = new TextDecoder(t3, { fatal: false }), r = new Uint8Array(1);
  for (let s = 0; s < 256; s++) {
    r[0] = s;
    try {
      const i = n.decode(r);
      i.length === 1 && i !== "" && e[i] === void 0 && (e[i] = s);
    } catch {
      continue;
    }
  }
  return vy[t3] = e, e;
}
function ps(t3, e) {
  if (!t3) return new Uint8Array(0);
  const n = e.toLowerCase();
  try {
    if (n === "hex") {
      const i = t3.replace(/\s+/g, "").replace(/^0x/i, "");
      return P0e(i);
    }
    if (n === "base64") {
      const i = atob(t3), a = new Uint8Array(i.length);
      for (let o = 0; o < i.length; o++) a[o] = i.charCodeAt(o);
      return a;
    }
    if (n === "utf-8" || n === "text") return new TextEncoder().encode(t3);
    if (n === "utf-16le") {
      const i = new Uint8Array(t3.length * 2);
      for (let a = 0; a < t3.length; a++) {
        const o = t3.charCodeAt(a);
        i[a * 2] = o & 255, i[a * 2 + 1] = o >> 8 & 255;
      }
      return i;
    }
    if (n === "utf-16be") {
      const i = new Uint8Array(t3.length * 2);
      for (let a = 0; a < t3.length; a++) {
        const o = t3.charCodeAt(a);
        i[a * 2] = o >> 8 & 255, i[a * 2 + 1] = o & 255;
      }
      return i;
    }
    if (n === "x-user-defined") {
      const i = new Uint8Array(t3.length);
      for (let a = 0; a < t3.length; a++) {
        const o = t3.charCodeAt(a);
        o <= 127 ? i[a] = o : o >= 63360 && o <= 63487 ? i[a] = o - 63360 + 128 : i[a] = o & 255;
      }
      return i;
    }
    const r = U0e(n), s = new Uint8Array(t3.length);
    for (let i = 0; i < t3.length; i++) {
      const a = t3[i];
      let o = r[a];
      if (o === void 0) {
        const f = t3.charCodeAt(i);
        if (f < 128) o = f;
        else throw new Error(`Character '${a}' cannot be represented in ${e}`);
      }
      s[i] = o;
    }
    return s;
  } catch (r) {
    throw new Error(`Encoding Error (${e}): ${r.message}`);
  }
}
function L0e(t3, e, n = "utf-8") {
  return t3 ? e === "encode" ? O0e(t3, n) : Q0e(t3, n) : "";
}
function O0e(t3, e) {
  let n;
  try {
    n = ps(t3, e);
  } catch (s) {
    throw new Error(`Encoding Error: ${s.message}`);
  }
  let r = "";
  for (let s = 0; s < n.length; s++) {
    const a = n[s].toString(2).padStart(8, "0");
    r += a + " ";
  }
  return r.trim();
}
function Q0e(t3, e) {
  const n = t3.replace(/[^01]/g, "");
  if (!n) throw new Error("Input does not contain valid binary data (0s and 1s).");
  if (n.length % 8 !== 0) throw new Error("Binary string length must be a multiple of 8.");
  const r = n.length / 8, s = new Uint8Array(r);
  for (let i = 0; i < r; i++) {
    const a = n.substr(i * 8, 8);
    s[i] = parseInt(a, 2);
  }
  if (e === "hex") return [...s].map((i) => i.toString(16).padStart(2, "0")).join("");
  if (e === "base64") return btoa(String.fromCharCode(...s));
  try {
    return new TextDecoder(e).decode(s);
  } catch {
    throw new Error(`The encoding '${e}' is not supported for decoding by your browser.`);
  }
}
const gs = [{ value: "utf-8", label: "UTF-8 (Default)" }, { value: "utf-16le", label: "UTF-16LE (Little Endian)" }, { value: "utf-16be", label: "UTF-16BE (Big Endian)" }, { value: "hex", label: "Hex String" }, { value: "base64", label: "Base64" }, { value: "windows-1250", label: "Windows-1250 (Central Eur)" }, { value: "windows-1251", label: "Windows-1251 (Cyrillic)" }, { value: "windows-1252", label: "Windows-1252 (Western)" }, { value: "windows-1253", label: "Windows-1253 (Greek)" }, { value: "windows-1254", label: "Windows-1254 (Turkish)" }, { value: "windows-1255", label: "Windows-1255 (Hebrew)" }, { value: "windows-1256", label: "Windows-1256 (Arabic)" }, { value: "windows-1257", label: "Windows-1257 (Baltic)" }, { value: "windows-1258", label: "Windows-1258 (Vietnamese)" }, { value: "windows-874", label: "Windows-874 (Thai)" }, { value: "iso-8859-2", label: "ISO-8859-2 (Latin-2)" }, { value: "iso-8859-3", label: "ISO-8859-3 (Latin-3)" }, { value: "iso-8859-4", label: "ISO-8859-4 (Latin-4)" }, { value: "iso-8859-5", label: "ISO-8859-5 (Cyrillic)" }, { value: "iso-8859-6", label: "ISO-8859-6 (Arabic)" }, { value: "iso-8859-7", label: "ISO-8859-7 (Greek)" }, { value: "iso-8859-8", label: "ISO-8859-8 (Hebrew)" }, { value: "iso-8859-10", label: "ISO-8859-10 (Latin-6)" }, { value: "iso-8859-13", label: "ISO-8859-13 (Latin-7)" }, { value: "iso-8859-14", label: "ISO-8859-14 (Celtic)" }, { value: "iso-8859-15", label: "ISO-8859-15 (Latin-9)" }, { value: "iso-8859-16", label: "ISO-8859-16 (Romanian)" }, { value: "shift_jis", label: "Shift_JIS (Japanese)" }, { value: "windows-874", label: "Windows-874 (Thai)" }, { value: "ibm866", label: "IBM866 (DOS Cyrillic)" }, { value: "koi8-r", label: "KOI8-R (Russian)" }, { value: "koi8-u", label: "KOI8-U (Ukrainian)" }, { value: "macintosh", label: "Macintosh (MacRoman)" }, { value: "x-user-defined", label: "x-user-defined" }];
function K0e(t3) {
  let e;
  return { c() {
    e = we("Convert");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function H0e(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function L7(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[5]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 32 && Ze(n, r[5]);
  }, d(r) {
    r && D(e);
  } };
}
function O7(t3) {
  let e, n;
  return e = new et({ props: { label: t3[1] === "encode" ? "Binary Output:" : "Text Output:", value: t3[4], readonly: true, expandable: true, withCopy: true } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, s) {
    const i = {};
    s & 2 && (i.label = r[1] === "encode" ? "Binary Output:" : "Text Output:"), s & 16 && (i.value = r[4]), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function q0e(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U, Q, P;
  function N(x) {
    t3[9](x);
  }
  let L = { label: "Mode:", options: t3[6] };
  t3[1] !== void 0 && (L.value = t3[1]), n = new Ht({ props: L }), Qe.push(() => ze(n, "value", N));
  function B(x) {
    t3[10](x);
  }
  let u = { label: t3[1] === "encode" ? "Text Encoding:" : "Target Encoding:", options: gs.map(V0e) };
  t3[2] !== void 0 && (u.value = t3[2]), i = new Ht({ props: u }), Qe.push(() => ze(i, "value", B));
  function p(x) {
    t3[11](x);
  }
  let d = { label: t3[1] === "encode" ? "Input Text:" : "Input Binary:", placeholder: t3[1] === "encode" ? "Type text..." : "e.g. 01001000 01100101...", expandable: true };
  t3[0] !== void 0 && (d.value = t3[0]), f = new et({ props: d }), Qe.push(() => ze(f, "value", p)), m = new ut({ props: { $$slots: { default: [K0e] }, $$scope: { ctx: t3 } } }), m.$on("click", t3[7]), b = new ut({ props: { variant: "secondary", $$slots: { default: [H0e] }, $$scope: { ctx: t3 } } }), b.$on("click", t3[12]), _ = new hn({}), _.$on("click", t3[8]);
  function y(x) {
    t3[13](x);
  }
  let w = {};
  t3[3] !== void 0 && (w.checked = t3[3]), S = new xr({ props: w }), Qe.push(() => ze(S, "checked", y));
  let E = t3[5] && L7(t3), M = t3[4] && O7(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), fe(i.$$.fragment), o = z(), fe(f.$$.fragment), l = z(), h = H("div"), fe(m.$$.fragment), v = z(), fe(b.$$.fragment), A = z(), fe(_.$$.fragment), C = z(), I = H("div"), fe(S.$$.fragment), F = z(), E && E.c(), U = z(), M && M.c(), Q = Lt(), V(e, "class", "controls-row"), St(I, "margin-left", "auto"), V(h, "class", "button-row");
  }, m(x, g) {
    R(x, e, g), ae(n, e, null), q(e, s), ae(i, e, null), R(x, o, g), ae(f, x, g), R(x, l, g), R(x, h, g), ae(m, h, null), q(h, v), ae(b, h, null), q(h, A), ae(_, h, null), q(h, C), q(h, I), ae(S, I, null), R(x, F, g), E && E.m(x, g), R(x, U, g), M && M.m(x, g), R(x, Q, g), P = true;
  }, p(x, g) {
    const k = {};
    !r && g & 2 && (r = true, k.value = x[1], qe(() => r = false)), n.$set(k);
    const T = {};
    g & 2 && (T.label = x[1] === "encode" ? "Text Encoding:" : "Target Encoding:"), !a && g & 4 && (a = true, T.value = x[2], qe(() => a = false)), i.$set(T);
    const O = {};
    g & 2 && (O.label = x[1] === "encode" ? "Input Text:" : "Input Binary:"), g & 2 && (O.placeholder = x[1] === "encode" ? "Type text..." : "e.g. 01001000 01100101..."), !c && g & 1 && (c = true, O.value = x[0], qe(() => c = false)), f.$set(O);
    const K = {};
    g & 16384 && (K.$$scope = { dirty: g, ctx: x }), m.$set(K);
    const Y = {};
    g & 16384 && (Y.$$scope = { dirty: g, ctx: x }), b.$set(Y);
    const J = {};
    !$ && g & 8 && ($ = true, J.checked = x[3], qe(() => $ = false)), S.$set(J), x[5] ? E ? E.p(x, g) : (E = L7(x), E.c(), E.m(U.parentNode, U)) : E && (E.d(1), E = null), x[4] ? M ? (M.p(x, g), g & 16 && W(M, 1)) : (M = O7(x), M.c(), W(M, 1), M.m(Q.parentNode, Q)) : M && (Xt(), j(M, 1, 1, () => {
      M = null;
    }), er());
  }, i(x) {
    P || (W(n.$$.fragment, x), W(i.$$.fragment, x), W(f.$$.fragment, x), W(m.$$.fragment, x), W(b.$$.fragment, x), W(_.$$.fragment, x), W(S.$$.fragment, x), W(M), P = true);
  }, o(x) {
    j(n.$$.fragment, x), j(i.$$.fragment, x), j(f.$$.fragment, x), j(m.$$.fragment, x), j(b.$$.fragment, x), j(_.$$.fragment, x), j(S.$$.fragment, x), j(M), P = false;
  }, d(x) {
    x && (D(e), D(o), D(l), D(h), D(F), D(U), D(Q)), oe(n), oe(i), oe(f, x), oe(m), oe(b), oe(_), oe(S), E && E.d(x), M && M.d(x);
  } };
}
function z0e(t3) {
  let e, n, r, s, i, a, o;
  return { c() {
    e = H("p"), e.innerHTML = `<strong>Binary</strong> (Base-2) is the foundational language of computers. 
    It represents all data using only two symbols: <strong>0</strong> and <strong>1</strong>.`, n = z(), r = H("p"), r.innerHTML = "When you type text, computers store it as a sequence of bytes. In the standard <strong>UTF-8</strong> encoding:", s = z(), i = H("ul"), i.innerHTML = "<li>The letter <strong>&#39;A&#39;</strong> is number 65, which is <code>01000001</code> in binary.</li> <li>The letter <strong>&#39;a&#39;</strong> is number 97, which is <code>01100001</code> in binary.</li>", a = z(), o = H("p"), o.textContent = `This tool allows you to see exactly how your text looks to a computer, supporting standard formats (UTF-8) 
    as well as legacy encodings (Windows-1252, Shift-JIS, etc.).`;
  }, m(f, c) {
    R(f, e, c), R(f, n, c), R(f, r, c), R(f, s, c), R(f, i, c), R(f, a, c), R(f, o, c);
  }, p: dt, d(f) {
    f && (D(e), D(n), D(r), D(s), D(i), D(a), D(o));
  } };
}
function G0e(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Binary Converter", $$slots: { default: [q0e] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Binary", links: [{ text: "Binary number - Wikipedia", url: "https://en.wikipedia.org/wiki/Binary_number" }], $$slots: { default: [z0e] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 16447 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 16384 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
const V0e = (t3) => t3.value;
function Y0e(t3, e, n) {
  let r = "", s = "encode", i = "utf-8", a = "", o = "", f = true;
  const c = [{ value: "encode", label: "Text to Binary" }, { value: "decode", label: "Binary to Text" }];
  function l() {
    if (!r) {
      n(4, a = ""), n(5, o = "");
      return;
    }
    n(5, o = "");
    try {
      n(4, a = L0e(r, s, i));
    } catch (C) {
      n(5, o = C.message), n(4, a = "");
    }
  }
  function h() {
    s === "encode" ? (n(1, s = "decode"), a && n(0, r = a)) : (n(1, s = "encode"), a && n(0, r = a)), l();
  }
  function m(C) {
    s = C, n(1, s);
  }
  function v(C) {
    i = C, n(2, i);
  }
  function b(C) {
    r = C, n(0, r);
  }
  const A = () => {
    n(0, r = ""), n(4, a = "");
  };
  function _(C) {
    f = C, n(3, f);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 15 && f && (r || s || i) && l();
  }, [r, s, i, f, a, o, c, l, h, m, v, b, A, _];
}
class W0e extends xt {
  constructor(e) {
    super(), wt(this, e, Y0e, G0e, At, {});
  }
}
function J0e(t3, e, n = "utf-8") {
  return !t3 || !t3.trim() ? "" : e === "encode" ? Z0e(t3, n) : j0e(t3, n);
}
function Z0e(t3, e) {
  let n;
  try {
    n = ps(t3, e);
  } catch (r) {
    throw new Error(r.message);
  }
  return Array.from(n).join(" ");
}
function j0e(t3, e) {
  const n = t3.trim().split(/[^0-9]+/), r = new Uint8Array(n.length);
  for (let s = 0; s < n.length; s++) {
    const i = n[s];
    if (!i) continue;
    const a = parseInt(i, 10);
    if (isNaN(a) || a > 255) throw new Error(`Value '${a}' is not a valid 8-bit byte (0-255).`);
    r[s] = a;
  }
  if (e === "hex") return [...r].map((s) => s.toString(16).padStart(2, "0")).join("");
  if (e === "base64") return btoa(String.fromCharCode(...r));
  try {
    return new TextDecoder(e).decode(r);
  } catch {
    throw new Error(`The encoding '${e}' is not supported.`);
  }
}
function X0e(t3) {
  let e;
  return { c() {
    e = we("Convert");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function eue(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function Q7(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[5]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 32 && Ze(n, r[5]);
  }, d(r) {
    r && D(e);
  } };
}
function K7(t3) {
  let e, n;
  return e = new et({ props: { label: t3[1] === "encode" ? "ASCII (Decimal) Output:" : "Text Output:", value: t3[4], readonly: true, expandable: true, withCopy: true } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, s) {
    const i = {};
    s & 2 && (i.label = r[1] === "encode" ? "ASCII (Decimal) Output:" : "Text Output:"), s & 16 && (i.value = r[4]), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function tue(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U, Q, P;
  function N(x) {
    t3[9](x);
  }
  let L = { label: "Mode:", options: t3[6] };
  t3[1] !== void 0 && (L.value = t3[1]), n = new Ht({ props: L }), Qe.push(() => ze(n, "value", N));
  function B(x) {
    t3[10](x);
  }
  let u = { label: t3[1] === "encode" ? "Input Encoding:" : "Target Encoding:", options: gs.map(iue) };
  t3[2] !== void 0 && (u.value = t3[2]), i = new Ht({ props: u }), Qe.push(() => ze(i, "value", B));
  function p(x) {
    t3[11](x);
  }
  let d = { label: t3[1] === "encode" ? "Input Data:" : "Input ASCII Codes:", placeholder: t3[1] === "encode" ? "Type text..." : "e.g. 72 101 108 108 111", expandable: true };
  t3[0] !== void 0 && (d.value = t3[0]), f = new et({ props: d }), Qe.push(() => ze(f, "value", p)), m = new ut({ props: { $$slots: { default: [X0e] }, $$scope: { ctx: t3 } } }), m.$on("click", t3[7]), b = new ut({ props: { variant: "secondary", $$slots: { default: [eue] }, $$scope: { ctx: t3 } } }), b.$on("click", t3[12]), _ = new hn({}), _.$on("click", t3[8]);
  function y(x) {
    t3[13](x);
  }
  let w = {};
  t3[3] !== void 0 && (w.checked = t3[3]), S = new xr({ props: w }), Qe.push(() => ze(S, "checked", y));
  let E = t3[5] && Q7(t3), M = t3[4] && K7(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), fe(i.$$.fragment), o = z(), fe(f.$$.fragment), l = z(), h = H("div"), fe(m.$$.fragment), v = z(), fe(b.$$.fragment), A = z(), fe(_.$$.fragment), C = z(), I = H("div"), fe(S.$$.fragment), F = z(), E && E.c(), U = z(), M && M.c(), Q = Lt(), V(e, "class", "controls-row"), St(I, "margin-left", "auto"), V(h, "class", "button-row");
  }, m(x, g) {
    R(x, e, g), ae(n, e, null), q(e, s), ae(i, e, null), R(x, o, g), ae(f, x, g), R(x, l, g), R(x, h, g), ae(m, h, null), q(h, v), ae(b, h, null), q(h, A), ae(_, h, null), q(h, C), q(h, I), ae(S, I, null), R(x, F, g), E && E.m(x, g), R(x, U, g), M && M.m(x, g), R(x, Q, g), P = true;
  }, p(x, g) {
    const k = {};
    !r && g & 2 && (r = true, k.value = x[1], qe(() => r = false)), n.$set(k);
    const T = {};
    g & 2 && (T.label = x[1] === "encode" ? "Input Encoding:" : "Target Encoding:"), !a && g & 4 && (a = true, T.value = x[2], qe(() => a = false)), i.$set(T);
    const O = {};
    g & 2 && (O.label = x[1] === "encode" ? "Input Data:" : "Input ASCII Codes:"), g & 2 && (O.placeholder = x[1] === "encode" ? "Type text..." : "e.g. 72 101 108 108 111"), !c && g & 1 && (c = true, O.value = x[0], qe(() => c = false)), f.$set(O);
    const K = {};
    g & 16384 && (K.$$scope = { dirty: g, ctx: x }), m.$set(K);
    const Y = {};
    g & 16384 && (Y.$$scope = { dirty: g, ctx: x }), b.$set(Y);
    const J = {};
    !$ && g & 8 && ($ = true, J.checked = x[3], qe(() => $ = false)), S.$set(J), x[5] ? E ? E.p(x, g) : (E = Q7(x), E.c(), E.m(U.parentNode, U)) : E && (E.d(1), E = null), x[4] ? M ? (M.p(x, g), g & 16 && W(M, 1)) : (M = K7(x), M.c(), W(M, 1), M.m(Q.parentNode, Q)) : M && (Xt(), j(M, 1, 1, () => {
      M = null;
    }), er());
  }, i(x) {
    P || (W(n.$$.fragment, x), W(i.$$.fragment, x), W(f.$$.fragment, x), W(m.$$.fragment, x), W(b.$$.fragment, x), W(_.$$.fragment, x), W(S.$$.fragment, x), W(M), P = true);
  }, o(x) {
    j(n.$$.fragment, x), j(i.$$.fragment, x), j(f.$$.fragment, x), j(m.$$.fragment, x), j(b.$$.fragment, x), j(_.$$.fragment, x), j(S.$$.fragment, x), j(M), P = false;
  }, d(x) {
    x && (D(e), D(o), D(l), D(h), D(F), D(U), D(Q)), oe(n), oe(i), oe(f, x), oe(m), oe(b), oe(_), oe(S), E && E.d(x), M && M.d(x);
  } };
}
function rue(t3) {
  let e, n, r, s, i, a, o;
  return { c() {
    e = H("p"), e.innerHTML = "<strong>ASCII</strong> (American Standard Code for Information Interchange) is a character encoding standard that assigns a unique number to characters.", n = z(), r = H("p"), r.textContent = "For example:", s = z(), i = H("ul"), i.innerHTML = "<li><strong>A</strong> = 65</li> <li><strong>a</strong> = 97</li> <li><strong>Space</strong> = 32</li>", a = z(), o = H("p"), o.innerHTML = `<strong>Why Extended ASCII?</strong> Standard ASCII uses only 7 bits (0-127). &quot;Extended ASCII&quot; uses the full 8 bits (0-255) 
    to support additional characters like <strong>\xF1</strong>, <strong>\xF6</strong>, or <strong>\u20AC</strong>. 
    Using the encoding selector, you can see how these special characters map to different decimal values depending on the standard (e.g., Windows-1252 vs ISO-8859-1).`;
  }, m(f, c) {
    R(f, e, c), R(f, n, c), R(f, r, c), R(f, s, c), R(f, i, c), R(f, a, c), R(f, o, c);
  }, p: dt, d(f) {
    f && (D(e), D(n), D(r), D(s), D(i), D(a), D(o));
  } };
}
function nue(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "ASCII Converter", $$slots: { default: [tue] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About ASCII", links: [{ text: "ASCII - Wikipedia", url: "https://en.wikipedia.org/wiki/ASCII" }, { text: "ASCII-CODE.com", url: "https://www.ascii-code.com/" }], $$slots: { default: [rue] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 16447 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 16384 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
const iue = (t3) => t3.value;
function sue(t3, e, n) {
  let r = "", s = "encode", i = "utf-8", a = "", o = "", f = true;
  const c = [{ value: "encode", label: "Text to ASCII (Decimal)" }, { value: "decode", label: "ASCII (Decimal) to Text" }];
  function l() {
    if (!r) {
      n(4, a = ""), n(5, o = "");
      return;
    }
    n(5, o = "");
    try {
      n(4, a = J0e(r, s, i));
    } catch (C) {
      n(5, o = C.message), n(4, a = "");
    }
  }
  function h() {
    n(1, s = s === "encode" ? "decode" : "encode"), a && !o && n(0, r = a), l();
  }
  function m(C) {
    s = C, n(1, s);
  }
  function v(C) {
    i = C, n(2, i);
  }
  function b(C) {
    r = C, n(0, r);
  }
  const A = () => {
    n(0, r = ""), n(4, a = "");
  };
  function _(C) {
    f = C, n(3, f);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 15 && f && (r || s || i) && l();
  }, [r, s, i, f, a, o, c, l, h, m, v, b, A, _];
}
class aue extends xt {
  constructor(e) {
    super(), wt(this, e, sue, nue, At, {});
  }
}
function oue(t3, e) {
  if (!t3) return "";
  const n = t3.trim().replace(/[\s,]/g, "");
  return e === "dec2bin" ? fue(n) : lue(n);
}
function fue(t3) {
  try {
    return BigInt(t3).toString(2);
  } catch {
    throw new Error("Invalid Decimal Number. Please enter integers only.");
  }
}
function lue(t3) {
  if (!/^-?[01]+$/.test(t3)) throw new Error("Invalid Binary. Only 0 and 1 are allowed.");
  try {
    return BigInt("0b" + t3).toString(10);
  } catch {
    throw new Error("Could not parse binary string.");
  }
}
function uue(t3) {
  let e;
  return { c() {
    e = we("Convert");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function cue(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function H7(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[4]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 16 && Ze(n, r[4]);
  }, d(r) {
    r && D(e);
  } };
}
function q7(t3) {
  let e, n;
  return e = new et({ props: { label: t3[1] === "dec2bin" ? "Binary Result:" : "Decimal Result:", value: t3[3], readonly: true, expandable: true, withCopy: true } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, s) {
    const i = {};
    s & 2 && (i.label = r[1] === "dec2bin" ? "Binary Result:" : "Decimal Result:"), s & 8 && (i.value = r[3]), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function hue(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F;
  function U(d) {
    t3[8](d);
  }
  let Q = { label: "Conversion Mode:", options: t3[5] };
  t3[1] !== void 0 && (Q.value = t3[1]), n = new Ht({ props: Q }), Qe.push(() => ze(n, "value", U));
  function P(d) {
    t3[9](d);
  }
  let N = { label: t3[1] === "dec2bin" ? "Decimal Number (Base-10):" : "Binary Number (Base-2):", placeholder: t3[1] === "dec2bin" ? "e.g. 42" : "e.g. 101010", expandable: true };
  t3[0] !== void 0 && (N.value = t3[0]), i = new et({ props: N }), Qe.push(() => ze(i, "value", P)), c = new ut({ props: { $$slots: { default: [uue] }, $$scope: { ctx: t3 } } }), c.$on("click", t3[6]), h = new ut({ props: { variant: "secondary", $$slots: { default: [cue] }, $$scope: { ctx: t3 } } }), h.$on("click", t3[10]), v = new hn({}), v.$on("click", t3[7]);
  function L(d) {
    t3[11](d);
  }
  let B = {};
  t3[2] !== void 0 && (B.checked = t3[2]), _ = new xr({ props: B }), Qe.push(() => ze(_, "checked", L));
  let u = t3[4] && H7(t3), p = t3[3] && q7(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), fe(i.$$.fragment), o = z(), f = H("div"), fe(c.$$.fragment), l = z(), fe(h.$$.fragment), m = z(), fe(v.$$.fragment), b = z(), A = H("div"), fe(_.$$.fragment), I = z(), u && u.c(), S = z(), p && p.c(), $ = Lt(), V(e, "class", "controls-row"), St(A, "margin-left", "auto"), V(f, "class", "button-row");
  }, m(d, y) {
    R(d, e, y), ae(n, e, null), R(d, s, y), ae(i, d, y), R(d, o, y), R(d, f, y), ae(c, f, null), q(f, l), ae(h, f, null), q(f, m), ae(v, f, null), q(f, b), q(f, A), ae(_, A, null), R(d, I, y), u && u.m(d, y), R(d, S, y), p && p.m(d, y), R(d, $, y), F = true;
  }, p(d, y) {
    const w = {};
    !r && y & 2 && (r = true, w.value = d[1], qe(() => r = false)), n.$set(w);
    const E = {};
    y & 2 && (E.label = d[1] === "dec2bin" ? "Decimal Number (Base-10):" : "Binary Number (Base-2):"), y & 2 && (E.placeholder = d[1] === "dec2bin" ? "e.g. 42" : "e.g. 101010"), !a && y & 1 && (a = true, E.value = d[0], qe(() => a = false)), i.$set(E);
    const M = {};
    y & 4096 && (M.$$scope = { dirty: y, ctx: d }), c.$set(M);
    const x = {};
    y & 4096 && (x.$$scope = { dirty: y, ctx: d }), h.$set(x);
    const g = {};
    !C && y & 4 && (C = true, g.checked = d[2], qe(() => C = false)), _.$set(g), d[4] ? u ? u.p(d, y) : (u = H7(d), u.c(), u.m(S.parentNode, S)) : u && (u.d(1), u = null), d[3] ? p ? (p.p(d, y), y & 8 && W(p, 1)) : (p = q7(d), p.c(), W(p, 1), p.m($.parentNode, $)) : p && (Xt(), j(p, 1, 1, () => {
      p = null;
    }), er());
  }, i(d) {
    F || (W(n.$$.fragment, d), W(i.$$.fragment, d), W(c.$$.fragment, d), W(h.$$.fragment, d), W(v.$$.fragment, d), W(_.$$.fragment, d), W(p), F = true);
  }, o(d) {
    j(n.$$.fragment, d), j(i.$$.fragment, d), j(c.$$.fragment, d), j(h.$$.fragment, d), j(v.$$.fragment, d), j(_.$$.fragment, d), j(p), F = false;
  }, d(d) {
    d && (D(e), D(s), D(o), D(f), D(I), D(S), D($)), oe(n), oe(i, d), oe(c), oe(h), oe(v), oe(_), u && u.d(d), p && p.d(d);
  } };
}
function due(t3) {
  let e, n, r, s, i;
  return { c() {
    e = H("p"), e.textContent = "This tool converts integers between the two most fundamental number systems in computing:", n = z(), r = H("ul"), r.innerHTML = "<li><strong>Decimal (Base-10):</strong> The standard system humans use (digits 0-9).</li> <li><strong>Binary (Base-2):</strong> The system computers use (digits 0 and 1).</li>", s = z(), i = H("p"), i.innerHTML = `<strong>How it works:</strong>
    To convert Decimal to Binary, you repeatedly divide the number by 2 and keep the remainders. 
    To convert Binary to Decimal, you multiply each digit by powers of 2 (1, 2, 4, 8, 16...) and add them up.`;
  }, m(a, o) {
    R(a, e, o), R(a, n, o), R(a, r, o), R(a, s, o), R(a, i, o);
  }, p: dt, d(a) {
    a && (D(e), D(n), D(r), D(s), D(i));
  } };
}
function pue(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Decimal / Binary Converter", $$slots: { default: [hue] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Number Bases", $$slots: { default: [due] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 4127 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 4096 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function gue(t3, e, n) {
  let r = "", s = "dec2bin", i = "", a = "", o = true;
  const f = [{ value: "dec2bin", label: "Decimal to Binary" }, { value: "bin2dec", label: "Binary to Decimal" }];
  function c() {
    if (!r) {
      n(3, i = ""), n(4, a = "");
      return;
    }
    n(4, a = "");
    try {
      n(3, i = oue(r, s));
    } catch (A) {
      n(4, a = A.message), n(3, i = "");
    }
  }
  function l() {
    n(1, s = s === "dec2bin" ? "bin2dec" : "dec2bin"), i && !a && n(0, r = i), c();
  }
  function h(A) {
    s = A, n(1, s);
  }
  function m(A) {
    r = A, n(0, r);
  }
  const v = () => {
    n(0, r = ""), n(3, i = "");
  };
  function b(A) {
    o = A, n(2, o);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 7 && o && (r || s) && c();
  }, [r, s, o, i, a, f, c, l, h, m, v, b];
}
class mue extends xt {
  constructor(e) {
    super(), wt(this, e, gue, pue, At, {});
  }
}
function vue(t3, e) {
  if (!t3) return "";
  const n = t3.trim().replace(/[\s,]/g, "");
  return e === "dec2oct" ? yue(n) : bue(n);
}
function yue(t3) {
  try {
    return BigInt(t3).toString(8);
  } catch {
    throw new Error("Invalid Decimal Number. Please enter integers only.");
  }
}
function bue(t3) {
  if (!/^-?[0-7]+$/.test(t3)) throw new Error("Invalid Octal. Only digits 0-7 are allowed.");
  try {
    return BigInt("0o" + t3).toLocaleString("en-US");
  } catch {
    throw new Error("Could not parse octal string.");
  }
}
function Aue(t3) {
  let e;
  return { c() {
    e = we("Convert");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function wue(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function z7(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[4]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 16 && Ze(n, r[4]);
  }, d(r) {
    r && D(e);
  } };
}
function G7(t3) {
  let e, n;
  return e = new et({ props: { label: t3[1] === "dec2oct" ? "Octal Result:" : "Decimal Result:", value: t3[3], readonly: true, expandable: true, withCopy: true } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, s) {
    const i = {};
    s & 2 && (i.label = r[1] === "dec2oct" ? "Octal Result:" : "Decimal Result:"), s & 8 && (i.value = r[3]), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function xue(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F;
  function U(d) {
    t3[8](d);
  }
  let Q = { label: "Conversion Mode:", options: t3[5] };
  t3[1] !== void 0 && (Q.value = t3[1]), n = new Ht({ props: Q }), Qe.push(() => ze(n, "value", U));
  function P(d) {
    t3[9](d);
  }
  let N = { label: t3[1] === "dec2oct" ? "Decimal Number (Base-10):" : "Octal Number (Base-8):", placeholder: t3[1] === "dec2oct" ? "e.g. 64" : "e.g. 100", expandable: true };
  t3[0] !== void 0 && (N.value = t3[0]), i = new et({ props: N }), Qe.push(() => ze(i, "value", P)), c = new ut({ props: { $$slots: { default: [Aue] }, $$scope: { ctx: t3 } } }), c.$on("click", t3[6]), h = new ut({ props: { variant: "secondary", $$slots: { default: [wue] }, $$scope: { ctx: t3 } } }), h.$on("click", t3[10]), v = new hn({}), v.$on("click", t3[7]);
  function L(d) {
    t3[11](d);
  }
  let B = {};
  t3[2] !== void 0 && (B.checked = t3[2]), _ = new xr({ props: B }), Qe.push(() => ze(_, "checked", L));
  let u = t3[4] && z7(t3), p = t3[3] && G7(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), fe(i.$$.fragment), o = z(), f = H("div"), fe(c.$$.fragment), l = z(), fe(h.$$.fragment), m = z(), fe(v.$$.fragment), b = z(), A = H("div"), fe(_.$$.fragment), I = z(), u && u.c(), S = z(), p && p.c(), $ = Lt(), V(e, "class", "controls-row"), St(A, "margin-left", "auto"), V(f, "class", "button-row");
  }, m(d, y) {
    R(d, e, y), ae(n, e, null), R(d, s, y), ae(i, d, y), R(d, o, y), R(d, f, y), ae(c, f, null), q(f, l), ae(h, f, null), q(f, m), ae(v, f, null), q(f, b), q(f, A), ae(_, A, null), R(d, I, y), u && u.m(d, y), R(d, S, y), p && p.m(d, y), R(d, $, y), F = true;
  }, p(d, y) {
    const w = {};
    !r && y & 2 && (r = true, w.value = d[1], qe(() => r = false)), n.$set(w);
    const E = {};
    y & 2 && (E.label = d[1] === "dec2oct" ? "Decimal Number (Base-10):" : "Octal Number (Base-8):"), y & 2 && (E.placeholder = d[1] === "dec2oct" ? "e.g. 64" : "e.g. 100"), !a && y & 1 && (a = true, E.value = d[0], qe(() => a = false)), i.$set(E);
    const M = {};
    y & 4096 && (M.$$scope = { dirty: y, ctx: d }), c.$set(M);
    const x = {};
    y & 4096 && (x.$$scope = { dirty: y, ctx: d }), h.$set(x);
    const g = {};
    !C && y & 4 && (C = true, g.checked = d[2], qe(() => C = false)), _.$set(g), d[4] ? u ? u.p(d, y) : (u = z7(d), u.c(), u.m(S.parentNode, S)) : u && (u.d(1), u = null), d[3] ? p ? (p.p(d, y), y & 8 && W(p, 1)) : (p = G7(d), p.c(), W(p, 1), p.m($.parentNode, $)) : p && (Xt(), j(p, 1, 1, () => {
      p = null;
    }), er());
  }, i(d) {
    F || (W(n.$$.fragment, d), W(i.$$.fragment, d), W(c.$$.fragment, d), W(h.$$.fragment, d), W(v.$$.fragment, d), W(_.$$.fragment, d), W(p), F = true);
  }, o(d) {
    j(n.$$.fragment, d), j(i.$$.fragment, d), j(c.$$.fragment, d), j(h.$$.fragment, d), j(v.$$.fragment, d), j(_.$$.fragment, d), j(p), F = false;
  }, d(d) {
    d && (D(e), D(s), D(o), D(f), D(I), D(S), D($)), oe(n), oe(i, d), oe(c), oe(h), oe(v), oe(_), u && u.d(d), p && p.d(d);
  } };
}
function _ue(t3) {
  let e, n, r, s, i, a, o;
  return { c() {
    e = H("p"), e.innerHTML = "The <b>Octal</b> system (Base-8) uses digits from <b>0 to 7</b>.", n = z(), r = H("p"), r.textContent = `Historically, octal was very popular in early computing (like the PDP-8 and Unix file permissions) because 
    it maps perfectly to 3 bits ($2^3 = 8$).`, s = z(), i = H("ul"), i.innerHTML = "<li>Decimal 8 = Octal `10`</li> <li>Decimal 64 = Octal `100`</li>", a = z(), o = H("p"), o.textContent = "While Hexadecimal (Base-16) is more common today, Octal is still widely used in Linux/Unix file permissions \n    (e.g., `chmod 755`).";
  }, m(f, c) {
    R(f, e, c), R(f, n, c), R(f, r, c), R(f, s, c), R(f, i, c), R(f, a, c), R(f, o, c);
  }, p: dt, d(f) {
    f && (D(e), D(n), D(r), D(s), D(i), D(a), D(o));
  } };
}
function Eue(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Octal Converter", $$slots: { default: [xue] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Octal", links: [{ text: "Octal - Wikipedia", url: "https://en.wikipedia.org/wiki/Octal" }], $$slots: { default: [_ue] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 4127 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 4096 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function Bue(t3, e, n) {
  let r = "", s = "dec2oct", i = "", a = "", o = true;
  const f = [{ value: "dec2oct", label: "Decimal to Octal" }, { value: "oct2dec", label: "Octal to Decimal" }];
  function c() {
    if (!r) {
      n(3, i = ""), n(4, a = "");
      return;
    }
    n(4, a = "");
    try {
      n(3, i = vue(r, s));
    } catch (A) {
      n(4, a = A.message), n(3, i = "");
    }
  }
  function l() {
    n(1, s = s === "dec2oct" ? "oct2dec" : "dec2oct"), i && !a && n(0, r = i), c();
  }
  function h(A) {
    s = A, n(1, s);
  }
  function m(A) {
    r = A, n(0, r);
  }
  const v = () => {
    n(0, r = ""), n(3, i = "");
  };
  function b(A) {
    o = A, n(2, o);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 7 && o && (r || s) && c();
  }, [r, s, o, i, a, f, c, l, h, m, v, b];
}
class Cue extends xt {
  constructor(e) {
    super(), wt(this, e, Bue, Eue, At, {});
  }
}
function kue(t3, e, n = "utf-8") {
  if (!t3) return "";
  const r = t3.trim();
  return e === "encode" ? Iue(r, n) : Sue(r, n);
}
function Iue(t3, e) {
  let n;
  try {
    n = ps(t3, e);
  } catch (r) {
    throw new Error(r.message);
  }
  return Array.from(n).map((r) => r.toString(16).padStart(2, "0")).join("");
}
function Sue(t3, e) {
  const n = t3.replace(/[\s:-]/g, "");
  if (n.length % 2 !== 0) throw new Error("Invalid Hex string. Length must be even.");
  if (!/^[0-9a-fA-F]+$/.test(n)) throw new Error("Invalid characters found. Hex only allows 0-9 and A-F.");
  const r = n.length / 2, s = new Uint8Array(r);
  for (let i = 0; i < r; i++) {
    const a = parseInt(n.substr(i * 2, 2), 16);
    s[i] = a;
  }
  try {
    return new TextDecoder(e).decode(s);
  } catch {
    throw new Error(`The encoding '${e}' is not supported.`);
  }
}
function Mue(t3) {
  let e;
  return { c() {
    e = we("Convert");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function $ue(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function V7(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[5]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 32 && Ze(n, r[5]);
  }, d(r) {
    r && D(e);
  } };
}
function Y7(t3) {
  let e, n;
  return e = new et({ props: { label: t3[1] === "encode" ? "Hex Output:" : "Text Output:", value: t3[4], readonly: true, expandable: true, withCopy: true } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, s) {
    const i = {};
    s & 2 && (i.label = r[1] === "encode" ? "Hex Output:" : "Text Output:"), s & 16 && (i.value = r[4]), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function Tue(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U, Q, P;
  function N(x) {
    t3[9](x);
  }
  let L = { label: "Mode:", options: t3[6] };
  t3[1] !== void 0 && (L.value = t3[1]), n = new Ht({ props: L }), Qe.push(() => ze(n, "value", N));
  function B(x) {
    t3[10](x);
  }
  let u = { label: t3[1] === "encode" ? "Input Encoding:" : "Target Encoding:", options: gs.map(Fue) };
  t3[2] !== void 0 && (u.value = t3[2]), i = new Ht({ props: u }), Qe.push(() => ze(i, "value", B));
  function p(x) {
    t3[11](x);
  }
  let d = { label: t3[1] === "encode" ? "Input Text:" : "Input Hex String:", placeholder: t3[1] === "encode" ? "Type text..." : "e.g. 48656c6c6f", expandable: true };
  t3[0] !== void 0 && (d.value = t3[0]), f = new et({ props: d }), Qe.push(() => ze(f, "value", p)), m = new ut({ props: { $$slots: { default: [Mue] }, $$scope: { ctx: t3 } } }), m.$on("click", t3[7]), b = new ut({ props: { variant: "secondary", $$slots: { default: [$ue] }, $$scope: { ctx: t3 } } }), b.$on("click", t3[12]), _ = new hn({}), _.$on("click", t3[8]);
  function y(x) {
    t3[13](x);
  }
  let w = {};
  t3[3] !== void 0 && (w.checked = t3[3]), S = new xr({ props: w }), Qe.push(() => ze(S, "checked", y));
  let E = t3[5] && V7(t3), M = t3[4] && Y7(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), fe(i.$$.fragment), o = z(), fe(f.$$.fragment), l = z(), h = H("div"), fe(m.$$.fragment), v = z(), fe(b.$$.fragment), A = z(), fe(_.$$.fragment), C = z(), I = H("div"), fe(S.$$.fragment), F = z(), E && E.c(), U = z(), M && M.c(), Q = Lt(), V(e, "class", "controls-row"), St(I, "margin-left", "auto"), V(h, "class", "button-row");
  }, m(x, g) {
    R(x, e, g), ae(n, e, null), q(e, s), ae(i, e, null), R(x, o, g), ae(f, x, g), R(x, l, g), R(x, h, g), ae(m, h, null), q(h, v), ae(b, h, null), q(h, A), ae(_, h, null), q(h, C), q(h, I), ae(S, I, null), R(x, F, g), E && E.m(x, g), R(x, U, g), M && M.m(x, g), R(x, Q, g), P = true;
  }, p(x, g) {
    const k = {};
    !r && g & 2 && (r = true, k.value = x[1], qe(() => r = false)), n.$set(k);
    const T = {};
    g & 2 && (T.label = x[1] === "encode" ? "Input Encoding:" : "Target Encoding:"), !a && g & 4 && (a = true, T.value = x[2], qe(() => a = false)), i.$set(T);
    const O = {};
    g & 2 && (O.label = x[1] === "encode" ? "Input Text:" : "Input Hex String:"), g & 2 && (O.placeholder = x[1] === "encode" ? "Type text..." : "e.g. 48656c6c6f"), !c && g & 1 && (c = true, O.value = x[0], qe(() => c = false)), f.$set(O);
    const K = {};
    g & 16384 && (K.$$scope = { dirty: g, ctx: x }), m.$set(K);
    const Y = {};
    g & 16384 && (Y.$$scope = { dirty: g, ctx: x }), b.$set(Y);
    const J = {};
    !$ && g & 8 && ($ = true, J.checked = x[3], qe(() => $ = false)), S.$set(J), x[5] ? E ? E.p(x, g) : (E = V7(x), E.c(), E.m(U.parentNode, U)) : E && (E.d(1), E = null), x[4] ? M ? (M.p(x, g), g & 16 && W(M, 1)) : (M = Y7(x), M.c(), W(M, 1), M.m(Q.parentNode, Q)) : M && (Xt(), j(M, 1, 1, () => {
      M = null;
    }), er());
  }, i(x) {
    P || (W(n.$$.fragment, x), W(i.$$.fragment, x), W(f.$$.fragment, x), W(m.$$.fragment, x), W(b.$$.fragment, x), W(_.$$.fragment, x), W(S.$$.fragment, x), W(M), P = true);
  }, o(x) {
    j(n.$$.fragment, x), j(i.$$.fragment, x), j(f.$$.fragment, x), j(m.$$.fragment, x), j(b.$$.fragment, x), j(_.$$.fragment, x), j(S.$$.fragment, x), j(M), P = false;
  }, d(x) {
    x && (D(e), D(o), D(l), D(h), D(F), D(U), D(Q)), oe(n), oe(i), oe(f, x), oe(m), oe(b), oe(_), oe(S), E && E.d(x), M && M.d(x);
  } };
}
function Due(t3) {
  let e, n, r, s, i, a, o;
  return { c() {
    e = H("p"), e.innerHTML = "<strong>Hexadecimal</strong> (Base-16) is the most common way to represent binary data in a human-readable format.", n = z(), r = H("p"), r.innerHTML = "It uses 16 symbols: <strong>0-9</strong> followed by <strong>A-F</strong>.", s = z(), i = H("ul"), i.innerHTML = "<li><strong>A</strong> = 10</li> <li><strong>F</strong> = 15</li> <li><strong>space</strong> = 20</li> <li><strong>10</strong> (Hex) = 16 (Decimal)</li>", a = z(), o = H("p"), o.textContent = 'Computers group data into Bytes (8 bits). Since one Hex digit represents exactly 4 bits (a "nibble"), two Hex digits represent exactly one Byte.\n     This makes Hex perfect for debugging memory, colors (HTML `#FFFFFF`), or binary files.';
  }, m(f, c) {
    R(f, e, c), R(f, n, c), R(f, r, c), R(f, s, c), R(f, i, c), R(f, a, c), R(f, o, c);
  }, p: dt, d(f) {
    f && (D(e), D(n), D(r), D(s), D(i), D(a), D(o));
  } };
}
function Rue(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Hex Converter", $$slots: { default: [Tue] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Hexadecimal", links: [{ text: "Hexadecimal - Wikipedia", url: "https://en.wikipedia.org/wiki/Hexadecimal" }], $$slots: { default: [Due] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 16447 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 16384 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
const Fue = (t3) => t3.value;
function Pue(t3, e, n) {
  let r = "", s = "encode", i = "utf-8", a = "", o = "", f = true;
  const c = [{ value: "encode", label: "Text to Hex" }, { value: "decode", label: "Hex to Text" }];
  function l() {
    if (!r) {
      n(4, a = ""), n(5, o = "");
      return;
    }
    n(5, o = "");
    try {
      n(4, a = kue(r, s, i));
    } catch (C) {
      n(5, o = C.message), n(4, a = "");
    }
  }
  function h() {
    n(1, s = s === "encode" ? "decode" : "encode"), a && !o && n(0, r = a), l();
  }
  function m(C) {
    s = C, n(1, s);
  }
  function v(C) {
    i = C, n(2, i);
  }
  function b(C) {
    r = C, n(0, r);
  }
  const A = () => {
    n(0, r = ""), n(4, a = "");
  };
  function _(C) {
    f = C, n(3, f);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 15 && f && (r || s || i) && l();
  }, [r, s, i, f, a, o, c, l, h, m, v, b, A, _];
}
class Nue extends xt {
  constructor(e) {
    super(), wt(this, e, Pue, Rue, At, {});
  }
}
function Uue(t3, e) {
  return !t3 || !t3.trim() ? "" : e === "char2cp" ? Lue(t3) : Oue(t3);
}
function Lue(t3) {
  return Array.from(t3).map((n) => {
    let s = n.codePointAt(0).toString(16).toUpperCase();
    return s.length < 4 && (s = s.padStart(4, "0")), `U+${s}`;
  }).join(" ");
}
function Oue(t3) {
  return t3.trim().split(/\s+/).map((n) => {
    const r = n.replace(/^U\+/i, "");
    if (!/^[0-9A-Fa-f]+$/.test(r)) throw new Error(`Invalid codepoint format: "${n}"`);
    const s = parseInt(r, 16);
    if (s > 1114111) throw new Error(`Codepoint out of range: "${n}"`);
    try {
      return String.fromCodePoint(s);
    } catch {
      throw new Error(`Invalid codepoint: "${n}"`);
    }
  }).join("");
}
function Que(t3) {
  let e;
  return { c() {
    e = we("Convert");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function Kue(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function W7(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[4]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 16 && Ze(n, r[4]);
  }, d(r) {
    r && D(e);
  } };
}
function J7(t3) {
  let e, n;
  return e = new et({ props: { label: t3[1] === "char2cp" ? "Codepoint Output:" : "Text Output:", value: t3[3], readonly: true, expandable: true, withCopy: true } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, s) {
    const i = {};
    s & 2 && (i.label = r[1] === "char2cp" ? "Codepoint Output:" : "Text Output:"), s & 8 && (i.value = r[3]), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function Hue(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F;
  function U(d) {
    t3[8](d);
  }
  let Q = { label: "Mode:", options: t3[5] };
  t3[1] !== void 0 && (Q.value = t3[1]), n = new Ht({ props: Q }), Qe.push(() => ze(n, "value", U));
  function P(d) {
    t3[9](d);
  }
  let N = { label: t3[1] === "char2cp" ? "Input Text:" : "Input Codepoints:", placeholder: t3[1] === "char2cp" ? "Type text or emojis..." : "e.g. U+0048 U+0069", expandable: true };
  t3[0] !== void 0 && (N.value = t3[0]), i = new et({ props: N }), Qe.push(() => ze(i, "value", P)), c = new ut({ props: { $$slots: { default: [Que] }, $$scope: { ctx: t3 } } }), c.$on("click", t3[6]), h = new ut({ props: { variant: "secondary", $$slots: { default: [Kue] }, $$scope: { ctx: t3 } } }), h.$on("click", t3[10]), v = new hn({}), v.$on("click", t3[7]);
  function L(d) {
    t3[11](d);
  }
  let B = {};
  t3[2] !== void 0 && (B.checked = t3[2]), _ = new xr({ props: B }), Qe.push(() => ze(_, "checked", L));
  let u = t3[4] && W7(t3), p = t3[3] && J7(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), fe(i.$$.fragment), o = z(), f = H("div"), fe(c.$$.fragment), l = z(), fe(h.$$.fragment), m = z(), fe(v.$$.fragment), b = z(), A = H("div"), fe(_.$$.fragment), I = z(), u && u.c(), S = z(), p && p.c(), $ = Lt(), V(e, "class", "controls-row"), St(A, "margin-left", "auto"), V(f, "class", "button-row");
  }, m(d, y) {
    R(d, e, y), ae(n, e, null), R(d, s, y), ae(i, d, y), R(d, o, y), R(d, f, y), ae(c, f, null), q(f, l), ae(h, f, null), q(f, m), ae(v, f, null), q(f, b), q(f, A), ae(_, A, null), R(d, I, y), u && u.m(d, y), R(d, S, y), p && p.m(d, y), R(d, $, y), F = true;
  }, p(d, y) {
    const w = {};
    !r && y & 2 && (r = true, w.value = d[1], qe(() => r = false)), n.$set(w);
    const E = {};
    y & 2 && (E.label = d[1] === "char2cp" ? "Input Text:" : "Input Codepoints:"), y & 2 && (E.placeholder = d[1] === "char2cp" ? "Type text or emojis..." : "e.g. U+0048 U+0069"), !a && y & 1 && (a = true, E.value = d[0], qe(() => a = false)), i.$set(E);
    const M = {};
    y & 4096 && (M.$$scope = { dirty: y, ctx: d }), c.$set(M);
    const x = {};
    y & 4096 && (x.$$scope = { dirty: y, ctx: d }), h.$set(x);
    const g = {};
    !C && y & 4 && (C = true, g.checked = d[2], qe(() => C = false)), _.$set(g), d[4] ? u ? u.p(d, y) : (u = W7(d), u.c(), u.m(S.parentNode, S)) : u && (u.d(1), u = null), d[3] ? p ? (p.p(d, y), y & 8 && W(p, 1)) : (p = J7(d), p.c(), W(p, 1), p.m($.parentNode, $)) : p && (Xt(), j(p, 1, 1, () => {
      p = null;
    }), er());
  }, i(d) {
    F || (W(n.$$.fragment, d), W(i.$$.fragment, d), W(c.$$.fragment, d), W(h.$$.fragment, d), W(v.$$.fragment, d), W(_.$$.fragment, d), W(p), F = true);
  }, o(d) {
    j(n.$$.fragment, d), j(i.$$.fragment, d), j(c.$$.fragment, d), j(h.$$.fragment, d), j(v.$$.fragment, d), j(_.$$.fragment, d), j(p), F = false;
  }, d(d) {
    d && (D(e), D(s), D(o), D(f), D(I), D(S), D($)), oe(n), oe(i, d), oe(c), oe(h), oe(v), oe(_), u && u.d(d), p && p.d(d);
  } };
}
function que(t3) {
  let e, n, r, s, i, a, o;
  return { c() {
    e = H("p"), e.innerHTML = "<strong>Unicode</strong> is the universal standard for representing text. It assigns a unique number, called a <strong>Codepoint</strong>, to every character in almost every language (including emojis!).", n = z(), r = H("p"), r.innerHTML = "The standard format for writing these is <code>U+</code> followed by the hexadecimal number.", s = z(), i = H("ul"), i.innerHTML = "<li><strong>A</strong> = <code>U+0041</code></li> <li><strong>\u20AC</strong> = <code>U+20AC</code></li>", a = z(), o = H("p"), o.textContent = 'Unlike older encodings (like ASCII) which were limited to 128 characters, Unicode supports over 149,000 characters, organized into "Planes" and "Blocks".';
  }, m(f, c) {
    R(f, e, c), R(f, n, c), R(f, r, c), R(f, s, c), R(f, i, c), R(f, a, c), R(f, o, c);
  }, p: dt, d(f) {
    f && (D(e), D(n), D(r), D(s), D(i), D(a), D(o));
  } };
}
function zue(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Unicode Codepoint Converter", $$slots: { default: [Hue] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Unicode Codepoints", links: [{ text: "Unicode Characters - Wikipedia", url: "https://en.wikipedia.org/wiki/List_of_Unicode_characters" }], $$slots: { default: [que] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 4127 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 4096 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function Gue(t3, e, n) {
  let r = "", s = "char2cp", i = "", a = "", o = true;
  const f = [{ value: "char2cp", label: "Text to Codepoint (U+XXXX)" }, { value: "cp2char", label: "Codepoint to Text" }];
  function c() {
    if (!r) {
      n(3, i = ""), n(4, a = "");
      return;
    }
    n(4, a = "");
    try {
      n(3, i = Uue(r, s));
    } catch (A) {
      n(4, a = A.message), n(3, i = "");
    }
  }
  function l() {
    n(1, s = s === "char2cp" ? "cp2char" : "char2cp"), i && !a && n(0, r = i), c();
  }
  function h(A) {
    s = A, n(1, s);
  }
  function m(A) {
    r = A, n(0, r);
  }
  const v = () => {
    n(0, r = ""), n(3, i = "");
  };
  function b(A) {
    o = A, n(2, o);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 7 && o && (r || s) && c();
  }, [r, s, o, i, a, f, c, l, h, m, v, b];
}
class Vue extends xt {
  constructor(e) {
    super(), wt(this, e, Gue, zue, At, {});
  }
}
function Z7(t3) {
  let e, n;
  return { c() {
    e = H("span"), n = we(t3[1]), V(e, "class", "label-text svelte-53eh7h");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 2 && Ze(n, r[1]);
  }, d(r) {
    r && D(e);
  } };
}
function j7(t3) {
  let e, n;
  return { c() {
    e = H("span"), n = we(t3[2]), V(e, "class", "suffix svelte-53eh7h");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 4 && Ze(n, r[2]);
  }, d(r) {
    r && D(e);
  } };
}
function Yue(t3) {
  let e, n, r, s, i, a, o, f = t3[1] && Z7(t3), c = t3[2] && j7(t3);
  return { c() {
    e = H("div"), f && f.c(), n = z(), r = H("div"), s = H("input"), i = z(), c && c.c(), V(s, "type", "number"), V(s, "min", t3[3]), V(s, "step", t3[4]), V(s, "class", "svelte-53eh7h"), V(r, "class", "input-container svelte-53eh7h"), V(e, "class", "small-input-wrapper svelte-53eh7h");
  }, m(l, h) {
    R(l, e, h), f && f.m(e, null), q(e, n), q(e, r), q(r, s), yr(s, t3[0]), q(r, i), c && c.m(r, null), a || (o = [Kt(s, "input", t3[6]), Kt(s, "input", t3[5])], a = true);
  }, p(l, [h]) {
    l[1] ? f ? f.p(l, h) : (f = Z7(l), f.c(), f.m(e, n)) : f && (f.d(1), f = null), h & 8 && V(s, "min", l[3]), h & 16 && V(s, "step", l[4]), h & 1 && Nn(s.value) !== l[0] && yr(s, l[0]), l[2] ? c ? c.p(l, h) : (c = j7(l), c.c(), c.m(r, null)) : c && (c.d(1), c = null);
  }, i: dt, o: dt, d(l) {
    l && D(e), f && f.d(), c && c.d(), a = false, Mn(o);
  } };
}
function Wue(t3, e, n) {
  let { value: r } = e, { label: s = "" } = e, { suffix: i = "" } = e, { min: a = 0 } = e, { step: o = 1 } = e;
  const f = Vh();
  function c() {
    f("input", r);
  }
  function l() {
    r = Nn(this.value), n(0, r);
  }
  return t3.$$set = (h) => {
    "value" in h && n(0, r = h.value), "label" in h && n(1, s = h.label), "suffix" in h && n(2, i = h.suffix), "min" in h && n(3, a = h.min), "step" in h && n(4, o = h.step);
  }, [r, s, i, a, o, c, l];
}
class U4 extends xt {
  constructor(e) {
    super(), wt(this, e, Wue, Yue, At, { value: 0, label: 1, suffix: 2, min: 3, step: 4 });
  }
}
function Jue(t3, e, n) {
  if (!t3) return "";
  const r = Number(e);
  if (isNaN(r) || r < 2 || r > 36) throw new Error("Base must be an integer between 2 and 36.");
  const s = t3.trim().replace(/[\s,]/g, "");
  return n === "dec2radix" ? Zue(s, r) : jue(s, r);
}
function Zue(t3, e) {
  try {
    return BigInt(t3).toString(e).toUpperCase();
  } catch {
    throw new Error("Invalid Decimal Number.");
  }
}
function jue(t3, e) {
  let n = false, r = t3;
  r.startsWith("-") && (n = true, r = r.substring(1));
  const s = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ".slice(0, e);
  if (!new RegExp(`^[${s}]+$`, "i").test(r)) throw new Error(`Invalid digit found for Base-${e}. Allowed: 0-${s[s.length - 1]}`);
  let a = 0n;
  const o = BigInt(e);
  for (const f of r) {
    const c = BigInt(parseInt(f, 36));
    a = a * o + c;
  }
  return n && (a = -a), a.toLocaleString("en-US");
}
function Xue(t3) {
  let e;
  return { c() {
    e = we("Convert");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function ece(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function X7(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[5]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 32 && Ze(n, r[5]);
  }, d(r) {
    r && D(e);
  } };
}
function e9(t3) {
  let e, n;
  return e = new et({ props: { label: t3[1] === "dec2radix" ? `Base-${t3[2]} Result:` : "Decimal Result:", value: t3[4], readonly: true, expandable: true, withCopy: true } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, s) {
    const i = {};
    s & 6 && (i.label = r[1] === "dec2radix" ? `Base-${r[2]} Result:` : "Decimal Result:"), s & 16 && (i.value = r[4]), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function tce(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U, Q, P;
  function N(x) {
    t3[9](x);
  }
  let L = { label: "Mode:", options: t3[6] };
  t3[1] !== void 0 && (L.value = t3[1]), n = new Ht({ props: L }), Qe.push(() => ze(n, "value", N));
  function B(x) {
    t3[10](x);
  }
  let u = { label: "Base (Radix):", min: "2", max: "36" };
  t3[2] !== void 0 && (u.value = t3[2]), i = new U4({ props: u }), Qe.push(() => ze(i, "value", B)), i.$on("input", t3[11]);
  function p(x) {
    t3[12](x);
  }
  let d = { label: t3[1] === "dec2radix" ? "Decimal Number:" : `Base-${t3[2]} Number:`, placeholder: t3[1] === "dec2radix" ? "e.g. 255" : "e.g. FF", expandable: true };
  t3[0] !== void 0 && (d.value = t3[0]), f = new et({ props: d }), Qe.push(() => ze(f, "value", p)), m = new ut({ props: { $$slots: { default: [Xue] }, $$scope: { ctx: t3 } } }), m.$on("click", t3[7]), b = new ut({ props: { variant: "secondary", $$slots: { default: [ece] }, $$scope: { ctx: t3 } } }), b.$on("click", t3[13]), _ = new hn({}), _.$on("click", t3[8]);
  function y(x) {
    t3[14](x);
  }
  let w = {};
  t3[3] !== void 0 && (w.checked = t3[3]), S = new xr({ props: w }), Qe.push(() => ze(S, "checked", y));
  let E = t3[5] && X7(t3), M = t3[4] && e9(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), fe(i.$$.fragment), o = z(), fe(f.$$.fragment), l = z(), h = H("div"), fe(m.$$.fragment), v = z(), fe(b.$$.fragment), A = z(), fe(_.$$.fragment), C = z(), I = H("div"), fe(S.$$.fragment), F = z(), E && E.c(), U = z(), M && M.c(), Q = Lt(), V(e, "class", "controls-row"), St(I, "margin-left", "auto"), V(h, "class", "button-row");
  }, m(x, g) {
    R(x, e, g), ae(n, e, null), q(e, s), ae(i, e, null), R(x, o, g), ae(f, x, g), R(x, l, g), R(x, h, g), ae(m, h, null), q(h, v), ae(b, h, null), q(h, A), ae(_, h, null), q(h, C), q(h, I), ae(S, I, null), R(x, F, g), E && E.m(x, g), R(x, U, g), M && M.m(x, g), R(x, Q, g), P = true;
  }, p(x, g) {
    const k = {};
    !r && g & 2 && (r = true, k.value = x[1], qe(() => r = false)), n.$set(k);
    const T = {};
    !a && g & 4 && (a = true, T.value = x[2], qe(() => a = false)), i.$set(T);
    const O = {};
    g & 6 && (O.label = x[1] === "dec2radix" ? "Decimal Number:" : `Base-${x[2]} Number:`), g & 2 && (O.placeholder = x[1] === "dec2radix" ? "e.g. 255" : "e.g. FF"), !c && g & 1 && (c = true, O.value = x[0], qe(() => c = false)), f.$set(O);
    const K = {};
    g & 32768 && (K.$$scope = { dirty: g, ctx: x }), m.$set(K);
    const Y = {};
    g & 32768 && (Y.$$scope = { dirty: g, ctx: x }), b.$set(Y);
    const J = {};
    !$ && g & 8 && ($ = true, J.checked = x[3], qe(() => $ = false)), S.$set(J), x[5] ? E ? E.p(x, g) : (E = X7(x), E.c(), E.m(U.parentNode, U)) : E && (E.d(1), E = null), x[4] ? M ? (M.p(x, g), g & 16 && W(M, 1)) : (M = e9(x), M.c(), W(M, 1), M.m(Q.parentNode, Q)) : M && (Xt(), j(M, 1, 1, () => {
      M = null;
    }), er());
  }, i(x) {
    P || (W(n.$$.fragment, x), W(i.$$.fragment, x), W(f.$$.fragment, x), W(m.$$.fragment, x), W(b.$$.fragment, x), W(_.$$.fragment, x), W(S.$$.fragment, x), W(M), P = true);
  }, o(x) {
    j(n.$$.fragment, x), j(i.$$.fragment, x), j(f.$$.fragment, x), j(m.$$.fragment, x), j(b.$$.fragment, x), j(_.$$.fragment, x), j(S.$$.fragment, x), j(M), P = false;
  }, d(x) {
    x && (D(e), D(o), D(l), D(h), D(F), D(U), D(Q)), oe(n), oe(i), oe(f, x), oe(m), oe(b), oe(_), oe(S), E && E.d(x), M && M.d(x);
  } };
}
function rce(t3) {
  let e, n, r, s, i;
  return { c() {
    e = H("p"), e.innerHTML = "The <strong>Radix</strong> (or Base) represents the number of unique digits available in a number system.", n = z(), r = H("ul"), r.innerHTML = "<li><strong>Base 2 (Binary):</strong> 0, 1</li> <li><strong>Base 10 (Decimal):</strong> 0-9</li> <li><strong>Base 16 (Hex):</strong> 0-9, A-F</li> <li><strong>Base 36:</strong> 0-9, A-Z (The maximum standard alphanumeric base).</li>", s = z(), i = H("p"), i.textContent = `This tool allows you to convert between the standard Decimal system and any custom base up to 36. 
    It is useful for encoding identifiers, shortening URLs, or understanding how different counting systems work.`;
  }, m(a, o) {
    R(a, e, o), R(a, n, o), R(a, r, o), R(a, s, o), R(a, i, o);
  }, p: dt, d(a) {
    a && (D(e), D(n), D(r), D(s), D(i));
  } };
}
function nce(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Decimal / Radix Converter", $$slots: { default: [tce] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Radix (Base)", $$slots: { default: [rce] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 32831 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 32768 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function ice(t3, e, n) {
  let r = "", s = "dec2radix", i = 36, a = "", o = "", f = true;
  const c = [{ value: "dec2radix", label: "Decimal to Base-N" }, { value: "radix2dec", label: "Base-N to Decimal" }];
  function l() {
    if (!r) {
      n(4, a = ""), n(5, o = "");
      return;
    }
    n(5, o = "");
    try {
      n(4, a = Jue(r, i, s));
    } catch (I) {
      n(5, o = I.message), n(4, a = "");
    }
  }
  function h() {
    n(1, s = s === "dec2radix" ? "radix2dec" : "dec2radix"), a && !o && n(0, r = a.replace(/,/g, "")), l();
  }
  function m(I) {
    s = I, n(1, s);
  }
  function v(I) {
    i = I, n(2, i);
  }
  const b = () => {
    f && l();
  };
  function A(I) {
    r = I, n(0, r);
  }
  const _ = () => {
    n(0, r = ""), n(4, a = "");
  };
  function C(I) {
    f = I, n(3, f);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 15 && f && (r || s || i) && l();
  }, [r, s, i, f, a, o, c, l, h, m, v, b, A, _, C];
}
class sce extends xt {
  constructor(e) {
    super(), wt(this, e, ice, nce, At, {});
  }
}
function ace(t3, e) {
  if (!t3) return "";
  const n = t3.trim();
  return e === "dec2bcd" ? oce(n) : fce(n);
}
function oce(t3) {
  if (!/^\d+$/.test(t3)) throw new Error("Invalid Decimal. Please enter digits 0-9 only.");
  return t3.split("").map((r) => parseInt(r, 10).toString(2).padStart(4, "0")).join(" ");
}
function fce(t3) {
  const e = t3.trim().split(/\s+/);
  let n = "";
  for (const r of e) {
    if (!/^[01]+$/.test(r)) throw new Error(`Invalid binary group found: "${r}"`);
    const s = parseInt(r, 2);
    if (s > 9) throw new Error(`Invalid BCD sequence: "${r}" evaluates to ${s}, which is not a digit (0-9).`);
    n += s.toString();
  }
  return n;
}
function lce(t3) {
  let e;
  return { c() {
    e = we("Convert");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function uce(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function t9(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[4]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 16 && Ze(n, r[4]);
  }, d(r) {
    r && D(e);
  } };
}
function r9(t3) {
  let e, n;
  return e = new et({ props: { label: t3[1] === "dec2bcd" ? "BCD Output:" : "Decimal Output:", value: t3[3], readonly: true, expandable: true, withCopy: true } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, s) {
    const i = {};
    s & 2 && (i.label = r[1] === "dec2bcd" ? "BCD Output:" : "Decimal Output:"), s & 8 && (i.value = r[3]), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function cce(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F;
  function U(d) {
    t3[8](d);
  }
  let Q = { label: "Mode:", options: t3[5] };
  t3[1] !== void 0 && (Q.value = t3[1]), n = new Ht({ props: Q }), Qe.push(() => ze(n, "value", U));
  function P(d) {
    t3[9](d);
  }
  let N = { label: t3[1] === "dec2bcd" ? "Decimal Input:" : "BCD Input:", placeholder: t3[1] === "dec2bcd" ? "e.g. 95" : "e.g. 1001 0101", expandable: true };
  t3[0] !== void 0 && (N.value = t3[0]), i = new et({ props: N }), Qe.push(() => ze(i, "value", P)), c = new ut({ props: { $$slots: { default: [lce] }, $$scope: { ctx: t3 } } }), c.$on("click", t3[6]), h = new ut({ props: { variant: "secondary", $$slots: { default: [uce] }, $$scope: { ctx: t3 } } }), h.$on("click", t3[10]), v = new hn({}), v.$on("click", t3[7]);
  function L(d) {
    t3[11](d);
  }
  let B = {};
  t3[2] !== void 0 && (B.checked = t3[2]), _ = new xr({ props: B }), Qe.push(() => ze(_, "checked", L));
  let u = t3[4] && t9(t3), p = t3[3] && r9(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), fe(i.$$.fragment), o = z(), f = H("div"), fe(c.$$.fragment), l = z(), fe(h.$$.fragment), m = z(), fe(v.$$.fragment), b = z(), A = H("div"), fe(_.$$.fragment), I = z(), u && u.c(), S = z(), p && p.c(), $ = Lt(), V(e, "class", "controls-row"), St(A, "margin-left", "auto"), V(f, "class", "button-row");
  }, m(d, y) {
    R(d, e, y), ae(n, e, null), R(d, s, y), ae(i, d, y), R(d, o, y), R(d, f, y), ae(c, f, null), q(f, l), ae(h, f, null), q(f, m), ae(v, f, null), q(f, b), q(f, A), ae(_, A, null), R(d, I, y), u && u.m(d, y), R(d, S, y), p && p.m(d, y), R(d, $, y), F = true;
  }, p(d, y) {
    const w = {};
    !r && y & 2 && (r = true, w.value = d[1], qe(() => r = false)), n.$set(w);
    const E = {};
    y & 2 && (E.label = d[1] === "dec2bcd" ? "Decimal Input:" : "BCD Input:"), y & 2 && (E.placeholder = d[1] === "dec2bcd" ? "e.g. 95" : "e.g. 1001 0101"), !a && y & 1 && (a = true, E.value = d[0], qe(() => a = false)), i.$set(E);
    const M = {};
    y & 4096 && (M.$$scope = { dirty: y, ctx: d }), c.$set(M);
    const x = {};
    y & 4096 && (x.$$scope = { dirty: y, ctx: d }), h.$set(x);
    const g = {};
    !C && y & 4 && (C = true, g.checked = d[2], qe(() => C = false)), _.$set(g), d[4] ? u ? u.p(d, y) : (u = t9(d), u.c(), u.m(S.parentNode, S)) : u && (u.d(1), u = null), d[3] ? p ? (p.p(d, y), y & 8 && W(p, 1)) : (p = r9(d), p.c(), W(p, 1), p.m($.parentNode, $)) : p && (Xt(), j(p, 1, 1, () => {
      p = null;
    }), er());
  }, i(d) {
    F || (W(n.$$.fragment, d), W(i.$$.fragment, d), W(c.$$.fragment, d), W(h.$$.fragment, d), W(v.$$.fragment, d), W(_.$$.fragment, d), W(p), F = true);
  }, o(d) {
    j(n.$$.fragment, d), j(i.$$.fragment, d), j(c.$$.fragment, d), j(h.$$.fragment, d), j(v.$$.fragment, d), j(_.$$.fragment, d), j(p), F = false;
  }, d(d) {
    d && (D(e), D(s), D(o), D(f), D(I), D(S), D($)), oe(n), oe(i, d), oe(c), oe(h), oe(v), oe(_), u && u.d(d), p && p.d(d);
  } };
}
function hce(t3) {
  let e, n, r, s, i, a, o;
  return { c() {
    e = H("p"), e.innerHTML = "<strong>Binary-Coded Decimal (BCD)</strong> is a class of binary encodings of decimal numbers where each decimal digit is represented by a fixed number of bits, usually four.", n = z(), r = H("p"), r.innerHTML = "<strong>Difference from Pure Binary:</strong>", s = z(), i = H("ul"), i.innerHTML = `<li>In <strong>Pure Binary</strong>, the number <code>12</code> is stored as <code>1100</code>.</li> <li>In <strong>BCD</strong>, the number <code>12</code> is split into digits <code>1</code> and <code>2</code>.
      <ul><li>1 = <code>0001</code></li> <li>2 = <code>0010</code></li> <li>Result = <code>0001 0010</code></li></ul></li>`, a = z(), o = H("p"), o.textContent = "BCD is less compact than pure binary but allows for easier display of digits on electronic systems (like digital clocks) and avoids rounding errors in financial software.";
  }, m(f, c) {
    R(f, e, c), R(f, n, c), R(f, r, c), R(f, s, c), R(f, i, c), R(f, a, c), R(f, o, c);
  }, p: dt, d(f) {
    f && (D(e), D(n), D(r), D(s), D(i), D(a), D(o));
  } };
}
function dce(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Decimal / BCD Converter", $$slots: { default: [cce] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About BCD", $$slots: { default: [hce] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 4127 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 4096 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function pce(t3, e, n) {
  let r = "", s = "dec2bcd", i = "", a = "", o = true;
  const f = [{ value: "dec2bcd", label: "Decimal to BCD" }, { value: "bcd2dec", label: "BCD to Decimal" }];
  function c() {
    if (!r) {
      n(3, i = ""), n(4, a = "");
      return;
    }
    n(4, a = "");
    try {
      n(3, i = ace(r, s));
    } catch (A) {
      n(4, a = A.message), n(3, i = "");
    }
  }
  function l() {
    n(1, s = s === "dec2bcd" ? "bcd2dec" : "dec2bcd"), i && !a && n(0, r = i), c();
  }
  function h(A) {
    s = A, n(1, s);
  }
  function m(A) {
    r = A, n(0, r);
  }
  const v = () => {
    n(0, r = ""), n(3, i = "");
  };
  function b(A) {
    o = A, n(2, o);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 7 && o && (r || s) && c();
  }, [r, s, o, i, a, f, c, l, h, m, v, b];
}
class gce extends xt {
  constructor(e) {
    super(), wt(this, e, pce, dce, At, {});
  }
}
function mce(t3, e) {
  return t3 ? e === "char2entity" ? vce(t3) : yce(t3) : "";
}
function vce(t3) {
  return t3.replace(/[\u00A0-\u9999<>&"']/gim, function(e) {
    return "&#" + e.charCodeAt(0) + ";";
  }), t3.replace(/[<>&"']|[\u00A0-\u9999]/g, function(e) {
    switch (e) {
      case "<":
        return "&lt;";
      case ">":
        return "&gt;";
      case "&":
        return "&amp;";
      case '"':
        return "&quot;";
      case "'":
        return "&apos;";
      default:
        return "&#" + e.charCodeAt(0) + ";";
    }
  });
}
function yce(t3) {
  return typeof DOMParser > "u" ? t3 : new DOMParser().parseFromString(t3, "text/html").documentElement.textContent;
}
function bce(t3) {
  let e;
  return { c() {
    e = we("Convert");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function Ace(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function n9(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[4]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 16 && Ze(n, r[4]);
  }, d(r) {
    r && D(e);
  } };
}
function i9(t3) {
  let e, n;
  return e = new et({ props: { label: t3[1] === "char2entity" ? "HTML Safe Output:" : "Decoded Text:", value: t3[3], readonly: true, expandable: true, withCopy: true } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, s) {
    const i = {};
    s & 2 && (i.label = r[1] === "char2entity" ? "HTML Safe Output:" : "Decoded Text:"), s & 8 && (i.value = r[3]), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function wce(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F;
  function U(d) {
    t3[8](d);
  }
  let Q = { label: "Conversion Mode:", options: t3[5] };
  t3[1] !== void 0 && (Q.value = t3[1]), n = new Ht({ props: Q }), Qe.push(() => ze(n, "value", U));
  function P(d) {
    t3[9](d);
  }
  let N = { label: t3[1] === "char2entity" ? "Input Text:" : "Input HTML Entities:", placeholder: t3[1] === "char2entity" ? "Type <script> or special chars..." : "e.g. &lt;h1&gt;Hello&lt;/h1&gt;", expandable: true };
  t3[0] !== void 0 && (N.value = t3[0]), i = new et({ props: N }), Qe.push(() => ze(i, "value", P)), c = new ut({ props: { $$slots: { default: [bce] }, $$scope: { ctx: t3 } } }), c.$on("click", t3[6]), h = new ut({ props: { variant: "secondary", $$slots: { default: [Ace] }, $$scope: { ctx: t3 } } }), h.$on("click", t3[10]), v = new hn({}), v.$on("click", t3[7]);
  function L(d) {
    t3[11](d);
  }
  let B = {};
  t3[2] !== void 0 && (B.checked = t3[2]), _ = new xr({ props: B }), Qe.push(() => ze(_, "checked", L));
  let u = t3[4] && n9(t3), p = t3[3] && i9(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), fe(i.$$.fragment), o = z(), f = H("div"), fe(c.$$.fragment), l = z(), fe(h.$$.fragment), m = z(), fe(v.$$.fragment), b = z(), A = H("div"), fe(_.$$.fragment), I = z(), u && u.c(), S = z(), p && p.c(), $ = Lt(), V(e, "class", "controls-row"), St(A, "margin-left", "auto"), V(f, "class", "button-row");
  }, m(d, y) {
    R(d, e, y), ae(n, e, null), R(d, s, y), ae(i, d, y), R(d, o, y), R(d, f, y), ae(c, f, null), q(f, l), ae(h, f, null), q(f, m), ae(v, f, null), q(f, b), q(f, A), ae(_, A, null), R(d, I, y), u && u.m(d, y), R(d, S, y), p && p.m(d, y), R(d, $, y), F = true;
  }, p(d, y) {
    const w = {};
    !r && y & 2 && (r = true, w.value = d[1], qe(() => r = false)), n.$set(w);
    const E = {};
    y & 2 && (E.label = d[1] === "char2entity" ? "Input Text:" : "Input HTML Entities:"), y & 2 && (E.placeholder = d[1] === "char2entity" ? "Type <script> or special chars..." : "e.g. &lt;h1&gt;Hello&lt;/h1&gt;"), !a && y & 1 && (a = true, E.value = d[0], qe(() => a = false)), i.$set(E);
    const M = {};
    y & 4096 && (M.$$scope = { dirty: y, ctx: d }), c.$set(M);
    const x = {};
    y & 4096 && (x.$$scope = { dirty: y, ctx: d }), h.$set(x);
    const g = {};
    !C && y & 4 && (C = true, g.checked = d[2], qe(() => C = false)), _.$set(g), d[4] ? u ? u.p(d, y) : (u = n9(d), u.c(), u.m(S.parentNode, S)) : u && (u.d(1), u = null), d[3] ? p ? (p.p(d, y), y & 8 && W(p, 1)) : (p = i9(d), p.c(), W(p, 1), p.m($.parentNode, $)) : p && (Xt(), j(p, 1, 1, () => {
      p = null;
    }), er());
  }, i(d) {
    F || (W(n.$$.fragment, d), W(i.$$.fragment, d), W(c.$$.fragment, d), W(h.$$.fragment, d), W(v.$$.fragment, d), W(_.$$.fragment, d), W(p), F = true);
  }, o(d) {
    j(n.$$.fragment, d), j(i.$$.fragment, d), j(c.$$.fragment, d), j(h.$$.fragment, d), j(v.$$.fragment, d), j(_.$$.fragment, d), j(p), F = false;
  }, d(d) {
    d && (D(e), D(s), D(o), D(f), D(I), D(S), D($)), oe(n), oe(i, d), oe(c), oe(h), oe(v), oe(_), u && u.d(d), p && p.d(d);
  } };
}
function xce(t3) {
  let e, n, r, s, i, a, o, f, c;
  return { c() {
    e = H("p"), e.innerHTML = "<strong>HTML Entities</strong> are used to display reserved characters in HTML.", n = z(), r = H("p"), r.innerHTML = `For example, if you write <code>&lt;</code> in your HTML code, the browser thinks you are starting a tag. 
    To display the actual &quot;less than&quot; symbol, you must write <code>&amp;lt;</code> or <code>&amp;#60;</code>.`, s = z(), i = H("p"), i.innerHTML = "<strong>Common Entities:</strong>", a = z(), o = H("ul"), o.innerHTML = "<li><code>&amp;lt;</code> = &lt;</li> <li><code>&amp;gt;</code> = &gt;</li> <li><code>&amp;amp;</code> = &amp;</li> <li><code>&amp;quot;</code> = &quot;</li> <li><code>&amp;copy;</code> = \xA9</li>", f = z(), c = H("p"), c.textContent = `This tool also converts non-ASCII characters (like emojis or foreign letters) into their numeric decimal codes 
    to ensure they display correctly on all browsers.`;
  }, m(l, h) {
    R(l, e, h), R(l, n, h), R(l, r, h), R(l, s, h), R(l, i, h), R(l, a, h), R(l, o, h), R(l, f, h), R(l, c, h);
  }, p: dt, d(l) {
    l && (D(e), D(n), D(r), D(s), D(i), D(a), D(o), D(f), D(c));
  } };
}
function _ce(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "HTML Entity Converter", $$slots: { default: [wce] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About HTML Entities", links: [{ text: "Wikipedia", url: "https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references" }], $$slots: { default: [xce] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 4127 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 4096 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function Ece(t3, e, n) {
  let r = "", s = "char2entity", i = "", a = "", o = true;
  const f = [{ value: "char2entity", label: "Text to HTML Entities" }, { value: "entity2char", label: "HTML Entities to Text" }];
  function c() {
    if (!r) {
      n(3, i = ""), n(4, a = "");
      return;
    }
    n(4, a = "");
    try {
      n(3, i = mce(r, s));
    } catch (A) {
      n(4, a = A.message), n(3, i = "");
    }
  }
  function l() {
    n(1, s = s === "char2entity" ? "entity2char" : "char2entity"), i && !a && n(0, r = i), c();
  }
  function h(A) {
    s = A, n(1, s);
  }
  function m(A) {
    r = A, n(0, r);
  }
  const v = () => {
    n(0, r = ""), n(3, i = "");
  };
  function b(A) {
    o = A, n(2, o);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 7 && o && (r || s) && c();
  }, [r, s, o, i, a, f, c, l, h, m, v, b];
}
class Bce extends xt {
  constructor(e) {
    super(), wt(this, e, Ece, _ce, At, {});
  }
}
function Cce(t3, e, n = "CERTIFICATE") {
  return !t3 || !t3.trim() ? "" : e === "pem2der" ? kce(t3) : Ice(t3, n);
}
function kce(t3) {
  let e = t3.replace(/-----BEGIN [^-]+-----/g, "").replace(/-----END [^-]+-----/g, "").replace(/\s+/g, "");
  try {
    const n = atob(e);
    let r = "";
    for (let s = 0; s < n.length; s++) {
      const i = n.charCodeAt(s).toString(16).padStart(2, "0");
      r += i;
    }
    return r.toUpperCase();
  } catch {
    throw new Error("Invalid PEM format. Could not Decode Base64.");
  }
}
function Ice(t3, e) {
  const n = t3.replace(/[\s:]/g, "");
  if (!/^[0-9A-Fa-f]+$/.test(n)) throw new Error("Invalid Hex string. Only 0-9 and A-F allowed.");
  if (n.length % 2 !== 0) throw new Error("Invalid Hex length. Must be even.");
  let r = "";
  for (let o = 0; o < n.length; o += 2) r += String.fromCharCode(parseInt(n.substr(o, 2), 16));
  const i = btoa(r).match(/.{1,64}/g), a = i ? i.join(`
`) : "";
  return `-----BEGIN ${e}-----
${a}
-----END ${e}-----`;
}
function s9(t3) {
  let e, n, r;
  function s(a) {
    t3[12](a);
  }
  let i = { label: "PEM Header Type:", options: t3[6] ? t3[7] : [] };
  return t3[2] !== void 0 && (i.value = t3[2]), e = new Ht({ props: i }), Qe.push(() => ze(e, "value", s)), { c() {
    fe(e.$$.fragment);
  }, m(a, o) {
    ae(e, a, o), r = true;
  }, p(a, o) {
    const f = {};
    !n && o & 4 && (n = true, f.value = a[2], qe(() => n = false)), e.$set(f);
  }, i(a) {
    r || (W(e.$$.fragment, a), r = true);
  }, o(a) {
    j(e.$$.fragment, a), r = false;
  }, d(a) {
    oe(e, a);
  } };
}
function Sce(t3) {
  let e;
  return { c() {
    e = we("Convert");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function Mce(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function a9(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[5]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 32 && Ze(n, r[5]);
  }, d(r) {
    r && D(e);
  } };
}
function o9(t3) {
  let e, n;
  return e = new et({ props: { label: t3[1] === "pem2der" ? "DER Output (Hex):" : "PEM Output:", value: t3[4], readonly: true, expandable: true, withCopy: true, rows: 6 } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, s) {
    const i = {};
    s & 2 && (i.label = r[1] === "pem2der" ? "DER Output (Hex):" : "PEM Output:"), s & 16 && (i.value = r[4]), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function $ce(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U;
  function Q(w) {
    t3[11](w);
  }
  let P = { label: "Mode:", options: t3[6] };
  t3[1] !== void 0 && (P.value = t3[1]), n = new Ht({ props: P }), Qe.push(() => ze(n, "value", Q));
  let N = t3[1] === "der2pem" && s9(t3);
  function L(w) {
    t3[13](w);
  }
  let B = { label: t3[1] === "pem2der" ? "Input PEM:" : "Input DER (Hex):", placeholder: t3[1] === "pem2der" ? "-----BEGIN CERTIFICATE-----..." : "e.g. 308201...", expandable: true, rows: 6 };
  t3[0] !== void 0 && (B.value = t3[0]), a = new et({ props: B }), Qe.push(() => ze(a, "value", L)), l = new ut({ props: { $$slots: { default: [Sce] }, $$scope: { ctx: t3 } } }), l.$on("click", t3[8]), m = new ut({ props: { variant: "secondary", $$slots: { default: [Mce] }, $$scope: { ctx: t3 } } }), m.$on("click", t3[14]), b = new hn({}), b.$on("click", t3[9]);
  function u(w) {
    t3[15](w);
  }
  let p = {};
  t3[3] !== void 0 && (p.checked = t3[3]), C = new xr({ props: p }), Qe.push(() => ze(C, "checked", u));
  let d = t3[5] && a9(t3), y = t3[4] && o9(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), N && N.c(), i = z(), fe(a.$$.fragment), f = z(), c = H("div"), fe(l.$$.fragment), h = z(), fe(m.$$.fragment), v = z(), fe(b.$$.fragment), A = z(), _ = H("div"), fe(C.$$.fragment), S = z(), d && d.c(), $ = z(), y && y.c(), F = Lt(), V(e, "class", "controls-row"), St(_, "margin-left", "auto"), V(c, "class", "button-row");
  }, m(w, E) {
    R(w, e, E), ae(n, e, null), q(e, s), N && N.m(e, null), R(w, i, E), ae(a, w, E), R(w, f, E), R(w, c, E), ae(l, c, null), q(c, h), ae(m, c, null), q(c, v), ae(b, c, null), q(c, A), q(c, _), ae(C, _, null), R(w, S, E), d && d.m(w, E), R(w, $, E), y && y.m(w, E), R(w, F, E), U = true;
  }, p(w, E) {
    const M = {};
    !r && E & 2 && (r = true, M.value = w[1], qe(() => r = false)), n.$set(M), w[1] === "der2pem" ? N ? (N.p(w, E), E & 2 && W(N, 1)) : (N = s9(w), N.c(), W(N, 1), N.m(e, null)) : N && (Xt(), j(N, 1, 1, () => {
      N = null;
    }), er());
    const x = {};
    E & 2 && (x.label = w[1] === "pem2der" ? "Input PEM:" : "Input DER (Hex):"), E & 2 && (x.placeholder = w[1] === "pem2der" ? "-----BEGIN CERTIFICATE-----..." : "e.g. 308201..."), !o && E & 1 && (o = true, x.value = w[0], qe(() => o = false)), a.$set(x);
    const g = {};
    E & 65536 && (g.$$scope = { dirty: E, ctx: w }), l.$set(g);
    const k = {};
    E & 65536 && (k.$$scope = { dirty: E, ctx: w }), m.$set(k);
    const T = {};
    !I && E & 8 && (I = true, T.checked = w[3], qe(() => I = false)), C.$set(T), w[5] ? d ? d.p(w, E) : (d = a9(w), d.c(), d.m($.parentNode, $)) : d && (d.d(1), d = null), w[4] ? y ? (y.p(w, E), E & 16 && W(y, 1)) : (y = o9(w), y.c(), W(y, 1), y.m(F.parentNode, F)) : y && (Xt(), j(y, 1, 1, () => {
      y = null;
    }), er());
  }, i(w) {
    U || (W(n.$$.fragment, w), W(N), W(a.$$.fragment, w), W(l.$$.fragment, w), W(m.$$.fragment, w), W(b.$$.fragment, w), W(C.$$.fragment, w), W(y), U = true);
  }, o(w) {
    j(n.$$.fragment, w), j(N), j(a.$$.fragment, w), j(l.$$.fragment, w), j(m.$$.fragment, w), j(b.$$.fragment, w), j(C.$$.fragment, w), j(y), U = false;
  }, d(w) {
    w && (D(e), D(i), D(f), D(c), D(S), D($), D(F)), oe(n), N && N.d(), oe(a, w), oe(l), oe(m), oe(b), oe(C), d && d.d(w), y && y.d(w);
  } };
}
function Tce(t3) {
  let e, n, r, s, i, a, o;
  return { c() {
    e = H("p"), e.innerHTML = `<strong>PEM (Privacy Enhanced Mail)</strong> is the most common format for certificates and keys. 
    It is essentially Base64 encoded data wrapped in header/footer lines.`, n = z(), r = H("p"), r.innerHTML = `<strong>DER (Distinguished Encoding Rules)</strong> is the binary version of that data. 
    It is what the computer actually uses to parse the ASN.1 structure of the certificate.`, s = z(), i = H("ul"), i.innerHTML = "<li><strong>PEM:</strong> Used by Apache, Nginx, and OpenSSL CLI.</li> <li><strong>DER:</strong> Used by Java and Windows internals.</li>", a = z(), o = H("p"), o.textContent = "Use this tool to convert a binary hex dump back into a usable certificate file, or to strip a certificate down to its raw hex bytes for analysis.";
  }, m(f, c) {
    R(f, e, c), R(f, n, c), R(f, r, c), R(f, s, c), R(f, i, c), R(f, a, c), R(f, o, c);
  }, p: dt, d(f) {
    f && (D(e), D(n), D(r), D(s), D(i), D(a), D(o));
  } };
}
function Dce(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "PEM / DER Converter", $$slots: { default: [$ce] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About PEM & DER", links: t3[10], $$slots: { default: [Tce] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 65599 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 65536 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function Rce(t3, e, n) {
  let r = "", s = "pem2der", i = "CERTIFICATE", a = "", o = "", f = true;
  const c = [{ value: "pem2der", label: "PEM to DER (Hex)" }, { value: "der2pem", label: "DER (Hex) to PEM" }], l = [{ value: "CERTIFICATE", label: "Certificate (X.509)" }, { value: "PUBLIC KEY", label: "Public Key" }, { value: "PRIVATE KEY", label: "Private Key" }, { value: "RSA PRIVATE KEY", label: "RSA Private Key" }, { value: "CERTIFICATE REQUEST", label: "CSR (Request)" }];
  function h() {
    if (!r) {
      n(4, a = ""), n(5, o = "");
      return;
    }
    n(5, o = "");
    try {
      n(4, a = Cce(r, s, i));
    } catch (S) {
      n(5, o = S.message), n(4, a = "");
    }
  }
  function m() {
    n(1, s = s === "pem2der" ? "der2pem" : "pem2der"), a && !o && n(0, r = a), h();
  }
  const v = [{ text: "PEM - Wikipedia", url: "https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail" }, { text: "DER - Wikipedia", url: "https://en.wikipedia.org/wiki/X.690#DER_encoding" }];
  function b(S) {
    s = S, n(1, s);
  }
  function A(S) {
    i = S, n(2, i);
  }
  function _(S) {
    r = S, n(0, r);
  }
  const C = () => {
    n(0, r = ""), n(4, a = "");
  };
  function I(S) {
    f = S, n(3, f);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 15 && f && (r || s || i) && h();
  }, [r, s, i, f, a, o, c, l, h, m, v, b, A, _, C, I];
}
class Fce extends xt {
  constructor(e) {
    super(), wt(this, e, Rce, Dce, At, {});
  }
}
function Pce(t3, e) {
  return t3 ? e === "human2unix" ? Nce(t3) : Uce(t3) : "";
}
function Nce(t3) {
  const e = new Date(t3);
  if (isNaN(e.getTime())) throw new Error("Invalid Date format.");
  return Math.floor(e.getTime() / 1e3).toString();
}
function Uce(t3) {
  const e = t3.trim();
  if (!/^-?\d+$/.test(e)) throw new Error("Invalid Timestamp. Must be an integer.");
  let n = Number(e), r = false;
  e.length > 11 ? r = true : n *= 1e3;
  const s = new Date(n), i = s.toUTCString(), a = s.toLocaleString();
  return `UTC:   ${i}
Local: ${a} ${r ? "(Input was Milliseconds)" : ""}`;
}
function Lce(t3) {
  let e;
  return { c() {
    e = we("Use Current Time");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function Oce(t3) {
  let e, n, r, s, i, a;
  return { c() {
    e = H("div"), n = H("label"), n.textContent = "Select Date & Time:", r = z(), s = H("input"), St(n, "display", "block"), St(n, "font-weight", "500"), St(n, "color", "#334155"), St(n, "margin-bottom", "0.5rem"), V(s, "type", "datetime-local"), St(s, "width", "100%"), St(s, "padding", "0.6rem"), St(s, "border", "1px solid #cbd5e1"), St(s, "border-radius", "6px"), St(e, "margin-bottom", "1rem");
  }, m(o, f) {
    R(o, e, f), q(e, n), q(e, r), q(e, s), yr(s, t3[0]), i || (a = [Kt(s, "input", t3[11]), Kt(s, "input", t3[12])], i = true);
  }, p(o, f) {
    f & 1 && yr(s, o[0]);
  }, i: dt, o: dt, d(o) {
    o && D(e), i = false, Mn(a);
  } };
}
function Qce(t3) {
  let e, n, r;
  function s(a) {
    t3[10](a);
  }
  let i = { label: "Unix Timestamp:", placeholder: "e.g. 1672531200", expandable: false };
  return t3[0] !== void 0 && (i.value = t3[0]), e = new et({ props: i }), Qe.push(() => ze(e, "value", s)), { c() {
    fe(e.$$.fragment);
  }, m(a, o) {
    ae(e, a, o), r = true;
  }, p(a, o) {
    const f = {};
    !n && o & 1 && (n = true, f.value = a[0], qe(() => n = false)), e.$set(f);
  }, i(a) {
    r || (W(e.$$.fragment, a), r = true);
  }, o(a) {
    j(e.$$.fragment, a), r = false;
  }, d(a) {
    oe(e, a);
  } };
}
function Kce(t3) {
  let e;
  return { c() {
    e = we("Convert");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function Hce(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function f9(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[4]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 16 && Ze(n, r[4]);
  }, d(r) {
    r && D(e);
  } };
}
function l9(t3) {
  let e, n;
  return e = new et({ props: { label: "Result:", value: t3[3], readonly: true, expandable: true, withCopy: true } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, s) {
    const i = {};
    s & 8 && (i.value = r[3]), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function qce(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U, Q, P;
  function N(M) {
    t3[9](M);
  }
  let L = { label: "Mode:", options: t3[5] };
  t3[1] !== void 0 && (L.value = t3[1]), n = new Ht({ props: L }), Qe.push(() => ze(n, "value", N)), a = new ut({ props: { variant: "secondary", $$slots: { default: [Lce] }, $$scope: { ctx: t3 } } }), a.$on("click", t3[7]);
  const B = [Qce, Oce], u = [];
  function p(M, x) {
    return M[1] === "unix2human" ? 0 : 1;
  }
  f = p(t3), c = u[f] = B[f](t3), m = new ut({ props: { $$slots: { default: [Kce] }, $$scope: { ctx: t3 } } }), m.$on("click", t3[6]), b = new ut({ props: { variant: "secondary", $$slots: { default: [Hce] }, $$scope: { ctx: t3 } } }), b.$on("click", t3[13]), _ = new hn({}), _.$on("click", t3[8]);
  function d(M) {
    t3[14](M);
  }
  let y = {};
  t3[2] !== void 0 && (y.checked = t3[2]), S = new xr({ props: y }), Qe.push(() => ze(S, "checked", d));
  let w = t3[4] && f9(t3), E = t3[3] && l9(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), i = H("div"), fe(a.$$.fragment), o = z(), c.c(), l = z(), h = H("div"), fe(m.$$.fragment), v = z(), fe(b.$$.fragment), A = z(), fe(_.$$.fragment), C = z(), I = H("div"), fe(S.$$.fragment), F = z(), w && w.c(), U = z(), E && E.c(), Q = Lt(), St(i, "align-self", "flex-end"), St(i, "margin-left", "auto"), St(i, "margin-bottom", "1rem"), V(e, "class", "controls-row"), St(I, "margin-left", "auto"), V(h, "class", "button-row");
  }, m(M, x) {
    R(M, e, x), ae(n, e, null), q(e, s), q(e, i), ae(a, i, null), R(M, o, x), u[f].m(M, x), R(M, l, x), R(M, h, x), ae(m, h, null), q(h, v), ae(b, h, null), q(h, A), ae(_, h, null), q(h, C), q(h, I), ae(S, I, null), R(M, F, x), w && w.m(M, x), R(M, U, x), E && E.m(M, x), R(M, Q, x), P = true;
  }, p(M, x) {
    const g = {};
    !r && x & 2 && (r = true, g.value = M[1], qe(() => r = false)), n.$set(g);
    const k = {};
    x & 32768 && (k.$$scope = { dirty: x, ctx: M }), a.$set(k);
    let T = f;
    f = p(M), f === T ? u[f].p(M, x) : (Xt(), j(u[T], 1, 1, () => {
      u[T] = null;
    }), er(), c = u[f], c ? c.p(M, x) : (c = u[f] = B[f](M), c.c()), W(c, 1), c.m(l.parentNode, l));
    const O = {};
    x & 32768 && (O.$$scope = { dirty: x, ctx: M }), m.$set(O);
    const K = {};
    x & 32768 && (K.$$scope = { dirty: x, ctx: M }), b.$set(K);
    const Y = {};
    !$ && x & 4 && ($ = true, Y.checked = M[2], qe(() => $ = false)), S.$set(Y), M[4] ? w ? w.p(M, x) : (w = f9(M), w.c(), w.m(U.parentNode, U)) : w && (w.d(1), w = null), M[3] ? E ? (E.p(M, x), x & 8 && W(E, 1)) : (E = l9(M), E.c(), W(E, 1), E.m(Q.parentNode, Q)) : E && (Xt(), j(E, 1, 1, () => {
      E = null;
    }), er());
  }, i(M) {
    P || (W(n.$$.fragment, M), W(a.$$.fragment, M), W(c), W(m.$$.fragment, M), W(b.$$.fragment, M), W(_.$$.fragment, M), W(S.$$.fragment, M), W(E), P = true);
  }, o(M) {
    j(n.$$.fragment, M), j(a.$$.fragment, M), j(c), j(m.$$.fragment, M), j(b.$$.fragment, M), j(_.$$.fragment, M), j(S.$$.fragment, M), j(E), P = false;
  }, d(M) {
    M && (D(e), D(o), D(l), D(h), D(F), D(U), D(Q)), oe(n), oe(a), u[f].d(M), oe(m), oe(b), oe(_), oe(S), w && w.d(M), E && E.d(M);
  } };
}
function zce(t3) {
  let e, n, r;
  return { c() {
    e = H("p"), e.innerHTML = `<strong>Unix Time</strong> (also known as POSIX time) is a system for describing a point in time. 
    It is defined as the number of seconds that have elapsed since <strong>00:00:00 UTC on 1 January 1970</strong> (the Unix Epoch), minus leap seconds.`, n = z(), r = H("p"), r.textContent = `It is widely used in operating systems and file formats because it represents time as a single simple integer, 
    making it easy to calculate time differences (just subtract one number from another).`;
  }, m(s, i) {
    R(s, e, i), R(s, n, i), R(s, r, i);
  }, p: dt, d(s) {
    s && (D(e), D(n), D(r));
  } };
}
function Gce(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Unix Time Converter", $$slots: { default: [qce] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Unix Time", links: [{ text: "Unix time - Wikipedia", url: "https://en.wikipedia.org/wiki/Unix_time" }], $$slots: { default: [zce] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 32799 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 32768 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function Vce(t3, e, n) {
  let r = "", s = "unix2human", i = "", a = "", o = true;
  const f = [{ value: "unix2human", label: "Unix Timestamp to Date" }, { value: "human2unix", label: "Date to Unix Timestamp" }];
  function c() {
    if (!r) {
      n(3, i = ""), n(4, a = "");
      return;
    }
    n(4, a = "");
    try {
      n(3, i = Pce(r, s));
    } catch (I) {
      n(4, a = I.message), n(3, i = "");
    }
  }
  function l() {
    if (s === "unix2human") n(0, r = Math.floor(Date.now() / 1e3).toString());
    else {
      const I = /* @__PURE__ */ new Date();
      I.setMinutes(I.getMinutes() - I.getTimezoneOffset()), n(0, r = I.toISOString().slice(0, 16));
    }
    o && c();
  }
  function h() {
    n(1, s = s === "unix2human" ? "human2unix" : "unix2human"), n(0, r = ""), n(3, i = "");
  }
  function m(I) {
    s = I, n(1, s);
  }
  function v(I) {
    r = I, n(0, r);
  }
  function b() {
    r = this.value, n(0, r);
  }
  const A = () => {
    o && c();
  }, _ = () => {
    n(0, r = ""), n(3, i = "");
  };
  function C(I) {
    o = I, n(2, o);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 7 && o && (r || s) && c();
  }, [r, s, o, i, a, f, c, l, h, m, v, b, A, _, C];
}
class Yce extends xt {
  constructor(e) {
    super(), wt(this, e, Vce, Gce, At, {});
  }
}
const Sb = { A: "Alfa", B: "Bravo", C: "Charlie", D: "Delta", E: "Echo", F: "Foxtrot", G: "Golf", H: "Hotel", I: "India", J: "Juliett", K: "Kilo", L: "Lima", M: "Mike", N: "November", O: "Oscar", P: "Papa", Q: "Quebec", R: "Romeo", S: "Sierra", T: "Tango", U: "Uniform", V: "Victor", W: "Whiskey", X: "X-ray", Y: "Yankee", Z: "Zulu", 0: "Zero", 1: "One", 2: "Two", 3: "Three", 4: "Four", 5: "Five", 6: "Six", 7: "Seven", 8: "Eight", 9: "Nine" }, u9 = Object.entries(Sb).reduce((t3, [e, n]) => (t3[n.toUpperCase()] = e, t3), {});
function Wce(t3, e) {
  return !t3 || !t3.trim() ? "" : e === "text2nato" ? Jce(t3) : Zce(t3);
}
function Jce(t3) {
  return Array.from(t3).map((r) => {
    const s = r.toUpperCase();
    return Sb[s] ? Sb[s] : /\s/.test(r) ? "(space)" : r;
  }).join(" ");
}
function Zce(t3) {
  return t3.trim().split(/\s+/).map((r) => {
    const s = r.toUpperCase();
    return s === "(SPACE)" ? " " : u9[s] ? u9[s] : (r.length === 1, r);
  }).join("");
}
function jce(t3) {
  let e;
  return { c() {
    e = we("Convert");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function Xce(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function c9(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[4]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 16 && Ze(n, r[4]);
  }, d(r) {
    r && D(e);
  } };
}
function h9(t3) {
  let e, n;
  return e = new et({ props: { label: t3[1] === "text2nato" ? "NATO Output:" : "Text Output:", value: t3[3], readonly: true, expandable: true, withCopy: true } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, s) {
    const i = {};
    s & 2 && (i.label = r[1] === "text2nato" ? "NATO Output:" : "Text Output:"), s & 8 && (i.value = r[3]), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function ehe(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F;
  function U(d) {
    t3[8](d);
  }
  let Q = { label: "Mode:", options: t3[5] };
  t3[1] !== void 0 && (Q.value = t3[1]), n = new Ht({ props: Q }), Qe.push(() => ze(n, "value", U));
  function P(d) {
    t3[9](d);
  }
  let N = { label: t3[1] === "text2nato" ? "Input Text:" : "Input NATO Code:", placeholder: t3[1] === "text2nato" ? "Type text..." : "e.g. Alfa Bravo Charlie", expandable: true };
  t3[0] !== void 0 && (N.value = t3[0]), i = new et({ props: N }), Qe.push(() => ze(i, "value", P)), c = new ut({ props: { $$slots: { default: [jce] }, $$scope: { ctx: t3 } } }), c.$on("click", t3[6]), h = new ut({ props: { variant: "secondary", $$slots: { default: [Xce] }, $$scope: { ctx: t3 } } }), h.$on("click", t3[10]), v = new hn({}), v.$on("click", t3[7]);
  function L(d) {
    t3[11](d);
  }
  let B = {};
  t3[2] !== void 0 && (B.checked = t3[2]), _ = new xr({ props: B }), Qe.push(() => ze(_, "checked", L));
  let u = t3[4] && c9(t3), p = t3[3] && h9(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), fe(i.$$.fragment), o = z(), f = H("div"), fe(c.$$.fragment), l = z(), fe(h.$$.fragment), m = z(), fe(v.$$.fragment), b = z(), A = H("div"), fe(_.$$.fragment), I = z(), u && u.c(), S = z(), p && p.c(), $ = Lt(), V(e, "class", "controls-row"), St(A, "margin-left", "auto"), V(f, "class", "button-row");
  }, m(d, y) {
    R(d, e, y), ae(n, e, null), R(d, s, y), ae(i, d, y), R(d, o, y), R(d, f, y), ae(c, f, null), q(f, l), ae(h, f, null), q(f, m), ae(v, f, null), q(f, b), q(f, A), ae(_, A, null), R(d, I, y), u && u.m(d, y), R(d, S, y), p && p.m(d, y), R(d, $, y), F = true;
  }, p(d, y) {
    const w = {};
    !r && y & 2 && (r = true, w.value = d[1], qe(() => r = false)), n.$set(w);
    const E = {};
    y & 2 && (E.label = d[1] === "text2nato" ? "Input Text:" : "Input NATO Code:"), y & 2 && (E.placeholder = d[1] === "text2nato" ? "Type text..." : "e.g. Alfa Bravo Charlie"), !a && y & 1 && (a = true, E.value = d[0], qe(() => a = false)), i.$set(E);
    const M = {};
    y & 4096 && (M.$$scope = { dirty: y, ctx: d }), c.$set(M);
    const x = {};
    y & 4096 && (x.$$scope = { dirty: y, ctx: d }), h.$set(x);
    const g = {};
    !C && y & 4 && (C = true, g.checked = d[2], qe(() => C = false)), _.$set(g), d[4] ? u ? u.p(d, y) : (u = c9(d), u.c(), u.m(S.parentNode, S)) : u && (u.d(1), u = null), d[3] ? p ? (p.p(d, y), y & 8 && W(p, 1)) : (p = h9(d), p.c(), W(p, 1), p.m($.parentNode, $)) : p && (Xt(), j(p, 1, 1, () => {
      p = null;
    }), er());
  }, i(d) {
    F || (W(n.$$.fragment, d), W(i.$$.fragment, d), W(c.$$.fragment, d), W(h.$$.fragment, d), W(v.$$.fragment, d), W(_.$$.fragment, d), W(p), F = true);
  }, o(d) {
    j(n.$$.fragment, d), j(i.$$.fragment, d), j(c.$$.fragment, d), j(h.$$.fragment, d), j(v.$$.fragment, d), j(_.$$.fragment, d), j(p), F = false;
  }, d(d) {
    d && (D(e), D(s), D(o), D(f), D(I), D(S), D($)), oe(n), oe(i, d), oe(c), oe(h), oe(v), oe(_), u && u.d(d), p && p.d(d);
  } };
}
function the(t3) {
  let e, n, r, s, i, a, o;
  return { c() {
    e = H("p"), e.innerHTML = "The <strong>NATO Phonetic Alphabet</strong> (officially the International Radiotelephony Spelling Alphabet) assigns a code word to each letter of the alphabet.", n = z(), r = H("p"), r.textContent = "It is designed to prevent confusion during voice communication, where letters like 'B', 'D', 'P', and 'T' can sound identical over noisy radio channels.", s = z(), i = H("ul"), i.innerHTML = "<li><strong>A</strong> to Alfa</li> <li><strong>B</strong> to Bravo</li> <li><strong>C</strong> to Charlie</li>", a = z(), o = H("p"), o.textContent = `This tool uses the official ICAO standard spellings (note "Alfa" with an 'f' and "Juliett" with two 't's), which ensure consistent pronunciation across different native languages.`;
  }, m(f, c) {
    R(f, e, c), R(f, n, c), R(f, r, c), R(f, s, c), R(f, i, c), R(f, a, c), R(f, o, c);
  }, p: dt, d(f) {
    f && (D(e), D(n), D(r), D(s), D(i), D(a), D(o));
  } };
}
function rhe(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "NATO Phonetic Converter", $$slots: { default: [ehe] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About NATO Phonetic Alphabet", links: [{ text: "NATO Phonetic Alphabet - Wikipedia", url: "https://en.wikipedia.org/wiki/NATO_phonetic_alphabet" }], $$slots: { default: [the] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 4127 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 4096 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function nhe(t3, e, n) {
  let r = "", s = "text2nato", i = "", a = "", o = true;
  const f = [{ value: "text2nato", label: "Text to NATO" }, { value: "nato2text", label: "NATO to Text" }];
  function c() {
    if (!r) {
      n(3, i = ""), n(4, a = "");
      return;
    }
    n(4, a = "");
    try {
      n(3, i = Wce(r, s));
    } catch (A) {
      n(4, a = A.message), n(3, i = "");
    }
  }
  function l() {
    n(1, s = s === "text2nato" ? "nato2text" : "text2nato"), i && !a && n(0, r = i), c();
  }
  function h(A) {
    s = A, n(1, s);
  }
  function m(A) {
    r = A, n(0, r);
  }
  const v = () => {
    n(0, r = ""), n(3, i = "");
  };
  function b(A) {
    o = A, n(2, o);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 7 && o && (r || s) && c();
  }, [r, s, o, i, a, f, c, l, h, m, v, b];
}
class ihe extends xt {
  constructor(e) {
    super(), wt(this, e, nhe, rhe, At, {});
  }
}
function d9(t3, e = 16, n = "utf-8") {
  if (!t3) return "";
  let r;
  if (t3 instanceof Uint8Array) r = t3;
  else try {
    r = ps(t3, n);
  } catch (a) {
    throw new Error(a.message);
  }
  const s = [], i = e * 3 - 1;
  for (let a = 0; a < r.length; a += e) {
    const o = r.slice(a, a + e), c = Array.from(o).map((m) => m.toString(16).padStart(2, "0")).join(" ").padEnd(i, " "), l = Array.from(o).map((m) => m >= 32 && m <= 126 ? String.fromCharCode(m) : ".").join(""), h = a.toString(16).padStart(8, "0");
    s.push(`${h}  ${c}  |${l}|`);
  }
  return s.join(`
`);
}
function she(t3) {
  let e;
  return { c() {
    e = we("Generate Dump");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function ahe(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function p9(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[5]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 32 && Ze(n, r[5]);
  }, d(r) {
    r && D(e);
  } };
}
function g9(t3) {
  let e, n;
  return e = new et({ props: { label: "Hexdump Output:", value: t3[4], readonly: true, expandable: true, withCopy: true, rows: 10, monospace: true } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, s) {
    const i = {};
    s & 16 && (i.value = r[4]), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function ohe(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U, Q, P, N, L, B, u, p;
  function d(K) {
    t3[10](K);
  }
  let y = { label: "Input Encoding:", options: gs.map(uhe) };
  t3[1] !== void 0 && (y.value = t3[1]), n = new Ht({ props: y }), Qe.push(() => ze(n, "value", d));
  function w(K) {
    t3[11](K);
  }
  let E = { label: "Width:", options: t3[7] };
  t3[2] !== void 0 && (E.value = t3[2]), i = new Ht({ props: E }), Qe.push(() => ze(i, "value", w));
  function M(K) {
    t3[12](K);
  }
  let x = { label: "Input Data:", placeholder: "Type text here...", expandable: true };
  t3[0] !== void 0 && (x.value = t3[0]), f = new et({ props: x }), Qe.push(() => ze(f, "value", M)), C = new ut({ props: { $$slots: { default: [she] }, $$scope: { ctx: t3 } } }), C.$on("click", t3[8]), S = new ut({ props: { variant: "secondary", $$slots: { default: [ahe] }, $$scope: { ctx: t3 } } }), S.$on("click", t3[14]);
  function g(K) {
    t3[15](K);
  }
  let k = {};
  t3[3] !== void 0 && (k.checked = t3[3]), U = new xr({ props: k }), Qe.push(() => ze(U, "checked", g));
  let T = t3[5] && p9(t3), O = t3[4] && g9(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), fe(i.$$.fragment), o = z(), fe(f.$$.fragment), l = z(), h = H("div"), m = H("label"), m.textContent = "Or upload a binary file:", v = z(), b = H("input"), A = z(), _ = H("div"), fe(C.$$.fragment), I = z(), fe(S.$$.fragment), $ = z(), F = H("div"), fe(U.$$.fragment), P = z(), T && T.c(), N = z(), O && O.c(), L = Lt(), V(e, "class", "controls-row"), St(m, "font-size", "0.9rem"), St(m, "font-weight", "500"), St(m, "color", "#334155"), V(b, "type", "file"), St(b, "margin-top", "0.3rem"), St(h, "margin-top", "0.5rem"), St(h, "margin-bottom", "1rem"), St(F, "margin-left", "auto"), V(_, "class", "button-row");
  }, m(K, Y) {
    R(K, e, Y), ae(n, e, null), q(e, s), ae(i, e, null), R(K, o, Y), ae(f, K, Y), R(K, l, Y), R(K, h, Y), q(h, m), q(h, v), q(h, b), t3[13](b), R(K, A, Y), R(K, _, Y), ae(C, _, null), q(_, I), ae(S, _, null), q(_, $), q(_, F), ae(U, F, null), R(K, P, Y), T && T.m(K, Y), R(K, N, Y), O && O.m(K, Y), R(K, L, Y), B = true, u || (p = Kt(b, "change", t3[9]), u = true);
  }, p(K, Y) {
    const J = {};
    !r && Y & 2 && (r = true, J.value = K[1], qe(() => r = false)), n.$set(J);
    const G = {};
    !a && Y & 4 && (a = true, G.value = K[2], qe(() => a = false)), i.$set(G);
    const X = {};
    !c && Y & 1 && (c = true, X.value = K[0], qe(() => c = false)), f.$set(X);
    const ie = {};
    Y & 65536 && (ie.$$scope = { dirty: Y, ctx: K }), C.$set(ie);
    const de = {};
    Y & 65536 && (de.$$scope = { dirty: Y, ctx: K }), S.$set(de);
    const se = {};
    !Q && Y & 8 && (Q = true, se.checked = K[3], qe(() => Q = false)), U.$set(se), K[5] ? T ? T.p(K, Y) : (T = p9(K), T.c(), T.m(N.parentNode, N)) : T && (T.d(1), T = null), K[4] ? O ? (O.p(K, Y), Y & 16 && W(O, 1)) : (O = g9(K), O.c(), W(O, 1), O.m(L.parentNode, L)) : O && (Xt(), j(O, 1, 1, () => {
      O = null;
    }), er());
  }, i(K) {
    B || (W(n.$$.fragment, K), W(i.$$.fragment, K), W(f.$$.fragment, K), W(C.$$.fragment, K), W(S.$$.fragment, K), W(U.$$.fragment, K), W(O), B = true);
  }, o(K) {
    j(n.$$.fragment, K), j(i.$$.fragment, K), j(f.$$.fragment, K), j(C.$$.fragment, K), j(S.$$.fragment, K), j(U.$$.fragment, K), j(O), B = false;
  }, d(K) {
    K && (D(e), D(o), D(l), D(h), D(A), D(_), D(P), D(N), D(L)), oe(n), oe(i), oe(f, K), t3[13](null), oe(C), oe(S), oe(U), T && T.d(K), O && O.d(K), u = false, p();
  } };
}
function fhe(t3) {
  let e, n, r, s, i, a, o;
  return { c() {
    e = H("p"), e.innerHTML = "A <strong>Hexdump</strong> provides a view of data that is useful for debugging and reverse engineering.", n = z(), r = H("p"), r.textContent = "It consists of three columns:", s = z(), i = H("ol"), i.innerHTML = "<li><strong>Offset:</strong> The memory address or file position (in Hex).</li> <li><strong>Hex:</strong> The actual byte values.</li> <li><strong>ASCII:</strong> The text representation. Non-printable characters (like null bytes or newlines) are replaced with a dot (<code>.</code>).</li>", a = z(), o = H("p"), o.textContent = "This format allows you to see the structure of binary files (like PNG headers) or find hidden strings inside compiled programs.";
  }, m(f, c) {
    R(f, e, c), R(f, n, c), R(f, r, c), R(f, s, c), R(f, i, c), R(f, a, c), R(f, o, c);
  }, p: dt, d(f) {
    f && (D(e), D(n), D(r), D(s), D(i), D(a), D(o));
  } };
}
function lhe(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Hexdump Generator", $$slots: { default: [ohe] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Hexdumps", links: [{ text: "Hexdump - Wikipedia", url: "https://en.wikipedia.org/wiki/Hexdump" }], $$slots: { default: [fhe] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 65663 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 65536 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
const uhe = (t3) => t3.value;
function che(t3, e, n) {
  let r = "", s = "utf-8", i = 16, a = "", o = "", f = true, c;
  const l = [{ value: 8, label: "8 Bytes per line" }, { value: 16, label: "16 Bytes per line" }, { value: 32, label: "32 Bytes per line" }];
  function h() {
    if (!r) {
      n(4, a = ""), n(5, o = "");
      return;
    }
    n(5, o = "");
    try {
      n(4, a = d9(r, i, s));
    } catch (S) {
      n(5, o = S.message), n(4, a = "");
    }
  }
  function m(S) {
    const $ = S.target.files[0];
    if (!$) return;
    const F = new FileReader();
    F.onload = (U) => {
      const Q = U.target.result, P = new Uint8Array(Q);
      try {
        n(4, a = d9(P, i)), n(0, r = `[Binary File Loaded: ${$.name} (${$.size} bytes)]`);
      } catch (N) {
        n(5, o = N.message);
      }
    }, F.readAsArrayBuffer($);
  }
  function v(S) {
    s = S, n(1, s);
  }
  function b(S) {
    i = S, n(2, i);
  }
  function A(S) {
    r = S, n(0, r);
  }
  function _(S) {
    Qe[S ? "unshift" : "push"](() => {
      c = S, n(6, c);
    });
  }
  const C = () => {
    n(0, r = ""), n(4, a = ""), c && n(6, c.value = "", c);
  };
  function I(S) {
    f = S, n(3, f);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 15 && f && r && !r.startsWith("[Binary") && (s || i) && h();
  }, [r, s, i, f, a, o, c, l, h, m, v, b, A, _, C, I];
}
class hhe extends xt {
  constructor(e) {
    super(), wt(this, e, che, lhe, At, {});
  }
}
var yF = { exports: {} };
/* @license
Papa Parse
v5.5.3
https://github.com/mholt/PapaParse
License: MIT
*/
(function(t3, e) {
  ((n, r) => {
    t3.exports = r();
  })(mt, function n() {
    var r = typeof self < "u" ? self : typeof window < "u" ? window : r !== void 0 ? r : {}, s, i = !r.document && !!r.postMessage, a = r.IS_PAPA_WORKER || false, o = {}, f = 0, c = {};
    function l(P) {
      this._handle = null, this._finished = false, this._completed = false, this._halted = false, this._input = null, this._baseIndex = 0, this._partialLine = "", this._rowCount = 0, this._start = 0, this._nextChunk = null, this.isFirstChunk = true, this._completeResults = { data: [], errors: [], meta: {} }, (function(N) {
        var L = F(N);
        L.chunkSize = parseInt(L.chunkSize), N.step || N.chunk || (L.chunkSize = null), this._handle = new A(L), (this._handle.streamer = this)._config = L;
      }).call(this, P), this.parseChunk = function(N, L) {
        var B = parseInt(this._config.skipFirstNLines) || 0;
        if (this.isFirstChunk && 0 < B) {
          let p = this._config.newline;
          p || (u = this._config.quoteChar || '"', p = this._handle.guessLineEndings(N, u)), N = [...N.split(p).slice(B)].join(p);
        }
        this.isFirstChunk && Q(this._config.beforeFirstChunk) && (u = this._config.beforeFirstChunk(N)) !== void 0 && (N = u), this.isFirstChunk = false, this._halted = false;
        var B = this._partialLine + N, u = (this._partialLine = "", this._handle.parse(B, this._baseIndex, !this._finished));
        if (!this._handle.paused() && !this._handle.aborted()) {
          if (N = u.meta.cursor, B = (this._finished || (this._partialLine = B.substring(N - this._baseIndex), this._baseIndex = N), u && u.data && (this._rowCount += u.data.length), this._finished || this._config.preview && this._rowCount >= this._config.preview), a) r.postMessage({ results: u, workerId: c.WORKER_ID, finished: B });
          else if (Q(this._config.chunk) && !L) {
            if (this._config.chunk(u, this._handle), this._handle.paused() || this._handle.aborted()) return void (this._halted = true);
            this._completeResults = u = void 0;
          }
          return this._config.step || this._config.chunk || (this._completeResults.data = this._completeResults.data.concat(u.data), this._completeResults.errors = this._completeResults.errors.concat(u.errors), this._completeResults.meta = u.meta), this._completed || !B || !Q(this._config.complete) || u && u.meta.aborted || (this._config.complete(this._completeResults, this._input), this._completed = true), B || u && u.meta.paused || this._nextChunk(), u;
        }
        this._halted = true;
      }, this._sendError = function(N) {
        Q(this._config.error) ? this._config.error(N) : a && this._config.error && r.postMessage({ workerId: c.WORKER_ID, error: N, finished: false });
      };
    }
    function h(P) {
      var N;
      (P = P || {}).chunkSize || (P.chunkSize = c.RemoteChunkSize), l.call(this, P), this._nextChunk = i ? function() {
        this._readChunk(), this._chunkLoaded();
      } : function() {
        this._readChunk();
      }, this.stream = function(L) {
        this._input = L, this._nextChunk();
      }, this._readChunk = function() {
        if (this._finished) this._chunkLoaded();
        else {
          if (N = new XMLHttpRequest(), this._config.withCredentials && (N.withCredentials = this._config.withCredentials), i || (N.onload = U(this._chunkLoaded, this), N.onerror = U(this._chunkError, this)), N.open(this._config.downloadRequestBody ? "POST" : "GET", this._input, !i), this._config.downloadRequestHeaders) {
            var L, B = this._config.downloadRequestHeaders;
            for (L in B) N.setRequestHeader(L, B[L]);
          }
          var u;
          this._config.chunkSize && (u = this._start + this._config.chunkSize - 1, N.setRequestHeader("Range", "bytes=" + this._start + "-" + u));
          try {
            N.send(this._config.downloadRequestBody);
          } catch (p) {
            this._chunkError(p.message);
          }
          i && N.status === 0 && this._chunkError();
        }
      }, this._chunkLoaded = function() {
        N.readyState === 4 && (N.status < 200 || 400 <= N.status ? this._chunkError() : (this._start += this._config.chunkSize || N.responseText.length, this._finished = !this._config.chunkSize || this._start >= ((L) => (L = L.getResponseHeader("Content-Range")) !== null ? parseInt(L.substring(L.lastIndexOf("/") + 1)) : -1)(N), this.parseChunk(N.responseText)));
      }, this._chunkError = function(L) {
        L = N.statusText || L, this._sendError(new Error(L));
      };
    }
    function m(P) {
      (P = P || {}).chunkSize || (P.chunkSize = c.LocalChunkSize), l.call(this, P);
      var N, L, B = typeof FileReader < "u";
      this.stream = function(u) {
        this._input = u, L = u.slice || u.webkitSlice || u.mozSlice, B ? ((N = new FileReader()).onload = U(this._chunkLoaded, this), N.onerror = U(this._chunkError, this)) : N = new FileReaderSync(), this._nextChunk();
      }, this._nextChunk = function() {
        this._finished || this._config.preview && !(this._rowCount < this._config.preview) || this._readChunk();
      }, this._readChunk = function() {
        var u = this._input, p = (this._config.chunkSize && (p = Math.min(this._start + this._config.chunkSize, this._input.size), u = L.call(u, this._start, p)), N.readAsText(u, this._config.encoding));
        B || this._chunkLoaded({ target: { result: p } });
      }, this._chunkLoaded = function(u) {
        this._start += this._config.chunkSize, this._finished = !this._config.chunkSize || this._start >= this._input.size, this.parseChunk(u.target.result);
      }, this._chunkError = function() {
        this._sendError(N.error);
      };
    }
    function v(P) {
      var N;
      l.call(this, P = P || {}), this.stream = function(L) {
        return N = L, this._nextChunk();
      }, this._nextChunk = function() {
        var L, B;
        if (!this._finished) return L = this._config.chunkSize, N = L ? (B = N.substring(0, L), N.substring(L)) : (B = N, ""), this._finished = !N, this.parseChunk(B);
      };
    }
    function b(P) {
      l.call(this, P = P || {});
      var N = [], L = true, B = false;
      this.pause = function() {
        l.prototype.pause.apply(this, arguments), this._input.pause();
      }, this.resume = function() {
        l.prototype.resume.apply(this, arguments), this._input.resume();
      }, this.stream = function(u) {
        this._input = u, this._input.on("data", this._streamData), this._input.on("end", this._streamEnd), this._input.on("error", this._streamError);
      }, this._checkIsFinished = function() {
        B && N.length === 1 && (this._finished = true);
      }, this._nextChunk = function() {
        this._checkIsFinished(), N.length ? this.parseChunk(N.shift()) : L = true;
      }, this._streamData = U(function(u) {
        try {
          N.push(typeof u == "string" ? u : u.toString(this._config.encoding)), L && (L = false, this._checkIsFinished(), this.parseChunk(N.shift()));
        } catch (p) {
          this._streamError(p);
        }
      }, this), this._streamError = U(function(u) {
        this._streamCleanUp(), this._sendError(u);
      }, this), this._streamEnd = U(function() {
        this._streamCleanUp(), B = true, this._streamData("");
      }, this), this._streamCleanUp = U(function() {
        this._input.removeListener("data", this._streamData), this._input.removeListener("end", this._streamEnd), this._input.removeListener("error", this._streamError);
      }, this);
    }
    function A(P) {
      var N, L, B, u, p = Math.pow(2, 53), d = -p, y = /^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/, w = /^((\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z)))$/, E = this, M = 0, x = 0, g = false, k = false, T = [], O = { data: [], errors: [], meta: {} };
      function K(X) {
        return P.skipEmptyLines === "greedy" ? X.join("").trim() === "" : X.length === 1 && X[0].length === 0;
      }
      function Y() {
        if (O && B && (G("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + c.DefaultDelimiter + "'"), B = false), P.skipEmptyLines && (O.data = O.data.filter(function(se) {
          return !K(se);
        })), J()) {
          let se = function(te, le) {
            Q(P.transformHeader) && (te = P.transformHeader(te, le)), T.push(te);
          };
          if (O) if (Array.isArray(O.data[0])) {
            for (var X = 0; J() && X < O.data.length; X++) O.data[X].forEach(se);
            O.data.splice(0, 1);
          } else O.data.forEach(se);
        }
        function ie(se, te) {
          for (var le = P.header ? {} : [], Z = 0; Z < se.length; Z++) {
            var ve = Z, he = se[Z], he = ((me, ce) => ((ye) => (P.dynamicTypingFunction && P.dynamicTyping[ye] === void 0 && (P.dynamicTyping[ye] = P.dynamicTypingFunction(ye)), (P.dynamicTyping[ye] || P.dynamicTyping) === true))(me) ? ce === "true" || ce === "TRUE" || ce !== "false" && ce !== "FALSE" && (((ye) => {
              if (y.test(ye) && (ye = parseFloat(ye), d < ye && ye < p)) return 1;
            })(ce) ? parseFloat(ce) : w.test(ce) ? new Date(ce) : ce === "" ? null : ce) : ce)(ve = P.header ? Z >= T.length ? "__parsed_extra" : T[Z] : ve, he = P.transform ? P.transform(he, ve) : he);
            ve === "__parsed_extra" ? (le[ve] = le[ve] || [], le[ve].push(he)) : le[ve] = he;
          }
          return P.header && (Z > T.length ? G("FieldMismatch", "TooManyFields", "Too many fields: expected " + T.length + " fields but parsed " + Z, x + te) : Z < T.length && G("FieldMismatch", "TooFewFields", "Too few fields: expected " + T.length + " fields but parsed " + Z, x + te)), le;
        }
        var de;
        O && (P.header || P.dynamicTyping || P.transform) && (de = 1, !O.data.length || Array.isArray(O.data[0]) ? (O.data = O.data.map(ie), de = O.data.length) : O.data = ie(O.data, 0), P.header && O.meta && (O.meta.fields = T), x += de);
      }
      function J() {
        return P.header && T.length === 0;
      }
      function G(X, ie, de, se) {
        X = { type: X, code: ie, message: de }, se !== void 0 && (X.row = se), O.errors.push(X);
      }
      Q(P.step) && (u = P.step, P.step = function(X) {
        O = X, J() ? Y() : (Y(), O.data.length !== 0 && (M += X.data.length, P.preview && M > P.preview ? L.abort() : (O.data = O.data[0], u(O, E))));
      }), this.parse = function(X, ie, de) {
        var se = P.quoteChar || '"', se = (P.newline || (P.newline = this.guessLineEndings(X, se)), B = false, P.delimiter ? Q(P.delimiter) && (P.delimiter = P.delimiter(X), O.meta.delimiter = P.delimiter) : ((se = ((te, le, Z, ve, he) => {
          var me, ce, ye, Oe;
          he = he || [",", "	", "|", ";", c.RECORD_SEP, c.UNIT_SEP];
          for (var Se = 0; Se < he.length; Se++) {
            for (var Ce, Ne = he[Se], $e = 0, Re = 0, Ge = 0, Fe = (ye = void 0, new C({ comments: ve, delimiter: Ne, newline: le, preview: 10 }).parse(te)), Ue = 0; Ue < Fe.data.length; Ue++) Z && K(Fe.data[Ue]) ? Ge++ : (Ce = Fe.data[Ue].length, Re += Ce, ye === void 0 ? ye = Ce : 0 < Ce && ($e += Math.abs(Ce - ye), ye = Ce));
            0 < Fe.data.length && (Re /= Fe.data.length - Ge), (ce === void 0 || $e <= ce) && (Oe === void 0 || Oe < Re) && 1.99 < Re && (ce = $e, me = Ne, Oe = Re);
          }
          return { successful: !!(P.delimiter = me), bestDelimiter: me };
        })(X, P.newline, P.skipEmptyLines, P.comments, P.delimitersToGuess)).successful ? P.delimiter = se.bestDelimiter : (B = true, P.delimiter = c.DefaultDelimiter), O.meta.delimiter = P.delimiter), F(P));
        return P.preview && P.header && se.preview++, N = X, L = new C(se), O = L.parse(N, ie, de), Y(), g ? { meta: { paused: true } } : O || { meta: { paused: false } };
      }, this.paused = function() {
        return g;
      }, this.pause = function() {
        g = true, L.abort(), N = Q(P.chunk) ? "" : N.substring(L.getCharIndex());
      }, this.resume = function() {
        E.streamer._halted ? (g = false, E.streamer.parseChunk(N, true)) : setTimeout(E.resume, 3);
      }, this.aborted = function() {
        return k;
      }, this.abort = function() {
        k = true, L.abort(), O.meta.aborted = true, Q(P.complete) && P.complete(O), N = "";
      }, this.guessLineEndings = function(te, se) {
        te = te.substring(0, 1048576);
        var se = new RegExp(_(se) + "([^]*?)" + _(se), "gm"), de = (te = te.replace(se, "")).split("\r"), se = te.split(`
`), te = 1 < se.length && se[0].length < de[0].length;
        if (de.length === 1 || te) return `
`;
        for (var le = 0, Z = 0; Z < de.length; Z++) de[Z][0] === `
` && le++;
        return le >= de.length / 2 ? `\r
` : "\r";
      };
    }
    function _(P) {
      return P.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function C(P) {
      var N = (P = P || {}).delimiter, L = P.newline, B = P.comments, u = P.step, p = P.preview, d = P.fastMode, y = null, w = false, E = P.quoteChar == null ? '"' : P.quoteChar, M = E;
      if (P.escapeChar !== void 0 && (M = P.escapeChar), (typeof N != "string" || -1 < c.BAD_DELIMITERS.indexOf(N)) && (N = ","), B === N) throw new Error("Comment character same as delimiter");
      B === true ? B = "#" : (typeof B != "string" || -1 < c.BAD_DELIMITERS.indexOf(B)) && (B = false), L !== `
` && L !== "\r" && L !== `\r
` && (L = `
`);
      var x = 0, g = false;
      this.parse = function(k, T, O) {
        if (typeof k != "string") throw new Error("Input must be a string");
        var K = k.length, Y = N.length, J = L.length, G = B.length, X = Q(u), ie = [], de = [], se = [], te = x = 0;
        if (!k) return $e();
        if (d || d !== false && k.indexOf(E) === -1) {
          for (var le = k.split(L), Z = 0; Z < le.length; Z++) {
            if (se = le[Z], x += se.length, Z !== le.length - 1) x += L.length;
            else if (O) return $e();
            if (!B || se.substring(0, G) !== B) {
              if (X) {
                if (ie = [], Oe(se.split(N)), Re(), g) return $e();
              } else Oe(se.split(N));
              if (p && p <= Z) return ie = ie.slice(0, p), $e(true);
            }
          }
          return $e();
        }
        for (var ve = k.indexOf(N, x), he = k.indexOf(L, x), me = new RegExp(_(M) + _(E), "g"), ce = k.indexOf(E, x); ; ) if (k[x] === E) for (ce = x, x++; ; ) {
          if ((ce = k.indexOf(E, ce + 1)) === -1) return O || de.push({ type: "Quotes", code: "MissingQuotes", message: "Quoted field unterminated", row: ie.length, index: x }), Ce();
          if (ce === K - 1) return Ce(k.substring(x, ce).replace(me, E));
          if (E === M && k[ce + 1] === M) ce++;
          else if (E === M || ce === 0 || k[ce - 1] !== M) {
            ve !== -1 && ve < ce + 1 && (ve = k.indexOf(N, ce + 1));
            var ye = Se((he = he !== -1 && he < ce + 1 ? k.indexOf(L, ce + 1) : he) === -1 ? ve : Math.min(ve, he));
            if (k.substr(ce + 1 + ye, Y) === N) {
              se.push(k.substring(x, ce).replace(me, E)), k[x = ce + 1 + ye + Y] !== E && (ce = k.indexOf(E, x)), ve = k.indexOf(N, x), he = k.indexOf(L, x);
              break;
            }
            if (ye = Se(he), k.substring(ce + 1 + ye, ce + 1 + ye + J) === L) {
              if (se.push(k.substring(x, ce).replace(me, E)), Ne(ce + 1 + ye + J), ve = k.indexOf(N, x), ce = k.indexOf(E, x), X && (Re(), g)) return $e();
              if (p && ie.length >= p) return $e(true);
              break;
            }
            de.push({ type: "Quotes", code: "InvalidQuotes", message: "Trailing quote on quoted field is malformed", row: ie.length, index: x }), ce++;
          }
        }
        else if (B && se.length === 0 && k.substring(x, x + G) === B) {
          if (he === -1) return $e();
          x = he + J, he = k.indexOf(L, x), ve = k.indexOf(N, x);
        } else if (ve !== -1 && (ve < he || he === -1)) se.push(k.substring(x, ve)), x = ve + Y, ve = k.indexOf(N, x);
        else {
          if (he === -1) break;
          if (se.push(k.substring(x, he)), Ne(he + J), X && (Re(), g)) return $e();
          if (p && ie.length >= p) return $e(true);
        }
        return Ce();
        function Oe(Ge) {
          ie.push(Ge), te = x;
        }
        function Se(Ge) {
          var Fe = 0;
          return Fe = Ge !== -1 && (Ge = k.substring(ce + 1, Ge)) && Ge.trim() === "" ? Ge.length : Fe;
        }
        function Ce(Ge) {
          return O || (Ge === void 0 && (Ge = k.substring(x)), se.push(Ge), x = K, Oe(se), X && Re()), $e();
        }
        function Ne(Ge) {
          x = Ge, Oe(se), se = [], he = k.indexOf(L, x);
        }
        function $e(Ge) {
          if (P.header && !T && ie.length && !w) {
            var Fe = ie[0], Ue = /* @__PURE__ */ Object.create(null), kt = new Set(Fe);
            let pe = false;
            for (let re = 0; re < Fe.length; re++) {
              let ue = Fe[re];
              if (Ue[ue = Q(P.transformHeader) ? P.transformHeader(ue, re) : ue]) {
                let xe, Me = Ue[ue];
                for (; xe = ue + "_" + Me, Me++, kt.has(xe); ) ;
                kt.add(xe), Fe[re] = xe, Ue[ue]++, pe = true, (y = y === null ? {} : y)[xe] = ue;
              } else Ue[ue] = 1, Fe[re] = ue;
              kt.add(ue);
            }
            pe && console.warn("Duplicate headers found and renamed."), w = true;
          }
          return { data: ie, errors: de, meta: { delimiter: N, linebreak: L, aborted: g, truncated: !!Ge, cursor: te + (T || 0), renamedHeaders: y } };
        }
        function Re() {
          u($e()), ie = [], de = [];
        }
      }, this.abort = function() {
        g = true;
      }, this.getCharIndex = function() {
        return x;
      };
    }
    function I(P) {
      var N = P.data, L = o[N.workerId], B = false;
      if (N.error) L.userError(N.error, N.file);
      else if (N.results && N.results.data) {
        var u = { abort: function() {
          B = true, S(N.workerId, { data: [], errors: [], meta: { aborted: true } });
        }, pause: $, resume: $ };
        if (Q(L.userStep)) {
          for (var p = 0; p < N.results.data.length && (L.userStep({ data: N.results.data[p], errors: N.results.errors, meta: N.results.meta }, u), !B); p++) ;
          delete N.results;
        } else Q(L.userChunk) && (L.userChunk(N.results, u, N.file), delete N.results);
      }
      N.finished && !B && S(N.workerId, N.results);
    }
    function S(P, N) {
      var L = o[P];
      Q(L.userComplete) && L.userComplete(N), L.terminate(), delete o[P];
    }
    function $() {
      throw new Error("Not implemented.");
    }
    function F(P) {
      if (typeof P != "object" || P === null) return P;
      var N, L = Array.isArray(P) ? [] : {};
      for (N in P) L[N] = F(P[N]);
      return L;
    }
    function U(P, N) {
      return function() {
        P.apply(N, arguments);
      };
    }
    function Q(P) {
      return typeof P == "function";
    }
    return c.parse = function(P, N) {
      var L = (N = N || {}).dynamicTyping || false;
      if (Q(L) && (N.dynamicTypingFunction = L, L = {}), N.dynamicTyping = L, N.transform = !!Q(N.transform) && N.transform, !N.worker || !c.WORKERS_SUPPORTED) return L = null, c.NODE_STREAM_INPUT, typeof P == "string" ? (P = ((B) => B.charCodeAt(0) !== 65279 ? B : B.slice(1))(P), L = new (N.download ? h : v)(N)) : P.readable === true && Q(P.read) && Q(P.on) ? L = new b(N) : (r.File && P instanceof File || P instanceof Object) && (L = new m(N)), L.stream(P);
      (L = (() => {
        var B;
        return !!c.WORKERS_SUPPORTED && (B = (() => {
          var u = r.URL || r.webkitURL || null, p = n.toString();
          return c.BLOB_URL || (c.BLOB_URL = u.createObjectURL(new Blob(["var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; ", "(", p, ")();"], { type: "text/javascript" })));
        })(), (B = new r.Worker(B)).onmessage = I, B.id = f++, o[B.id] = B);
      })()).userStep = N.step, L.userChunk = N.chunk, L.userComplete = N.complete, L.userError = N.error, N.step = Q(N.step), N.chunk = Q(N.chunk), N.complete = Q(N.complete), N.error = Q(N.error), delete N.worker, L.postMessage({ input: P, config: N, workerId: L.id });
    }, c.unparse = function(P, N) {
      var L = false, B = true, u = ",", p = `\r
`, d = '"', y = d + d, w = false, E = null, M = false, x = ((() => {
        if (typeof N == "object") {
          if (typeof N.delimiter != "string" || c.BAD_DELIMITERS.filter(function(T) {
            return N.delimiter.indexOf(T) !== -1;
          }).length || (u = N.delimiter), typeof N.quotes != "boolean" && typeof N.quotes != "function" && !Array.isArray(N.quotes) || (L = N.quotes), typeof N.skipEmptyLines != "boolean" && typeof N.skipEmptyLines != "string" || (w = N.skipEmptyLines), typeof N.newline == "string" && (p = N.newline), typeof N.quoteChar == "string" && (d = N.quoteChar), typeof N.header == "boolean" && (B = N.header), Array.isArray(N.columns)) {
            if (N.columns.length === 0) throw new Error("Option columns is empty");
            E = N.columns;
          }
          N.escapeChar !== void 0 && (y = N.escapeChar + d), N.escapeFormulae instanceof RegExp ? M = N.escapeFormulae : typeof N.escapeFormulae == "boolean" && N.escapeFormulae && (M = /^[=+\-@\t\r].*$/);
        }
      })(), new RegExp(_(d), "g"));
      if (typeof P == "string" && (P = JSON.parse(P)), Array.isArray(P)) {
        if (!P.length || Array.isArray(P[0])) return g(null, P, w);
        if (typeof P[0] == "object") return g(E || Object.keys(P[0]), P, w);
      } else if (typeof P == "object") return typeof P.data == "string" && (P.data = JSON.parse(P.data)), Array.isArray(P.data) && (P.fields || (P.fields = P.meta && P.meta.fields || E), P.fields || (P.fields = Array.isArray(P.data[0]) ? P.fields : typeof P.data[0] == "object" ? Object.keys(P.data[0]) : []), Array.isArray(P.data[0]) || typeof P.data[0] == "object" || (P.data = [P.data])), g(P.fields || [], P.data || [], w);
      throw new Error("Unable to serialize unrecognized input");
      function g(T, O, K) {
        var Y = "", J = (typeof T == "string" && (T = JSON.parse(T)), typeof O == "string" && (O = JSON.parse(O)), Array.isArray(T) && 0 < T.length), G = !Array.isArray(O[0]);
        if (J && B) {
          for (var X = 0; X < T.length; X++) 0 < X && (Y += u), Y += k(T[X], X);
          0 < O.length && (Y += p);
        }
        for (var ie = 0; ie < O.length; ie++) {
          var de = (J ? T : O[ie]).length, se = false, te = J ? Object.keys(O[ie]).length === 0 : O[ie].length === 0;
          if (K && !J && (se = K === "greedy" ? O[ie].join("").trim() === "" : O[ie].length === 1 && O[ie][0].length === 0), K === "greedy" && J) {
            for (var le = [], Z = 0; Z < de; Z++) {
              var ve = G ? T[Z] : Z;
              le.push(O[ie][ve]);
            }
            se = le.join("").trim() === "";
          }
          if (!se) {
            for (var he = 0; he < de; he++) {
              0 < he && !te && (Y += u);
              var me = J && G ? T[he] : he;
              Y += k(O[ie][me], he);
            }
            ie < O.length - 1 && (!K || 0 < de && !te) && (Y += p);
          }
        }
        return Y;
      }
      function k(T, O) {
        var K, Y;
        return T == null ? "" : T.constructor === Date ? JSON.stringify(T).slice(1, 25) : (Y = false, M && typeof T == "string" && M.test(T) && (T = "'" + T, Y = true), K = T.toString().replace(x, y), (Y = Y || L === true || typeof L == "function" && L(T, O) || Array.isArray(L) && L[O] || ((J, G) => {
          for (var X = 0; X < G.length; X++) if (-1 < J.indexOf(G[X])) return true;
          return false;
        })(K, c.BAD_DELIMITERS) || -1 < K.indexOf(u) || K.charAt(0) === " " || K.charAt(K.length - 1) === " ") ? d + K + d : K);
      }
    }, c.RECORD_SEP = "", c.UNIT_SEP = "", c.BYTE_ORDER_MARK = "\uFEFF", c.BAD_DELIMITERS = ["\r", `
`, '"', c.BYTE_ORDER_MARK], c.WORKERS_SUPPORTED = !i && !!r.Worker, c.NODE_STREAM_INPUT = 1, c.LocalChunkSize = 10485760, c.RemoteChunkSize = 5242880, c.DefaultDelimiter = ",", c.Parser = C, c.ParserHandle = A, c.NetworkStreamer = h, c.FileStreamer = m, c.StringStreamer = v, c.ReadableStreamStreamer = b, r.jQuery && ((s = r.jQuery).fn.parse = function(P) {
      var N = P.config || {}, L = [];
      return this.each(function(p) {
        if (!(s(this).prop("tagName").toUpperCase() === "INPUT" && s(this).attr("type").toLowerCase() === "file" && r.FileReader) || !this.files || this.files.length === 0) return true;
        for (var d = 0; d < this.files.length; d++) L.push({ file: this.files[d], inputElem: this, instanceConfig: s.extend({}, N) });
      }), B(), this;
      function B() {
        if (L.length === 0) Q(P.complete) && P.complete();
        else {
          var p, d, y, w, E = L[0];
          if (Q(P.before)) {
            var M = P.before(E.file, E.inputElem);
            if (typeof M == "object") {
              if (M.action === "abort") return p = "AbortError", d = E.file, y = E.inputElem, w = M.reason, void (Q(P.error) && P.error({ name: p }, d, y, w));
              if (M.action === "skip") return void u();
              typeof M.config == "object" && (E.instanceConfig = s.extend(E.instanceConfig, M.config));
            } else if (M === "skip") return void u();
          }
          var x = E.instanceConfig.complete;
          E.instanceConfig.complete = function(g) {
            Q(x) && x(g, E.file, E.inputElem), u();
          }, c.parse(E.file, E.instanceConfig);
        }
      }
      function u() {
        L.splice(0, 1), B();
      }
    }), a && (r.onmessage = function(P) {
      P = P.data, c.WORKER_ID === void 0 && P && (c.WORKER_ID = P.workerId), typeof P.input == "string" ? r.postMessage({ workerId: c.WORKER_ID, results: c.parse(P.input, P.config), finished: true }) : (r.File && P.input instanceof File || P.input instanceof Object) && (P = c.parse(P.input, P.config)) && r.postMessage({ workerId: c.WORKER_ID, results: P, finished: true });
    }), (h.prototype = Object.create(l.prototype)).constructor = h, (m.prototype = Object.create(l.prototype)).constructor = m, (v.prototype = Object.create(v.prototype)).constructor = v, (b.prototype = Object.create(l.prototype)).constructor = b, c;
  });
})(yF);
var dhe = yF.exports;
const bF = Fa(dhe);
function phe(t3) {
  return new Promise((e, n) => {
    bF.parse(t3, { header: true, skipEmptyLines: true, dynamicTyping: true, complete: (r) => {
      r.errors.length > 0 ? n(new Error("CSV Parsing Error: " + r.errors[0].message)) : e(JSON.stringify(r.data, null, 4));
    }, error: (r) => {
      n(r);
    } });
  });
}
function ghe(t3) {
  try {
    let e;
    return typeof t3 == "string" ? e = JSON.parse(t3) : e = t3, Array.isArray(e) || (e = [e]), bF.unparse(e, { quotes: false, quoteChar: '"', escapeChar: '"', delimiter: ",", header: true, newline: `\r
`, skipEmptyLines: true });
  } catch {
    throw new Error("JSON Parsing Error: Invalid JSON format.");
  }
}
function mhe(t3) {
  let e;
  return { c() {
    e = we("Convert");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function vhe(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function m9(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[3]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 8 && Ze(n, r[3]);
  }, d(r) {
    r && D(e);
  } };
}
function v9(t3) {
  let e, n, r, s, i, a;
  return n = new et({ props: { label: "Result:", value: t3[2], readonly: true, expandable: true, withCopy: true, rows: 6 } }), i = new ut({ props: { variant: "secondary", $$slots: { default: [yhe] }, $$scope: { ctx: t3 } } }), i.$on("click", t3[8]), { c() {
    e = H("div"), fe(n.$$.fragment), r = z(), s = H("div"), fe(i.$$.fragment), V(s, "class", "download-btn-container svelte-1tip6ow"), St(s, "display", "flex"), St(s, "margin", "auto"), St(s, "justify-content", "center"), V(e, "class", "result-section svelte-1tip6ow");
  }, m(o, f) {
    R(o, e, f), ae(n, e, null), q(e, r), q(e, s), ae(i, s, null), a = true;
  }, p(o, f) {
    const c = {};
    f & 4 && (c.value = o[2]), n.$set(c);
    const l = {};
    f & 8192 && (l.$$scope = { dirty: f, ctx: o }), i.$set(l);
  }, i(o) {
    a || (W(n.$$.fragment, o), W(i.$$.fragment, o), a = true);
  }, o(o) {
    j(n.$$.fragment, o), j(i.$$.fragment, o), a = false;
  }, d(o) {
    o && D(e), oe(n), oe(i);
  } };
}
function yhe(t3) {
  let e;
  return { c() {
    e = we("Download as File");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function bhe(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I;
  function S(N) {
    t3[10](N);
  }
  let $ = { label: "Conversion Mode:", options: t3[5] };
  t3[0] !== void 0 && ($.value = t3[0]), n = new Ht({ props: $ }), Qe.push(() => ze(n, "value", S)), a = new la({ props: { accept: t3[0] === "csv2json" ? ".csv" : ".json", label: `Upload ${t3[0] === "csv2json" ? "CSV" : "JSON"} File` } }), a.$on("change", t3[6]);
  function F(N) {
    t3[11](N);
  }
  let U = { label: t3[0] === "csv2json" ? "Input CSV Data:" : "Input JSON Data:", placeholder: "Paste data here...", expandable: true, rows: 6 };
  t3[1] !== void 0 && (U.value = t3[1]), f = new et({ props: U }), Qe.push(() => ze(f, "value", F)), m = new ut({ props: { $$slots: { default: [mhe] }, $$scope: { ctx: t3 } } }), m.$on("click", t3[7]), b = new ut({ props: { variant: "secondary", $$slots: { default: [vhe] }, $$scope: { ctx: t3 } } }), b.$on("click", t3[12]);
  let Q = t3[3] && m9(t3), P = t3[2] && v9(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), i = H("div"), fe(a.$$.fragment), o = z(), fe(f.$$.fragment), l = z(), h = H("div"), fe(m.$$.fragment), v = z(), fe(b.$$.fragment), A = z(), Q && Q.c(), _ = z(), P && P.c(), C = Lt(), V(e, "class", "controls-row svelte-1tip6ow"), V(i, "class", "drop-container svelte-1tip6ow"), V(h, "class", "button-row");
  }, m(N, L) {
    R(N, e, L), ae(n, e, null), R(N, s, L), R(N, i, L), ae(a, i, null), R(N, o, L), ae(f, N, L), R(N, l, L), R(N, h, L), ae(m, h, null), q(h, v), ae(b, h, null), R(N, A, L), Q && Q.m(N, L), R(N, _, L), P && P.m(N, L), R(N, C, L), I = true;
  }, p(N, L) {
    const B = {};
    !r && L & 1 && (r = true, B.value = N[0], qe(() => r = false)), n.$set(B);
    const u = {};
    L & 1 && (u.accept = N[0] === "csv2json" ? ".csv" : ".json"), L & 1 && (u.label = `Upload ${N[0] === "csv2json" ? "CSV" : "JSON"} File`), a.$set(u);
    const p = {};
    L & 1 && (p.label = N[0] === "csv2json" ? "Input CSV Data:" : "Input JSON Data:"), !c && L & 2 && (c = true, p.value = N[1], qe(() => c = false)), f.$set(p);
    const d = {};
    L & 8192 && (d.$$scope = { dirty: L, ctx: N }), m.$set(d);
    const y = {};
    L & 8192 && (y.$$scope = { dirty: L, ctx: N }), b.$set(y), N[3] ? Q ? Q.p(N, L) : (Q = m9(N), Q.c(), Q.m(_.parentNode, _)) : Q && (Q.d(1), Q = null), N[2] ? P ? (P.p(N, L), L & 4 && W(P, 1)) : (P = v9(N), P.c(), W(P, 1), P.m(C.parentNode, C)) : P && (Xt(), j(P, 1, 1, () => {
      P = null;
    }), er());
  }, i(N) {
    I || (W(n.$$.fragment, N), W(a.$$.fragment, N), W(f.$$.fragment, N), W(m.$$.fragment, N), W(b.$$.fragment, N), W(P), I = true);
  }, o(N) {
    j(n.$$.fragment, N), j(a.$$.fragment, N), j(f.$$.fragment, N), j(m.$$.fragment, N), j(b.$$.fragment, N), j(P), I = false;
  }, d(N) {
    N && (D(e), D(s), D(i), D(o), D(l), D(h), D(A), D(_), D(C)), oe(n), oe(a), oe(f, N), oe(m), oe(b), Q && Q.d(N), P && P.d(N);
  } };
}
function Ahe(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b;
  return { c() {
    e = H("p"), e.innerHTML = `<b>CSV (Comma-Separated Values)</b> and <b>JSON (JavaScript Object Notation)</b> 
    are two common file formats used for data storage and transfer.`, n = z(), r = H("p"), r.innerHTML = `<b>CSV</b> is a simple text-based file format used to represent 
    tabular data (data arranged in rows and columns). Each line in a CSV 
    file corresponds to a data record, with fields (or columns) separated 
    by commas. For example:`, s = z(), i = H("pre"), i.innerHTML = `Name,    Age, Country<br/>
    John Doe, 30, USA<br/>
    Jane Smith, 25, Canada`, a = H("br"), o = z(), f = H("p"), f.innerHTML = `<b>JSON</b> is a text-based file format that represents structured data 
    in a readable form. It uses key-value pairs and supports nested data 
    structures. It is often used for data interchange, especially in 
    web applications. Example:`, c = z(), l = H("pre"), l.innerHTML = `        &quot;name&quot;: &quot;John Doe&quot;,<br/>
        &quot;age&quot;: 30,<br/>
        &quot;address&quot;: <br/>
            &quot;city&quot;: &quot;New York&quot;,<br/>
            &quot;country&quot;: &quot;USA&quot;,<br/>
        &quot;hobbies&quot;: [&quot;reading&quot;, &quot;traveling&quot;, &quot;coding&quot;]<br/><br/>`, h = z(), m = H("ul"), m.innerHTML = "<li><strong>CSV to JSON:</strong> Converts rows into an array of objects. First row is treated as headers (keys).</li> <li><strong>JSON to CSV:</strong> Flattens an array of objects back into rows. Keys become headers.</li>", v = z(), b = H("p"), b.innerHTML = "<em><b>Note:</b> NO FILES OR FOLDERS are sent to any server. Uploading happens only in your browser.</em>";
  }, m(A, _) {
    R(A, e, _), R(A, n, _), R(A, r, _), R(A, s, _), R(A, i, _), R(A, a, _), R(A, o, _), R(A, f, _), R(A, c, _), R(A, l, _), R(A, h, _), R(A, m, _), R(A, v, _), R(A, b, _);
  }, p: dt, d(A) {
    A && (D(e), D(n), D(r), D(s), D(i), D(a), D(o), D(f), D(c), D(l), D(h), D(m), D(v), D(b));
  } };
}
function whe(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "CSV / JSON Converter", $$slots: { default: [bhe] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About CSV and JSON", links: t3[9], $$slots: { default: [Ahe] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 8223 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 8192 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function xhe(t3, e, n) {
  let r = "csv2json", s = "", i = "", a = "", o = "";
  const f = [{ value: "csv2json", label: "CSV to JSON" }, { value: "json2csv", label: "JSON to CSV" }];
  function c(_) {
    const C = _.detail[0];
    if (!C) return;
    n(4, o = C.name.split(".")[0]);
    const I = new FileReader();
    I.onload = (S) => {
      n(1, s = S.target.result), C.name.toLowerCase().endsWith(".json") ? n(0, r = "json2csv") : C.name.toLowerCase().endsWith(".csv") && n(0, r = "csv2json"), l();
    }, I.readAsText(C);
  }
  async function l() {
    if (n(3, a = ""), n(2, i = ""), !s.trim()) {
      n(3, a = "Please enter text or upload a file.");
      return;
    }
    try {
      r === "csv2json" ? n(2, i = await phe(s)) : n(2, i = ghe(s));
    } catch (_) {
      n(3, a = _.message);
    }
  }
  function h() {
    if (!i) return;
    const _ = r === "csv2json" ? "json" : "csv", C = new Blob([i], { type: "text/plain" }), I = URL.createObjectURL(C), S = document.createElement("a");
    S.href = I, S.download = `${o || "converted_data"}.${_}`, document.body.appendChild(S), S.click(), document.body.removeChild(S), URL.revokeObjectURL(I);
  }
  const m = [{ text: "CSV - Wikipedia", url: "https://en.wikipedia.org/wiki/Comma-separated_values" }, { text: "JSON - Wikipedia", url: "https://en.wikipedia.org/wiki/JSON" }];
  function v(_) {
    r = _, n(0, r);
  }
  function b(_) {
    s = _, n(1, s);
  }
  return [r, s, i, a, o, f, c, l, h, m, v, b, () => {
    n(1, s = ""), n(2, i = ""), n(4, o = "");
  }];
}
class _he extends xt {
  constructor(e) {
    super(), wt(this, e, xhe, whe, At, {});
  }
}
function Ehe(t3, e) {
  return !t3 || !t3.trim() ? "" : e === "encode" ? Bhe(t3) : Che(t3);
}
function Bhe(t3) {
  const e = [];
  for (let n = 0; n < t3.length; n++) {
    const r = t3[n], s = r.toUpperCase().charCodeAt(0);
    if (s >= 65 && s <= 90) {
      const i = s - 64;
      e.push(i);
    } else r.trim() !== "" && e.push(r);
  }
  return e.join(" ");
}
function Che(t3) {
  const e = t3.trim().split(/[\s,.-]+/);
  let n = "";
  for (const r of e) {
    if (!r) continue;
    const s = parseInt(r, 10);
    !isNaN(s) && s >= 1 && s <= 26 ? n += String.fromCharCode(s + 64) : n += "?";
  }
  return n;
}
function khe(t3) {
  let e;
  return { c() {
    e = we("Convert");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function Ihe(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function y9(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[4]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 16 && Ze(n, r[4]);
  }, d(r) {
    r && D(e);
  } };
}
function b9(t3) {
  let e, n;
  return e = new et({ props: { label: "Result:", value: t3[3], readonly: true, expandable: true, withCopy: true } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, s) {
    const i = {};
    s & 8 && (i.value = r[3]), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function She(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F;
  function U(d) {
    t3[8](d);
  }
  let Q = { label: "Mode:", options: t3[5] };
  t3[1] !== void 0 && (Q.value = t3[1]), n = new Ht({ props: Q }), Qe.push(() => ze(n, "value", U));
  function P(d) {
    t3[9](d);
  }
  let N = { label: t3[1] === "encode" ? "Input Text:" : "Input Numbers:", placeholder: t3[1] === "encode" ? "e.g. Hello World" : "e.g. 8 5 12 12 15", expandable: true };
  t3[0] !== void 0 && (N.value = t3[0]), i = new et({ props: N }), Qe.push(() => ze(i, "value", P)), c = new ut({ props: { $$slots: { default: [khe] }, $$scope: { ctx: t3 } } }), c.$on("click", t3[6]), h = new ut({ props: { variant: "secondary", $$slots: { default: [Ihe] }, $$scope: { ctx: t3 } } }), h.$on("click", t3[10]), v = new hn({}), v.$on("click", t3[7]);
  function L(d) {
    t3[11](d);
  }
  let B = {};
  t3[2] !== void 0 && (B.checked = t3[2]), _ = new xr({ props: B }), Qe.push(() => ze(_, "checked", L));
  let u = t3[4] && y9(t3), p = t3[3] && b9(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), fe(i.$$.fragment), o = z(), f = H("div"), fe(c.$$.fragment), l = z(), fe(h.$$.fragment), m = z(), fe(v.$$.fragment), b = z(), A = H("div"), fe(_.$$.fragment), I = z(), u && u.c(), S = z(), p && p.c(), $ = Lt(), V(e, "class", "controls-row"), St(A, "margin-left", "auto"), V(f, "class", "button-row");
  }, m(d, y) {
    R(d, e, y), ae(n, e, null), R(d, s, y), ae(i, d, y), R(d, o, y), R(d, f, y), ae(c, f, null), q(f, l), ae(h, f, null), q(f, m), ae(v, f, null), q(f, b), q(f, A), ae(_, A, null), R(d, I, y), u && u.m(d, y), R(d, S, y), p && p.m(d, y), R(d, $, y), F = true;
  }, p(d, y) {
    const w = {};
    !r && y & 2 && (r = true, w.value = d[1], qe(() => r = false)), n.$set(w);
    const E = {};
    y & 2 && (E.label = d[1] === "encode" ? "Input Text:" : "Input Numbers:"), y & 2 && (E.placeholder = d[1] === "encode" ? "e.g. Hello World" : "e.g. 8 5 12 12 15"), !a && y & 1 && (a = true, E.value = d[0], qe(() => a = false)), i.$set(E);
    const M = {};
    y & 4096 && (M.$$scope = { dirty: y, ctx: d }), c.$set(M);
    const x = {};
    y & 4096 && (x.$$scope = { dirty: y, ctx: d }), h.$set(x);
    const g = {};
    !C && y & 4 && (C = true, g.checked = d[2], qe(() => C = false)), _.$set(g), d[4] ? u ? u.p(d, y) : (u = y9(d), u.c(), u.m(S.parentNode, S)) : u && (u.d(1), u = null), d[3] ? p ? (p.p(d, y), y & 8 && W(p, 1)) : (p = b9(d), p.c(), W(p, 1), p.m($.parentNode, $)) : p && (Xt(), j(p, 1, 1, () => {
      p = null;
    }), er());
  }, i(d) {
    F || (W(n.$$.fragment, d), W(i.$$.fragment, d), W(c.$$.fragment, d), W(h.$$.fragment, d), W(v.$$.fragment, d), W(_.$$.fragment, d), W(p), F = true);
  }, o(d) {
    j(n.$$.fragment, d), j(i.$$.fragment, d), j(c.$$.fragment, d), j(h.$$.fragment, d), j(v.$$.fragment, d), j(_.$$.fragment, d), j(p), F = false;
  }, d(d) {
    d && (D(e), D(s), D(o), D(f), D(I), D(S), D($)), oe(n), oe(i, d), oe(c), oe(h), oe(v), oe(_), u && u.d(d), p && p.d(d);
  } };
}
function Mhe(t3) {
  let e, n, r, s, i;
  return { c() {
    e = H("p"), e.innerHTML = "The <strong>A1Z26 Cipher</strong> is a simple substitution cipher that replaces each letter with its position in the alphabet.", n = z(), r = H("ul"), r.innerHTML = "<li><strong>A</strong> = 1</li> <li><strong>B</strong> = 2</li> <li>...</li> <li><strong>Z</strong> = 26</li>", s = z(), i = H("p"), i.textContent = `It is often used as a basic puzzle step or combined with other ciphers (like Atbash) to create more complex codes.
    Decoding requires the numbers to be separated by spaces, commas, or dashes.`;
  }, m(a, o) {
    R(a, e, o), R(a, n, o), R(a, r, o), R(a, s, o), R(a, i, o);
  }, p: dt, d(a) {
    a && (D(e), D(n), D(r), D(s), D(i));
  } };
}
function $he(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "A1Z26 Encoder/Decoder", $$slots: { default: [She] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About A1Z26", $$slots: { default: [Mhe] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 4127 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 4096 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function The(t3, e, n) {
  let r = "", s = "encode", i = "", a = "", o = true;
  const f = [{ value: "encode", label: "Text to A1Z26 (Numbers)" }, { value: "decode", label: "A1Z26 (Numbers) to Text" }];
  function c() {
    if (!r) {
      n(3, i = ""), n(4, a = "");
      return;
    }
    n(4, a = "");
    try {
      n(3, i = Ehe(r, s));
    } catch (A) {
      n(4, a = A.message), n(3, i = "");
    }
  }
  function l() {
    n(1, s = s === "encode" ? "decode" : "encode"), i && !a && n(0, r = i), c();
  }
  function h(A) {
    s = A, n(1, s);
  }
  function m(A) {
    r = A, n(0, r);
  }
  const v = () => {
    n(0, r = ""), n(3, i = "");
  };
  function b(A) {
    o = A, n(2, o);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 7 && o && (r || s) && c();
  }, [r, s, o, i, a, f, c, l, h, m, v, b];
}
class Dhe extends xt {
  constructor(e) {
    super(), wt(this, e, The, $he, At, {});
  }
}
const AF = { a: "\u2801", b: "\u2803", c: "\u2809", d: "\u2819", e: "\u2811", f: "\u280B", g: "\u281B", h: "\u2813", i: "\u280A", j: "\u281A", k: "\u2805", l: "\u2807", m: "\u280D", n: "\u281D", o: "\u2815", p: "\u280F", q: "\u281F", r: "\u2817", s: "\u280E", t: "\u281E", u: "\u2825", v: "\u2827", w: "\u283A", x: "\u282D", y: "\u283D", z: "\u2835", " ": "\u2800", ",": "\u2802", ";": "\u2806", ":": "\u2812", ".": "\u2832", "!": "\u2816", "(": "\u2826", ")": "\u2834", "?": "\u2826", '"': "\u2836", "'": "\u2804", "-": "\u2824", 1: "\u2802", 2: "\u2806", 3: "\u2812", 4: "\u2832", 5: "\u2822", 6: "\u2816", 7: "\u2836", 8: "\u2826", 9: "\u2814", 0: "\u2834" }, Rhe = Object.entries(AF).reduce((t3, [e, n]) => (t3[n] = e, t3), {});
function Fhe(t3, e) {
  return t3 ? e === "text2braille" ? Phe(t3) : Nhe(t3) : "";
}
function Phe(t3) {
  return Array.from(t3.toLowerCase()).map((e) => AF[e] || e).join("");
}
function Nhe(t3) {
  return Array.from(t3).map((e) => Rhe[e] || e).join("");
}
function Uhe(t3) {
  let e;
  return { c() {
    e = we("Translate");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function Lhe(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function A9(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[4]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 16 && Ze(n, r[4]);
  }, d(r) {
    r && D(e);
  } };
}
function w9(t3) {
  let e, n;
  return e = new et({ props: { label: "Result:", value: t3[3], readonly: true, expandable: true, withCopy: true, rows: 4 } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, s) {
    const i = {};
    s & 8 && (i.value = r[3]), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function Ohe(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F;
  function U(d) {
    t3[9](d);
  }
  let Q = { label: "Mode:", options: t3[5] };
  t3[1] !== void 0 && (Q.value = t3[1]), n = new Ht({ props: Q }), Qe.push(() => ze(n, "value", U));
  function P(d) {
    t3[10](d);
  }
  let N = { label: t3[1] === "text2braille" ? "Input Text:" : "Input Braille:", placeholder: t3[1] === "text2braille" ? "e.g. Hello World" : "e.g. \u2813\u2811\u2807\u2807\u2815", expandable: true };
  t3[0] !== void 0 && (N.value = t3[0]), i = new et({ props: N }), Qe.push(() => ze(i, "value", P)), c = new ut({ props: { $$slots: { default: [Uhe] }, $$scope: { ctx: t3 } } }), c.$on("click", t3[6]), h = new ut({ props: { variant: "secondary", $$slots: { default: [Lhe] }, $$scope: { ctx: t3 } } }), h.$on("click", t3[11]), v = new hn({}), v.$on("click", t3[7]);
  function L(d) {
    t3[12](d);
  }
  let B = {};
  t3[2] !== void 0 && (B.checked = t3[2]), _ = new xr({ props: B }), Qe.push(() => ze(_, "checked", L));
  let u = t3[4] && A9(t3), p = t3[3] && w9(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), fe(i.$$.fragment), o = z(), f = H("div"), fe(c.$$.fragment), l = z(), fe(h.$$.fragment), m = z(), fe(v.$$.fragment), b = z(), A = H("div"), fe(_.$$.fragment), I = z(), u && u.c(), S = z(), p && p.c(), $ = Lt(), V(e, "class", "controls-row"), St(A, "margin-left", "auto"), V(f, "class", "button-row");
  }, m(d, y) {
    R(d, e, y), ae(n, e, null), R(d, s, y), ae(i, d, y), R(d, o, y), R(d, f, y), ae(c, f, null), q(f, l), ae(h, f, null), q(f, m), ae(v, f, null), q(f, b), q(f, A), ae(_, A, null), R(d, I, y), u && u.m(d, y), R(d, S, y), p && p.m(d, y), R(d, $, y), F = true;
  }, p(d, y) {
    const w = {};
    !r && y & 2 && (r = true, w.value = d[1], qe(() => r = false)), n.$set(w);
    const E = {};
    y & 2 && (E.label = d[1] === "text2braille" ? "Input Text:" : "Input Braille:"), y & 2 && (E.placeholder = d[1] === "text2braille" ? "e.g. Hello World" : "e.g. \u2813\u2811\u2807\u2807\u2815"), !a && y & 1 && (a = true, E.value = d[0], qe(() => a = false)), i.$set(E);
    const M = {};
    y & 8192 && (M.$$scope = { dirty: y, ctx: d }), c.$set(M);
    const x = {};
    y & 8192 && (x.$$scope = { dirty: y, ctx: d }), h.$set(x);
    const g = {};
    !C && y & 4 && (C = true, g.checked = d[2], qe(() => C = false)), _.$set(g), d[4] ? u ? u.p(d, y) : (u = A9(d), u.c(), u.m(S.parentNode, S)) : u && (u.d(1), u = null), d[3] ? p ? (p.p(d, y), y & 8 && W(p, 1)) : (p = w9(d), p.c(), W(p, 1), p.m($.parentNode, $)) : p && (Xt(), j(p, 1, 1, () => {
      p = null;
    }), er());
  }, i(d) {
    F || (W(n.$$.fragment, d), W(i.$$.fragment, d), W(c.$$.fragment, d), W(h.$$.fragment, d), W(v.$$.fragment, d), W(_.$$.fragment, d), W(p), F = true);
  }, o(d) {
    j(n.$$.fragment, d), j(i.$$.fragment, d), j(c.$$.fragment, d), j(h.$$.fragment, d), j(v.$$.fragment, d), j(_.$$.fragment, d), j(p), F = false;
  }, d(d) {
    d && (D(e), D(s), D(o), D(f), D(I), D(S), D($)), oe(n), oe(i, d), oe(c), oe(h), oe(v), oe(_), u && u.d(d), p && p.d(d);
  } };
}
function Qhe(t3) {
  let e, n, r;
  return { c() {
    e = H("p"), e.innerHTML = `<b>Braille</b> is a tactile writing system used by individuals who are 
    visually impaired or blind. It was invented by Louis Braille, 
    a French educator who lost his sight due to a childhood accident.`, n = z(), r = H("p"), r.textContent = `He developed this system in the early 19th century to make reading 
    and writing more accessible for people who cannot use traditional print. 
    The fundamental component of Braille is the 'Braille cell', which 
    is made up of six raised dots arranged in two parallel columns of 
    three dots each. These dots are numbered from 1 to 6, with dot 1 
    at the top left and dot 6 at the bottom right. Different combinations 
    of these dots represent different letters, numbers, punctuation marks, 
    and even entire words or phrases. There are 64 possible combinations 
    of the six dots, including a configuration with no dots raised. These 
    combinations are used to encode letters, numbers, and other symbols. 
    For example, the letter 'A' is represented by a single raised dot
    in position 1, while 'B' has raised dots in positions 1 and 2.`;
  }, m(s, i) {
    R(s, e, i), R(s, n, i), R(s, r, i);
  }, p: dt, d(s) {
    s && (D(e), D(n), D(r));
  } };
}
function Khe(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Braille Tactile Writing System Encoder/Decoder", $$slots: { default: [Ohe] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Braille", links: t3[8], $$slots: { default: [Qhe] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 8223 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 8192 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function Hhe(t3, e, n) {
  let r = "", s = "text2braille", i = "", a = "", o = true;
  const f = [{ value: "text2braille", label: "Text to Braille" }, { value: "braille2text", label: "Braille to Text" }];
  function c() {
    if (!r) {
      n(3, i = ""), n(4, a = "");
      return;
    }
    n(4, a = "");
    try {
      n(3, i = Fhe(r, s));
    } catch (_) {
      n(4, a = _.message), n(3, i = "");
    }
  }
  function l() {
    n(1, s = s === "text2braille" ? "braille2text" : "text2braille"), i && !a && n(0, r = i), c();
  }
  const h = [{ text: "Braille - Wikipedia", url: "https://en.wikipedia.org/wiki/Braille" }, { text: "Britannica", url: "https://www.britannica.com/topic/Braille-writing-system" }];
  function m(_) {
    s = _, n(1, s);
  }
  function v(_) {
    r = _, n(0, r);
  }
  const b = () => {
    n(0, r = ""), n(3, i = "");
  };
  function A(_) {
    o = _, n(2, o);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 7 && o && (r || s) && c();
  }, [r, s, o, i, a, f, c, l, h, m, v, b, A];
}
class qhe extends xt {
  constructor(e) {
    super(), wt(this, e, Hhe, Khe, At, {});
  }
}
const ni = { base32: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", base45: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:", base58: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz", base62: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", base85: "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~", base92: "!#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_abcdefghijklmnopqrstuvwxyz{|}" };
function zhe(t3, e, n, r = "utf-8", s = "RFC4648") {
  if (!t3) return "";
  if (n === "encode") {
    let i;
    try {
      i = ps(t3, r);
    } catch (a) {
      throw new Error(a.message);
    }
    switch (e) {
      case "base32":
        return Yhe(i);
      case "base45":
        return Jhe(i);
      case "base58":
        return yy(i, ni.base58);
      case "base62":
        return yy(i, ni.base62);
      case "base64":
        return Ghe(i, s);
      case "base85":
        return jhe(i);
      case "base92":
        return yy(i, ni.base92);
      default:
        throw new Error("Unknown Base");
    }
  } else {
    const i = t3.trim();
    let a;
    switch (e) {
      case "base32":
        a = Whe(i);
        break;
      case "base45":
        a = Zhe(i);
        break;
      case "base58":
        a = by(i, ni.base58);
        break;
      case "base62":
        a = by(i, ni.base62);
        break;
      case "base64":
        a = Vhe(i, s);
        break;
      case "base85":
        a = Xhe(i);
        break;
      case "base92":
        a = by(i, ni.base92);
        break;
      default:
        throw new Error("Unknown Base");
    }
    return new TextDecoder().decode(a);
  }
}
function Ghe(t3, e) {
  let n = "";
  const r = t3.byteLength;
  for (let i = 0; i < r; i++) n += String.fromCharCode(t3[i]);
  let s = btoa(n);
  switch (e) {
    case "RFC4648":
      return s;
    case "RFC4648-URL":
      return s.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
    case "RFC2045":
      return s.match(/.{1,76}/g).join(`\r
`);
    case "RFC2152":
      return s.replace(/=+$/, "");
    case "RFC3501":
      return s.replace(/\//g, ",").replace(/=+$/, "");
    default:
      return s;
  }
}
function Vhe(t3, e) {
  let n = t3;
  switch (e) {
    case "RFC4648-URL":
      n = n.replace(/-/g, "+").replace(/_/g, "/");
      break;
    case "RFC2045":
      n = n.replace(/[\r\n]/g, "");
      break;
    case "RFC3501":
      n = n.replace(/,/g, "/");
      break;
  }
  for (; n.length % 4; ) n += "=";
  try {
    const r = atob(n), s = new Uint8Array(r.length);
    for (let i = 0; i < r.length; i++) s[i] = r.charCodeAt(i);
    return s;
  } catch {
    throw new Error("Invalid Base64 sequence for " + e);
  }
}
function Yhe(t3) {
  let e = 0, n = 0, r = "";
  for (let s = 0; s < t3.length; s++) for (n = n << 8 | t3[s], e += 8; e >= 5; ) r += ni.base32[n >>> e - 5 & 31], e -= 5;
  for (e > 0 && (r += ni.base32[n << 5 - e & 31]); r.length % 8 !== 0; ) r += "=";
  return r;
}
function Whe(t3) {
  const e = {};
  for (let a = 0; a < ni.base32.length; a++) e[ni.base32[a]] = a;
  let n = t3.replace(/=+$/, "").toUpperCase(), r = 0, s = 0, i = [];
  for (let a = 0; a < n.length; a++) {
    const o = e[n[a]];
    if (o === void 0) throw new Error("Invalid Base32 char");
    for (s = s << 5 | o, r += 5; r >= 8; ) i.push(s >>> r - 8 & 255), r -= 8;
  }
  return new Uint8Array(i);
}
function Jhe(t3) {
  let e = "";
  for (let n = 0; n < t3.length; n += 2) if (t3.length - n > 1) {
    const r = (t3[n] << 8) + t3[n + 1];
    e += ni.base45[r % 45] + ni.base45[Math.floor(r % (45 * 45) / 45)] + ni.base45[Math.floor(r / (45 * 45))];
  } else {
    const r = t3[n];
    e += ni.base45[r % 45] + ni.base45[Math.floor(r / 45)];
  }
  return e;
}
function Zhe(t3) {
  const e = {};
  for (let r = 0; r < ni.base45.length; r++) e[ni.base45[r]] = r;
  const n = [];
  for (let r = 0; r < t3.length; r += 3) if (t3.length - r >= 3) {
    const s = e[t3[r]] + e[t3[r + 1]] * 45 + e[t3[r + 2]] * 45 * 45;
    n.push(s >> 8), n.push(s & 255);
  } else {
    const s = e[t3[r]] + e[t3[r + 1]] * 45;
    n.push(s);
  }
  return new Uint8Array(n);
}
function jhe(t3) {
  let e = "";
  const n = (4 - t3.length % 4) % 4, r = new Uint8Array(t3.length + n);
  r.set(t3);
  for (let s = 0; s < r.length; s += 4) {
    let i = r[s] << 24 | r[s + 1] << 16 | r[s + 2] << 8 | r[s + 3], a = [];
    for (let o = 0; o < 5; o++) a.unshift(ni.base85[i % 85]), i = Math.floor(i / 85);
    e += a.join("");
  }
  return e.substring(0, e.length - n);
}
function Xhe(t3) {
  let e = t3.replace(/\s/g, "");
  const n = (5 - e.length % 5) % 5;
  e += "u".repeat(n);
  const r = {};
  for (let i = 0; i < ni.base85.length; i++) r[ni.base85[i]] = i;
  const s = [];
  for (let i = 0; i < e.length; i += 5) {
    let a = 0;
    for (let o = 0; o < 5; o++) a = a * 85 + r[e[i + o]];
    s.push(a >>> 24 & 255), s.push(a >>> 16 & 255), s.push(a >>> 8 & 255), s.push(a & 255);
  }
  return new Uint8Array(s.slice(0, s.length - n));
}
function yy(t3, e) {
  if (t3.length === 0) return "";
  let n = 0n;
  for (let i = 0; i < t3.length; i++) n = n * 256n + BigInt(t3[i]);
  const r = BigInt(e.length);
  let s = "";
  for (; n > 0n; ) s = e[Number(n % r)] + s, n = n / r;
  for (let i = 0; i < t3.length && t3[i] === 0; i++) s = e[0] + s;
  return s;
}
function by(t3, e) {
  if (t3.length === 0) return new Uint8Array(0);
  const n = BigInt(e.length), r = {};
  for (let a = 0; a < e.length; a++) r[e[a]] = BigInt(a);
  let s = 0n;
  for (let a = 0; a < t3.length; a++) {
    if (r[t3[a]] === void 0) throw new Error("Invalid char");
    s = s * n + r[t3[a]];
  }
  const i = [];
  for (; s > 0n; ) i.unshift(Number(s % 256n)), s = s / 256n;
  for (let a = 0; a < t3.length && t3[a] === e[0]; a++) i.unshift(0);
  return new Uint8Array(i);
}
function x9(t3) {
  let e, n, r;
  function s(a) {
    t3[16](a);
  }
  let i = { label: "Input Encoding:", options: gs.map(sde) };
  return t3[3] !== void 0 && (i.value = t3[3]), e = new Ht({ props: i }), Qe.push(() => ze(e, "value", s)), { c() {
    fe(e.$$.fragment);
  }, m(a, o) {
    ae(e, a, o), r = true;
  }, p(a, o) {
    const f = {};
    !n && o & 8 && (n = true, f.value = a[3], qe(() => n = false)), e.$set(f);
  }, i(a) {
    r || (W(e.$$.fragment, a), r = true);
  }, o(a) {
    j(e.$$.fragment, a), r = false;
  }, d(a) {
    oe(e, a);
  } };
}
function _9(t3) {
  let e, n, r;
  function s(a) {
    t3[17](a);
  }
  let i = { label: "RFC Format:", options: t3[10] };
  return t3[4] !== void 0 && (i.value = t3[4]), e = new Ht({ props: i }), Qe.push(() => ze(e, "value", s)), { c() {
    fe(e.$$.fragment);
  }, m(a, o) {
    ae(e, a, o), r = true;
  }, p(a, o) {
    const f = {};
    !n && o & 16 && (n = true, f.value = a[4], qe(() => n = false)), e.$set(f);
  }, i(a) {
    r || (W(e.$$.fragment, a), r = true);
  }, o(a) {
    j(e.$$.fragment, a), r = false;
  }, d(a) {
    oe(e, a);
  } };
}
function ede(t3) {
  let e;
  return { c() {
    e = we("Convert");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function tde(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function E9(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[7]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 128 && Ze(n, r[7]);
  }, d(r) {
    r && D(e);
  } };
}
function B9(t3) {
  let e, n;
  return e = new et({ props: { label: "Result:", value: t3[6], readonly: true, expandable: true, withCopy: true, rows: 4 } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, s) {
    const i = {};
    s & 64 && (i.value = r[6]), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function rde(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U, Q, P, N, L, B;
  function u(K) {
    t3[14](K);
  }
  let p = { label: "Operation:", options: t3[8] };
  t3[1] !== void 0 && (p.value = t3[1]), n = new Ht({ props: p }), Qe.push(() => ze(n, "value", u));
  function d(K) {
    t3[15](K);
  }
  let y = { label: "Encoding Standard:", options: t3[9] };
  t3[2] !== void 0 && (y.value = t3[2]), i = new Ht({ props: y }), Qe.push(() => ze(i, "value", d));
  let w = t3[1] === "encode" && x9(t3), E = t3[2] === "base64" && t3[1] === "encode" && _9(t3);
  function M(K) {
    t3[18](K);
  }
  let x = { label: t3[1] === "encode" ? "Input Data:" : `Input ${t3[2]} string:`, placeholder: t3[1] === "encode" ? "Type here..." : "e.g. 5rWf...", expandable: true };
  t3[0] !== void 0 && (x.value = t3[0]), h = new et({ props: x }), Qe.push(() => ze(h, "value", M)), A = new ut({ props: { $$slots: { default: [ede] }, $$scope: { ctx: t3 } } }), A.$on("click", t3[11]), C = new ut({ props: { variant: "secondary", $$slots: { default: [tde] }, $$scope: { ctx: t3 } } }), C.$on("click", t3[19]), S = new hn({}), S.$on("click", t3[12]);
  function g(K) {
    t3[20](K);
  }
  let k = {};
  t3[5] !== void 0 && (k.checked = t3[5]), U = new xr({ props: k }), Qe.push(() => ze(U, "checked", g));
  let T = t3[7] && E9(t3), O = t3[6] && B9(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), fe(i.$$.fragment), o = z(), f = H("div"), w && w.c(), c = z(), E && E.c(), l = z(), fe(h.$$.fragment), v = z(), b = H("div"), fe(A.$$.fragment), _ = z(), fe(C.$$.fragment), I = z(), fe(S.$$.fragment), $ = z(), F = H("div"), fe(U.$$.fragment), P = z(), T && T.c(), N = z(), O && O.c(), L = Lt(), V(e, "class", "controls-row"), V(f, "class", "controls-row"), St(f, "margin-top", "0.5rem"), St(F, "margin-left", "auto"), V(b, "class", "button-row");
  }, m(K, Y) {
    R(K, e, Y), ae(n, e, null), q(e, s), ae(i, e, null), R(K, o, Y), R(K, f, Y), w && w.m(f, null), q(f, c), E && E.m(f, null), R(K, l, Y), ae(h, K, Y), R(K, v, Y), R(K, b, Y), ae(A, b, null), q(b, _), ae(C, b, null), q(b, I), ae(S, b, null), q(b, $), q(b, F), ae(U, F, null), R(K, P, Y), T && T.m(K, Y), R(K, N, Y), O && O.m(K, Y), R(K, L, Y), B = true;
  }, p(K, Y) {
    const J = {};
    !r && Y & 2 && (r = true, J.value = K[1], qe(() => r = false)), n.$set(J);
    const G = {};
    !a && Y & 4 && (a = true, G.value = K[2], qe(() => a = false)), i.$set(G), K[1] === "encode" ? w ? (w.p(K, Y), Y & 2 && W(w, 1)) : (w = x9(K), w.c(), W(w, 1), w.m(f, c)) : w && (Xt(), j(w, 1, 1, () => {
      w = null;
    }), er()), K[2] === "base64" && K[1] === "encode" ? E ? (E.p(K, Y), Y & 6 && W(E, 1)) : (E = _9(K), E.c(), W(E, 1), E.m(f, null)) : E && (Xt(), j(E, 1, 1, () => {
      E = null;
    }), er());
    const X = {};
    Y & 6 && (X.label = K[1] === "encode" ? "Input Data:" : `Input ${K[2]} string:`), Y & 2 && (X.placeholder = K[1] === "encode" ? "Type here..." : "e.g. 5rWf..."), !m && Y & 1 && (m = true, X.value = K[0], qe(() => m = false)), h.$set(X);
    const ie = {};
    Y & 2097152 && (ie.$$scope = { dirty: Y, ctx: K }), A.$set(ie);
    const de = {};
    Y & 2097152 && (de.$$scope = { dirty: Y, ctx: K }), C.$set(de);
    const se = {};
    !Q && Y & 32 && (Q = true, se.checked = K[5], qe(() => Q = false)), U.$set(se), K[7] ? T ? T.p(K, Y) : (T = E9(K), T.c(), T.m(N.parentNode, N)) : T && (T.d(1), T = null), K[6] ? O ? (O.p(K, Y), Y & 64 && W(O, 1)) : (O = B9(K), O.c(), W(O, 1), O.m(L.parentNode, L)) : O && (Xt(), j(O, 1, 1, () => {
      O = null;
    }), er());
  }, i(K) {
    B || (W(n.$$.fragment, K), W(i.$$.fragment, K), W(w), W(E), W(h.$$.fragment, K), W(A.$$.fragment, K), W(C.$$.fragment, K), W(S.$$.fragment, K), W(U.$$.fragment, K), W(O), B = true);
  }, o(K) {
    j(n.$$.fragment, K), j(i.$$.fragment, K), j(w), j(E), j(h.$$.fragment, K), j(A.$$.fragment, K), j(C.$$.fragment, K), j(S.$$.fragment, K), j(U.$$.fragment, K), j(O), B = false;
  }, d(K) {
    K && (D(e), D(o), D(f), D(l), D(v), D(b), D(P), D(N), D(L)), oe(n), oe(i), w && w.d(), E && E.d(), oe(h, K), oe(A), oe(C), oe(S), oe(U), T && T.d(K), O && O.d(K);
  } };
}
function nde(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v;
  return { c() {
    e = H("p"), e.innerHTML = `<b>BASE32</b> is a binary-to-text encoding scheme that is used to represent 
    binary data in an ASCII string format. It is designed to encode data  
    in a way that is more efficient than some other encoding methods, 
    such as BASE64, when dealing with systems that are case-insensitive or 
    when working with text that needs to avoid special characters.
    The character set used in BASE32 is: ABCDEFGHIJKLMNOPQRSTUVWXYZ234567 
    Each character in the BASE32 alphabet encodes 5 bits of binary data 
    (since 2**5 = 32). BASE32 uses the &#39;=&#39; character for padding to make 
    the length of the encoded output a multiple of 8 characters, ensuring 
    proper decoding.`, n = z(), r = H("p"), r.innerHTML = `<b>Base45</b> is a relatively newer binary-to-text encoding scheme compared 
    to common encoding schemes like Base64 and Base32. It has emerged with 
    specific use cases where compact data representation is needed, 
    especially in environments that may have character restrictions. 
    A notable application of Base45 is in encoding information for EU 
    Digital COVID Certificates. The Base45 character set includes the 
    following characters:0-9 (digits), A-Z (uppercase letters), and 
    space plus the characters: $%*+-./:
    Each character in the Base45 alphabet represents 45 possible values,
    which is enough to encode 2 bytes (16 bits) into 3 characters (since 
    452&gt;256452&gt;256, where 256 represents 8-bit data for a byte).`, s = z(), i = H("p"), i.innerHTML = `<b>Base58</b> is a binary-to-text encoding scheme designed to 
    represent large integers in a compact and human-friendly 
    way. It is used in various applications where shortened 
    representations of binary data are needed, particularly 
    in cryptocurrencies and blockchain technology. Base58 
    uses a set of 58 alphanumeric characters: 123456789ABCDE
    FGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz.
    e.g: A typical Bitcoin address might look like this: 
    1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa. This address is 
    encoded in Base58Check.`, a = z(), o = H("p"), o.innerHTML = `<b>Base62</b> is a binary-to-text encoding scheme that is often used 
    to represent large integers or binary data in a shorter and 
    more human-readable form. It is commonly used in scenarios 
    where data needs to be compact yet readable, such as URL 
    shorteners, unique identifiers for database records, and cases 
    where a high-density encoding is needed that can be transmitted 
    using alphanumeric characters. The full character set for Base62 
    looks like this: 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz 
    Base62 provides a compact representation. Since it uses 62 characters, 
    it can represent data more efficiently than Base10, Base16, or Base32. 
    For example, a shorter URL generated using Base62 is easier to type 
    and more visually manageable.`, f = z(), c = H("p"), c.innerHTML = `<b>Base64</b> is a binary-to-text encoding scheme that represents binary 
    data in an ASCII string format. It is commonly used to encode 
    data when transmitting it over media that are designed to handle text, 
    ensuring that the data remains intact without modification during transport. 
    Here is the full set of characters used in Base64 encoding:
    ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/ 
    Base64 is not a secure way to encode data; it&#39;s simply a reversible 
    encoding mechanism. It&#39;s not intended to hide information, as anyone 
    who understands Base64 can easily decode it.`, l = z(), h = H("p"), h.innerHTML = `<b>Base85</b>, also known as Ascii85, is a binary-to-text encoding scheme 
    used to encode binary data into a string of ASCII characters. 
    This is useful when transmitting binary data over channels that are 
    designed to handle only text, such as email or certain internet protocols. 
    Base85 is more efficient than Base64. While Base64 uses 4 characters to 
    represent every 3 bytes of binary data (a 33% increase in size), Base85 
    uses 5 characters to encode every 4 bytes of binary data, resulting in 
    only a 25% increase in size. Thus, Base85 is more space-efficient.`, m = z(), v = H("p"), v.innerHTML = `<b>Base92</b> is an encoding system designed to efficiently represent 
    binary data using a subset of ASCII characters. It is similar to 
    other encoding schemes like Base64, but it optimizes for cases where 
    minimizing the output size is important. The idea behind Base 92 
    is to use a set of 92 printable ASCII characters to represent data, 
    which reduces the expansion factor compared to Base64. The character 
    set for Base 92 encoding includes printable ASCII characters, excluding 
    characters that might cause issues in text processing or when displayed. 
    Specifically, it uses a set of 92 characters selected from the printable 
    range of ASCII characters (33 to 126).`;
  }, m(b, A) {
    R(b, e, A), R(b, n, A), R(b, r, A), R(b, s, A), R(b, i, A), R(b, a, A), R(b, o, A), R(b, f, A), R(b, c, A), R(b, l, A), R(b, h, A), R(b, m, A), R(b, v, A);
  }, p: dt, d(b) {
    b && (D(e), D(n), D(r), D(s), D(i), D(a), D(o), D(f), D(c), D(l), D(h), D(m), D(v));
  } };
}
function ide(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Universal Base Encoder", $$slots: { default: [rde] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Base Encodings", links: t3[13], $$slots: { default: [nde] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 2097407 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 2097152 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
const sde = (t3) => t3.value;
function ade(t3, e, n) {
  let r = "", s = "encode", i = "base64", a = "utf-8", o = "RFC4648", f = "", c = "", l = true;
  const h = [{ value: "encode", label: "Text/Bytes to Base" }, { value: "decode", label: "Base to Text" }], m = [{ value: "base32", label: "Base32" }, { value: "base45", label: "Base45" }, { value: "base58", label: "Base58" }, { value: "base62", label: "Base62" }, { value: "base64", label: "Base64" }, { value: "base85", label: "Base85" }, { value: "base92", label: "Base92" }], v = [{ value: "RFC4648", label: "RFC 4648 (Standard)" }, { value: "RFC4648-URL", label: "RFC 4648 (URL Safe)" }, { value: "RFC2045", label: "RFC 2045 (MIME)" }, { value: "RFC2152", label: "RFC 2152 (UTF-7)" }, { value: "RFC3501", label: "RFC 3501 (IMAP)" }];
  function b() {
    if (!r) {
      n(6, f = ""), n(7, c = "");
      return;
    }
    n(7, c = "");
    try {
      n(6, f = zhe(r, i, s, a, o));
    } catch (P) {
      n(7, c = P.message), n(6, f = "");
    }
  }
  function A() {
    n(1, s = s === "encode" ? "decode" : "encode"), f && !c && n(0, r = f), b();
  }
  const _ = [{ text: "Binary to Text Encoding - Wikipedia", url: "https://en.wikipedia.org/wiki/Binary-to-text_encoding" }, { text: "Base32 - Wikipedia", url: "https://en.wikipedia.org/wiki/Base32" }, { text: "Base62 - Wikipedia", url: "https://en.wikipedia.org/wiki/Base62" }, { text: "Base64 - Wikipedia", url: "https://en.wikipedia.org/wiki/Base64" }, { text: "Base85/Ascii85 - Wikipedia", url: "https://en.wikipedia.org/wiki/Ascii85" }];
  function C(P) {
    s = P, n(1, s);
  }
  function I(P) {
    i = P, n(2, i);
  }
  function S(P) {
    a = P, n(3, a);
  }
  function $(P) {
    o = P, n(4, o);
  }
  function F(P) {
    r = P, n(0, r);
  }
  const U = () => {
    n(0, r = ""), n(6, f = "");
  };
  function Q(P) {
    l = P, n(5, l);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 63 && l && (r || s || i || a || o) && b();
  }, [r, s, i, a, o, l, f, c, h, m, v, b, A, _, C, I, S, $, F, U, Q];
}
class ode extends xt {
  constructor(e) {
    super(), wt(this, e, ade, ide, At, {});
  }
}
const Mb = { A: ".-", B: "-...", C: "-.-.", D: "-..", E: ".", F: "..-.", G: "--.", H: "....", I: "..", J: ".---", K: "-.-", L: ".-..", M: "--", N: "-.", O: "---", P: ".--.", Q: "--.-", R: ".-.", S: "...", T: "-", U: "..-", V: "...-", W: ".--", X: "-..-", Y: "-.--", Z: "--..", 1: ".----", 2: "..---", 3: "...--", 4: "....-", 5: ".....", 6: "-....", 7: "--...", 8: "---..", 9: "----.", 0: "-----", ".": ".-.-.-", ",": "--..--", "?": "..--..", "'": ".----.", "!": "-.-.--", "/": "-..-.", "(": "-.--.", ")": "-.--.-", "&": ".-...", ":": "---...", ";": "-.-.-.", "=": "-...-", "+": ".-.-.", "-": "-....-", _: "..--.-", '"': ".-..-.", $: "...-..-", "@": ".--.-." }, C9 = Object.entries(Mb).reduce((t3, [e, n]) => (t3[n] = e, t3), {});
function fde(t3, e) {
  return !t3 || !t3.trim() ? "" : e === "text2morse" ? lde(t3) : ude(t3);
}
function lde(t3) {
  const e = t3.toUpperCase().replace(/\s+/g, " ");
  let n = [];
  for (let r of e) r === " " ? n.push("/") : Mb[r] ? n.push(Mb[r]) : n.push(r);
  return n.join(" ");
}
function ude(t3) {
  const e = t3.trim().split(/\s+/);
  let n = "";
  for (let r of e) r === "/" ? n += " " : C9[r] ? n += C9[r] : n += r;
  return n;
}
function cde(t3) {
  let e;
  return { c() {
    e = we("Convert");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function hde(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function k9(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[4]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 16 && Ze(n, r[4]);
  }, d(r) {
    r && D(e);
  } };
}
function I9(t3) {
  let e, n;
  return e = new et({ props: { label: t3[1] === "text2morse" ? "Morse Output:" : "Text Output:", value: t3[3], readonly: true, expandable: true, withCopy: true } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, s) {
    const i = {};
    s & 2 && (i.label = r[1] === "text2morse" ? "Morse Output:" : "Text Output:"), s & 8 && (i.value = r[3]), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function dde(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F;
  function U(d) {
    t3[9](d);
  }
  let Q = { label: "Mode:", options: t3[5] };
  t3[1] !== void 0 && (Q.value = t3[1]), n = new Ht({ props: Q }), Qe.push(() => ze(n, "value", U));
  function P(d) {
    t3[10](d);
  }
  let N = { label: t3[1] === "text2morse" ? "Input Text:" : "Input Morse:", placeholder: t3[1] === "text2morse" ? "e.g. SOS" : "e.g. ... --- ...", expandable: true };
  t3[0] !== void 0 && (N.value = t3[0]), i = new et({ props: N }), Qe.push(() => ze(i, "value", P)), c = new ut({ props: { $$slots: { default: [cde] }, $$scope: { ctx: t3 } } }), c.$on("click", t3[6]), h = new ut({ props: { variant: "secondary", $$slots: { default: [hde] }, $$scope: { ctx: t3 } } }), h.$on("click", t3[11]), v = new hn({}), v.$on("click", t3[7]);
  function L(d) {
    t3[12](d);
  }
  let B = {};
  t3[2] !== void 0 && (B.checked = t3[2]), _ = new xr({ props: B }), Qe.push(() => ze(_, "checked", L));
  let u = t3[4] && k9(t3), p = t3[3] && I9(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), fe(i.$$.fragment), o = z(), f = H("div"), fe(c.$$.fragment), l = z(), fe(h.$$.fragment), m = z(), fe(v.$$.fragment), b = z(), A = H("div"), fe(_.$$.fragment), I = z(), u && u.c(), S = z(), p && p.c(), $ = Lt(), V(e, "class", "controls-row"), St(A, "margin-left", "auto"), V(f, "class", "button-row");
  }, m(d, y) {
    R(d, e, y), ae(n, e, null), R(d, s, y), ae(i, d, y), R(d, o, y), R(d, f, y), ae(c, f, null), q(f, l), ae(h, f, null), q(f, m), ae(v, f, null), q(f, b), q(f, A), ae(_, A, null), R(d, I, y), u && u.m(d, y), R(d, S, y), p && p.m(d, y), R(d, $, y), F = true;
  }, p(d, y) {
    const w = {};
    !r && y & 2 && (r = true, w.value = d[1], qe(() => r = false)), n.$set(w);
    const E = {};
    y & 2 && (E.label = d[1] === "text2morse" ? "Input Text:" : "Input Morse:"), y & 2 && (E.placeholder = d[1] === "text2morse" ? "e.g. SOS" : "e.g. ... --- ..."), !a && y & 1 && (a = true, E.value = d[0], qe(() => a = false)), i.$set(E);
    const M = {};
    y & 8192 && (M.$$scope = { dirty: y, ctx: d }), c.$set(M);
    const x = {};
    y & 8192 && (x.$$scope = { dirty: y, ctx: d }), h.$set(x);
    const g = {};
    !C && y & 4 && (C = true, g.checked = d[2], qe(() => C = false)), _.$set(g), d[4] ? u ? u.p(d, y) : (u = k9(d), u.c(), u.m(S.parentNode, S)) : u && (u.d(1), u = null), d[3] ? p ? (p.p(d, y), y & 8 && W(p, 1)) : (p = I9(d), p.c(), W(p, 1), p.m($.parentNode, $)) : p && (Xt(), j(p, 1, 1, () => {
      p = null;
    }), er());
  }, i(d) {
    F || (W(n.$$.fragment, d), W(i.$$.fragment, d), W(c.$$.fragment, d), W(h.$$.fragment, d), W(v.$$.fragment, d), W(_.$$.fragment, d), W(p), F = true);
  }, o(d) {
    j(n.$$.fragment, d), j(i.$$.fragment, d), j(c.$$.fragment, d), j(h.$$.fragment, d), j(v.$$.fragment, d), j(_.$$.fragment, d), j(p), F = false;
  }, d(d) {
    d && (D(e), D(s), D(o), D(f), D(I), D(S), D($)), oe(n), oe(i, d), oe(c), oe(h), oe(v), oe(_), u && u.d(d), p && p.d(d);
  } };
}
function pde(t3) {
  let e, n, r, s, i, a;
  return { c() {
    e = H("p"), e.innerHTML = `<b>Morse code</b> is a method of transmitting text information using 
    a series of on-off signals, which can be in the form of sound, 
    light, or visual signals. It encodes the characters of the alphabet, 
    numerals, and punctuation marks as sequences of dots (.) and  
    dashes (\u2212). Morse code was developed in the early 1830s and 
    1840s by Samuel Morse and Alfred Vail, primarily for use in telegraphy.`, n = we(`
    Each letter or number is represented by a unique sequence of dots and dashes. 
    A dot is a short signal, while a dash is a longer one, typically three times 
    the duration of a dot. `), r = H("br"), s = z(), i = H("b"), i.textContent = "e.g:", a = we(" S= ..., O= ---, so the word SOS becomes: ...---...");
  }, m(o, f) {
    R(o, e, f), R(o, n, f), R(o, r, f), R(o, s, f), R(o, i, f), R(o, a, f);
  }, p: dt, d(o) {
    o && (D(e), D(n), D(r), D(s), D(i), D(a));
  } };
}
function gde(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Morse Code Encoder/Decoder", $$slots: { default: [dde] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Morse Code", links: t3[8], $$slots: { default: [pde] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 8223 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 8192 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function mde(t3, e, n) {
  let r = "", s = "text2morse", i = "", a = "", o = true;
  const f = [{ value: "text2morse", label: "Text to Morse Code" }, { value: "morse2text", label: "Morse Code to Text" }];
  function c() {
    if (!r) {
      n(3, i = ""), n(4, a = "");
      return;
    }
    n(4, a = "");
    try {
      n(3, i = fde(r, s));
    } catch (_) {
      n(4, a = _.message), n(3, i = "");
    }
  }
  function l() {
    n(1, s = s === "text2morse" ? "morse2text" : "text2morse"), i && !a && n(0, r = i), c();
  }
  const h = [{ text: "Morse Code - Wikipedia", url: "https://en.wikipedia.org/wiki/Morse_code" }];
  function m(_) {
    s = _, n(1, s);
  }
  function v(_) {
    r = _, n(0, r);
  }
  const b = () => {
    n(0, r = ""), n(3, i = "");
  };
  function A(_) {
    o = _, n(2, o);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 7 && o && (r || s) && c();
  }, [r, s, o, i, a, f, c, l, h, m, v, b, A];
}
class vde extends xt {
  constructor(e) {
    super(), wt(this, e, mde, gde, At, {});
  }
}
const Ks = 36, yh = 1, Kh = 26, yde = 38, bde = 700, wF = 72, xF = 128, _F = "-";
function Ade(t3, e) {
  return t3 ? e === "encode" ? wde(t3) : xde(t3) : "";
}
function wde(t3) {
  let e = [];
  t3 = String(t3);
  let n = t3.length, r = xF, s = 0, i = wF;
  for (let f of t3) f.charCodeAt(0) < 128 && e.push(f);
  let a = e.length, o = a;
  for (a > 0 && e.push(_F); o < n; ) {
    let f = Number.MAX_SAFE_INTEGER;
    for (let c of t3) {
      let l = c.codePointAt(0);
      l >= r && l < f && (f = l);
    }
    s += (f - r) * (o + 1), r = f;
    for (let c of t3) {
      let l = c.codePointAt(0);
      if (l < r) s++;
      else if (l === r) {
        let h = s;
        for (let m = Ks; ; m += Ks) {
          let v = m <= i ? yh : m >= i + Kh ? Kh : m - i;
          if (h < v) break;
          e.push(String.fromCharCode(S9(v + (h - v) % (Ks - v), 0))), h = Math.floor((h - v) / (Ks - v));
        }
        e.push(String.fromCharCode(S9(h, 0))), i = EF(s, o + 1, o === a), s = 0, o++;
      }
    }
    s++, r++;
  }
  return "xn--" + e.join("");
}
function xde(t3) {
  t3.startsWith("xn--") && (t3 = t3.substring(4));
  let e = [], n = t3.length, r = 0, s = xF, i = wF, a = t3.lastIndexOf(_F);
  if (a > 0) {
    for (let o = 0; o < a; o++) {
      let f = t3.charCodeAt(o);
      if (f >= 128) throw new Error("Invalid input: Non-basic character found");
      e.push(f);
    }
    r = a + 1;
  }
  for (; r < n; ) {
    let o = r, f = 1;
    for (let l = Ks; ; l += Ks) {
      if (r >= n) throw new Error("Invalid input: Incomplete sequence");
      let h = _de(t3.charCodeAt(r++));
      if (h >= Ks) throw new Error("Invalid input: Invalid character");
      if (h > Math.floor((Number.MAX_SAFE_INTEGER - r) / f)) throw new Error("Overflow");
      r += h * f;
      let m = l <= i ? yh : l >= i + Kh ? Kh : l - i;
      if (h < m) break;
      f *= Ks - m;
    }
    let c = e.length + 1;
    if (i = EF(r - o, c, o === 0), Math.floor(r / c) > Number.MAX_SAFE_INTEGER - s) throw new Error("Overflow");
    s += Math.floor(r / c), r %= c, e.splice(r, 0, s), r++;
  }
  return String.fromCodePoint(...e);
}
function EF(t3, e, n) {
  t3 = Math.floor(n ? t3 / bde : t3 / 2), t3 += Math.floor(t3 / e);
  let r = 0;
  for (; t3 > (Ks - yh) * Kh / 2; ) t3 = Math.floor(t3 / (Ks - yh)), r += Ks;
  return Math.floor(r + (Ks - yh + 1) * t3 / (t3 + yde));
}
function S9(t3, e) {
  return t3 + 22 + 75 * (t3 < 26) - ((e != 0) << 5);
}
function _de(t3) {
  return t3 >= 48 && t3 <= 57 ? t3 - 22 : t3 >= 65 && t3 <= 90 ? t3 - 65 : t3 >= 97 && t3 <= 122 ? t3 - 97 : Ks;
}
function Ede(t3) {
  let e;
  return { c() {
    e = we("Convert");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function Bde(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function M9(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[4]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 16 && Ze(n, r[4]);
  }, d(r) {
    r && D(e);
  } };
}
function $9(t3) {
  let e, n;
  return e = new et({ props: { label: "Result:", value: t3[3], readonly: true, expandable: true, withCopy: true } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, s) {
    const i = {};
    s & 8 && (i.value = r[3]), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function Cde(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F;
  function U(d) {
    t3[8](d);
  }
  let Q = { label: "Operation:", options: t3[5] };
  t3[1] !== void 0 && (Q.value = t3[1]), n = new Ht({ props: Q }), Qe.push(() => ze(n, "value", U));
  function P(d) {
    t3[9](d);
  }
  let N = { label: t3[1] === "encode" ? "Unicode Domain (e.g. m\xFCnich):" : "Punycode (e.g. xn--mnich-kva):", placeholder: t3[1] === "encode" ? "Type non-ASCII text..." : "Type xn-- string...", expandable: true };
  t3[0] !== void 0 && (N.value = t3[0]), i = new et({ props: N }), Qe.push(() => ze(i, "value", P)), c = new ut({ props: { $$slots: { default: [Ede] }, $$scope: { ctx: t3 } } }), c.$on("click", t3[6]), h = new ut({ props: { variant: "secondary", $$slots: { default: [Bde] }, $$scope: { ctx: t3 } } }), h.$on("click", t3[10]), v = new hn({}), v.$on("click", t3[7]);
  function L(d) {
    t3[11](d);
  }
  let B = {};
  t3[2] !== void 0 && (B.checked = t3[2]), _ = new xr({ props: B }), Qe.push(() => ze(_, "checked", L));
  let u = t3[4] && M9(t3), p = t3[3] && $9(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), fe(i.$$.fragment), o = z(), f = H("div"), fe(c.$$.fragment), l = z(), fe(h.$$.fragment), m = z(), fe(v.$$.fragment), b = z(), A = H("div"), fe(_.$$.fragment), I = z(), u && u.c(), S = z(), p && p.c(), $ = Lt(), V(e, "class", "controls-row"), St(A, "margin-left", "auto"), V(f, "class", "button-row");
  }, m(d, y) {
    R(d, e, y), ae(n, e, null), R(d, s, y), ae(i, d, y), R(d, o, y), R(d, f, y), ae(c, f, null), q(f, l), ae(h, f, null), q(f, m), ae(v, f, null), q(f, b), q(f, A), ae(_, A, null), R(d, I, y), u && u.m(d, y), R(d, S, y), p && p.m(d, y), R(d, $, y), F = true;
  }, p(d, y) {
    const w = {};
    !r && y & 2 && (r = true, w.value = d[1], qe(() => r = false)), n.$set(w);
    const E = {};
    y & 2 && (E.label = d[1] === "encode" ? "Unicode Domain (e.g. m\xFCnich):" : "Punycode (e.g. xn--mnich-kva):"), y & 2 && (E.placeholder = d[1] === "encode" ? "Type non-ASCII text..." : "Type xn-- string..."), !a && y & 1 && (a = true, E.value = d[0], qe(() => a = false)), i.$set(E);
    const M = {};
    y & 4096 && (M.$$scope = { dirty: y, ctx: d }), c.$set(M);
    const x = {};
    y & 4096 && (x.$$scope = { dirty: y, ctx: d }), h.$set(x);
    const g = {};
    !C && y & 4 && (C = true, g.checked = d[2], qe(() => C = false)), _.$set(g), d[4] ? u ? u.p(d, y) : (u = M9(d), u.c(), u.m(S.parentNode, S)) : u && (u.d(1), u = null), d[3] ? p ? (p.p(d, y), y & 8 && W(p, 1)) : (p = $9(d), p.c(), W(p, 1), p.m($.parentNode, $)) : p && (Xt(), j(p, 1, 1, () => {
      p = null;
    }), er());
  }, i(d) {
    F || (W(n.$$.fragment, d), W(i.$$.fragment, d), W(c.$$.fragment, d), W(h.$$.fragment, d), W(v.$$.fragment, d), W(_.$$.fragment, d), W(p), F = true);
  }, o(d) {
    j(n.$$.fragment, d), j(i.$$.fragment, d), j(c.$$.fragment, d), j(h.$$.fragment, d), j(v.$$.fragment, d), j(_.$$.fragment, d), j(p), F = false;
  }, d(d) {
    d && (D(e), D(s), D(o), D(f), D(I), D(S), D($)), oe(n), oe(i, d), oe(c), oe(h), oe(v), oe(_), u && u.d(d), p && p.d(d);
  } };
}
function kde(t3) {
  let e, n, r, s, i, a, o;
  return { c() {
    e = H("p"), e.innerHTML = `Punycode is a way to represent Unicode characters using ASCII characters only.<br/>
    It is mainly used for Internationalized Domain Names (IDNs) to allow non-ASCII characters in web addresses.<br/><br/> <b>Example:</b><br/>
    m\xFCnich \u2192 mnich-kva<br/>
    caf\xE9 \u2192 caf-dma<br/><br/>`, n = z(), r = H("p"), r.innerHTML = "<strong>How it works:</strong>", s = z(), i = H("ul"), i.innerHTML = "<li>The domain <code>m\xFCnich.com</code> contains the special character &#39;\xFC&#39;.</li> <li>Punycode keeps the basic letters (&#39;mnich&#39;) and moves the special info to the end.</li> <li>The result is prefixed with <code>xn--</code> to tell browsers it is encoded.</li> <li>Result: <code>xn--mnich-kva.com</code></li>", a = z(), o = H("p"), o.textContent = "This allows international domains (IDNs) to work on the existing internet infrastructure.";
  }, m(f, c) {
    R(f, e, c), R(f, n, c), R(f, r, c), R(f, s, c), R(f, i, c), R(f, a, c), R(f, o, c);
  }, p: dt, d(f) {
    f && (D(e), D(n), D(r), D(s), D(i), D(a), D(o));
  } };
}
function Ide(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Punycode Converter", $$slots: { default: [Cde] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Punycode", links: [{ text: "Punycode - Wikipedia", url: "https://en.wikipedia.org/wiki/Punycode" }], $$slots: { default: [kde] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 4127 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 4096 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function Sde(t3, e, n) {
  let r = "", s = "encode", i = "", a = "", o = true;
  const f = [{ value: "encode", label: "Unicode to Punycode" }, { value: "decode", label: "Punycode to Unicode" }];
  function c() {
    if (!r) {
      n(3, i = ""), n(4, a = "");
      return;
    }
    n(4, a = "");
    try {
      n(3, i = Ade(r, s));
    } catch (A) {
      n(4, a = A.message), n(3, i = "");
    }
  }
  function l() {
    n(1, s = s === "encode" ? "decode" : "encode"), i && !a && n(0, r = i), c();
  }
  function h(A) {
    s = A, n(1, s);
  }
  function m(A) {
    r = A, n(0, r);
  }
  const v = () => {
    n(0, r = ""), n(3, i = "");
  };
  function b(A) {
    o = A, n(2, o);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 7 && o && (r || s) && c();
  }, [r, s, o, i, a, f, c, l, h, m, v, b];
}
class Mde extends xt {
  constructor(e) {
    super(), wt(this, e, Sde, Ide, At, {});
  }
}
function $de(t3, e) {
  return t3 ? e === "encode" ? Tde(t3) : Dde(t3) : "";
}
function Tde(t3) {
  const n = new TextEncoder().encode(t3);
  let r = "";
  for (let s = 0; s < n.length; s++) {
    const i = n[s];
    i >= 33 && i <= 126 && i !== 61 || (i === 32 || i === 9) ? r += String.fromCharCode(i) : r += "=" + i.toString(16).toUpperCase().padStart(2, "0");
  }
  return Rde(r, 76);
}
function Dde(t3) {
  let e = t3.replace(/=\r?\n/g, "");
  const n = [];
  for (let s = 0; s < e.length; s++) {
    const i = e[s];
    if (i === "=") {
      const a = e.substr(s + 1, 2);
      /^[0-9A-Fa-f]{2}$/.test(a) ? (n.push(parseInt(a, 16)), s += 2) : n.push(61);
    } else n.push(i.charCodeAt(0));
  }
  return new TextDecoder("utf-8").decode(new Uint8Array(n));
}
function Rde(t3, e) {
  let n = "", r = 0;
  for (let s = 0; s < t3.length; s++) {
    const i = t3[s];
    r >= e - 1 && (n += `=
`, r = 0), n += i, r++, i === `
` && (r = 0);
  }
  return n;
}
function Fde(t3) {
  let e;
  return { c() {
    e = we("Convert");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function Pde(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function T9(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[4]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 16 && Ze(n, r[4]);
  }, d(r) {
    r && D(e);
  } };
}
function D9(t3) {
  let e, n;
  return e = new et({ props: { label: "Result:", value: t3[3], readonly: true, expandable: true, withCopy: true, monospace: true } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, s) {
    const i = {};
    s & 8 && (i.value = r[3]), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function Nde(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F;
  function U(d) {
    t3[8](d);
  }
  let Q = { label: "Operation:", options: t3[5] };
  t3[1] !== void 0 && (Q.value = t3[1]), n = new Ht({ props: Q }), Qe.push(() => ze(n, "value", U));
  function P(d) {
    t3[9](d);
  }
  let N = { label: t3[1] === "encode" ? "Input Text:" : "Input Encoded Data:", placeholder: t3[1] === "encode" ? "e.g. M\xFCnchen" : "e.g. M=C3=BCnchen", expandable: true };
  t3[0] !== void 0 && (N.value = t3[0]), i = new et({ props: N }), Qe.push(() => ze(i, "value", P)), c = new ut({ props: { $$slots: { default: [Fde] }, $$scope: { ctx: t3 } } }), c.$on("click", t3[6]), h = new ut({ props: { variant: "secondary", $$slots: { default: [Pde] }, $$scope: { ctx: t3 } } }), h.$on("click", t3[10]), v = new hn({}), v.$on("click", t3[7]);
  function L(d) {
    t3[11](d);
  }
  let B = {};
  t3[2] !== void 0 && (B.checked = t3[2]), _ = new xr({ props: B }), Qe.push(() => ze(_, "checked", L));
  let u = t3[4] && T9(t3), p = t3[3] && D9(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), fe(i.$$.fragment), o = z(), f = H("div"), fe(c.$$.fragment), l = z(), fe(h.$$.fragment), m = z(), fe(v.$$.fragment), b = z(), A = H("div"), fe(_.$$.fragment), I = z(), u && u.c(), S = z(), p && p.c(), $ = Lt(), V(e, "class", "controls-row"), St(A, "margin-left", "auto"), V(f, "class", "button-row");
  }, m(d, y) {
    R(d, e, y), ae(n, e, null), R(d, s, y), ae(i, d, y), R(d, o, y), R(d, f, y), ae(c, f, null), q(f, l), ae(h, f, null), q(f, m), ae(v, f, null), q(f, b), q(f, A), ae(_, A, null), R(d, I, y), u && u.m(d, y), R(d, S, y), p && p.m(d, y), R(d, $, y), F = true;
  }, p(d, y) {
    const w = {};
    !r && y & 2 && (r = true, w.value = d[1], qe(() => r = false)), n.$set(w);
    const E = {};
    y & 2 && (E.label = d[1] === "encode" ? "Input Text:" : "Input Encoded Data:"), y & 2 && (E.placeholder = d[1] === "encode" ? "e.g. M\xFCnchen" : "e.g. M=C3=BCnchen"), !a && y & 1 && (a = true, E.value = d[0], qe(() => a = false)), i.$set(E);
    const M = {};
    y & 4096 && (M.$$scope = { dirty: y, ctx: d }), c.$set(M);
    const x = {};
    y & 4096 && (x.$$scope = { dirty: y, ctx: d }), h.$set(x);
    const g = {};
    !C && y & 4 && (C = true, g.checked = d[2], qe(() => C = false)), _.$set(g), d[4] ? u ? u.p(d, y) : (u = T9(d), u.c(), u.m(S.parentNode, S)) : u && (u.d(1), u = null), d[3] ? p ? (p.p(d, y), y & 8 && W(p, 1)) : (p = D9(d), p.c(), W(p, 1), p.m($.parentNode, $)) : p && (Xt(), j(p, 1, 1, () => {
      p = null;
    }), er());
  }, i(d) {
    F || (W(n.$$.fragment, d), W(i.$$.fragment, d), W(c.$$.fragment, d), W(h.$$.fragment, d), W(v.$$.fragment, d), W(_.$$.fragment, d), W(p), F = true);
  }, o(d) {
    j(n.$$.fragment, d), j(i.$$.fragment, d), j(c.$$.fragment, d), j(h.$$.fragment, d), j(v.$$.fragment, d), j(_.$$.fragment, d), j(p), F = false;
  }, d(d) {
    d && (D(e), D(s), D(o), D(f), D(I), D(S), D($)), oe(n), oe(i, d), oe(c), oe(h), oe(v), oe(_), u && u.d(d), p && p.d(d);
  } };
}
function Ude(t3) {
  let e, n, r, s, i, a, o;
  return { c() {
    e = H("p"), e.innerHTML = "<strong>Quoted-Printable</strong> (QP) is an encoding used for email (MIME) to ensure safe delivery of text.", n = z(), r = H("p"), r.innerHTML = `Legacy email systems often only support 7-bit ASCII characters (English letters/numbers). 
    If you try to send special characters (like <code>=</code>, <code>\xFC</code>, or emojis), they might break the system.`, s = z(), i = H("p"), i.innerHTML = "<strong>How it works:</strong>", a = z(), o = H("ul"), o.innerHTML = `<li>Standard characters (<code>A-Z</code>) are left alone.</li> <li>Special characters are converted to <code>=</code> followed by their Hex code.
      <br/>Example: <code>=</code> becomes <code>=3D</code>.</li> <li>Lines are limited to 76 characters. Long lines are &quot;soft wrapped&quot; by adding an <code>=</code> at the end of the line.</li>`;
  }, m(f, c) {
    R(f, e, c), R(f, n, c), R(f, r, c), R(f, s, c), R(f, i, c), R(f, a, c), R(f, o, c);
  }, p: dt, d(f) {
    f && (D(e), D(n), D(r), D(s), D(i), D(a), D(o));
  } };
}
function Lde(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Quoted-Printable Encoding", $$slots: { default: [Nde] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Quoted-Printable", links: [{ text: "QP - Wikipedia", url: "https://en.wikipedia.org/wiki/Quoted-printable" }], $$slots: { default: [Ude] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 4127 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 4096 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function Ode(t3, e, n) {
  let r = "", s = "encode", i = "", a = "", o = true;
  const f = [{ value: "encode", label: "Text to Quoted-Printable" }, { value: "decode", label: "Quoted-Printable to Text" }];
  function c() {
    if (!r) {
      n(3, i = ""), n(4, a = "");
      return;
    }
    n(4, a = "");
    try {
      n(3, i = $de(r, s));
    } catch (A) {
      n(4, a = A.message), n(3, i = "");
    }
  }
  function l() {
    n(1, s = s === "encode" ? "decode" : "encode"), i && !a && n(0, r = i), c();
  }
  function h(A) {
    s = A, n(1, s);
  }
  function m(A) {
    r = A, n(0, r);
  }
  const v = () => {
    n(0, r = ""), n(3, i = "");
  };
  function b(A) {
    o = A, n(2, o);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 7 && o && (r || s) && c();
  }, [r, s, o, i, a, f, c, l, h, m, v, b];
}
class Qde extends xt {
  constructor(e) {
    super(), wt(this, e, Ode, Lde, At, {});
  }
}
function Kde(t3, e) {
  return t3 ? e === "encode" ? Hde(t3) : qde(t3) : "";
}
function Hde(t3) {
  let e = encodeURIComponent(t3);
  return e = e.replace(/%20/g, "+"), e;
}
function qde(t3) {
  const e = t3.replace(/\+/g, "%20");
  try {
    return decodeURIComponent(e);
  } catch {
    throw new Error("Malformed URI sequence.");
  }
}
function zde(t3) {
  let e;
  return { c() {
    e = we("Convert");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function Gde(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function R9(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[4]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 16 && Ze(n, r[4]);
  }, d(r) {
    r && D(e);
  } };
}
function F9(t3) {
  let e, n;
  return e = new et({ props: { label: "Result:", value: t3[3], readonly: true, expandable: true, withCopy: true } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, s) {
    const i = {};
    s & 8 && (i.value = r[3]), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function Vde(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F;
  function U(d) {
    t3[8](d);
  }
  let Q = { label: "Operation:", options: t3[5] };
  t3[1] !== void 0 && (Q.value = t3[1]), n = new Ht({ props: Q }), Qe.push(() => ze(n, "value", U));
  function P(d) {
    t3[9](d);
  }
  let N = { label: t3[1] === "encode" ? "Input Text:" : "Input URL Parameter:", placeholder: t3[1] === "encode" ? "e.g. C++ Programming" : "e.g. C%2B%2B+Programming", expandable: true };
  t3[0] !== void 0 && (N.value = t3[0]), i = new et({ props: N }), Qe.push(() => ze(i, "value", P)), c = new ut({ props: { $$slots: { default: [zde] }, $$scope: { ctx: t3 } } }), c.$on("click", t3[6]), h = new ut({ props: { variant: "secondary", $$slots: { default: [Gde] }, $$scope: { ctx: t3 } } }), h.$on("click", t3[10]), v = new hn({}), v.$on("click", t3[7]);
  function L(d) {
    t3[11](d);
  }
  let B = {};
  t3[2] !== void 0 && (B.checked = t3[2]), _ = new xr({ props: B }), Qe.push(() => ze(_, "checked", L));
  let u = t3[4] && R9(t3), p = t3[3] && F9(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), fe(i.$$.fragment), o = z(), f = H("div"), fe(c.$$.fragment), l = z(), fe(h.$$.fragment), m = z(), fe(v.$$.fragment), b = z(), A = H("div"), fe(_.$$.fragment), I = z(), u && u.c(), S = z(), p && p.c(), $ = Lt(), V(e, "class", "controls-row"), St(A, "margin-left", "auto"), V(f, "class", "button-row");
  }, m(d, y) {
    R(d, e, y), ae(n, e, null), R(d, s, y), ae(i, d, y), R(d, o, y), R(d, f, y), ae(c, f, null), q(f, l), ae(h, f, null), q(f, m), ae(v, f, null), q(f, b), q(f, A), ae(_, A, null), R(d, I, y), u && u.m(d, y), R(d, S, y), p && p.m(d, y), R(d, $, y), F = true;
  }, p(d, y) {
    const w = {};
    !r && y & 2 && (r = true, w.value = d[1], qe(() => r = false)), n.$set(w);
    const E = {};
    y & 2 && (E.label = d[1] === "encode" ? "Input Text:" : "Input URL Parameter:"), y & 2 && (E.placeholder = d[1] === "encode" ? "e.g. C++ Programming" : "e.g. C%2B%2B+Programming"), !a && y & 1 && (a = true, E.value = d[0], qe(() => a = false)), i.$set(E);
    const M = {};
    y & 4096 && (M.$$scope = { dirty: y, ctx: d }), c.$set(M);
    const x = {};
    y & 4096 && (x.$$scope = { dirty: y, ctx: d }), h.$set(x);
    const g = {};
    !C && y & 4 && (C = true, g.checked = d[2], qe(() => C = false)), _.$set(g), d[4] ? u ? u.p(d, y) : (u = R9(d), u.c(), u.m(S.parentNode, S)) : u && (u.d(1), u = null), d[3] ? p ? (p.p(d, y), y & 8 && W(p, 1)) : (p = F9(d), p.c(), W(p, 1), p.m($.parentNode, $)) : p && (Xt(), j(p, 1, 1, () => {
      p = null;
    }), er());
  }, i(d) {
    F || (W(n.$$.fragment, d), W(i.$$.fragment, d), W(c.$$.fragment, d), W(h.$$.fragment, d), W(v.$$.fragment, d), W(_.$$.fragment, d), W(p), F = true);
  }, o(d) {
    j(n.$$.fragment, d), j(i.$$.fragment, d), j(c.$$.fragment, d), j(h.$$.fragment, d), j(v.$$.fragment, d), j(_.$$.fragment, d), j(p), F = false;
  }, d(d) {
    d && (D(e), D(s), D(o), D(f), D(I), D(S), D($)), oe(n), oe(i, d), oe(c), oe(h), oe(v), oe(_), u && u.d(d), p && p.d(d);
  } };
}
function Yde(t3) {
  let e, n, r;
  return { c() {
    e = H("p"), e.innerHTML = `<b>URL encoding</b>, also known as percent encoding, is a method 
    used to encode special characters in a Uniform Resource Locator (URL) 
    so they can be safely transmitted over the Internet. URLs can only be 
    sent over the Internet using the ASCII character set. Since URLs often 
    contain characters outside the ASCII set, URL encoding is used to 
    convert them into a valid ASCII format. URL encoding replaces non-ASCII 
    characters or reserved characters with a &#39;%&#39; followed by two hexadecimal
    digits representing the character\u2019s ASCII code. For example, a space 
    character, which is not allowed in a URL, is encoded as %20 or +.`, n = z(), r = H("p"), r.innerHTML = `<b>e.g.:</b> https://example.com/search?q=C++ programming <b>becomes:</b> 
    https://example.com/search?q=C%2B%2B%20programming`;
  }, m(s, i) {
    R(s, e, i), R(s, n, i), R(s, r, i);
  }, p: dt, d(s) {
    s && (D(e), D(n), D(r));
  } };
}
function Wde(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "URL Encoder / Decoder", $$slots: { default: [Vde] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About URL Encoding", links: [{ text: "Percent-encoding -Wikipedia", url: "https://en.wikipedia.org/wiki/Percent-encoding" }], $$slots: { default: [Yde] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 4127 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 4096 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function Jde(t3, e, n) {
  let r = "", s = "encode", i = "", a = "", o = true;
  const f = [{ value: "encode", label: "Text to URL Encoded" }, { value: "decode", label: "URL Encoded to Text" }];
  function c() {
    if (!r) {
      n(3, i = ""), n(4, a = "");
      return;
    }
    n(4, a = "");
    try {
      n(3, i = Kde(r, s));
    } catch (A) {
      n(4, a = A.message), n(3, i = "");
    }
  }
  function l() {
    n(1, s = s === "encode" ? "decode" : "encode"), i && !a && n(0, r = i), c();
  }
  function h(A) {
    s = A, n(1, s);
  }
  function m(A) {
    r = A, n(0, r);
  }
  const v = () => {
    n(0, r = ""), n(3, i = "");
  };
  function b(A) {
    o = A, n(2, o);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 7 && o && (r || s) && c();
  }, [r, s, o, i, a, f, c, l, h, m, v, b];
}
class Zde extends xt {
  constructor(e) {
    super(), wt(this, e, Jde, Wde, At, {});
  }
}
function jde(t3, e, n) {
  return t3 ? n === "encode" ? Xde(t3, e) : epe(t3, e) : "";
}
function Xde(t3, e) {
  let n;
  switch (e) {
    case "utf-8":
      n = new TextEncoder().encode(t3);
      break;
    case "utf-16le":
    case "utf-16be":
      n = tpe(t3, e === "utf-16be");
      break;
    case "utf-32le":
    case "utf-32be":
      n = rpe(t3, e === "utf-32be");
      break;
    default:
      throw new Error(`Unsupported encoding: ${e}`);
  }
  return Array.from(n).map((r) => `\\x${r.toString(16).padStart(2, "0").toUpperCase()}`).join("");
}
function epe(t3, e) {
  const n = t3.replace(/(\\x|0x|\s|,)/g, "");
  if (n.length % 2 !== 0) throw new Error("Invalid Hex string. Length must be even.");
  const r = n.length / 2, s = new Uint8Array(r);
  for (let i = 0; i < r; i++) s[i] = parseInt(n.substr(i * 2, 2), 16);
  try {
    return new TextDecoder(e).decode(s);
  } catch (i) {
    if (e.endsWith("be")) return npe(s, e);
    throw new Error(`Error decoding ${e}: ${i.message}`);
  }
}
function tpe(t3, e) {
  const n = [];
  for (let r = 0; r < t3.length; r++) {
    const s = t3.charCodeAt(r), i = s & 255, a = s >> 8 & 255;
    e ? n.push(a, i) : n.push(i, a);
  }
  return new Uint8Array(n);
}
function rpe(t3, e) {
  const n = [];
  for (let r of t3) {
    const s = r.codePointAt(0), i = s & 255, a = s >> 8 & 255, o = s >> 16 & 255, f = s >> 24 & 255;
    e ? n.push(f, o, a, i) : n.push(i, a, o, f);
  }
  return new Uint8Array(n);
}
function npe(t3, e) {
  let n = "";
  const r = e.includes("32") ? 4 : 2;
  for (let s = 0; s < t3.length; s += r) {
    let i = 0;
    r === 2 ? i = t3[s] << 8 | t3[s + 1] : i = t3[s] << 24 | t3[s + 1] << 16 | t3[s + 2] << 8 | t3[s + 3], n += String.fromCodePoint(i);
  }
  return n;
}
function ipe(t3) {
  let e;
  return { c() {
    e = we("Convert");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function spe(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function P9(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[5]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 32 && Ze(n, r[5]);
  }, d(r) {
    r && D(e);
  } };
}
function N9(t3) {
  let e, n;
  return e = new et({ props: { label: "Result:", value: t3[4], readonly: true, expandable: true, withCopy: true, monospace: true } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, s) {
    const i = {};
    s & 16 && (i.value = r[4]), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function ape(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U, Q, P;
  function N(x) {
    t3[10](x);
  }
  let L = { label: "Operation:", options: t3[6] };
  t3[1] !== void 0 && (L.value = t3[1]), n = new Ht({ props: L }), Qe.push(() => ze(n, "value", N));
  function B(x) {
    t3[11](x);
  }
  let u = { label: "Encoding Standard:", options: t3[7] };
  t3[2] !== void 0 && (u.value = t3[2]), i = new Ht({ props: u }), Qe.push(() => ze(i, "value", B));
  function p(x) {
    t3[12](x);
  }
  let d = { label: t3[1] === "encode" ? "Input Text:" : "Input Bytes (Hex):", placeholder: t3[1] === "encode" ? "Type text..." : "\\x48\\x69 or 48 69", expandable: true };
  t3[0] !== void 0 && (d.value = t3[0]), f = new et({ props: d }), Qe.push(() => ze(f, "value", p)), m = new ut({ props: { $$slots: { default: [ipe] }, $$scope: { ctx: t3 } } }), m.$on("click", t3[8]), b = new ut({ props: { variant: "secondary", $$slots: { default: [spe] }, $$scope: { ctx: t3 } } }), b.$on("click", t3[13]), _ = new hn({}), _.$on("click", t3[9]);
  function y(x) {
    t3[14](x);
  }
  let w = {};
  t3[3] !== void 0 && (w.checked = t3[3]), S = new xr({ props: w }), Qe.push(() => ze(S, "checked", y));
  let E = t3[5] && P9(t3), M = t3[4] && N9(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), fe(i.$$.fragment), o = z(), fe(f.$$.fragment), l = z(), h = H("div"), fe(m.$$.fragment), v = z(), fe(b.$$.fragment), A = z(), fe(_.$$.fragment), C = z(), I = H("div"), fe(S.$$.fragment), F = z(), E && E.c(), U = z(), M && M.c(), Q = Lt(), V(e, "class", "controls-row"), St(I, "margin-left", "auto"), V(h, "class", "button-row");
  }, m(x, g) {
    R(x, e, g), ae(n, e, null), q(e, s), ae(i, e, null), R(x, o, g), ae(f, x, g), R(x, l, g), R(x, h, g), ae(m, h, null), q(h, v), ae(b, h, null), q(h, A), ae(_, h, null), q(h, C), q(h, I), ae(S, I, null), R(x, F, g), E && E.m(x, g), R(x, U, g), M && M.m(x, g), R(x, Q, g), P = true;
  }, p(x, g) {
    const k = {};
    !r && g & 2 && (r = true, k.value = x[1], qe(() => r = false)), n.$set(k);
    const T = {};
    !a && g & 4 && (a = true, T.value = x[2], qe(() => a = false)), i.$set(T);
    const O = {};
    g & 2 && (O.label = x[1] === "encode" ? "Input Text:" : "Input Bytes (Hex):"), g & 2 && (O.placeholder = x[1] === "encode" ? "Type text..." : "\\x48\\x69 or 48 69"), !c && g & 1 && (c = true, O.value = x[0], qe(() => c = false)), f.$set(O);
    const K = {};
    g & 32768 && (K.$$scope = { dirty: g, ctx: x }), m.$set(K);
    const Y = {};
    g & 32768 && (Y.$$scope = { dirty: g, ctx: x }), b.$set(Y);
    const J = {};
    !$ && g & 8 && ($ = true, J.checked = x[3], qe(() => $ = false)), S.$set(J), x[5] ? E ? E.p(x, g) : (E = P9(x), E.c(), E.m(U.parentNode, U)) : E && (E.d(1), E = null), x[4] ? M ? (M.p(x, g), g & 16 && W(M, 1)) : (M = N9(x), M.c(), W(M, 1), M.m(Q.parentNode, Q)) : M && (Xt(), j(M, 1, 1, () => {
      M = null;
    }), er());
  }, i(x) {
    P || (W(n.$$.fragment, x), W(i.$$.fragment, x), W(f.$$.fragment, x), W(m.$$.fragment, x), W(b.$$.fragment, x), W(_.$$.fragment, x), W(S.$$.fragment, x), W(M), P = true);
  }, o(x) {
    j(n.$$.fragment, x), j(i.$$.fragment, x), j(f.$$.fragment, x), j(m.$$.fragment, x), j(b.$$.fragment, x), j(_.$$.fragment, x), j(S.$$.fragment, x), j(M), P = false;
  }, d(x) {
    x && (D(e), D(o), D(l), D(h), D(F), D(U), D(Q)), oe(n), oe(i), oe(f, x), oe(m), oe(b), oe(_), oe(S), E && E.d(x), M && M.d(x);
  } };
}
function ope(t3) {
  let e, n, r, s, i, a, o;
  return { c() {
    e = H("p"), e.innerHTML = `<b>Unicode Transformation Formats (UTFs)</b> are a set of methods 
    used to encode Unicode characters so they can be efficiently 
    represented in computer systems. Unicode itself is a 
    standardized encoding system that assigns a unique code point 
    (an integer) to every character across different languages, scripts, 
    and symbols worldwide. However, storing or transmitting these 
    code points directly as integers isn&#39;t always practical, 
    so Unicode Transformation Formats come into play to encode 
    these code points into sequences of bytes.`, n = z(), r = H("ul"), r.innerHTML = `<li><strong>UTF-8:</strong> UTF-8 is the most widely used Unicode encoding 
    and is variable-length. It uses 1 to 4 bytes to represent a character.</li> <li><strong>UTF-16:</strong> UTF-16 is also a variable-length encoding, using either 2 or 4 bytes. Used by Windows and Java.</li> <li><strong>UTF-32:</strong> UTF-32 is a fixed-length encoding that uses 4 bytes for every 
    character, regardless of the code point. Simple but uses more memory.</li>`, s = z(), i = H("strong"), i.textContent = "Endianness (LE/BE):", a = we(` Refers to the order of bytes:
    `), o = H("ul"), o.innerHTML = "<li><em>Little Endian (LE)</em> stores the least significant byte first (common on Intel/Apple silicon).</li> <li><em>Big Endian (BE)</em> stores the most significant byte first (network standard).</li>";
  }, m(f, c) {
    R(f, e, c), R(f, n, c), R(f, r, c), R(f, s, c), R(f, i, c), R(f, a, c), R(f, o, c);
  }, p: dt, d(f) {
    f && (D(e), D(n), D(r), D(s), D(i), D(a), D(o));
  } };
}
function fpe(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "UTF Encoder / Decoder", $$slots: { default: [ape] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About UTF Encodings", $$slots: { default: [ope] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 32831 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 32768 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function lpe(t3, e, n) {
  let r = "", s = "encode", i = "utf-8", a = "", o = "", f = true;
  const c = [{ value: "encode", label: "Text to Bytes (Hex)" }, { value: "decode", label: "Bytes (Hex) to Text" }], l = [{ value: "utf-8", label: "UTF-8" }, { value: "utf-16le", label: "UTF-16 LE (Little Endian)" }, { value: "utf-16be", label: "UTF-16 BE (Big Endian)" }, { value: "utf-32le", label: "UTF-32 LE" }, { value: "utf-32be", label: "UTF-32 BE" }];
  function h() {
    if (!r) {
      n(4, a = ""), n(5, o = "");
      return;
    }
    n(5, o = "");
    try {
      n(4, a = jde(r, i, s));
    } catch (I) {
      n(5, o = I.message), n(4, a = "");
    }
  }
  function m() {
    n(1, s = s === "encode" ? "decode" : "encode"), a && !o && n(0, r = a), h();
  }
  function v(I) {
    s = I, n(1, s);
  }
  function b(I) {
    i = I, n(2, i);
  }
  function A(I) {
    r = I, n(0, r);
  }
  const _ = () => {
    n(0, r = ""), n(4, a = "");
  };
  function C(I) {
    f = I, n(3, f);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 15 && f && (r || s || i) && h();
  }, [r, s, i, f, a, o, c, l, h, m, v, b, A, _, C];
}
class upe extends xt {
  constructor(e) {
    super(), wt(this, e, lpe, fpe, At, {});
  }
}
function cpe(t3, e, n, r) {
  if (typeof t3.setBigUint64 == "function") return t3.setBigUint64(e, n, r);
  const s = BigInt(32), i = BigInt(4294967295), a = Number(n >> s & i), o = Number(n & i), f = r ? 4 : 0, c = r ? 0 : 4;
  t3.setUint32(e + f, a, r), t3.setUint32(e + c, o, r);
}
function hpe(t3, e, n) {
  return t3 & e ^ ~t3 & n;
}
function dpe(t3, e, n) {
  return t3 & e ^ t3 & n ^ e & n;
}
class L4 extends Bm {
  constructor(e, n, r, s) {
    super(), this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.blockLen = e, this.outputLen = n, this.padOffset = r, this.isLE = s, this.buffer = new Uint8Array(e), this.view = my(this.buffer);
  }
  update(e) {
    lf(this), e = rs(e), Ra(e);
    const { view: n, buffer: r, blockLen: s } = this, i = e.length;
    for (let a = 0; a < i; ) {
      const o = Math.min(s - this.pos, i - a);
      if (o === s) {
        const f = my(e);
        for (; s <= i - a; a += s) this.process(f, a);
        continue;
      }
      r.set(e.subarray(a, a + o), this.pos), this.pos += o, a += o, this.pos === s && (this.process(n, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    lf(this), Em(e, this), this.finished = true;
    const { buffer: n, view: r, blockLen: s, isLE: i } = this;
    let { pos: a } = this;
    n[a++] = 128, Li(this.buffer.subarray(a)), this.padOffset > s - a && (this.process(r, 0), a = 0);
    for (let h = a; h < s; h++) n[h] = 0;
    cpe(r, s - 8, BigInt(this.length * 8), i), this.process(r, 0);
    const o = my(e), f = this.outputLen;
    if (f % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const c = f / 4, l = this.get();
    if (c > l.length) throw new Error("_sha2: outputLen bigger than state");
    for (let h = 0; h < c; h++) o.setUint32(4 * h, l[h], i);
  }
  digest() {
    const { buffer: e, outputLen: n } = this;
    this.digestInto(e);
    const r = e.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: n, buffer: r, length: s, finished: i, destroyed: a, pos: o } = this;
    return e.destroyed = a, e.finished = i, e.length = s, e.pos = o, s % n && e.buffer.set(r), e;
  }
  clone() {
    return this._cloneInto();
  }
}
const Ga = Uint32Array.from([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]), If = Uint32Array.from([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]), ji = Uint32Array.from([3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]), Xi = Uint32Array.from([1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209]), cp = BigInt(2 ** 32 - 1), U9 = BigInt(32);
function Hh(t3, e = false) {
  return e ? { h: Number(t3 & cp), l: Number(t3 >> U9 & cp) } : { h: Number(t3 >> U9 & cp) | 0, l: Number(t3 & cp) | 0 };
}
function BF(t3, e = false) {
  const n = t3.length;
  let r = new Uint32Array(n), s = new Uint32Array(n);
  for (let i = 0; i < n; i++) {
    const { h: a, l: o } = Hh(t3[i], e);
    [r[i], s[i]] = [a, o];
  }
  return [r, s];
}
const L9 = (t3, e, n) => t3 >>> n, O9 = (t3, e, n) => t3 << 32 - n | e >>> n, Qf = (t3, e, n) => t3 >>> n | e << 32 - n, Kf = (t3, e, n) => t3 << 32 - n | e >>> n, th = (t3, e, n) => t3 << 64 - n | e >>> n - 32, rh = (t3, e, n) => t3 >>> n - 32 | e << 64 - n, ppe = (t3, e) => e, gpe = (t3, e) => t3, mpe = (t3, e, n) => t3 << n | e >>> 32 - n, vpe = (t3, e, n) => e << n | t3 >>> 32 - n, ype = (t3, e, n) => e << n - 32 | t3 >>> 64 - n, bpe = (t3, e, n) => t3 << n - 32 | e >>> 64 - n;
function _a(t3, e, n, r) {
  const s = (e >>> 0) + (r >>> 0);
  return { h: t3 + n + (s / 2 ** 32 | 0) | 0, l: s | 0 };
}
const O4 = (t3, e, n) => (t3 >>> 0) + (e >>> 0) + (n >>> 0), Q4 = (t3, e, n, r) => e + n + r + (t3 / 2 ** 32 | 0) | 0, Ape = (t3, e, n, r) => (t3 >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0), wpe = (t3, e, n, r, s) => e + n + r + s + (t3 / 2 ** 32 | 0) | 0, xpe = (t3, e, n, r, s) => (t3 >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0) + (s >>> 0), _pe = (t3, e, n, r, s, i) => e + n + r + s + i + (t3 / 2 ** 32 | 0) | 0, Epe = Uint32Array.from([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]), Sf = new Uint32Array(64);
class CF extends L4 {
  constructor(e = 32) {
    super(64, e, 8, false), this.A = Ga[0] | 0, this.B = Ga[1] | 0, this.C = Ga[2] | 0, this.D = Ga[3] | 0, this.E = Ga[4] | 0, this.F = Ga[5] | 0, this.G = Ga[6] | 0, this.H = Ga[7] | 0;
  }
  get() {
    const { A: e, B: n, C: r, D: s, E: i, F: a, G: o, H: f } = this;
    return [e, n, r, s, i, a, o, f];
  }
  set(e, n, r, s, i, a, o, f) {
    this.A = e | 0, this.B = n | 0, this.C = r | 0, this.D = s | 0, this.E = i | 0, this.F = a | 0, this.G = o | 0, this.H = f | 0;
  }
  process(e, n) {
    for (let h = 0; h < 16; h++, n += 4) Sf[h] = e.getUint32(n, false);
    for (let h = 16; h < 64; h++) {
      const m = Sf[h - 15], v = Sf[h - 2], b = As(m, 7) ^ As(m, 18) ^ m >>> 3, A = As(v, 17) ^ As(v, 19) ^ v >>> 10;
      Sf[h] = A + Sf[h - 7] + b + Sf[h - 16] | 0;
    }
    let { A: r, B: s, C: i, D: a, E: o, F: f, G: c, H: l } = this;
    for (let h = 0; h < 64; h++) {
      const m = As(o, 6) ^ As(o, 11) ^ As(o, 25), v = l + m + hpe(o, f, c) + Epe[h] + Sf[h] | 0, A = (As(r, 2) ^ As(r, 13) ^ As(r, 22)) + dpe(r, s, i) | 0;
      l = c, c = f, f = o, o = a + v | 0, a = i, i = s, s = r, r = v + A | 0;
    }
    r = r + this.A | 0, s = s + this.B | 0, i = i + this.C | 0, a = a + this.D | 0, o = o + this.E | 0, f = f + this.F | 0, c = c + this.G | 0, l = l + this.H | 0, this.set(r, s, i, a, o, f, c, l);
  }
  roundClean() {
    Li(Sf);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), Li(this.buffer);
  }
}
class Bpe extends CF {
  constructor() {
    super(28), this.A = If[0] | 0, this.B = If[1] | 0, this.C = If[2] | 0, this.D = If[3] | 0, this.E = If[4] | 0, this.F = If[5] | 0, this.G = If[6] | 0, this.H = If[7] | 0;
  }
}
const kF = BF(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((t3) => BigInt(t3))), Cpe = kF[0], kpe = kF[1], Mf = new Uint32Array(80), $f = new Uint32Array(80);
class IF extends L4 {
  constructor(e = 64) {
    super(128, e, 16, false), this.Ah = Xi[0] | 0, this.Al = Xi[1] | 0, this.Bh = Xi[2] | 0, this.Bl = Xi[3] | 0, this.Ch = Xi[4] | 0, this.Cl = Xi[5] | 0, this.Dh = Xi[6] | 0, this.Dl = Xi[7] | 0, this.Eh = Xi[8] | 0, this.El = Xi[9] | 0, this.Fh = Xi[10] | 0, this.Fl = Xi[11] | 0, this.Gh = Xi[12] | 0, this.Gl = Xi[13] | 0, this.Hh = Xi[14] | 0, this.Hl = Xi[15] | 0;
  }
  get() {
    const { Ah: e, Al: n, Bh: r, Bl: s, Ch: i, Cl: a, Dh: o, Dl: f, Eh: c, El: l, Fh: h, Fl: m, Gh: v, Gl: b, Hh: A, Hl: _ } = this;
    return [e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _];
  }
  set(e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _) {
    this.Ah = e | 0, this.Al = n | 0, this.Bh = r | 0, this.Bl = s | 0, this.Ch = i | 0, this.Cl = a | 0, this.Dh = o | 0, this.Dl = f | 0, this.Eh = c | 0, this.El = l | 0, this.Fh = h | 0, this.Fl = m | 0, this.Gh = v | 0, this.Gl = b | 0, this.Hh = A | 0, this.Hl = _ | 0;
  }
  process(e, n) {
    for (let S = 0; S < 16; S++, n += 4) Mf[S] = e.getUint32(n), $f[S] = e.getUint32(n += 4);
    for (let S = 16; S < 80; S++) {
      const $ = Mf[S - 15] | 0, F = $f[S - 15] | 0, U = Qf($, F, 1) ^ Qf($, F, 8) ^ L9($, F, 7), Q = Kf($, F, 1) ^ Kf($, F, 8) ^ O9($, F, 7), P = Mf[S - 2] | 0, N = $f[S - 2] | 0, L = Qf(P, N, 19) ^ th(P, N, 61) ^ L9(P, N, 6), B = Kf(P, N, 19) ^ rh(P, N, 61) ^ O9(P, N, 6), u = Ape(Q, B, $f[S - 7], $f[S - 16]), p = wpe(u, U, L, Mf[S - 7], Mf[S - 16]);
      Mf[S] = p | 0, $f[S] = u | 0;
    }
    let { Ah: r, Al: s, Bh: i, Bl: a, Ch: o, Cl: f, Dh: c, Dl: l, Eh: h, El: m, Fh: v, Fl: b, Gh: A, Gl: _, Hh: C, Hl: I } = this;
    for (let S = 0; S < 80; S++) {
      const $ = Qf(h, m, 14) ^ Qf(h, m, 18) ^ th(h, m, 41), F = Kf(h, m, 14) ^ Kf(h, m, 18) ^ rh(h, m, 41), U = h & v ^ ~h & A, Q = m & b ^ ~m & _, P = xpe(I, F, Q, kpe[S], $f[S]), N = _pe(P, C, $, U, Cpe[S], Mf[S]), L = P | 0, B = Qf(r, s, 28) ^ th(r, s, 34) ^ th(r, s, 39), u = Kf(r, s, 28) ^ rh(r, s, 34) ^ rh(r, s, 39), p = r & i ^ r & o ^ i & o, d = s & a ^ s & f ^ a & f;
      C = A | 0, I = _ | 0, A = v | 0, _ = b | 0, v = h | 0, b = m | 0, { h, l: m } = _a(c | 0, l | 0, N | 0, L | 0), c = o | 0, l = f | 0, o = i | 0, f = a | 0, i = r | 0, a = s | 0;
      const y = O4(L, u, d);
      r = Q4(y, N, B, p), s = y | 0;
    }
    ({ h: r, l: s } = _a(this.Ah | 0, this.Al | 0, r | 0, s | 0)), { h: i, l: a } = _a(this.Bh | 0, this.Bl | 0, i | 0, a | 0), { h: o, l: f } = _a(this.Ch | 0, this.Cl | 0, o | 0, f | 0), { h: c, l } = _a(this.Dh | 0, this.Dl | 0, c | 0, l | 0), { h, l: m } = _a(this.Eh | 0, this.El | 0, h | 0, m | 0), { h: v, l: b } = _a(this.Fh | 0, this.Fl | 0, v | 0, b | 0), { h: A, l: _ } = _a(this.Gh | 0, this.Gl | 0, A | 0, _ | 0), { h: C, l: I } = _a(this.Hh | 0, this.Hl | 0, C | 0, I | 0), this.set(r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I);
  }
  roundClean() {
    Li(Mf, $f);
  }
  destroy() {
    Li(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
class Ipe extends IF {
  constructor() {
    super(48), this.Ah = ji[0] | 0, this.Al = ji[1] | 0, this.Bh = ji[2] | 0, this.Bl = ji[3] | 0, this.Ch = ji[4] | 0, this.Cl = ji[5] | 0, this.Dh = ji[6] | 0, this.Dl = ji[7] | 0, this.Eh = ji[8] | 0, this.El = ji[9] | 0, this.Fh = ji[10] | 0, this.Fl = ji[11] | 0, this.Gh = ji[12] | 0, this.Gl = ji[13] | 0, this.Hh = ji[14] | 0, this.Hl = ji[15] | 0;
  }
}
const SF = hc(() => new CF()), Spe = hc(() => new Bpe()), MF = hc(() => new IF()), $F = hc(() => new Ipe()), Mpe = { "SHA2-256": SF, "SHA2-384": $F, "SHA2-512": MF };
function $pe(t3, e, n = "utf-8") {
  if (!t3) throw new Error("Please enter some text.");
  const r = Mpe[e];
  if (!r) throw new Error(`Algorithm ${e} is not supported.`);
  let s;
  try {
    s = ps(t3, n);
  } catch (f) {
    throw new Error(f.message);
  }
  const i = r(s), a = Al(i), o = btoa(String.fromCharCode(...i));
  return { hex: a, base64: o, bitLength: i.length * 8 };
}
function Tpe(t3) {
  let e;
  return { c() {
    e = we("Generate Hash");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function Dpe(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function Q9(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[5]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 32 && Ze(n, r[5]);
  }, d(r) {
    r && D(e);
  } };
}
function K9(t3) {
  let e, n, r, s;
  return e = new et({ props: { label: t3[1] + " Hex:", value: t3[4].hex, readonly: true, expandable: true, withCopy: true } }), r = new et({ props: { label: t3[1] + " Base64:", value: t3[4].base64, readonly: true, expandable: true, withCopy: true } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, a) {
    const o = {};
    a & 2 && (o.label = i[1] + " Hex:"), a & 16 && (o.value = i[4].hex), e.$set(o);
    const f = {};
    a & 2 && (f.label = i[1] + " Base64:"), a & 16 && (f.value = i[4].base64), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function Rpe(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U;
  function Q(E) {
    t3[9](E);
  }
  let P = { label: "Algorithm:", options: t3[6] };
  t3[1] !== void 0 && (P.value = t3[1]), n = new Ht({ props: P }), Qe.push(() => ze(n, "value", Q));
  function N(E) {
    t3[10](E);
  }
  let L = { label: "Input Encoding:", options: gs.map(Npe) };
  t3[2] !== void 0 && (L.value = t3[2]), i = new Ht({ props: L }), Qe.push(() => ze(i, "value", N));
  function B(E) {
    t3[11](E);
  }
  let u = { label: "Input Data:", placeholder: t3[2] === "hex" ? "e.g. 4a 1b 3c..." : "Type text here...", expandable: true };
  t3[0] !== void 0 && (u.value = t3[0]), f = new et({ props: u }), Qe.push(() => ze(f, "value", B)), m = new ut({ props: { $$slots: { default: [Tpe] }, $$scope: { ctx: t3 } } }), m.$on("click", t3[7]), b = new ut({ props: { variant: "secondary", $$slots: { default: [Dpe] }, $$scope: { ctx: t3 } } }), b.$on("click", t3[12]);
  function p(E) {
    t3[13](E);
  }
  let d = {};
  t3[3] !== void 0 && (d.checked = t3[3]), C = new xr({ props: d }), Qe.push(() => ze(C, "checked", p));
  let y = t3[5] && Q9(t3), w = t3[4] && K9(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), fe(i.$$.fragment), o = z(), fe(f.$$.fragment), l = z(), h = H("div"), fe(m.$$.fragment), v = z(), fe(b.$$.fragment), A = z(), _ = H("div"), fe(C.$$.fragment), S = z(), y && y.c(), $ = z(), w && w.c(), F = Lt(), V(e, "class", "controls-row"), St(_, "margin-left", "auto"), V(h, "class", "button-row");
  }, m(E, M) {
    R(E, e, M), ae(n, e, null), q(e, s), ae(i, e, null), R(E, o, M), ae(f, E, M), R(E, l, M), R(E, h, M), ae(m, h, null), q(h, v), ae(b, h, null), q(h, A), q(h, _), ae(C, _, null), R(E, S, M), y && y.m(E, M), R(E, $, M), w && w.m(E, M), R(E, F, M), U = true;
  }, p(E, M) {
    const x = {};
    !r && M & 2 && (r = true, x.value = E[1], qe(() => r = false)), n.$set(x);
    const g = {};
    !a && M & 4 && (a = true, g.value = E[2], qe(() => a = false)), i.$set(g);
    const k = {};
    M & 4 && (k.placeholder = E[2] === "hex" ? "e.g. 4a 1b 3c..." : "Type text here..."), !c && M & 1 && (c = true, k.value = E[0], qe(() => c = false)), f.$set(k);
    const T = {};
    M & 16384 && (T.$$scope = { dirty: M, ctx: E }), m.$set(T);
    const O = {};
    M & 16384 && (O.$$scope = { dirty: M, ctx: E }), b.$set(O);
    const K = {};
    !I && M & 8 && (I = true, K.checked = E[3], qe(() => I = false)), C.$set(K), E[5] ? y ? y.p(E, M) : (y = Q9(E), y.c(), y.m($.parentNode, $)) : y && (y.d(1), y = null), E[4] ? w ? (w.p(E, M), M & 16 && W(w, 1)) : (w = K9(E), w.c(), W(w, 1), w.m(F.parentNode, F)) : w && (Xt(), j(w, 1, 1, () => {
      w = null;
    }), er());
  }, i(E) {
    U || (W(n.$$.fragment, E), W(i.$$.fragment, E), W(f.$$.fragment, E), W(m.$$.fragment, E), W(b.$$.fragment, E), W(C.$$.fragment, E), W(w), U = true);
  }, o(E) {
    j(n.$$.fragment, E), j(i.$$.fragment, E), j(f.$$.fragment, E), j(m.$$.fragment, E), j(b.$$.fragment, E), j(C.$$.fragment, E), j(w), U = false;
  }, d(E) {
    E && (D(e), D(o), D(l), D(h), D(S), D($), D(F)), oe(n), oe(i), oe(f, E), oe(m), oe(b), oe(C), y && y.d(E), w && w.d(E);
  } };
}
function Fpe(t3) {
  let e, n, r, s, i, a, o;
  return { c() {
    e = H("p"), e.innerHTML = `<strong>SHA-2 (Secure Hash Algorithm 2)</strong> is a family of cryptographic hash functions designed by the 
    <strong>National Security Agency (NSA)</strong> and published by NIST in 2001. It was developed to replace 
    SHA-1, addressing its security vulnerabilities.`, n = z(), r = H("p"), r.textContent = "This tool supports the three prominent members of the family:", s = z(), i = H("ul"), i.innerHTML = `<li><strong>SHA-256:</strong> Generates a 256-bit (32-byte) hash. It is one of the most famous algorithms in the world, 
      serving as the backbone of the <strong>Bitcoin</strong> network and most SSL/TLS certificates (https).</li> <li><strong>SHA-512:</strong> Generates a 512-bit (64-byte) hash. Unlike SHA-256, which uses 32-bit words, 
      SHA-512 operates on 64-bit words, making it generally faster on modern 64-bit processors.</li> <li><strong>SHA-384:</strong> Effectively a truncated version of SHA-512. It computes the hash using the SHA-512 
      logic but drops part of the result to output 384 bits.</li>`, a = z(), o = H("p"), o.innerHTML = `<strong>Security Status:</strong> Unlike its predecessors (MD5 and SHA-1), SHA-2 is widely considered secure. 
    While theoretical attacks exist for reduced-round versions, no practical collision attacks have been found against the full algorithm. 
    It remains the industry standard for digital signatures and authentication.`;
  }, m(f, c) {
    R(f, e, c), R(f, n, c), R(f, r, c), R(f, s, c), R(f, i, c), R(f, a, c), R(f, o, c);
  }, p: dt, d(f) {
    f && (D(e), D(n), D(r), D(s), D(i), D(a), D(o));
  } };
}
function Ppe(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "SHA2 Family", $$slots: { default: [Rpe] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About SHA-2", links: t3[8], $$slots: { default: [Fpe] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 16447 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 16384 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
const Npe = (t3) => t3.value;
function Upe(t3, e, n) {
  let r = "", s = "SHA2-256", i = "utf-8", a = null, o = "", f = true;
  const c = ["SHA2-256", "SHA2-384", "SHA2-512"];
  function l() {
    if (!r) {
      n(4, a = null), n(5, o = "");
      return;
    }
    n(5, o = ""), n(4, a = null);
    try {
      n(4, a = $pe(r, s, i));
    } catch (C) {
      n(5, o = C.message);
    }
  }
  const h = [{ text: "@noble/hashes NPM", url: "https://www.npmjs.com/package/@noble/hashes" }, { text: "SHA-2 Family - Wikipedia", url: "https://en.wikipedia.org/wiki/SHA-2" }];
  function m(C) {
    s = C, n(1, s);
  }
  function v(C) {
    i = C, n(2, i);
  }
  function b(C) {
    r = C, n(0, r);
  }
  const A = () => {
    n(0, r = ""), n(4, a = null);
  };
  function _(C) {
    f = C, n(3, f);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 15 && f && (r || s || i) && l();
  }, [r, s, i, f, a, o, c, l, h, m, v, b, A, _];
}
class Lpe extends xt {
  constructor(e) {
    super(), wt(this, e, Upe, Ppe, At, {});
  }
}
const Ope = BigInt(0), Nc = BigInt(1), Qpe = BigInt(2), Kpe = BigInt(7), Hpe = BigInt(256), qpe = BigInt(113), TF = [], DF = [], RF = [];
for (let t3 = 0, e = Nc, n = 1, r = 0; t3 < 24; t3++) {
  [n, r] = [r, (2 * n + 3 * r) % 5], TF.push(2 * (5 * r + n)), DF.push((t3 + 1) * (t3 + 2) / 2 % 64);
  let s = Ope;
  for (let i = 0; i < 7; i++) e = (e << Nc ^ (e >> Kpe) * qpe) % Hpe, e & Qpe && (s ^= Nc << (Nc << BigInt(i)) - Nc);
  RF.push(s);
}
const FF = BF(RF, true), zpe = FF[0], Gpe = FF[1], H9 = (t3, e, n) => n > 32 ? ype(t3, e, n) : mpe(t3, e, n), q9 = (t3, e, n) => n > 32 ? bpe(t3, e, n) : vpe(t3, e, n);
function Vpe(t3, e = 24) {
  const n = new Uint32Array(10);
  for (let r = 24 - e; r < 24; r++) {
    for (let a = 0; a < 10; a++) n[a] = t3[a] ^ t3[a + 10] ^ t3[a + 20] ^ t3[a + 30] ^ t3[a + 40];
    for (let a = 0; a < 10; a += 2) {
      const o = (a + 8) % 10, f = (a + 2) % 10, c = n[f], l = n[f + 1], h = H9(c, l, 1) ^ n[o], m = q9(c, l, 1) ^ n[o + 1];
      for (let v = 0; v < 50; v += 10) t3[a + v] ^= h, t3[a + v + 1] ^= m;
    }
    let s = t3[2], i = t3[3];
    for (let a = 0; a < 24; a++) {
      const o = DF[a], f = H9(s, i, o), c = q9(s, i, o), l = TF[a];
      s = t3[l], i = t3[l + 1], t3[l] = f, t3[l + 1] = c;
    }
    for (let a = 0; a < 50; a += 10) {
      for (let o = 0; o < 10; o++) n[o] = t3[a + o];
      for (let o = 0; o < 10; o++) t3[a + o] ^= ~n[(o + 2) % 10] & n[(o + 4) % 10];
    }
    t3[0] ^= zpe[r], t3[1] ^= Gpe[r];
  }
  Li(n);
}
let K4 = class PF extends Bm {
  constructor(e, n, r, s = false, i = 24) {
    if (super(), this.pos = 0, this.posOut = 0, this.finished = false, this.destroyed = false, this.enableXOF = false, this.blockLen = e, this.suffix = n, this.outputLen = r, this.enableXOF = s, this.rounds = i, cl(r), !(0 < e && e < 200)) throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200), this.state32 = uf(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    ls(this.state32), Vpe(this.state32, this.rounds), ls(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    lf(this), e = rs(e), Ra(e);
    const { blockLen: n, state: r } = this, s = e.length;
    for (let i = 0; i < s; ) {
      const a = Math.min(n - this.pos, s - i);
      for (let o = 0; o < a; o++) r[this.pos++] ^= e[i++];
      this.pos === n && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = true;
    const { state: e, suffix: n, pos: r, blockLen: s } = this;
    e[r] ^= n, n & 128 && r === s - 1 && this.keccak(), e[s - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    lf(this, false), Ra(e), this.finish();
    const n = this.state, { blockLen: r } = this;
    for (let s = 0, i = e.length; s < i; ) {
      this.posOut >= r && this.keccak();
      const a = Math.min(r - this.posOut, i - s);
      e.set(n.subarray(this.posOut, this.posOut + a), s), this.posOut += a, s += a;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return cl(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (Em(e, this), this.finished) throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true, Li(this.state);
  }
  _cloneInto(e) {
    const { blockLen: n, suffix: r, outputLen: s, rounds: i, enableXOF: a } = this;
    return e || (e = new PF(n, r, s, a, i)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = i, e.suffix = r, e.outputLen = s, e.enableXOF = a, e.destroyed = this.destroyed, e;
  }
};
const wl = (t3, e, n) => hc(() => new K4(e, t3, n)), Ype = wl(6, 144, 224 / 8), Wpe = wl(6, 136, 256 / 8), Jpe = wl(6, 104, 384 / 8), Zpe = wl(6, 72, 512 / 8), jpe = wl(1, 144, 224 / 8), Xpe = wl(1, 136, 256 / 8), e1e = wl(1, 104, 384 / 8), t1e = wl(1, 72, 512 / 8), NF = (t3, e, n) => N4((r = {}) => new K4(e, t3, r.dkLen === void 0 ? n : r.dkLen, true)), r1e = NF(31, 168, 128 / 8), n1e = NF(31, 136, 256 / 8), i1e = { "SHA3-224": Ype, "SHA3-256": Wpe, "SHA3-384": Jpe, "SHA3-512": Zpe };
function s1e(t3, e, n = "utf-8") {
  if (!t3) throw new Error("Please enter some text.");
  const r = i1e[e];
  if (!r) throw new Error(`Algorithm ${e} is not supported.`);
  let s;
  try {
    s = ps(t3, n);
  } catch (f) {
    throw new Error(f.message);
  }
  const i = r(s), a = Al(i), o = btoa(String.fromCharCode(...i));
  return { hex: a, base64: o, bitLength: i.length * 8 };
}
function a1e(t3) {
  let e;
  return { c() {
    e = we("Generate Hash");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function o1e(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function z9(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[5]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 32 && Ze(n, r[5]);
  }, d(r) {
    r && D(e);
  } };
}
function G9(t3) {
  let e, n, r, s;
  return e = new et({ props: { label: t3[1] + " Hex:", value: t3[4].hex, readonly: true, expandable: true, withCopy: true } }), r = new et({ props: { label: t3[1] + " Base64:", value: t3[4].base64, readonly: true, expandable: true, withCopy: true } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, a) {
    const o = {};
    a & 2 && (o.label = i[1] + " Hex:"), a & 16 && (o.value = i[4].hex), e.$set(o);
    const f = {};
    a & 2 && (f.label = i[1] + " Base64:"), a & 16 && (f.value = i[4].base64), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function f1e(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U;
  function Q(E) {
    t3[9](E);
  }
  let P = { label: "Algorithm:", options: t3[6] };
  t3[1] !== void 0 && (P.value = t3[1]), n = new Ht({ props: P }), Qe.push(() => ze(n, "value", Q));
  function N(E) {
    t3[10](E);
  }
  let L = { label: "Input Encoding:", options: gs.map(c1e) };
  t3[2] !== void 0 && (L.value = t3[2]), i = new Ht({ props: L }), Qe.push(() => ze(i, "value", N));
  function B(E) {
    t3[11](E);
  }
  let u = { label: "Input Data:", placeholder: t3[2] === "hex" ? "e.g. 4a 1b..." : "Type text here...", expandable: true };
  t3[0] !== void 0 && (u.value = t3[0]), f = new et({ props: u }), Qe.push(() => ze(f, "value", B)), m = new ut({ props: { $$slots: { default: [a1e] }, $$scope: { ctx: t3 } } }), m.$on("click", t3[7]), b = new ut({ props: { variant: "secondary", $$slots: { default: [o1e] }, $$scope: { ctx: t3 } } }), b.$on("click", t3[12]);
  function p(E) {
    t3[13](E);
  }
  let d = {};
  t3[3] !== void 0 && (d.checked = t3[3]), C = new xr({ props: d }), Qe.push(() => ze(C, "checked", p));
  let y = t3[5] && z9(t3), w = t3[4] && G9(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), fe(i.$$.fragment), o = z(), fe(f.$$.fragment), l = z(), h = H("div"), fe(m.$$.fragment), v = z(), fe(b.$$.fragment), A = z(), _ = H("div"), fe(C.$$.fragment), S = z(), y && y.c(), $ = z(), w && w.c(), F = Lt(), V(e, "class", "controls-row"), St(_, "margin-left", "auto"), V(h, "class", "button-row");
  }, m(E, M) {
    R(E, e, M), ae(n, e, null), q(e, s), ae(i, e, null), R(E, o, M), ae(f, E, M), R(E, l, M), R(E, h, M), ae(m, h, null), q(h, v), ae(b, h, null), q(h, A), q(h, _), ae(C, _, null), R(E, S, M), y && y.m(E, M), R(E, $, M), w && w.m(E, M), R(E, F, M), U = true;
  }, p(E, M) {
    const x = {};
    !r && M & 2 && (r = true, x.value = E[1], qe(() => r = false)), n.$set(x);
    const g = {};
    !a && M & 4 && (a = true, g.value = E[2], qe(() => a = false)), i.$set(g);
    const k = {};
    M & 4 && (k.placeholder = E[2] === "hex" ? "e.g. 4a 1b..." : "Type text here..."), !c && M & 1 && (c = true, k.value = E[0], qe(() => c = false)), f.$set(k);
    const T = {};
    M & 16384 && (T.$$scope = { dirty: M, ctx: E }), m.$set(T);
    const O = {};
    M & 16384 && (O.$$scope = { dirty: M, ctx: E }), b.$set(O);
    const K = {};
    !I && M & 8 && (I = true, K.checked = E[3], qe(() => I = false)), C.$set(K), E[5] ? y ? y.p(E, M) : (y = z9(E), y.c(), y.m($.parentNode, $)) : y && (y.d(1), y = null), E[4] ? w ? (w.p(E, M), M & 16 && W(w, 1)) : (w = G9(E), w.c(), W(w, 1), w.m(F.parentNode, F)) : w && (Xt(), j(w, 1, 1, () => {
      w = null;
    }), er());
  }, i(E) {
    U || (W(n.$$.fragment, E), W(i.$$.fragment, E), W(f.$$.fragment, E), W(m.$$.fragment, E), W(b.$$.fragment, E), W(C.$$.fragment, E), W(w), U = true);
  }, o(E) {
    j(n.$$.fragment, E), j(i.$$.fragment, E), j(f.$$.fragment, E), j(m.$$.fragment, E), j(b.$$.fragment, E), j(C.$$.fragment, E), j(w), U = false;
  }, d(E) {
    E && (D(e), D(o), D(l), D(h), D(S), D($), D(F)), oe(n), oe(i), oe(f, E), oe(m), oe(b), oe(C), y && y.d(E), w && w.d(E);
  } };
}
function l1e(t3) {
  let e, n, r, s, i, a, o;
  return { c() {
    e = H("p"), e.innerHTML = `<strong>SHA-3 (Secure Hash Algorithm 3)</strong> is the latest member of the Secure Hash Algorithm family, 
    released by NIST in 2015. It is based on the <strong>Keccak</strong> algorithm, which won the public NIST hash competition 
    against dozens of other candidates.`, n = z(), r = H("p"), r.innerHTML = `While SHA-2 is built using the Merkle-Damg\xE5rd structure (similar to MD5 and SHA-1), SHA-3 uses a completely different 
    architecture called the <strong>Sponge Construction</strong>. This fundamental difference means that even if a mathematical 
    breakthrough were to break SHA-2, SHA-3 would likely remain secure.`, s = z(), i = H("p"), i.innerHTML = "<strong>Key Characteristics:</strong>", a = z(), o = H("ul"), o.innerHTML = `<li><strong>Drop-in Replacement:</strong> SHA-3 was designed to have the same output lengths as SHA-2 
      (224, 256, 384, and 512 bits) so systems can switch easily.</li> <li><strong>Resistance:</strong> The sponge structure makes SHA-3 naturally resistant to &quot;Length Extension Attacks,&quot; 
      a vulnerability that affects MD5, SHA-1, and SHA-2.</li> <li><strong>Keccak vs. SHA-3:</strong> While SHA-3 is based on Keccak, NIST changed the &quot;padding&quot; (the final bytes added to the message) 
      in the final standard. This means <strong>SHA3-256 is not identical to Keccak-256</strong> (which is used by Ethereum).</li>`;
  }, m(f, c) {
    R(f, e, c), R(f, n, c), R(f, r, c), R(f, s, c), R(f, i, c), R(f, a, c), R(f, o, c);
  }, p: dt, d(f) {
    f && (D(e), D(n), D(r), D(s), D(i), D(a), D(o));
  } };
}
function u1e(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "SHA3 Family", $$slots: { default: [f1e] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About SHA-3", links: t3[8], $$slots: { default: [l1e] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 16447 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 16384 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
const c1e = (t3) => t3.value;
function h1e(t3, e, n) {
  let r = "", s = "SHA3-256", i = "utf-8", a = null, o = "", f = true;
  const c = ["SHA3-224", "SHA3-256", "SHA3-384", "SHA3-512"];
  function l() {
    if (!r) {
      n(4, a = null), n(5, o = "");
      return;
    }
    n(5, o = ""), n(4, a = null);
    try {
      n(4, a = s1e(r, s, i));
    } catch (C) {
      n(5, o = C.message);
    }
  }
  const h = [{ text: "@noble/hashes NPM", url: "https://www.npmjs.com/package/@noble/hashes" }, { text: "SHA-3 Family - Wikipedia", url: "https://en.wikipedia.org/wiki/SHA-3" }, { text: "NIST SHA-3 Standard", url: "https://csrc.nist.gov/pubs/fips/202/final" }, { text: "Sponge Function - Wikipedia", url: "https://en.wikipedia.org/wiki/Sponge_function" }];
  function m(C) {
    s = C, n(1, s);
  }
  function v(C) {
    i = C, n(2, i);
  }
  function b(C) {
    r = C, n(0, r);
  }
  const A = () => {
    n(0, r = ""), n(4, a = null);
  };
  function _(C) {
    f = C, n(3, f);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 15 && f && (r || s || i) && l();
  }, [r, s, i, f, a, o, c, l, h, m, v, b, A, _];
}
class d1e extends xt {
  constructor(e) {
    super(), wt(this, e, h1e, u1e, At, {});
  }
}
const p1e = { "CRC-8": 2, "CRC-16": 4, "BSD checksum": 4, "SYSV checksum": 4, "CRC-32": 8, "Adler-32": 8, "CRC-64": 16, MD2: 32, MD4: 32, MD5: 32, "SHA-1": 40, "RIPEMD-160": 40, "SHA-224": 56, "SHA-512/224": 56, "SHA3-224": 56, "SHA-256": 64, "SHA-512/256": 64, "SHA3-256": 64, BLAKE2s: 64, GOST: 64, BLAKE3: 64, "SHA-384": 96, "SHA3-384": 96, "SHA-512": 128, "SHA3-512": 128, BLAKE2b: 128, Whirlpool: 128, MD6: 128, Tiger: 48, "RIPEMD-320": 80, "Poly1305-AES": 32 };
function g1e(t3) {
  const n = t3.trim().length;
  return Object.entries(p1e).filter(([s, i]) => i === n).map(([s]) => s).sort();
}
function V9(t3, e, n) {
  const r = t3.slice();
  return r[8] = e[n], r;
}
function m1e(t3) {
  let e;
  return { c() {
    e = we("Identify");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function v1e(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function Y9(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[2]), V(e, "class", "msg error svelte-1lhkk72");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 4 && Ze(n, r[2]);
  }, d(r) {
    r && D(e);
  } };
}
function W9(t3) {
  let e, n, r, s, i = t3[0].length + "", a, o, f;
  function c(m, v) {
    return m[1].length > 0 ? b1e : y1e;
  }
  let l = c(t3), h = l(t3);
  return { c() {
    e = H("div"), n = H("div"), r = we("Detected Length: "), s = H("strong"), a = we(i), o = we(" characters"), f = z(), h.c(), V(n, "class", "info-badge svelte-1lhkk72"), V(e, "class", "result-area svelte-1lhkk72");
  }, m(m, v) {
    R(m, e, v), q(e, n), q(n, r), q(n, s), q(s, a), q(s, o), q(e, f), h.m(e, null);
  }, p(m, v) {
    v & 1 && i !== (i = m[0].length + "") && Ze(a, i), l === (l = c(m)) && h ? h.p(m, v) : (h.d(1), h = l(m), h && (h.c(), h.m(e, null)));
  }, d(m) {
    m && D(e), h.d();
  } };
}
function y1e(t3) {
  let e;
  return { c() {
    e = H("div"), e.textContent = "No matching algorithms found for this length.", V(e, "class", "msg warning svelte-1lhkk72");
  }, m(n, r) {
    R(n, e, r);
  }, p: dt, d(n) {
    n && D(e);
  } };
}
function b1e(t3) {
  let e, n, r, s, i = Mr(t3[1]), a = [];
  for (let o = 0; o < i.length; o += 1) a[o] = J9(V9(t3, i, o));
  return { c() {
    e = H("div"), n = H("h4"), n.textContent = "Possible Algorithms:", r = z(), s = H("div");
    for (let o = 0; o < a.length; o += 1) a[o].c();
    V(n, "class", "svelte-1lhkk72"), V(s, "class", "tags svelte-1lhkk72"), V(e, "class", "success-box svelte-1lhkk72");
  }, m(o, f) {
    R(o, e, f), q(e, n), q(e, r), q(e, s);
    for (let c = 0; c < a.length; c += 1) a[c] && a[c].m(s, null);
  }, p(o, f) {
    if (f & 2) {
      i = Mr(o[1]);
      let c;
      for (c = 0; c < i.length; c += 1) {
        const l = V9(o, i, c);
        a[c] ? a[c].p(l, f) : (a[c] = J9(l), a[c].c(), a[c].m(s, null));
      }
      for (; c < a.length; c += 1) a[c].d(1);
      a.length = i.length;
    }
  }, d(o) {
    o && D(e), jn(a, o);
  } };
}
function J9(t3) {
  let e, n = t3[8] + "", r;
  return { c() {
    e = H("span"), r = we(n), V(e, "class", "tag svelte-1lhkk72");
  }, m(s, i) {
    R(s, e, i), q(e, r);
  }, p(s, i) {
    i & 2 && n !== (n = s[8] + "") && Ze(r, n);
  }, d(s) {
    s && D(e);
  } };
}
function A1e(t3) {
  let e, n, r, s, i, a, o, f, c, l, h;
  function m(_) {
    t3[6](_);
  }
  let v = { label: "Enter hash:", placeholder: "Paste your hash string here..." };
  t3[0] !== void 0 && (v.value = t3[0]), e = new et({ props: v }), Qe.push(() => ze(e, "value", m)), i = new ut({ props: { $$slots: { default: [m1e] }, $$scope: { ctx: t3 } } }), i.$on("click", t3[4]), o = new ut({ props: { variant: "secondary", $$slots: { default: [v1e] }, $$scope: { ctx: t3 } } }), o.$on("click", t3[7]);
  let b = t3[2] && Y9(t3), A = t3[3] && W9(t3);
  return { c() {
    fe(e.$$.fragment), r = z(), s = H("div"), fe(i.$$.fragment), a = z(), fe(o.$$.fragment), f = z(), b && b.c(), c = z(), A && A.c(), l = Lt(), V(s, "class", "button-row svelte-1lhkk72");
  }, m(_, C) {
    ae(e, _, C), R(_, r, C), R(_, s, C), ae(i, s, null), q(s, a), ae(o, s, null), R(_, f, C), b && b.m(_, C), R(_, c, C), A && A.m(_, C), R(_, l, C), h = true;
  }, p(_, C) {
    const I = {};
    !n && C & 1 && (n = true, I.value = _[0], qe(() => n = false)), e.$set(I);
    const S = {};
    C & 2048 && (S.$$scope = { dirty: C, ctx: _ }), i.$set(S);
    const $ = {};
    C & 2048 && ($.$$scope = { dirty: C, ctx: _ }), o.$set($), _[2] ? b ? b.p(_, C) : (b = Y9(_), b.c(), b.m(c.parentNode, c)) : b && (b.d(1), b = null), _[3] ? A ? A.p(_, C) : (A = W9(_), A.c(), A.m(l.parentNode, l)) : A && (A.d(1), A = null);
  }, i(_) {
    h || (W(e.$$.fragment, _), W(i.$$.fragment, _), W(o.$$.fragment, _), h = true);
  }, o(_) {
    j(e.$$.fragment, _), j(i.$$.fragment, _), j(o.$$.fragment, _), h = false;
  }, d(_) {
    _ && (D(r), D(s), D(f), D(c), D(l)), oe(e, _), oe(i), oe(o), b && b.d(_), A && A.d(_);
  } };
}
function w1e(t3) {
  let e, n, r, s, i, a, o;
  return { c() {
    e = H("p"), e.textContent = `The Hash Identifier is designed to help you identify the possible hash algorithm used to generate 
    a given hash string based on its length. It is useful in cryptography, digital forensics, and other security-related fields.`, n = z(), r = H("p"), r.innerHTML = "<strong>Supported algorithms include:</strong>", s = z(), i = H("ul"), i.innerHTML = "<li>MD2, MD4, MD5</li> <li>SHA-1, SHA-2 Family, SHA-3 Family</li> <li>Checksums (CRC-8 to CRC-64)</li> <li>RIPEMD, Whirlpool, Tiger, BLAKE, and more.</li>", a = z(), o = H("p"), o.innerHTML = "<em>Note: Some algorithms produce hashes of the same length, so multiple results may be returned.</em>";
  }, m(f, c) {
    R(f, e, c), R(f, n, c), R(f, r, c), R(f, s, c), R(f, i, c), R(f, a, c), R(f, o, c);
  }, p: dt, d(f) {
    f && (D(e), D(n), D(r), D(s), D(i), D(a), D(o));
  } };
}
function x1e(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Hash Identifier", $$slots: { default: [A1e] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Hash Identifier", links: t3[5], $$slots: { default: [w1e] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 2063 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 2048 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function _1e(t3, e, n) {
  let r = "", s = [], i = "", a = false;
  function o() {
    if (n(2, i = ""), n(1, s = []), n(3, a = true), !r) {
      n(2, i = "Please enter a hash string.");
      return;
    }
    n(1, s = g1e(r));
  }
  const f = [{ text: "Hash Function - Wikipedia", url: "https://en.wikipedia.org/wiki/Hash_function" }];
  function c(h) {
    r = h, n(0, r);
  }
  return [r, s, i, a, o, f, c, () => {
    n(0, r = ""), n(3, a = false);
  }];
}
class E1e extends xt {
  constructor(e) {
    super(), wt(this, e, _1e, x1e, At, {});
  }
}
var UF = { exports: {} };
(function(t3) {
  /**
  * @license bcrypt.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
  * Released under the Apache License, Version 2.0
  * see: https://github.com/dcodeIO/bcrypt.js for details
  */
  (function(e, n) {
    typeof Gl == "function" && t3 && t3.exports ? t3.exports = n() : (e.dcodeIO = e.dcodeIO || {}).bcrypt = n();
  })(mt, function() {
    var e = {}, n = null;
    function r(B) {
      if (t3 && t3.exports) try {
        return vl().randomBytes(B);
      } catch {
      }
      try {
        var u;
        return (self.crypto || self.msCrypto).getRandomValues(u = new Uint32Array(B)), Array.prototype.slice.call(u);
      } catch {
      }
      if (!n) throw Error("Neither WebCryptoAPI nor a crypto module is available. Use bcrypt.setRandomFallback to set an alternative");
      return n(B);
    }
    var s = false;
    try {
      r(1), s = true;
    } catch {
    }
    n = null, e.setRandomFallback = function(B) {
      n = B;
    }, e.genSaltSync = function(B, u) {
      if (B = B || A, typeof B != "number") throw Error("Illegal arguments: " + typeof B + ", " + typeof u);
      B < 4 ? B = 4 : B > 31 && (B = 31);
      var p = [];
      return p.push("$2a$"), B < 10 && p.push("0"), p.push(B.toString()), p.push("$"), p.push(h(r(b), b)), p.join("");
    }, e.genSalt = function(B, u, p) {
      if (typeof u == "function" && (p = u, u = void 0), typeof B == "function" && (p = B, B = void 0), typeof B > "u") B = A;
      else if (typeof B != "number") throw Error("illegal arguments: " + typeof B);
      function d(y) {
        a(function() {
          try {
            y(null, e.genSaltSync(B));
          } catch (w) {
            y(w);
          }
        });
      }
      if (p) {
        if (typeof p != "function") throw Error("Illegal callback: " + typeof p);
        d(p);
      } else return new Promise(function(y, w) {
        d(function(E, M) {
          if (E) {
            w(E);
            return;
          }
          y(M);
        });
      });
    }, e.hashSync = function(B, u) {
      if (typeof u > "u" && (u = A), typeof u == "number" && (u = e.genSaltSync(u)), typeof B != "string" || typeof u != "string") throw Error("Illegal arguments: " + typeof B + ", " + typeof u);
      return L(B, u);
    }, e.hash = function(B, u, p, d) {
      function y(w) {
        typeof B == "string" && typeof u == "number" ? e.genSalt(u, function(E, M) {
          L(B, M, w, d);
        }) : typeof B == "string" && typeof u == "string" ? L(B, u, w, d) : a(w.bind(this, Error("Illegal arguments: " + typeof B + ", " + typeof u)));
      }
      if (p) {
        if (typeof p != "function") throw Error("Illegal callback: " + typeof p);
        y(p);
      } else return new Promise(function(w, E) {
        y(function(M, x) {
          if (M) {
            E(M);
            return;
          }
          w(x);
        });
      });
    };
    function i(B, u) {
      for (var p = 0, d = 0, y = 0, w = B.length; y < w; ++y) B.charCodeAt(y) === u.charCodeAt(y) ? ++p : ++d;
      return p < 0 ? false : d === 0;
    }
    e.compareSync = function(B, u) {
      if (typeof B != "string" || typeof u != "string") throw Error("Illegal arguments: " + typeof B + ", " + typeof u);
      return u.length !== 60 ? false : i(e.hashSync(B, u.substr(0, u.length - 31)), u);
    }, e.compare = function(B, u, p, d) {
      function y(w) {
        if (typeof B != "string" || typeof u != "string") {
          a(w.bind(this, Error("Illegal arguments: " + typeof B + ", " + typeof u)));
          return;
        }
        if (u.length !== 60) {
          a(w.bind(this, null, false));
          return;
        }
        e.hash(B, u.substr(0, 29), function(E, M) {
          E ? w(E) : w(null, i(M, u));
        }, d);
      }
      if (p) {
        if (typeof p != "function") throw Error("Illegal callback: " + typeof p);
        y(p);
      } else return new Promise(function(w, E) {
        y(function(M, x) {
          if (M) {
            E(M);
            return;
          }
          w(x);
        });
      });
    }, e.getRounds = function(B) {
      if (typeof B != "string") throw Error("Illegal arguments: " + typeof B);
      return parseInt(B.split("$")[2], 10);
    }, e.getSalt = function(B) {
      if (typeof B != "string") throw Error("Illegal arguments: " + typeof B);
      if (B.length !== 60) throw Error("Illegal hash length: " + B.length + " != 60");
      return B.substring(0, 29);
    };
    var a = typeof jt < "u" && jt && typeof jt.nextTick == "function" ? typeof setImmediate == "function" ? setImmediate : jt.nextTick : setTimeout;
    function o(B) {
      var u = [], p = 0;
      return v.encodeUTF16toUTF8(function() {
        return p >= B.length ? null : B.charCodeAt(p++);
      }, function(d) {
        u.push(d);
      }), u;
    }
    var f = "./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""), c = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, -1, -1, -1, -1, -1, -1, -1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, -1, -1, -1, -1, -1, -1, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, -1, -1, -1, -1, -1], l = String.fromCharCode;
    function h(B, u) {
      var p = 0, d = [], y, w;
      if (u <= 0 || u > B.length) throw Error("Illegal len: " + u);
      for (; p < u; ) {
        if (y = B[p++] & 255, d.push(f[y >> 2 & 63]), y = (y & 3) << 4, p >= u) {
          d.push(f[y & 63]);
          break;
        }
        if (w = B[p++] & 255, y |= w >> 4 & 15, d.push(f[y & 63]), y = (w & 15) << 2, p >= u) {
          d.push(f[y & 63]);
          break;
        }
        w = B[p++] & 255, y |= w >> 6 & 3, d.push(f[y & 63]), d.push(f[w & 63]);
      }
      return d.join("");
    }
    function m(B, u) {
      var p = 0, d = B.length, y = 0, w = [], E, M, x, g, k, T;
      if (u <= 0) throw Error("Illegal len: " + u);
      for (; p < d - 1 && y < u && (T = B.charCodeAt(p++), E = T < c.length ? c[T] : -1, T = B.charCodeAt(p++), M = T < c.length ? c[T] : -1, !(E == -1 || M == -1 || (k = E << 2 >>> 0, k |= (M & 48) >> 4, w.push(l(k)), ++y >= u || p >= d) || (T = B.charCodeAt(p++), x = T < c.length ? c[T] : -1, x == -1) || (k = (M & 15) << 4 >>> 0, k |= (x & 60) >> 2, w.push(l(k)), ++y >= u || p >= d))); ) T = B.charCodeAt(p++), g = T < c.length ? c[T] : -1, k = (x & 3) << 6 >>> 0, k |= g, w.push(l(k)), ++y;
      var O = [];
      for (p = 0; p < y; p++) O.push(w[p].charCodeAt(0));
      return O;
    }
    var v = function() {
      var B = {};
      return B.MAX_CODEPOINT = 1114111, B.encodeUTF8 = function(u, p) {
        var d = null;
        for (typeof u == "number" && (d = u, u = function() {
          return null;
        }); d !== null || (d = u()) !== null; ) d < 128 ? p(d & 127) : d < 2048 ? (p(d >> 6 & 31 | 192), p(d & 63 | 128)) : d < 65536 ? (p(d >> 12 & 15 | 224), p(d >> 6 & 63 | 128), p(d & 63 | 128)) : (p(d >> 18 & 7 | 240), p(d >> 12 & 63 | 128), p(d >> 6 & 63 | 128), p(d & 63 | 128)), d = null;
      }, B.decodeUTF8 = function(u, p) {
        for (var d, y, w, E, M = function(x) {
          x = x.slice(0, x.indexOf(null));
          var g = Error(x.toString());
          throw g.name = "TruncatedError", g.bytes = x, g;
        }; (d = u()) !== null; ) if (!(d & 128)) p(d);
        else if ((d & 224) === 192) (y = u()) === null && M([d, y]), p((d & 31) << 6 | y & 63);
        else if ((d & 240) === 224) ((y = u()) === null || (w = u()) === null) && M([d, y, w]), p((d & 15) << 12 | (y & 63) << 6 | w & 63);
        else if ((d & 248) === 240) ((y = u()) === null || (w = u()) === null || (E = u()) === null) && M([d, y, w, E]), p((d & 7) << 18 | (y & 63) << 12 | (w & 63) << 6 | E & 63);
        else throw RangeError("Illegal starting byte: " + d);
      }, B.UTF16toUTF8 = function(u, p) {
        for (var d, y = null; (d = y !== null ? y : u()) !== null; ) {
          if (d >= 55296 && d <= 57343 && (y = u()) !== null && y >= 56320 && y <= 57343) {
            p((d - 55296) * 1024 + y - 56320 + 65536), y = null;
            continue;
          }
          p(d);
        }
        y !== null && p(y);
      }, B.UTF8toUTF16 = function(u, p) {
        var d = null;
        for (typeof u == "number" && (d = u, u = function() {
          return null;
        }); d !== null || (d = u()) !== null; ) d <= 65535 ? p(d) : (d -= 65536, p((d >> 10) + 55296), p(d % 1024 + 56320)), d = null;
      }, B.encodeUTF16toUTF8 = function(u, p) {
        B.UTF16toUTF8(u, function(d) {
          B.encodeUTF8(d, p);
        });
      }, B.decodeUTF8toUTF16 = function(u, p) {
        B.decodeUTF8(u, function(d) {
          B.UTF8toUTF16(d, p);
        });
      }, B.calculateCodePoint = function(u) {
        return u < 128 ? 1 : u < 2048 ? 2 : u < 65536 ? 3 : 4;
      }, B.calculateUTF8 = function(u) {
        for (var p, d = 0; (p = u()) !== null; ) d += B.calculateCodePoint(p);
        return d;
      }, B.calculateUTF16asUTF8 = function(u) {
        var p = 0, d = 0;
        return B.UTF16toUTF8(u, function(y) {
          ++p, d += B.calculateCodePoint(y);
        }), [p, d];
      }, B;
    }();
    Date.now = Date.now || function() {
      return +/* @__PURE__ */ new Date();
    };
    var b = 16, A = 10, _ = 16, C = 100, I = [608135816, 2242054355, 320440878, 57701188, 2752067618, 698298832, 137296536, 3964562569, 1160258022, 953160567, 3193202383, 887688300, 3232508343, 3380367581, 1065670069, 3041331479, 2450970073, 2306472731], S = [3509652390, 2564797868, 805139163, 3491422135, 3101798381, 1780907670, 3128725573, 4046225305, 614570311, 3012652279, 134345442, 2240740374, 1667834072, 1901547113, 2757295779, 4103290238, 227898511, 1921955416, 1904987480, 2182433518, 2069144605, 3260701109, 2620446009, 720527379, 3318853667, 677414384, 3393288472, 3101374703, 2390351024, 1614419982, 1822297739, 2954791486, 3608508353, 3174124327, 2024746970, 1432378464, 3864339955, 2857741204, 1464375394, 1676153920, 1439316330, 715854006, 3033291828, 289532110, 2706671279, 2087905683, 3018724369, 1668267050, 732546397, 1947742710, 3462151702, 2609353502, 2950085171, 1814351708, 2050118529, 680887927, 999245976, 1800124847, 3300911131, 1713906067, 1641548236, 4213287313, 1216130144, 1575780402, 4018429277, 3917837745, 3693486850, 3949271944, 596196993, 3549867205, 258830323, 2213823033, 772490370, 2760122372, 1774776394, 2652871518, 566650946, 4142492826, 1728879713, 2882767088, 1783734482, 3629395816, 2517608232, 2874225571, 1861159788, 326777828, 3124490320, 2130389656, 2716951837, 967770486, 1724537150, 2185432712, 2364442137, 1164943284, 2105845187, 998989502, 3765401048, 2244026483, 1075463327, 1455516326, 1322494562, 910128902, 469688178, 1117454909, 936433444, 3490320968, 3675253459, 1240580251, 122909385, 2157517691, 634681816, 4142456567, 3825094682, 3061402683, 2540495037, 79693498, 3249098678, 1084186820, 1583128258, 426386531, 1761308591, 1047286709, 322548459, 995290223, 1845252383, 2603652396, 3431023940, 2942221577, 3202600964, 3727903485, 1712269319, 422464435, 3234572375, 1170764815, 3523960633, 3117677531, 1434042557, 442511882, 3600875718, 1076654713, 1738483198, 4213154764, 2393238008, 3677496056, 1014306527, 4251020053, 793779912, 2902807211, 842905082, 4246964064, 1395751752, 1040244610, 2656851899, 3396308128, 445077038, 3742853595, 3577915638, 679411651, 2892444358, 2354009459, 1767581616, 3150600392, 3791627101, 3102740896, 284835224, 4246832056, 1258075500, 768725851, 2589189241, 3069724005, 3532540348, 1274779536, 3789419226, 2764799539, 1660621633, 3471099624, 4011903706, 913787905, 3497959166, 737222580, 2514213453, 2928710040, 3937242737, 1804850592, 3499020752, 2949064160, 2386320175, 2390070455, 2415321851, 4061277028, 2290661394, 2416832540, 1336762016, 1754252060, 3520065937, 3014181293, 791618072, 3188594551, 3933548030, 2332172193, 3852520463, 3043980520, 413987798, 3465142937, 3030929376, 4245938359, 2093235073, 3534596313, 375366246, 2157278981, 2479649556, 555357303, 3870105701, 2008414854, 3344188149, 4221384143, 3956125452, 2067696032, 3594591187, 2921233993, 2428461, 544322398, 577241275, 1471733935, 610547355, 4027169054, 1432588573, 1507829418, 2025931657, 3646575487, 545086370, 48609733, 2200306550, 1653985193, 298326376, 1316178497, 3007786442, 2064951626, 458293330, 2589141269, 3591329599, 3164325604, 727753846, 2179363840, 146436021, 1461446943, 4069977195, 705550613, 3059967265, 3887724982, 4281599278, 3313849956, 1404054877, 2845806497, 146425753, 1854211946, 1266315497, 3048417604, 3681880366, 3289982499, 290971e4, 1235738493, 2632868024, 2414719590, 3970600049, 1771706367, 1449415276, 3266420449, 422970021, 1963543593, 2690192192, 3826793022, 1062508698, 1531092325, 1804592342, 2583117782, 2714934279, 4024971509, 1294809318, 4028980673, 1289560198, 2221992742, 1669523910, 35572830, 157838143, 1052438473, 1016535060, 1802137761, 1753167236, 1386275462, 3080475397, 2857371447, 1040679964, 2145300060, 2390574316, 1461121720, 2956646967, 4031777805, 4028374788, 33600511, 2920084762, 1018524850, 629373528, 3691585981, 3515945977, 2091462646, 2486323059, 586499841, 988145025, 935516892, 3367335476, 2599673255, 2839830854, 265290510, 3972581182, 2759138881, 3795373465, 1005194799, 847297441, 406762289, 1314163512, 1332590856, 1866599683, 4127851711, 750260880, 613907577, 1450815602, 3165620655, 3734664991, 3650291728, 3012275730, 3704569646, 1427272223, 778793252, 1343938022, 2676280711, 2052605720, 1946737175, 3164576444, 3914038668, 3967478842, 3682934266, 1661551462, 3294938066, 4011595847, 840292616, 3712170807, 616741398, 312560963, 711312465, 1351876610, 322626781, 1910503582, 271666773, 2175563734, 1594956187, 70604529, 3617834859, 1007753275, 1495573769, 4069517037, 2549218298, 2663038764, 504708206, 2263041392, 3941167025, 2249088522, 1514023603, 1998579484, 1312622330, 694541497, 2582060303, 2151582166, 1382467621, 776784248, 2618340202, 3323268794, 2497899128, 2784771155, 503983604, 4076293799, 907881277, 423175695, 432175456, 1378068232, 4145222326, 3954048622, 3938656102, 3820766613, 2793130115, 2977904593, 26017576, 3274890735, 3194772133, 1700274565, 1756076034, 4006520079, 3677328699, 720338349, 1533947780, 354530856, 688349552, 3973924725, 1637815568, 332179504, 3949051286, 53804574, 2852348879, 3044236432, 1282449977, 3583942155, 3416972820, 4006381244, 1617046695, 2628476075, 3002303598, 1686838959, 431878346, 2686675385, 1700445008, 1080580658, 1009431731, 832498133, 3223435511, 2605976345, 2271191193, 2516031870, 1648197032, 4164389018, 2548247927, 300782431, 375919233, 238389289, 3353747414, 2531188641, 2019080857, 1475708069, 455242339, 2609103871, 448939670, 3451063019, 1395535956, 2413381860, 1841049896, 1491858159, 885456874, 4264095073, 4001119347, 1565136089, 3898914787, 1108368660, 540939232, 1173283510, 2745871338, 3681308437, 4207628240, 3343053890, 4016749493, 1699691293, 1103962373, 3625875870, 2256883143, 3830138730, 1031889488, 3479347698, 1535977030, 4236805024, 3251091107, 2132092099, 1774941330, 1199868427, 1452454533, 157007616, 2904115357, 342012276, 595725824, 1480756522, 206960106, 497939518, 591360097, 863170706, 2375253569, 3596610801, 1814182875, 2094937945, 3421402208, 1082520231, 3463918190, 2785509508, 435703966, 3908032597, 1641649973, 2842273706, 3305899714, 1510255612, 2148256476, 2655287854, 3276092548, 4258621189, 236887753, 3681803219, 274041037, 1734335097, 3815195456, 3317970021, 1899903192, 1026095262, 4050517792, 356393447, 2410691914, 3873677099, 3682840055, 3913112168, 2491498743, 4132185628, 2489919796, 1091903735, 1979897079, 3170134830, 3567386728, 3557303409, 857797738, 1136121015, 1342202287, 507115054, 2535736646, 337727348, 3213592640, 1301675037, 2528481711, 1895095763, 1721773893, 3216771564, 62756741, 2142006736, 835421444, 2531993523, 1442658625, 3659876326, 2882144922, 676362277, 1392781812, 170690266, 3921047035, 1759253602, 3611846912, 1745797284, 664899054, 1329594018, 3901205900, 3045908486, 2062866102, 2865634940, 3543621612, 3464012697, 1080764994, 553557557, 3656615353, 3996768171, 991055499, 499776247, 1265440854, 648242737, 3940784050, 980351604, 3713745714, 1749149687, 3396870395, 4211799374, 3640570775, 1161844396, 3125318951, 1431517754, 545492359, 4268468663, 3499529547, 1437099964, 2702547544, 3433638243, 2581715763, 2787789398, 1060185593, 1593081372, 2418618748, 4260947970, 69676912, 2159744348, 86519011, 2512459080, 3838209314, 1220612927, 3339683548, 133810670, 1090789135, 1078426020, 1569222167, 845107691, 3583754449, 4072456591, 1091646820, 628848692, 1613405280, 3757631651, 526609435, 236106946, 48312990, 2942717905, 3402727701, 1797494240, 859738849, 992217954, 4005476642, 2243076622, 3870952857, 3732016268, 765654824, 3490871365, 2511836413, 1685915746, 3888969200, 1414112111, 2273134842, 3281911079, 4080962846, 172450625, 2569994100, 980381355, 4109958455, 2819808352, 2716589560, 2568741196, 3681446669, 3329971472, 1835478071, 660984891, 3704678404, 4045999559, 3422617507, 3040415634, 1762651403, 1719377915, 3470491036, 2693910283, 3642056355, 3138596744, 1364962596, 2073328063, 1983633131, 926494387, 3423689081, 2150032023, 4096667949, 1749200295, 3328846651, 309677260, 2016342300, 1779581495, 3079819751, 111262694, 1274766160, 443224088, 298511866, 1025883608, 3806446537, 1145181785, 168956806, 3641502830, 3584813610, 1689216846, 3666258015, 3200248200, 1692713982, 2646376535, 4042768518, 1618508792, 1610833997, 3523052358, 4130873264, 2001055236, 3610705100, 2202168115, 4028541809, 2961195399, 1006657119, 2006996926, 3186142756, 1430667929, 3210227297, 1314452623, 4074634658, 4101304120, 2273951170, 1399257539, 3367210612, 3027628629, 1190975929, 2062231137, 2333990788, 2221543033, 2438960610, 1181637006, 548689776, 2362791313, 3372408396, 3104550113, 3145860560, 296247880, 1970579870, 3078560182, 3769228297, 1714227617, 3291629107, 3898220290, 166772364, 1251581989, 493813264, 448347421, 195405023, 2709975567, 677966185, 3703036547, 1463355134, 2715995803, 1338867538, 1343315457, 2802222074, 2684532164, 233230375, 2599980071, 2000651841, 3277868038, 1638401717, 4028070440, 3237316320, 6314154, 819756386, 300326615, 590932579, 1405279636, 3267499572, 3150704214, 2428286686, 3959192993, 3461946742, 1862657033, 1266418056, 963775037, 2089974820, 2263052895, 1917689273, 448879540, 3550394620, 3981727096, 150775221, 3627908307, 1303187396, 508620638, 2975983352, 2726630617, 1817252668, 1876281319, 1457606340, 908771278, 3720792119, 3617206836, 2455994898, 1729034894, 1080033504, 976866871, 3556439503, 2881648439, 1522871579, 1555064734, 1336096578, 3548522304, 2579274686, 3574697629, 3205460757, 3593280638, 3338716283, 3079412587, 564236357, 2993598910, 1781952180, 1464380207, 3163844217, 3332601554, 1699332808, 1393555694, 1183702653, 3581086237, 1288719814, 691649499, 2847557200, 2895455976, 3193889540, 2717570544, 1781354906, 1676643554, 2592534050, 3230253752, 1126444790, 2770207658, 2633158820, 2210423226, 2615765581, 2414155088, 3127139286, 673620729, 2805611233, 1269405062, 4015350505, 3341807571, 4149409754, 1057255273, 2012875353, 2162469141, 2276492801, 2601117357, 993977747, 3918593370, 2654263191, 753973209, 36408145, 2530585658, 25011837, 3520020182, 2088578344, 530523599, 2918365339, 1524020338, 1518925132, 3760827505, 3759777254, 1202760957, 3985898139, 3906192525, 674977740, 4174734889, 2031300136, 2019492241, 3983892565, 4153806404, 3822280332, 352677332, 2297720250, 60907813, 90501309, 3286998549, 1016092578, 2535922412, 2839152426, 457141659, 509813237, 4120667899, 652014361, 1966332200, 2975202805, 55981186, 2327461051, 676427537, 3255491064, 2882294119, 3433927263, 1307055953, 942726286, 933058658, 2468411793, 3933900994, 4215176142, 1361170020, 2001714738, 2830558078, 3274259782, 1222529897, 1679025792, 2729314320, 3714953764, 1770335741, 151462246, 3013232138, 1682292957, 1483529935, 471910574, 1539241949, 458788160, 3436315007, 1807016891, 3718408830, 978976581, 1043663428, 3165965781, 1927990952, 4200891579, 2372276910, 3208408903, 3533431907, 1412390302, 2931980059, 4132332400, 1947078029, 3881505623, 4168226417, 2941484381, 1077988104, 1320477388, 886195818, 18198404, 3786409e3, 2509781533, 112762804, 3463356488, 1866414978, 891333506, 18488651, 661792760, 1628790961, 3885187036, 3141171499, 876946877, 2693282273, 1372485963, 791857591, 2686433993, 3759982718, 3167212022, 3472953795, 2716379847, 445679433, 3561995674, 3504004811, 3574258232, 54117162, 3331405415, 2381918588, 3769707343, 4154350007, 1140177722, 4074052095, 668550556, 3214352940, 367459370, 261225585, 2610173221, 4209349473, 3468074219, 3265815641, 314222801, 3066103646, 3808782860, 282218597, 3406013506, 3773591054, 379116347, 1285071038, 846784868, 2669647154, 3771962079, 3550491691, 2305946142, 453669953, 1268987020, 3317592352, 3279303384, 3744833421, 2610507566, 3859509063, 266596637, 3847019092, 517658769, 3462560207, 3443424879, 370717030, 4247526661, 2224018117, 4143653529, 4112773975, 2788324899, 2477274417, 1456262402, 2901442914, 1517677493, 1846949527, 2295493580, 3734397586, 2176403920, 1280348187, 1908823572, 3871786941, 846861322, 1172426758, 3287448474, 3383383037, 1655181056, 3139813346, 901632758, 1897031941, 2986607138, 3066810236, 3447102507, 1393639104, 373351379, 950779232, 625454576, 3124240540, 4148612726, 2007998917, 544563296, 2244738638, 2330496472, 2058025392, 1291430526, 424198748, 50039436, 29584100, 3605783033, 2429876329, 2791104160, 1057563949, 3255363231, 3075367218, 3463963227, 1469046755, 985887462], $ = [1332899944, 1700884034, 1701343084, 1684370003, 1668446532, 1869963892];
    function F(B, u, p, d) {
      var y, w = B[u], E = B[u + 1];
      return w ^= p[0], y = d[w >>> 24], y += d[256 | w >> 16 & 255], y ^= d[512 | w >> 8 & 255], y += d[768 | w & 255], E ^= y ^ p[1], y = d[E >>> 24], y += d[256 | E >> 16 & 255], y ^= d[512 | E >> 8 & 255], y += d[768 | E & 255], w ^= y ^ p[2], y = d[w >>> 24], y += d[256 | w >> 16 & 255], y ^= d[512 | w >> 8 & 255], y += d[768 | w & 255], E ^= y ^ p[3], y = d[E >>> 24], y += d[256 | E >> 16 & 255], y ^= d[512 | E >> 8 & 255], y += d[768 | E & 255], w ^= y ^ p[4], y = d[w >>> 24], y += d[256 | w >> 16 & 255], y ^= d[512 | w >> 8 & 255], y += d[768 | w & 255], E ^= y ^ p[5], y = d[E >>> 24], y += d[256 | E >> 16 & 255], y ^= d[512 | E >> 8 & 255], y += d[768 | E & 255], w ^= y ^ p[6], y = d[w >>> 24], y += d[256 | w >> 16 & 255], y ^= d[512 | w >> 8 & 255], y += d[768 | w & 255], E ^= y ^ p[7], y = d[E >>> 24], y += d[256 | E >> 16 & 255], y ^= d[512 | E >> 8 & 255], y += d[768 | E & 255], w ^= y ^ p[8], y = d[w >>> 24], y += d[256 | w >> 16 & 255], y ^= d[512 | w >> 8 & 255], y += d[768 | w & 255], E ^= y ^ p[9], y = d[E >>> 24], y += d[256 | E >> 16 & 255], y ^= d[512 | E >> 8 & 255], y += d[768 | E & 255], w ^= y ^ p[10], y = d[w >>> 24], y += d[256 | w >> 16 & 255], y ^= d[512 | w >> 8 & 255], y += d[768 | w & 255], E ^= y ^ p[11], y = d[E >>> 24], y += d[256 | E >> 16 & 255], y ^= d[512 | E >> 8 & 255], y += d[768 | E & 255], w ^= y ^ p[12], y = d[w >>> 24], y += d[256 | w >> 16 & 255], y ^= d[512 | w >> 8 & 255], y += d[768 | w & 255], E ^= y ^ p[13], y = d[E >>> 24], y += d[256 | E >> 16 & 255], y ^= d[512 | E >> 8 & 255], y += d[768 | E & 255], w ^= y ^ p[14], y = d[w >>> 24], y += d[256 | w >> 16 & 255], y ^= d[512 | w >> 8 & 255], y += d[768 | w & 255], E ^= y ^ p[15], y = d[E >>> 24], y += d[256 | E >> 16 & 255], y ^= d[512 | E >> 8 & 255], y += d[768 | E & 255], w ^= y ^ p[16], B[u] = E ^ p[_ + 1], B[u + 1] = w, B;
    }
    function U(B, u) {
      for (var p = 0, d = 0; p < 4; ++p) d = d << 8 | B[u] & 255, u = (u + 1) % B.length;
      return { key: d, offp: u };
    }
    function Q(B, u, p) {
      for (var d = 0, y = [0, 0], w = u.length, E = p.length, M, x = 0; x < w; x++) M = U(B, d), d = M.offp, u[x] = u[x] ^ M.key;
      for (x = 0; x < w; x += 2) y = F(y, 0, u, p), u[x] = y[0], u[x + 1] = y[1];
      for (x = 0; x < E; x += 2) y = F(y, 0, u, p), p[x] = y[0], p[x + 1] = y[1];
    }
    function P(B, u, p, d) {
      for (var y = 0, w = [0, 0], E = p.length, M = d.length, x, g = 0; g < E; g++) x = U(u, y), y = x.offp, p[g] = p[g] ^ x.key;
      for (y = 0, g = 0; g < E; g += 2) x = U(B, y), y = x.offp, w[0] ^= x.key, x = U(B, y), y = x.offp, w[1] ^= x.key, w = F(w, 0, p, d), p[g] = w[0], p[g + 1] = w[1];
      for (g = 0; g < M; g += 2) x = U(B, y), y = x.offp, w[0] ^= x.key, x = U(B, y), y = x.offp, w[1] ^= x.key, w = F(w, 0, p, d), d[g] = w[0], d[g + 1] = w[1];
    }
    function N(B, u, p, d, y) {
      var w = $.slice(), E = w.length, M;
      if (p < 4 || p > 31) if (M = Error("Illegal number of rounds (4-31): " + p), d) {
        a(d.bind(this, M));
        return;
      } else throw M;
      if (u.length !== b) if (M = Error("Illegal salt length: " + u.length + " != " + b), d) {
        a(d.bind(this, M));
        return;
      } else throw M;
      p = 1 << p >>> 0;
      var x, g, k = 0, T;
      Int32Array ? (x = new Int32Array(I), g = new Int32Array(S)) : (x = I.slice(), g = S.slice()), P(u, B, x, g);
      function O() {
        if (y && y(k / p), k < p) for (var Y = Date.now(); k < p && (k = k + 1, Q(B, x, g), Q(u, x, g), !(Date.now() - Y > C)); ) ;
        else {
          for (k = 0; k < 64; k++) for (T = 0; T < E >> 1; T++) F(w, T << 1, x, g);
          var J = [];
          for (k = 0; k < E; k++) J.push((w[k] >> 24 & 255) >>> 0), J.push((w[k] >> 16 & 255) >>> 0), J.push((w[k] >> 8 & 255) >>> 0), J.push((w[k] & 255) >>> 0);
          if (d) {
            d(null, J);
            return;
          } else return J;
        }
        d && a(O);
      }
      if (typeof d < "u") O();
      else for (var K; ; ) if (typeof (K = O()) < "u") return K || [];
    }
    function L(B, u, p, d) {
      var y;
      if (typeof B != "string" || typeof u != "string") if (y = Error("Invalid string / salt: Not a string"), p) {
        a(p.bind(this, y));
        return;
      } else throw y;
      var w, E;
      if (u.charAt(0) !== "$" || u.charAt(1) !== "2") if (y = Error("Invalid salt version: " + u.substring(0, 2)), p) {
        a(p.bind(this, y));
        return;
      } else throw y;
      if (u.charAt(2) === "$") w = "\0", E = 3;
      else {
        if (w = u.charAt(2), w !== "a" && w !== "b" && w !== "y" || u.charAt(3) !== "$") if (y = Error("Invalid salt revision: " + u.substring(2, 4)), p) {
          a(p.bind(this, y));
          return;
        } else throw y;
        E = 4;
      }
      if (u.charAt(E + 2) > "$") if (y = Error("Missing salt rounds"), p) {
        a(p.bind(this, y));
        return;
      } else throw y;
      var M = parseInt(u.substring(E, E + 1), 10) * 10, x = parseInt(u.substring(E + 1, E + 2), 10), g = M + x, k = u.substring(E + 3, E + 25);
      B += w >= "a" ? "\0" : "";
      var T = o(B), O = m(k, b);
      function K(Y) {
        var J = [];
        return J.push("$2"), w >= "a" && J.push(w), J.push("$"), g < 10 && J.push("0"), J.push(g.toString()), J.push("$"), J.push(h(O, O.length)), J.push(h(Y, $.length * 4 - 1)), J.join("");
      }
      if (typeof p > "u") return K(N(T, O, g));
      N(T, O, g, function(Y, J) {
        Y ? p(Y, null) : p(null, K(J));
      }, d);
    }
    return e.encodeBase64 = h, e.decodeBase64 = m, e;
  });
})(UF);
var B1e = UF.exports;
const C1e = Fa(B1e);
async function k1e(t3) {
  if (!t3) throw new Error("Please enter a password.");
  const e = await C1e.hash(t3, 10);
  return { raw: e, base64: btoa(e), hex: I1e(e) };
}
function I1e(t3) {
  let e = "";
  for (let n = 0; n < t3.length; n++) e += "" + t3.charCodeAt(n).toString(16);
  return e;
}
function S1e(t3) {
  let e;
  return { c() {
    e = we("Generate Hash");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function M1e(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function Z9(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[2]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 4 && Ze(n, r[2]);
  }, d(r) {
    r && D(e);
  } };
}
function j9(t3) {
  let e, n, r, s, i, a;
  return e = new et({ props: { label: "Hex digest:", value: t3[1].hex, readonly: true, expandable: true, withCopy: true } }), r = new et({ props: { label: "Base64 digest:", value: t3[1].base64, readonly: true, expandable: true, withCopy: true } }), i = new et({ props: { label: "Raw digest:", value: t3[1].raw, readonly: true, expandable: true, withCopy: true } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment), s = z(), fe(i.$$.fragment);
  }, m(o, f) {
    ae(e, o, f), R(o, n, f), ae(r, o, f), R(o, s, f), ae(i, o, f), a = true;
  }, p(o, f) {
    const c = {};
    f & 2 && (c.value = o[1].hex), e.$set(c);
    const l = {};
    f & 2 && (l.value = o[1].base64), r.$set(l);
    const h = {};
    f & 2 && (h.value = o[1].raw), i.$set(h);
  }, i(o) {
    a || (W(e.$$.fragment, o), W(r.$$.fragment, o), W(i.$$.fragment, o), a = true);
  }, o(o) {
    j(e.$$.fragment, o), j(r.$$.fragment, o), j(i.$$.fragment, o), a = false;
  }, d(o) {
    o && (D(n), D(s)), oe(e, o), oe(r, o), oe(i, o);
  } };
}
function $1e(t3) {
  let e, n, r, s, i, a, o, f, c, l, h;
  function m(_) {
    t3[5](_);
  }
  let v = { label: "Enter password:", type: "password", placeholder: "e.g SecretPass123", expandable: false };
  t3[0] !== void 0 && (v.value = t3[0]), e = new et({ props: v }), Qe.push(() => ze(e, "value", m)), i = new ut({ props: { $$slots: { default: [S1e] }, $$scope: { ctx: t3 } } }), i.$on("click", t3[3]), o = new ut({ props: { variant: "secondary", $$slots: { default: [M1e] }, $$scope: { ctx: t3 } } }), o.$on("click", t3[6]);
  let b = t3[2] && Z9(t3), A = t3[1] && j9(t3);
  return { c() {
    fe(e.$$.fragment), r = z(), s = H("div"), fe(i.$$.fragment), a = z(), fe(o.$$.fragment), f = z(), b && b.c(), c = z(), A && A.c(), l = Lt(), V(s, "class", "button-row");
  }, m(_, C) {
    ae(e, _, C), R(_, r, C), R(_, s, C), ae(i, s, null), q(s, a), ae(o, s, null), R(_, f, C), b && b.m(_, C), R(_, c, C), A && A.m(_, C), R(_, l, C), h = true;
  }, p(_, C) {
    const I = {};
    !n && C & 1 && (n = true, I.value = _[0], qe(() => n = false)), e.$set(I);
    const S = {};
    C & 256 && (S.$$scope = { dirty: C, ctx: _ }), i.$set(S);
    const $ = {};
    C & 256 && ($.$$scope = { dirty: C, ctx: _ }), o.$set($), _[2] ? b ? b.p(_, C) : (b = Z9(_), b.c(), b.m(c.parentNode, c)) : b && (b.d(1), b = null), _[1] ? A ? (A.p(_, C), C & 2 && W(A, 1)) : (A = j9(_), A.c(), W(A, 1), A.m(l.parentNode, l)) : A && (Xt(), j(A, 1, 1, () => {
      A = null;
    }), er());
  }, i(_) {
    h || (W(e.$$.fragment, _), W(i.$$.fragment, _), W(o.$$.fragment, _), W(A), h = true);
  }, o(_) {
    j(e.$$.fragment, _), j(i.$$.fragment, _), j(o.$$.fragment, _), j(A), h = false;
  }, d(_) {
    _ && (D(r), D(s), D(f), D(c), D(l)), oe(e, _), oe(i), oe(o), b && b.d(_), A && A.d(_);
  } };
}
function T1e(t3) {
  let e, n, r, s, i, a, o;
  return { c() {
    e = H("p"), e.innerHTML = `This tool allows you to securely hash passwords using the <b>Bcrypt</b> algorithm. 
    Simply enter a password and click to generate the hash.`, n = z(), r = H("p"), r.innerHTML = "<b>What is Bcrypt?</b>", s = z(), i = H("p"), i.innerHTML = `Bcrypt is a password hashing function designed for security. It incorporates automatic <b>salting</b> 
    and an adjustable cost factor, making it resistant to brute-force attacks.`, a = z(), o = H("p"), o.textContent = `Unlike traditional hashing methods, Bcrypt is deliberately slow, ensuring better protection against 
    modern computing power. Your passwords are automatically salted for enhanced security.`;
  }, m(f, c) {
    R(f, e, c), R(f, n, c), R(f, r, c), R(f, s, c), R(f, i, c), R(f, a, c), R(f, o, c);
  }, p: dt, d(f) {
    f && (D(e), D(n), D(r), D(s), D(i), D(a), D(o));
  } };
}
function D1e(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Bcrypt Hash Generator", $$slots: { default: [$1e] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Bcrypt", links: t3[4], $$slots: { default: [T1e] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 263 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 256 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function R1e(t3, e, n) {
  let r = "", s = null, i = "";
  async function a() {
    n(2, i = ""), n(1, s = null);
    try {
      n(1, s = await k1e(r));
    } catch (l) {
      console.error(l), n(2, i = l.message);
    } finally {
    }
  }
  const o = [{ text: "Bcrypt - Wikipedia", url: "https://en.wikipedia.org/wiki/Bcrypt" }, { text: "NPM Package", url: "https://www.npmjs.com/package/bcryptjs" }];
  function f(l) {
    r = l, n(0, r);
  }
  return [r, s, i, a, o, f, () => {
    n(0, r = ""), n(1, s = null);
  }];
}
class F1e extends xt {
  constructor(e) {
    super(), wt(this, e, R1e, D1e, At, {});
  }
}
const LF = Uint8Array.from([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9]);
function Tf(t3, e, n, r, s) {
  return t3 = t3 + e + s | 0, r = As(r ^ t3, 16), n = n + r | 0, e = As(e ^ n, 12), { a: t3, b: e, c: n, d: r };
}
function Df(t3, e, n, r, s) {
  return t3 = t3 + e + s | 0, r = As(r ^ t3, 8), n = n + r | 0, e = As(e ^ n, 7), { a: t3, b: e, c: n, d: r };
}
const fi = Uint32Array.from([4089235720, 1779033703, 2227873595, 3144134277, 4271175723, 1013904242, 1595750129, 2773480762, 2917565137, 1359893119, 725511199, 2600822924, 4215389547, 528734635, 327033209, 1541459225]), rr = new Uint32Array(32);
function Rf(t3, e, n, r, s, i) {
  const a = s[i], o = s[i + 1];
  let f = rr[2 * t3], c = rr[2 * t3 + 1], l = rr[2 * e], h = rr[2 * e + 1], m = rr[2 * n], v = rr[2 * n + 1], b = rr[2 * r], A = rr[2 * r + 1], _ = O4(f, l, a);
  c = Q4(_, c, h, o), f = _ | 0, { Dh: A, Dl: b } = { Dh: A ^ c, Dl: b ^ f }, { Dh: A, Dl: b } = { Dh: ppe(A, b), Dl: gpe(A) }, { h: v, l: m } = _a(v, m, A, b), { Bh: h, Bl: l } = { Bh: h ^ v, Bl: l ^ m }, { Bh: h, Bl: l } = { Bh: Qf(h, l, 24), Bl: Kf(h, l, 24) }, rr[2 * t3] = f, rr[2 * t3 + 1] = c, rr[2 * e] = l, rr[2 * e + 1] = h, rr[2 * n] = m, rr[2 * n + 1] = v, rr[2 * r] = b, rr[2 * r + 1] = A;
}
function Ff(t3, e, n, r, s, i) {
  const a = s[i], o = s[i + 1];
  let f = rr[2 * t3], c = rr[2 * t3 + 1], l = rr[2 * e], h = rr[2 * e + 1], m = rr[2 * n], v = rr[2 * n + 1], b = rr[2 * r], A = rr[2 * r + 1], _ = O4(f, l, a);
  c = Q4(_, c, h, o), f = _ | 0, { Dh: A, Dl: b } = { Dh: A ^ c, Dl: b ^ f }, { Dh: A, Dl: b } = { Dh: Qf(A, b, 16), Dl: Kf(A, b, 16) }, { h: v, l: m } = _a(v, m, A, b), { Bh: h, Bl: l } = { Bh: h ^ v, Bl: l ^ m }, { Bh: h, Bl: l } = { Bh: th(h, l, 63), Bl: rh(h, l, 63) }, rr[2 * t3] = f, rr[2 * t3 + 1] = c, rr[2 * e] = l, rr[2 * e + 1] = h, rr[2 * n] = m, rr[2 * n + 1] = v, rr[2 * r] = b, rr[2 * r + 1] = A;
}
function OF(t3, e = {}, n, r, s) {
  if (cl(n), t3 < 0 || t3 > n) throw new Error("outputLen bigger than keyLen");
  const { key: i, salt: a, personalization: o } = e;
  if (i !== void 0 && (i.length < 1 || i.length > n)) throw new Error("key length must be undefined or 1.." + n);
  if (a !== void 0 && a.length !== r) throw new Error("salt must be undefined or " + r);
  if (o !== void 0 && o.length !== s) throw new Error("personalization must be undefined or " + s);
}
class H4 extends Bm {
  constructor(e, n) {
    super(), this.finished = false, this.destroyed = false, this.length = 0, this.pos = 0, cl(e), cl(n), this.blockLen = e, this.outputLen = n, this.buffer = new Uint8Array(e), this.buffer32 = uf(this.buffer);
  }
  update(e) {
    lf(this), e = rs(e), Ra(e);
    const { blockLen: n, buffer: r, buffer32: s } = this, i = e.length, a = e.byteOffset, o = e.buffer;
    for (let f = 0; f < i; ) {
      this.pos === n && (ls(s), this.compress(s, 0, false), ls(s), this.pos = 0);
      const c = Math.min(n - this.pos, i - f), l = a + f;
      if (c === n && !(l % 4) && f + c < i) {
        const h = new Uint32Array(o, l, Math.floor((i - f) / 4));
        ls(h);
        for (let m = 0; f + n < i; m += s.length, f += n) this.length += n, this.compress(h, m, false);
        ls(h);
        continue;
      }
      r.set(e.subarray(f, f + c), this.pos), this.pos += c, this.length += c, f += c;
    }
    return this;
  }
  digestInto(e) {
    lf(this), Em(e, this);
    const { pos: n, buffer32: r } = this;
    this.finished = true, Li(this.buffer.subarray(n)), ls(r), this.compress(r, 0, true), ls(r);
    const s = uf(e);
    this.get().forEach((i, a) => s[a] = Ns(i));
  }
  digest() {
    const { buffer: e, outputLen: n } = this;
    this.digestInto(e);
    const r = e.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(e) {
    const { buffer: n, length: r, finished: s, destroyed: i, outputLen: a, pos: o } = this;
    return e || (e = new this.constructor({ dkLen: a })), e.set(...this.get()), e.buffer.set(n), e.destroyed = i, e.finished = s, e.length = r, e.pos = o, e.outputLen = a, e;
  }
  clone() {
    return this._cloneInto();
  }
}
class P1e extends H4 {
  constructor(e = {}) {
    const n = e.dkLen === void 0 ? 64 : e.dkLen;
    super(128, n), this.v0l = fi[0] | 0, this.v0h = fi[1] | 0, this.v1l = fi[2] | 0, this.v1h = fi[3] | 0, this.v2l = fi[4] | 0, this.v2h = fi[5] | 0, this.v3l = fi[6] | 0, this.v3h = fi[7] | 0, this.v4l = fi[8] | 0, this.v4h = fi[9] | 0, this.v5l = fi[10] | 0, this.v5h = fi[11] | 0, this.v6l = fi[12] | 0, this.v6h = fi[13] | 0, this.v7l = fi[14] | 0, this.v7h = fi[15] | 0, OF(n, e, 64, 16, 16);
    let { key: r, personalization: s, salt: i } = e, a = 0;
    if (r !== void 0 && (r = rs(r), a = r.length), this.v0l ^= this.outputLen | a << 8 | 65536 | 1 << 24, i !== void 0) {
      i = rs(i);
      const o = uf(i);
      this.v4l ^= Ns(o[0]), this.v4h ^= Ns(o[1]), this.v5l ^= Ns(o[2]), this.v5h ^= Ns(o[3]);
    }
    if (s !== void 0) {
      s = rs(s);
      const o = uf(s);
      this.v6l ^= Ns(o[0]), this.v6h ^= Ns(o[1]), this.v7l ^= Ns(o[2]), this.v7h ^= Ns(o[3]);
    }
    if (r !== void 0) {
      const o = new Uint8Array(this.blockLen);
      o.set(r), this.update(o);
    }
  }
  get() {
    let { v0l: e, v0h: n, v1l: r, v1h: s, v2l: i, v2h: a, v3l: o, v3h: f, v4l: c, v4h: l, v5l: h, v5h: m, v6l: v, v6h: b, v7l: A, v7h: _ } = this;
    return [e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _];
  }
  set(e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _) {
    this.v0l = e | 0, this.v0h = n | 0, this.v1l = r | 0, this.v1h = s | 0, this.v2l = i | 0, this.v2h = a | 0, this.v3l = o | 0, this.v3h = f | 0, this.v4l = c | 0, this.v4h = l | 0, this.v5l = h | 0, this.v5h = m | 0, this.v6l = v | 0, this.v6h = b | 0, this.v7l = A | 0, this.v7h = _ | 0;
  }
  compress(e, n, r) {
    this.get().forEach((f, c) => rr[c] = f), rr.set(fi, 16);
    let { h: s, l: i } = Hh(BigInt(this.length));
    rr[24] = fi[8] ^ i, rr[25] = fi[9] ^ s, r && (rr[28] = ~rr[28], rr[29] = ~rr[29]);
    let a = 0;
    const o = LF;
    for (let f = 0; f < 12; f++) Rf(0, 4, 8, 12, e, n + 2 * o[a++]), Ff(0, 4, 8, 12, e, n + 2 * o[a++]), Rf(1, 5, 9, 13, e, n + 2 * o[a++]), Ff(1, 5, 9, 13, e, n + 2 * o[a++]), Rf(2, 6, 10, 14, e, n + 2 * o[a++]), Ff(2, 6, 10, 14, e, n + 2 * o[a++]), Rf(3, 7, 11, 15, e, n + 2 * o[a++]), Ff(3, 7, 11, 15, e, n + 2 * o[a++]), Rf(0, 5, 10, 15, e, n + 2 * o[a++]), Ff(0, 5, 10, 15, e, n + 2 * o[a++]), Rf(1, 6, 11, 12, e, n + 2 * o[a++]), Ff(1, 6, 11, 12, e, n + 2 * o[a++]), Rf(2, 7, 8, 13, e, n + 2 * o[a++]), Ff(2, 7, 8, 13, e, n + 2 * o[a++]), Rf(3, 4, 9, 14, e, n + 2 * o[a++]), Ff(3, 4, 9, 14, e, n + 2 * o[a++]);
    this.v0l ^= rr[0] ^ rr[16], this.v0h ^= rr[1] ^ rr[17], this.v1l ^= rr[2] ^ rr[18], this.v1h ^= rr[3] ^ rr[19], this.v2l ^= rr[4] ^ rr[20], this.v2h ^= rr[5] ^ rr[21], this.v3l ^= rr[6] ^ rr[22], this.v3h ^= rr[7] ^ rr[23], this.v4l ^= rr[8] ^ rr[24], this.v4h ^= rr[9] ^ rr[25], this.v5l ^= rr[10] ^ rr[26], this.v5h ^= rr[11] ^ rr[27], this.v6l ^= rr[12] ^ rr[28], this.v6h ^= rr[13] ^ rr[29], this.v7l ^= rr[14] ^ rr[30], this.v7h ^= rr[15] ^ rr[31], Li(rr);
  }
  destroy() {
    this.destroyed = true, Li(this.buffer32), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
const N1e = vF((t3) => new P1e(t3));
function $b(t3, e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S) {
  let $ = 0;
  for (let F = 0; F < r; F++) ({ a: s, b: f, c: m, d: _ } = Tf(s, f, m, _, n[e + t3[$++]])), { a: s, b: f, c: m, d: _ } = Df(s, f, m, _, n[e + t3[$++]]), { a: i, b: c, c: v, d: C } = Tf(i, c, v, C, n[e + t3[$++]]), { a: i, b: c, c: v, d: C } = Df(i, c, v, C, n[e + t3[$++]]), { a, b: l, c: b, d: I } = Tf(a, l, b, I, n[e + t3[$++]]), { a, b: l, c: b, d: I } = Df(a, l, b, I, n[e + t3[$++]]), { a: o, b: h, c: A, d: S } = Tf(o, h, A, S, n[e + t3[$++]]), { a: o, b: h, c: A, d: S } = Df(o, h, A, S, n[e + t3[$++]]), { a: s, b: c, c: b, d: S } = Tf(s, c, b, S, n[e + t3[$++]]), { a: s, b: c, c: b, d: S } = Df(s, c, b, S, n[e + t3[$++]]), { a: i, b: l, c: A, d: _ } = Tf(i, l, A, _, n[e + t3[$++]]), { a: i, b: l, c: A, d: _ } = Df(i, l, A, _, n[e + t3[$++]]), { a, b: h, c: m, d: C } = Tf(a, h, m, C, n[e + t3[$++]]), { a, b: h, c: m, d: C } = Df(a, h, m, C, n[e + t3[$++]]), { a: o, b: f, c: v, d: I } = Tf(o, f, v, I, n[e + t3[$++]]), { a: o, b: f, c: v, d: I } = Df(o, f, v, I, n[e + t3[$++]]);
  return { v0: s, v1: i, v2: a, v3: o, v4: f, v5: c, v6: l, v7: h, v8: m, v9: v, v10: b, v11: A, v12: _, v13: C, v14: I, v15: S };
}
const Si = Ga;
class U1e extends H4 {
  constructor(e = {}) {
    const n = e.dkLen === void 0 ? 32 : e.dkLen;
    super(64, n), this.v0 = Si[0] | 0, this.v1 = Si[1] | 0, this.v2 = Si[2] | 0, this.v3 = Si[3] | 0, this.v4 = Si[4] | 0, this.v5 = Si[5] | 0, this.v6 = Si[6] | 0, this.v7 = Si[7] | 0, OF(n, e, 32, 8, 8);
    let { key: r, personalization: s, salt: i } = e, a = 0;
    if (r !== void 0 && (r = rs(r), a = r.length), this.v0 ^= this.outputLen | a << 8 | 65536 | 1 << 24, i !== void 0) {
      i = rs(i);
      const o = uf(i);
      this.v4 ^= Ns(o[0]), this.v5 ^= Ns(o[1]);
    }
    if (s !== void 0) {
      s = rs(s);
      const o = uf(s);
      this.v6 ^= Ns(o[0]), this.v7 ^= Ns(o[1]);
    }
    if (r !== void 0) {
      Ra(r);
      const o = new Uint8Array(this.blockLen);
      o.set(r), this.update(o);
    }
  }
  get() {
    const { v0: e, v1: n, v2: r, v3: s, v4: i, v5: a, v6: o, v7: f } = this;
    return [e, n, r, s, i, a, o, f];
  }
  set(e, n, r, s, i, a, o, f) {
    this.v0 = e | 0, this.v1 = n | 0, this.v2 = r | 0, this.v3 = s | 0, this.v4 = i | 0, this.v5 = a | 0, this.v6 = o | 0, this.v7 = f | 0;
  }
  compress(e, n, r) {
    const { h: s, l: i } = Hh(BigInt(this.length)), { v0: a, v1: o, v2: f, v3: c, v4: l, v5: h, v6: m, v7: v, v8: b, v9: A, v10: _, v11: C, v12: I, v13: S, v14: $, v15: F } = $b(LF, n, e, 10, this.v0, this.v1, this.v2, this.v3, this.v4, this.v5, this.v6, this.v7, Si[0], Si[1], Si[2], Si[3], i ^ Si[4], s ^ Si[5], r ? ~Si[6] : Si[6], Si[7]);
    this.v0 ^= a ^ b, this.v1 ^= o ^ A, this.v2 ^= f ^ _, this.v3 ^= c ^ C, this.v4 ^= l ^ I, this.v5 ^= h ^ S, this.v6 ^= m ^ $, this.v7 ^= v ^ F;
  }
  destroy() {
    this.destroyed = true, Li(this.buffer32), this.set(0, 0, 0, 0, 0, 0, 0, 0);
  }
}
const L1e = vF((t3) => new U1e(t3)), Ka = { CHUNK_START: 1, CHUNK_END: 2, PARENT: 4, ROOT: 8, KEYED_HASH: 16, DERIVE_KEY_CONTEXT: 32, DERIVE_KEY_MATERIAL: 64 }, Qo = Ga.slice(), X9 = (() => {
  const t3 = Array.from({ length: 16 }, (r, s) => s), e = (r) => [2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8].map((s) => r[s]), n = [];
  for (let r = 0, s = t3; r < 7; r++, s = e(s)) n.push(...s);
  return Uint8Array.from(n);
})();
class q4 extends H4 {
  constructor(e = {}, n = 0) {
    super(64, e.dkLen === void 0 ? 32 : e.dkLen), this.chunkPos = 0, this.chunksDone = 0, this.flags = 0, this.stack = [], this.posOut = 0, this.bufferOut32 = new Uint32Array(16), this.chunkOut = 0, this.enableXOF = true;
    const { key: r, context: s } = e, i = s !== void 0;
    if (r !== void 0) {
      if (i) throw new Error('Only "key" or "context" can be specified at same time');
      const a = rs(r).slice();
      Ra(a, 32), this.IV = uf(a), ls(this.IV), this.flags = n | Ka.KEYED_HASH;
    } else if (i) {
      const a = rs(s), o = new q4({ dkLen: 32 }, Ka.DERIVE_KEY_CONTEXT).update(a).digest();
      this.IV = uf(o), ls(this.IV), this.flags = n | Ka.DERIVE_KEY_MATERIAL;
    } else this.IV = Qo.slice(), this.flags = n;
    this.state = this.IV.slice(), this.bufferOut = D0e(this.bufferOut32);
  }
  get() {
    return [];
  }
  set() {
  }
  b2Compress(e, n, r, s = 0) {
    const { state: i, pos: a } = this, { h: o, l: f } = Hh(BigInt(e), true), { v0: c, v1: l, v2: h, v3: m, v4: v, v5: b, v6: A, v7: _, v8: C, v9: I, v10: S, v11: $, v12: F, v13: U, v14: Q, v15: P } = $b(X9, s, r, 7, i[0], i[1], i[2], i[3], i[4], i[5], i[6], i[7], Qo[0], Qo[1], Qo[2], Qo[3], o, f, a, n);
    i[0] = c ^ C, i[1] = l ^ I, i[2] = h ^ S, i[3] = m ^ $, i[4] = v ^ F, i[5] = b ^ U, i[6] = A ^ Q, i[7] = _ ^ P;
  }
  compress(e, n = 0, r = false) {
    let s = this.flags;
    if (this.chunkPos || (s |= Ka.CHUNK_START), (this.chunkPos === 15 || r) && (s |= Ka.CHUNK_END), r || (this.pos = this.blockLen), this.b2Compress(this.chunksDone, s, e, n), this.chunkPos += 1, this.chunkPos === 16 || r) {
      let i = this.state;
      this.state = this.IV.slice();
      for (let a, o = this.chunksDone + 1; (r || !(o & 1)) && (a = this.stack.pop()); o >>= 1) this.buffer32.set(a, 0), this.buffer32.set(i, 8), this.pos = this.blockLen, this.b2Compress(0, this.flags | Ka.PARENT, this.buffer32, 0), i = this.state, this.state = this.IV.slice();
      this.chunksDone++, this.chunkPos = 0, this.stack.push(i);
    }
    this.pos = 0;
  }
  _cloneInto(e) {
    e = super._cloneInto(e);
    const { IV: n, flags: r, state: s, chunkPos: i, posOut: a, chunkOut: o, stack: f, chunksDone: c } = this;
    return e.state.set(s.slice()), e.stack = f.map((l) => Uint32Array.from(l)), e.IV.set(n), e.flags = r, e.chunkPos = i, e.chunksDone = c, e.posOut = a, e.chunkOut = o, e.enableXOF = this.enableXOF, e.bufferOut32.set(this.bufferOut32), e;
  }
  destroy() {
    this.destroyed = true, Li(this.state, this.buffer32, this.IV, this.bufferOut32), Li(...this.stack);
  }
  b2CompressOut() {
    const { state: e, pos: n, flags: r, buffer32: s, bufferOut32: i } = this, { h: a, l: o } = Hh(BigInt(this.chunkOut++));
    ls(s);
    const { v0: f, v1: c, v2: l, v3: h, v4: m, v5: v, v6: b, v7: A, v8: _, v9: C, v10: I, v11: S, v12: $, v13: F, v14: U, v15: Q } = $b(X9, 0, s, 7, e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], Qo[0], Qo[1], Qo[2], Qo[3], o, a, n, r);
    i[0] = f ^ _, i[1] = c ^ C, i[2] = l ^ I, i[3] = h ^ S, i[4] = m ^ $, i[5] = v ^ F, i[6] = b ^ U, i[7] = A ^ Q, i[8] = e[0] ^ _, i[9] = e[1] ^ C, i[10] = e[2] ^ I, i[11] = e[3] ^ S, i[12] = e[4] ^ $, i[13] = e[5] ^ F, i[14] = e[6] ^ U, i[15] = e[7] ^ Q, ls(s), ls(i), this.posOut = 0;
  }
  finish() {
    if (this.finished) return;
    this.finished = true, Li(this.buffer.subarray(this.pos));
    let e = this.flags | Ka.ROOT;
    this.stack.length ? (e |= Ka.PARENT, ls(this.buffer32), this.compress(this.buffer32, 0, true), ls(this.buffer32), this.chunksDone = 0, this.pos = this.blockLen) : e |= (this.chunkPos ? 0 : Ka.CHUNK_START) | Ka.CHUNK_END, this.flags = e, this.b2CompressOut();
  }
  writeInto(e) {
    lf(this, false), Ra(e), this.finish();
    const { blockLen: n, bufferOut: r } = this;
    for (let s = 0, i = e.length; s < i; ) {
      this.posOut >= n && this.b2CompressOut();
      const a = Math.min(n - this.posOut, i - s);
      e.set(r.subarray(this.posOut, this.posOut + a), s), this.posOut += a, s += a;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF) throw new Error("XOF is not possible after digest call");
    return this.writeInto(e);
  }
  xof(e) {
    return cl(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (Em(e, this), this.finished) throw new Error("digest() was already called");
    return this.enableXOF = false, this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
}
const O1e = N4((t3) => new q4(t3)), Q1e = { BLAKE2s: L1e, BLAKE2b: N1e, BLAKE3: O1e };
function K1e(t3, e, n = "utf-8") {
  if (!t3) throw new Error("Please enter some text.");
  const r = Q1e[e];
  if (!r) throw new Error(`Algorithm ${e} is not supported or module is missing.`);
  let s;
  try {
    s = ps(t3, n);
  } catch (f) {
    throw new Error(f.message);
  }
  const i = r(s), a = Al(i), o = btoa(String.fromCharCode(...i));
  return { hex: a, base64: o, bitLength: i.length * 8 };
}
function H1e(t3) {
  let e;
  return { c() {
    e = we("Generate Hash");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function q1e(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function eB(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[5]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 32 && Ze(n, r[5]);
  }, d(r) {
    r && D(e);
  } };
}
function tB(t3) {
  let e, n, r, s;
  return e = new et({ props: { label: t3[1] + " Hex:", value: t3[4].hex, readonly: true, expandable: true, withCopy: true } }), r = new et({ props: { label: t3[1] + " Base64:", value: t3[4].base64, readonly: true, expandable: true, withCopy: true } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, a) {
    const o = {};
    a & 2 && (o.label = i[1] + " Hex:"), a & 16 && (o.value = i[4].hex), e.$set(o);
    const f = {};
    a & 2 && (f.label = i[1] + " Base64:"), a & 16 && (f.value = i[4].base64), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function z1e(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U;
  function Q(E) {
    t3[9](E);
  }
  let P = { label: "Algorithm:", options: t3[6] };
  t3[1] !== void 0 && (P.value = t3[1]), n = new Ht({ props: P }), Qe.push(() => ze(n, "value", Q));
  function N(E) {
    t3[10](E);
  }
  let L = { label: "Input Encoding:", options: gs.map(Y1e) };
  t3[2] !== void 0 && (L.value = t3[2]), i = new Ht({ props: L }), Qe.push(() => ze(i, "value", N));
  function B(E) {
    t3[11](E);
  }
  let u = { label: "Input Data:", expandable: true, placeholder: t3[2] === "hex" ? "e.g. 4a 1b..." : "Type text here..." };
  t3[0] !== void 0 && (u.value = t3[0]), f = new et({ props: u }), Qe.push(() => ze(f, "value", B)), m = new ut({ props: { $$slots: { default: [H1e] }, $$scope: { ctx: t3 } } }), m.$on("click", t3[7]), b = new ut({ props: { variant: "secondary", $$slots: { default: [q1e] }, $$scope: { ctx: t3 } } }), b.$on("click", t3[12]);
  function p(E) {
    t3[13](E);
  }
  let d = {};
  t3[3] !== void 0 && (d.checked = t3[3]), C = new xr({ props: d }), Qe.push(() => ze(C, "checked", p));
  let y = t3[5] && eB(t3), w = t3[4] && tB(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), fe(i.$$.fragment), o = z(), fe(f.$$.fragment), l = z(), h = H("div"), fe(m.$$.fragment), v = z(), fe(b.$$.fragment), A = z(), _ = H("div"), fe(C.$$.fragment), S = z(), y && y.c(), $ = z(), w && w.c(), F = Lt(), V(e, "class", "controls-row"), St(_, "margin-left", "auto"), V(h, "class", "button-row");
  }, m(E, M) {
    R(E, e, M), ae(n, e, null), q(e, s), ae(i, e, null), R(E, o, M), ae(f, E, M), R(E, l, M), R(E, h, M), ae(m, h, null), q(h, v), ae(b, h, null), q(h, A), q(h, _), ae(C, _, null), R(E, S, M), y && y.m(E, M), R(E, $, M), w && w.m(E, M), R(E, F, M), U = true;
  }, p(E, M) {
    const x = {};
    !r && M & 2 && (r = true, x.value = E[1], qe(() => r = false)), n.$set(x);
    const g = {};
    !a && M & 4 && (a = true, g.value = E[2], qe(() => a = false)), i.$set(g);
    const k = {};
    M & 4 && (k.placeholder = E[2] === "hex" ? "e.g. 4a 1b..." : "Type text here..."), !c && M & 1 && (c = true, k.value = E[0], qe(() => c = false)), f.$set(k);
    const T = {};
    M & 16384 && (T.$$scope = { dirty: M, ctx: E }), m.$set(T);
    const O = {};
    M & 16384 && (O.$$scope = { dirty: M, ctx: E }), b.$set(O);
    const K = {};
    !I && M & 8 && (I = true, K.checked = E[3], qe(() => I = false)), C.$set(K), E[5] ? y ? y.p(E, M) : (y = eB(E), y.c(), y.m($.parentNode, $)) : y && (y.d(1), y = null), E[4] ? w ? (w.p(E, M), M & 16 && W(w, 1)) : (w = tB(E), w.c(), W(w, 1), w.m(F.parentNode, F)) : w && (Xt(), j(w, 1, 1, () => {
      w = null;
    }), er());
  }, i(E) {
    U || (W(n.$$.fragment, E), W(i.$$.fragment, E), W(f.$$.fragment, E), W(m.$$.fragment, E), W(b.$$.fragment, E), W(C.$$.fragment, E), W(w), U = true);
  }, o(E) {
    j(n.$$.fragment, E), j(i.$$.fragment, E), j(f.$$.fragment, E), j(m.$$.fragment, E), j(b.$$.fragment, E), j(C.$$.fragment, E), j(w), U = false;
  }, d(E) {
    E && (D(e), D(o), D(l), D(h), D(S), D($), D(F)), oe(n), oe(i), oe(f, E), oe(m), oe(b), oe(C), y && y.d(E), w && w.d(E);
  } };
}
function G1e(t3) {
  let e, n, r, s, i, a, o, f, c, l;
  return { c() {
    e = H("p"), e.innerHTML = `<b>Blake2</b> is a cryptographic hash function that is designed 
    to be faster and more secure than MD5, SHA-1, and the 
    SHA-2 and SHA-3 families. Developed by Jean-Philippe Aumasson, 
    Samuel Neves, Zooko Wilcox-O&#39;Hearn, and Christian Winnerlein, 
    it was first presented in 2012 and is a follow-up to the original 
    BLAKE hash function, which was a finalist in the SHA-3 competition. 
    Blake2 is widely considered a robust and efficient hashing algorithm 
    suitable for a range of applications, from data integrity verification 
     to cryptographic security.`, n = z(), r = H("p"), r.textContent = `Blake2 is optimized for speed, often running 2 to 3 times faster than SHA-256. 
    It is designed to be highly efficient on modern CPUs, using fewer 
    computational resources than many alternatives. Blake2 has emerged as a 
    strong candidate for most cryptographic and non-cryptographic applications 
    due to its speed, security, and flexibility. It is well-suited for modern 
    software development and remains a preferred choice where both performance 
    and security are crucial.`, s = z(), i = H("p"), i.innerHTML = `<b>Blake3</b> is a modern cryptographic hash function that builds 
    upon the principles of Blake2 but introduces several enhancements 
    to achieve even greater speed, versatility, and efficiency. It 
    was introduced by a team of cryptographers including Jack O&#39;Connor, 
    Jean-Philippe Aumasson, Samuel Neves, and Zooko Wilcox-O&#39;Hearn in 
    2020.`, a = z(), o = H("p"), o.textContent = `Blake3 is designed to be exceptionally fast while maintaining 
    high security, making it suitable for a wide range of applications, 
    including cryptographic and non-cryptographic purposes.`, f = z(), c = H("p"), c.textContent = `Blake3 is significantly faster than Blake2, SHA-256, and other widely 
    used hash algorithms, often achieving speeds up to 10 times faster than 
    SHA-256 on modern hardware. It is highly optimized for multi-core 
    processors, vectorized instruction sets, and parallelism, making it one
    of the fastest cryptographic hash functions available.`, l = we(`
    Blake3 is a groundbreaking advancement in the world of cryptographic 
    hashing, offering unmatched speed and versatility. It is well-suited for 
    both cryptographic and non-cryptographic tasks, and its parallel-friendly 
    design makes it ideal for modern computing environments.`);
  }, m(h, m) {
    R(h, e, m), R(h, n, m), R(h, r, m), R(h, s, m), R(h, i, m), R(h, a, m), R(h, o, m), R(h, f, m), R(h, c, m), R(h, l, m);
  }, p: dt, d(h) {
    h && (D(e), D(n), D(r), D(s), D(i), D(a), D(o), D(f), D(c), D(l));
  } };
}
function V1e(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "BLAKE Hash Family", $$slots: { default: [z1e] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About BLAKE", links: t3[8], $$slots: { default: [G1e] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 16447 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 16384 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
const Y1e = (t3) => t3.value;
function W1e(t3, e, n) {
  let r = "", s = "BLAKE3", i = "utf-8", a = null, o = "", f = true;
  const c = ["BLAKE3", "BLAKE2s", "BLAKE2b"];
  function l() {
    if (!r) {
      n(4, a = null), n(5, o = "");
      return;
    }
    n(5, o = ""), n(4, a = null);
    try {
      n(4, a = K1e(r, s, i));
    } catch (C) {
      n(5, o = C.message);
    }
  }
  const h = [{ text: "BLAKE3 Official Site", url: "https://github.com/BLAKE3-team/BLAKE3" }, { text: "BLAKE2 Official Site", url: "https://www.blake2.net/" }, { text: "@noble/hashes NPM", url: "https://www.npmjs.com/package/@noble/hashes" }];
  function m(C) {
    s = C, n(1, s);
  }
  function v(C) {
    i = C, n(2, i);
  }
  function b(C) {
    r = C, n(0, r);
  }
  const A = () => {
    n(0, r = ""), n(4, a = null);
  };
  function _(C) {
    f = C, n(3, f);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 15 && f && (r || s || i) && l();
  }, [r, s, i, f, a, o, c, l, h, m, v, b, A, _];
}
class J1e extends xt {
  constructor(e) {
    super(), wt(this, e, W1e, V1e, At, {});
  }
}
var QF = {};
/*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */
(function(t3) {
  (function(e) {
    e(typeof DO_NOT_EXPORT_CRC > "u" ? t3 : {});
  })(function(e) {
    e.version = "1.2.2";
    function n() {
      for (var P = 0, N = new Array(256), L = 0; L != 256; ++L) P = L, P = P & 1 ? -306674912 ^ P >>> 1 : P >>> 1, P = P & 1 ? -306674912 ^ P >>> 1 : P >>> 1, P = P & 1 ? -306674912 ^ P >>> 1 : P >>> 1, P = P & 1 ? -306674912 ^ P >>> 1 : P >>> 1, P = P & 1 ? -306674912 ^ P >>> 1 : P >>> 1, P = P & 1 ? -306674912 ^ P >>> 1 : P >>> 1, P = P & 1 ? -306674912 ^ P >>> 1 : P >>> 1, P = P & 1 ? -306674912 ^ P >>> 1 : P >>> 1, N[L] = P;
      return typeof Int32Array < "u" ? new Int32Array(N) : N;
    }
    var r = n();
    function s(P) {
      var N = 0, L = 0, B = 0, u = typeof Int32Array < "u" ? new Int32Array(4096) : new Array(4096);
      for (B = 0; B != 256; ++B) u[B] = P[B];
      for (B = 0; B != 256; ++B) for (L = P[B], N = 256 + B; N < 4096; N += 256) L = u[N] = L >>> 8 ^ P[L & 255];
      var p = [];
      for (B = 1; B != 16; ++B) p[B - 1] = typeof Int32Array < "u" ? u.subarray(B * 256, B * 256 + 256) : u.slice(B * 256, B * 256 + 256);
      return p;
    }
    var i = s(r), a = i[0], o = i[1], f = i[2], c = i[3], l = i[4], h = i[5], m = i[6], v = i[7], b = i[8], A = i[9], _ = i[10], C = i[11], I = i[12], S = i[13], $ = i[14];
    function F(P, N) {
      for (var L = N ^ -1, B = 0, u = P.length; B < u; ) L = L >>> 8 ^ r[(L ^ P.charCodeAt(B++)) & 255];
      return ~L;
    }
    function U(P, N) {
      for (var L = N ^ -1, B = P.length - 15, u = 0; u < B; ) L = $[P[u++] ^ L & 255] ^ S[P[u++] ^ L >> 8 & 255] ^ I[P[u++] ^ L >> 16 & 255] ^ C[P[u++] ^ L >>> 24] ^ _[P[u++]] ^ A[P[u++]] ^ b[P[u++]] ^ v[P[u++]] ^ m[P[u++]] ^ h[P[u++]] ^ l[P[u++]] ^ c[P[u++]] ^ f[P[u++]] ^ o[P[u++]] ^ a[P[u++]] ^ r[P[u++]];
      for (B += 15; u < B; ) L = L >>> 8 ^ r[(L ^ P[u++]) & 255];
      return ~L;
    }
    function Q(P, N) {
      for (var L = N ^ -1, B = 0, u = P.length, p = 0, d = 0; B < u; ) p = P.charCodeAt(B++), p < 128 ? L = L >>> 8 ^ r[(L ^ p) & 255] : p < 2048 ? (L = L >>> 8 ^ r[(L ^ (192 | p >> 6 & 31)) & 255], L = L >>> 8 ^ r[(L ^ (128 | p & 63)) & 255]) : p >= 55296 && p < 57344 ? (p = (p & 1023) + 64, d = P.charCodeAt(B++) & 1023, L = L >>> 8 ^ r[(L ^ (240 | p >> 8 & 7)) & 255], L = L >>> 8 ^ r[(L ^ (128 | p >> 2 & 63)) & 255], L = L >>> 8 ^ r[(L ^ (128 | d >> 6 & 15 | (p & 3) << 4)) & 255], L = L >>> 8 ^ r[(L ^ (128 | d & 63)) & 255]) : (L = L >>> 8 ^ r[(L ^ (224 | p >> 12 & 15)) & 255], L = L >>> 8 ^ r[(L ^ (128 | p >> 6 & 63)) & 255], L = L >>> 8 ^ r[(L ^ (128 | p & 63)) & 255]);
      return ~L;
    }
    e.table = r, e.bstr = F, e.buf = U, e.str = Q;
  });
})(QF);
const Z1e = Fa(QF);
var KF = { exports: {} }, Ay = { exports: {} }, rB;
function j1e() {
  return rB || (rB = 1, function(t3) {
    (function() {
      var e = "input is invalid type", n = "finalize already called", r = typeof window == "object", s = r ? window : {};
      s.JS_CRC_NO_WINDOW && (r = false);
      var i = !r && typeof self == "object", a = !s.JS_CRC_NO_NODE_JS && typeof jt == "object" && jt.versions && jt.versions.node;
      a ? s = mt : i && (s = self);
      var o = !s.JS_CRC_NO_COMMON_JS && true && t3.exports, f = !s.JS_CRC_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u", c = "0123456789abcdef".split(""), l = ["hex", "array"], h = [{ width: 32, poly: 79764919, init: 4294967295, refin: true, refout: true, xorout: 4294967295, name: "crc32" }, { width: 16, poly: 32773, init: 0, refin: true, refout: true, xorout: 0, name: "crc16" }], m = Array.isArray;
      (s.JS_CRC_NO_NODE_JS || !m) && (m = function(p) {
        return Object.prototype.toString.call(p) === "[object Array]";
      });
      var v = ArrayBuffer.isView;
      f && (s.JS_CRC_NO_ARRAY_BUFFER_IS_VIEW || !v) && (v = function(p) {
        return typeof p == "object" && p.buffer && p.buffer.constructor === ArrayBuffer;
      });
      function b(p) {
        var d = typeof p;
        if (d === "string") return [p, true];
        if (d !== "object" || p === null) throw new Error(e);
        if (f && p.constructor === ArrayBuffer) return [new Uint8Array(p), false];
        if (!m(p) && !v(p)) throw new Error(e);
        return [p, false];
      }
      function A(p, d) {
        return function(y) {
          return new L(d).update(y)[p]();
        };
      }
      function _(p) {
        var d = 8 - (p.width % 8 || 8), y = Math.ceil(p.width / 8) % 4 || 4, w = y << 3, E = 1 << w - 1 >>> 0, M = w - 8, x = p.width % 32 || 32, g, k, T, O = p.width > 32;
        O ? (g = p.init.slice(), k = p.poly.slice(), C(g, d), C(k, d), T = [k.join("-"), M, E].join("_")) : (g = p.init << d, k = p.poly << d, T = [k, M, E].join("_"));
        var K = { refin: p.refin, refout: p.refout, xorout: p.xorout, width: p.width, multiWords: O, bitOffset: d, msb: E, msbOffset: M, maskBits: x, mask: 2 ** x - 1, crc: g, poly: k, tableId: T }, Y = A("hex", K);
        Y.create = function() {
          return new L(K);
        }, Y.update = function(X) {
          return Y.create().update(X);
        };
        for (var J = 0; J < l.length; ++J) {
          var G = l[J];
          Y[G] = A(G, K);
        }
        return Y;
      }
      function C(p, d) {
        if (d) {
          for (var y = 0; y < p.length - 1; ++y) p[y] = p[y] << d | p[y + 1] >>> 32 - d;
          p[y] = p[y] << d;
        }
      }
      function I(p, d) {
        if (d) {
          for (var y = p.length - 1; y > 0; --y) p[y] = p[y - 1] << 32 - d | p[y] >>> d;
          p[y] = p[y] >>> d;
        }
      }
      function S(p, d) {
        for (var y = 0; y < p.length; ++y) p[y] ^= d[y];
      }
      var $ = {};
      function F(p, d, y, w) {
        return $[p] || ($[p] = U(d, y, w)), $[p];
      }
      function U(p, d, y) {
        var w = [], E = m(p);
        for (E || (p = [p]), N = 0; N < 256; ++N) {
          for (var M = [N << d], x = 1; x < p.length; ++x) M[x] = 0;
          for (var x = 0; x < 8; ++x) if (M[0] & y) {
            C(M, 1);
            for (var g = 0; g < p.length; ++g) M[g] = M[g] ^ p[g];
          } else C(M, 1);
          w[N] = E ? M : M[0];
        }
        return w;
      }
      function Q(p, d) {
        for (var y = 0, w = 0; p; ++w) p & 1 && (y |= 1 << d - 1 - w), p = p >>> 1;
        return y;
      }
      for (var P = [], N = 0; N < 256; ++N) P[N] = Q(N, 8);
      function L(p) {
        this.options = p, this.refin = p.refin, this.multiWords = p.multiWords, this.bitOffset = p.bitOffset, this.msbOffset = p.msbOffset, this.maskBits = p.maskBits, this.mask = p.mask, this.table = F(p.tableId, p.poly, this.msbOffset, p.msb), this.multiWords ? this.crc = p.crc.slice() : this.crc = p.crc;
      }
      L.prototype.update = function(p) {
        if (this.finalized) throw new Error(n);
        var d = b(p);
        p = d[0];
        var y = d[1], w, E, M = p.length;
        if (y) for (E = 0; E < M; ++E) w = p.charCodeAt(E), w < 128 ? this.updateByte(w) : w < 2048 ? (this.updateByte(192 | w >> 6), this.updateByte(128 | w & 63)) : w < 55296 || w >= 57344 ? (this.updateByte(224 | w >> 12), this.updateByte(128 | w >> 6 & 63), this.updateByte(128 | w & 63)) : (w = 65536 + ((w & 1023) << 10 | p.charCodeAt(++E) & 1023), this.updateByte(240 | w >> 18), this.updateByte(128 | w >> 12 & 63), this.updateByte(128 | w >> 6 & 63), this.updateByte(128 | w & 63));
        else for (E = 0; E < M; ++E) this.updateByte(p[E]);
        return this;
      }, L.prototype.updateByte = function(p) {
        var d = this.crc;
        if (this.refin && (p = P[p]), this.multiWords) {
          d[0] = d[0] ^ p << this.msbOffset;
          var y = this.table[d[0] >> this.msbOffset & 255];
          C(d, 8), S(d, y);
        } else d = d ^ p << this.msbOffset, d = d << 8 ^ this.table[d >> this.msbOffset & 255];
        this.crc = d;
      }, L.prototype.finalize = function() {
        if (!this.finalized) if (this.finalized = true, this.multiWords) {
          if (I(this.crc, this.bitOffset), this.crc[0] = this.crc[0] & this.mask, this.options.refout) {
            C(this.crc, 32 - this.maskBits);
            for (var p = [], d = 0; d < this.crc.length; ++d) p[this.crc.length - d - 1] = Q(this.crc[d], 32);
            this.crc = p;
          }
          S(this.crc, this.options.xorout);
        } else this.crc = this.crc >>> this.bitOffset & this.mask, this.options.refout && (this.crc = Q(this.crc, this.options.width)), this.crc ^= this.options.xorout;
      }, L.prototype.hex = function() {
        this.finalize();
        var p = "", d = this.crc, y = this.options.width;
        this.multiWords && (d = d[0], y = y % 32 || 32);
        for (var w = (Math.ceil(y / 4) << 2) - 4; w >= 0; w -= 4) p += c[d >> w & 15];
        if (this.multiWords) for (var E = 1; E < this.crc.length; ++E) for (d = this.crc[E], w = 28; w >= 0; w -= 4) p += c[d >> w & 15];
        return p;
      }, L.prototype.toString = L.prototype.hex, L.prototype.array = function() {
        this.finalize();
        var p = new Array(Math.ceil(this.options.width / 8)), d = this.crc, y = this.options.width;
        this.multiWords && (d = d[0], y = y % 32 || 32);
        for (var w = 0, E = (Math.ceil(y / 8) << 3) - 8; E >= 0; E -= 8) p[w++] = d >> E & 255;
        if (this.multiWords) for (var M = 1; M < this.crc.length; ++M) for (d = this.crc[M], E = 24; E >= 0; E -= 8) p[w++] = d >> E & 255;
        return p;
      };
      for (var B = {}, N = 0; N < h.length; ++N) {
        var u = h[N];
        B[u.name] = _(u);
      }
      if (B.createModel = _, o) t3.exports = B;
      else {
        for (N = 0; N < h.length; ++N) {
          var u = h[N];
          s[u.name] = B[u.name];
        }
        s.createModel = _;
      }
    })();
  }(Ay)), Ay.exports;
}
(function(t3) {
  (function() {
    var e = [{ width: 3, poly: 3, init: 0, refin: false, refout: false, xorout: 7, name: "CRC-3/GSM" }, { width: 3, poly: 3, init: 7, refin: true, refout: true, xorout: 0, name: "CRC-3/ROHC" }, { width: 4, poly: 3, init: 0, refin: true, refout: true, xorout: 0, name: "CRC-4/G-704", alias: ["CRC-4/ITU"] }, { width: 4, poly: 3, init: 15, refin: false, refout: false, xorout: 15, name: "CRC-4/INTERLAKEN" }, { width: 5, poly: 9, init: 9, refin: false, refout: false, xorout: 0, name: "CRC-5/EPC-C1G2", alias: ["CRC-5/EPC"] }, { width: 5, poly: 21, init: 0, refin: true, refout: true, xorout: 0, name: "CRC-5/G-704", alias: ["CRC-5/ITU"] }, { width: 5, poly: 5, init: 31, refin: true, refout: true, xorout: 31, name: "CRC-5/USB" }, { width: 6, poly: 39, init: 63, refin: false, refout: false, xorout: 0, name: "CRC-6/CDMA2000-A" }, { width: 6, poly: 7, init: 63, refin: false, refout: false, xorout: 0, name: "CRC-6/CDMA2000-B" }, { width: 6, poly: 25, init: 0, refin: true, refout: true, xorout: 0, name: "CRC-6/DARC" }, { width: 6, poly: 3, init: 0, refin: true, refout: true, xorout: 0, name: "CRC-6/G-704", alias: ["CRC-6/ITU"] }, { width: 6, poly: 47, init: 0, refin: false, refout: false, xorout: 63, name: "CRC-6/GSM" }, { width: 7, poly: 9, init: 0, refin: false, refout: false, xorout: 0, name: "CRC-7/MMC", alias: ["CRC-7"] }, { width: 7, poly: 79, init: 127, refin: true, refout: true, xorout: 0, name: "CRC-7/ROHC" }, { width: 7, poly: 69, init: 0, refin: false, refout: false, xorout: 0, name: "CRC-7/UMTS" }, { width: 8, poly: 47, init: 255, refin: false, refout: false, xorout: 255, name: "CRC-8/AUTOSAR" }, { width: 8, poly: 167, init: 0, refin: true, refout: true, xorout: 0, name: "CRC-8/BLUETOOTH" }, { width: 8, poly: 155, init: 255, refin: false, refout: false, xorout: 0, name: "CRC-8/CDMA2000" }, { width: 8, poly: 57, init: 0, refin: true, refout: true, xorout: 0, name: "CRC-8/DARC" }, { width: 8, poly: 213, init: 0, refin: false, refout: false, xorout: 0, name: "CRC-8/DVB-S2" }, { width: 8, poly: 29, init: 0, refin: false, refout: false, xorout: 0, name: "CRC-8/GSM-A" }, { width: 8, poly: 73, init: 0, refin: false, refout: false, xorout: 255, name: "CRC-8/GSM-B" }, { width: 8, poly: 29, init: 255, refin: false, refout: false, xorout: 0, name: "CRC-8/HITAG" }, { width: 8, poly: 7, init: 0, refin: false, refout: false, xorout: 85, name: "CRC-8/I-432-1", alias: ["CRC-8/ITU"] }, { width: 8, poly: 29, init: 253, refin: false, refout: false, xorout: 0, name: "CRC-8/I-CODE" }, { width: 8, poly: 155, init: 0, refin: false, refout: false, xorout: 0, name: "CRC-8/LTE" }, { width: 8, poly: 49, init: 0, refin: true, refout: true, xorout: 0, name: "CRC-8/MAXIM-DOW", alias: ["CRC-8/MAXIM", "DOW-CRC"] }, { width: 8, poly: 29, init: 199, refin: false, refout: false, xorout: 0, name: "CRC-8/MIFARE-MAD" }, { width: 8, poly: 49, init: 255, refin: false, refout: false, xorout: 0, name: "CRC-8/NRSC-5" }, { width: 8, poly: 47, init: 0, refin: false, refout: false, xorout: 0, name: "CRC-8/OPENSAFETY" }, { width: 8, poly: 7, init: 255, refin: true, refout: true, xorout: 0, name: "CRC-8/ROHC" }, { width: 8, poly: 29, init: 255, refin: false, refout: false, xorout: 255, name: "CRC-8/SAE-J1850" }, { width: 8, poly: 7, init: 0, refin: false, refout: false, xorout: 0, name: "CRC-8/SMBUS", alias: ["CRC-8"] }, { width: 8, poly: 29, init: 255, refin: true, refout: true, xorout: 0, name: "CRC-8/TECH-3250", alias: ["CRC-8/AES", "CRC-8/EBU"] }, { width: 8, poly: 155, init: 0, refin: true, refout: true, xorout: 0, name: "CRC-8/WCDMA" }, { width: 10, poly: 563, init: 0, refin: false, refout: false, xorout: 0, name: "CRC-10/ATM", alias: ["CRC-10", "CRC-10/I-610"] }, { width: 10, poly: 985, init: 1023, refin: false, refout: false, xorout: 0, name: "CRC-10/CDMA2000" }, { width: 10, poly: 373, init: 0, refin: false, refout: false, xorout: 1023, name: "CRC-10/GSM" }, { width: 11, poly: 901, init: 26, refin: false, refout: false, xorout: 0, name: "CRC-11/FLEXRAY", alias: ["CRC-11"] }, { width: 11, poly: 775, init: 0, refin: false, refout: false, xorout: 0, name: "CRC-11/UMTS" }, { width: 12, poly: 3859, init: 4095, refin: false, refout: false, xorout: 0, name: "CRC-12/CDMA2000" }, { width: 12, poly: 2063, init: 0, refin: false, refout: false, xorout: 0, name: "CRC-12/DECT", alias: ["X-CRC-12"] }, { width: 12, poly: 3377, init: 0, refin: false, refout: false, xorout: 4095, name: "CRC-12/GSM" }, { width: 12, poly: 2063, init: 0, refin: false, refout: true, xorout: 0, name: "CRC-12/UMTS", alias: ["CRC-12/3GPP"] }, { width: 13, poly: 7413, init: 0, refin: false, refout: false, xorout: 0, name: "CRC-13/BBC" }, { width: 14, poly: 2053, init: 0, refin: true, refout: true, xorout: 0, name: "CRC-14/DARC" }, { width: 14, poly: 8237, init: 0, refin: false, refout: false, xorout: 16383, name: "CRC-14/GSM" }, { width: 15, poly: 17817, init: 0, refin: false, refout: false, xorout: 0, name: "CRC-15/CAN", alias: ["CRC-15"] }, { width: 15, poly: 26645, init: 0, refin: false, refout: false, xorout: 1, name: "CRC-15/MPT1327" }, { width: 16, poly: 32773, init: 0, refin: true, refout: true, xorout: 0, name: "CRC-16/ARC", alias: ["ARC", "CRC-16", "CRC-16/LHA", "CRC-IBM"] }, { width: 16, poly: 51303, init: 65535, refin: false, refout: false, xorout: 0, name: "CRC-16/CDMA2000" }, { width: 16, poly: 32773, init: 65535, refin: false, refout: false, xorout: 0, name: "CRC-16/CMS" }, { width: 16, poly: 32773, init: 32781, refin: false, refout: false, xorout: 0, name: "CRC-16/DDS-110" }, { width: 16, poly: 1417, init: 0, refin: false, refout: false, xorout: 1, name: "CRC-16/DECT-R", alias: ["R-CRC-16"] }, { width: 16, poly: 1417, init: 0, refin: false, refout: false, xorout: 0, name: "CRC-16/DECT-X", alias: ["X-CRC-16"] }, { width: 16, poly: 15717, init: 0, refin: true, refout: true, xorout: 65535, name: "CRC-16/DNP" }, { width: 16, poly: 15717, init: 0, refin: false, refout: false, xorout: 65535, name: "CRC-16/EN-13757" }, { width: 16, poly: 4129, init: 65535, refin: false, refout: false, xorout: 65535, name: "CRC-16/GENIBUS", alias: ["CRC-16/DARC", "CRC-16/EPC", "CRC-16/EPC-C1G2", "CRC-16/I-CODE"] }, { width: 16, poly: 4129, init: 0, refin: false, refout: false, xorout: 65535, name: "CRC-16/GSM" }, { width: 16, poly: 4129, init: 65535, refin: false, refout: false, xorout: 0, name: "CRC-16/IBM-3740", alias: ["CRC-16/AUTOSAR", "CRC-16/CCITT-FALSE"] }, { width: 16, poly: 4129, init: 65535, refin: true, refout: true, xorout: 65535, name: "CRC-16/IBM-SDLC", alias: ["CRC-16/ISO-HDLC", "CRC-16/ISO-IEC-14443-3-B", "CRC-16/X-25", "CRC-B", "X-25"] }, { width: 16, poly: 4129, init: 50886, refin: true, refout: true, xorout: 0, name: "CRC-16/ISO-IEC-14443-3-A", alias: ["CRC-A"] }, { width: 16, poly: 4129, init: 0, refin: true, refout: true, xorout: 0, name: "CRC-16/KERMIT", alias: ["CRC-16/BLUETOOTH", "CRC-16/CCITT", "CRC-16/CCITT-TRUE", "CRC-16/V-41-LSB", "CRC-CCITT", "KERMIT"] }, { width: 16, poly: 28515, init: 0, refin: false, refout: false, xorout: 0, name: "CRC-16/LJ1200" }, { width: 16, poly: 22837, init: 65535, refin: false, refout: false, xorout: 0, name: "CRC-16/M17" }, { width: 16, poly: 32773, init: 0, refin: true, refout: true, xorout: 65535, name: "CRC-16/MAXIM-DOW", alias: ["CRC-16/MAXIM"] }, { width: 16, poly: 4129, init: 65535, refin: true, refout: true, xorout: 0, name: "CRC-16/MCRF4XX" }, { width: 16, poly: 32773, init: 65535, refin: true, refout: true, xorout: 0, name: "CRC-16/MODBUS", alias: ["MODBUS"] }, { width: 16, poly: 2059, init: 65535, refin: true, refout: true, xorout: 0, name: "CRC-16/NRSC-5" }, { width: 16, poly: 22837, init: 0, refin: false, refout: false, xorout: 0, name: "CRC-16/OPENSAFETY-A" }, { width: 16, poly: 30043, init: 0, refin: false, refout: false, xorout: 0, name: "CRC-16/OPENSAFETY-B" }, { width: 16, poly: 7631, init: 65535, refin: false, refout: false, xorout: 65535, name: "CRC-16/PROFIBUS", alias: ["CRC-16/IEC-61158-2"] }, { width: 16, poly: 4129, init: 45738, refin: true, refout: true, xorout: 0, name: "CRC-16/RIELLO" }, { width: 16, poly: 4129, init: 7439, refin: false, refout: false, xorout: 0, name: "CRC-16/SPI-FUJITSU", alias: ["CRC-16/AUG-CCITT"] }, { width: 16, poly: 35767, init: 0, refin: false, refout: false, xorout: 0, name: "CRC-16/T10-DIF" }, { width: 16, poly: 41111, init: 0, refin: false, refout: false, xorout: 0, name: "CRC-16/TELEDISK" }, { width: 16, poly: 4129, init: 35308, refin: true, refout: true, xorout: 0, name: "CRC-16/TMS37157" }, { width: 16, poly: 32773, init: 0, refin: false, refout: false, xorout: 0, name: "CRC-16/UMTS", alias: ["CRC-16/BUYPASS", "CRC-16/VERIFONE"] }, { width: 16, poly: 32773, init: 65535, refin: true, refout: true, xorout: 65535, name: "CRC-16/USB" }, { width: 16, poly: 4129, init: 0, refin: false, refout: false, xorout: 0, name: "CRC-16/XMODEM", alias: ["CRC-16/ACORN", "CRC-16/LTE", "CRC-16/V-41-MSB", "XMODEM", "ZMODEM"] }, { width: 17, poly: 92251, init: 0, refin: false, refout: false, xorout: 0, name: "CRC-17/CAN-FD" }, { width: 21, poly: 1058969, init: 0, refin: false, refout: false, xorout: 0, name: "CRC-21/CAN-FD" }, { width: 24, poly: 1627, init: 5592405, refin: true, refout: true, xorout: 0, name: "CRC-24/BLE" }, { width: 24, poly: 6122955, init: 16702650, refin: false, refout: false, xorout: 0, name: "CRC-24/FLEXRAY-A" }, { width: 24, poly: 6122955, init: 11259375, refin: false, refout: false, xorout: 0, name: "CRC-24/FLEXRAY-B" }, { width: 24, poly: 3312483, init: 16777215, refin: false, refout: false, xorout: 16777215, name: "CRC-24/INTERLAKEN" }, { width: 24, poly: 8801531, init: 0, refin: false, refout: false, xorout: 0, name: "CRC-24/LTE-A" }, { width: 24, poly: 8388707, init: 0, refin: false, refout: false, xorout: 0, name: "CRC-24/LTE-B" }, { width: 24, poly: 8801531, init: 11994318, refin: false, refout: false, xorout: 0, name: "CRC-24/OPENPGP", alias: ["CRC-24"] }, { width: 24, poly: 8388707, init: 16777215, refin: false, refout: false, xorout: 16777215, name: "CRC-24/OS-9" }, { width: 30, poly: 540064199, init: 1073741823, refin: false, refout: false, xorout: 1073741823, name: "CRC-30/CDMA" }, { width: 31, poly: 79764919, init: 2147483647, refin: false, refout: false, xorout: 2147483647, name: "CRC-31/PHILIPS" }, { width: 32, poly: 2168537515, init: 0, refin: false, refout: false, xorout: 0, name: "CRC-32/AIXM", alias: ["CRC-32Q"] }, { width: 32, poly: 4104977171, init: 4294967295, refin: true, refout: true, xorout: 4294967295, name: "CRC-32/AUTOSAR" }, { width: 32, poly: 2821953579, init: 4294967295, refin: true, refout: true, xorout: 4294967295, name: "CRC-32/BASE91-D", alias: ["CRC-32D"] }, { width: 32, poly: 79764919, init: 4294967295, refin: false, refout: false, xorout: 4294967295, name: "CRC-32/BZIP2", alias: ["CRC-32/AAL5", "CRC-32/DECT-B", "B-CRC-32"] }, { width: 32, poly: 2147581979, init: 0, refin: true, refout: true, xorout: 0, name: "CRC-32/CD-ROM-EDC" }, { width: 32, poly: 79764919, init: 0, refin: false, refout: false, xorout: 4294967295, name: "CRC-32/CKSUM", alias: ["CKSUM", "CRC-32/POSIX"] }, { width: 32, poly: 517762881, init: 4294967295, refin: true, refout: true, xorout: 4294967295, name: "CRC-32/ISCSI", alias: ["CRC-32/BASE91-C", "CRC-32/CASTAGNOLI", "CRC-32/INTERLAKEN", "CRC-32C", "CRC-32/NVME"] }, { width: 32, poly: 79764919, init: 4294967295, refin: true, refout: true, xorout: 4294967295, name: "CRC-32/ISO-HDLC", alias: ["CRC-32", "CRC-32/ADCCP", "CRC-32/V-42", "CRC-32/XZ", "PKZIP"] }, { width: 32, poly: 79764919, init: 4294967295, refin: true, refout: true, xorout: 0, name: "CRC-32/JAMCRC", alias: ["JAMCRC"] }, { width: 32, poly: 1947962583, init: 4294967295, refin: true, refout: true, xorout: 0, name: "CRC-32/MEF" }, { width: 32, poly: 79764919, init: 4294967295, refin: false, refout: false, xorout: 0, name: "CRC-32/MPEG-2" }, { width: 32, poly: 175, init: 0, refin: false, refout: false, xorout: 0, name: "CRC-32/XFER", alias: ["XFER"] }, { width: 40, poly: [0, 75628553], init: [0, 0], refin: false, refout: false, xorout: [255, 4294967295], name: "CRC-40/GSM" }, { width: 64, poly: [1123082731, 2850698899], init: [0, 0], refin: false, refout: false, xorout: [0, 0], name: "CRC-64/ECMA-182", alias: ["CRC-64"] }, { width: 64, poly: [0, 27], init: [4294967295, 4294967295], refin: true, refout: true, xorout: [4294967295, 4294967295], name: "CRC-64/GO-ISO" }, { width: 64, poly: [631014603, 2789368649], init: [4294967295, 4294967295], refin: true, refout: true, xorout: [0, 0], name: "CRC-64/MS" }, { width: 64, poly: [2912145973, 2496214617], init: [4294967295, 4294967295], refin: true, refout: true, xorout: [4294967295, 4294967295], name: "CRC-64/NVME" }, { width: 64, poly: [2912145973, 2496214441], init: [0, 0], refin: true, refout: true, xorout: [0, 0], name: "CRC-64/REDIS" }, { width: 64, poly: [1123082731, 2850698899], init: [4294967295, 4294967295], refin: false, refout: false, xorout: [4294967295, 4294967295], name: "CRC-64/WE" }, { width: 64, poly: [1123082731, 2850698899], init: [4294967295, 4294967295], refin: true, refout: true, xorout: [4294967295, 4294967295], name: "CRC-64/XZ", alias: ["CRC-64/GO-ECMA"] }, { width: 82, poly: [12428, 17891604, 21234705], init: [0, 0, 0], refin: true, refout: true, xorout: [0, 0, 0], name: "CRC-82/DARC" }], n = typeof window == "object", r = n ? window : {};
    r.JS_CRC_NO_WINDOW && (n = false);
    var s = !n && typeof self == "object", i = !r.JS_CRC_NO_NODE_JS && typeof jt == "object" && jt.versions && jt.versions.node;
    i ? r = mt : s && (r = self);
    var a = !r.JS_CRC_NO_COMMON_JS && true && t3.exports;
    function o(h) {
      for (var m = 0; m < e.length; ++m) {
        var v = e[m], b = v.name.replace(/[-/]/g, "_").toLocaleLowerCase();
        if (h[b] = f(e[m]), v.alias) for (var A = 0; A < v.alias.length; ++A) {
          var _ = v.alias[A].replace(/[-/]/g, "_").toLocaleLowerCase();
          h[_] = h[b];
        }
      }
    }
    var f, c = {};
    if (a) f = j1e().createModel, o(c), t3.exports = c;
    else {
      f = r.createModel, o(c);
      for (var l in c) r[l] = c[l];
    }
  })();
})(KF);
var HF = KF.exports;
let Tb = [0, 49345, 49537, 320, 49921, 960, 640, 49729, 50689, 1728, 1920, 51009, 1280, 50625, 50305, 1088, 52225, 3264, 3456, 52545, 3840, 53185, 52865, 3648, 2560, 51905, 52097, 2880, 51457, 2496, 2176, 51265, 55297, 6336, 6528, 55617, 6912, 56257, 55937, 6720, 7680, 57025, 57217, 8e3, 56577, 7616, 7296, 56385, 5120, 54465, 54657, 5440, 55041, 6080, 5760, 54849, 53761, 4800, 4992, 54081, 4352, 53697, 53377, 4160, 61441, 12480, 12672, 61761, 13056, 62401, 62081, 12864, 13824, 63169, 63361, 14144, 62721, 13760, 13440, 62529, 15360, 64705, 64897, 15680, 65281, 16320, 16e3, 65089, 64001, 15040, 15232, 64321, 14592, 63937, 63617, 14400, 10240, 59585, 59777, 10560, 60161, 11200, 10880, 59969, 60929, 11968, 12160, 61249, 11520, 60865, 60545, 11328, 58369, 9408, 9600, 58689, 9984, 59329, 59009, 9792, 8704, 58049, 58241, 9024, 57601, 8640, 8320, 57409, 40961, 24768, 24960, 41281, 25344, 41921, 41601, 25152, 26112, 42689, 42881, 26432, 42241, 26048, 25728, 42049, 27648, 44225, 44417, 27968, 44801, 28608, 28288, 44609, 43521, 27328, 27520, 43841, 26880, 43457, 43137, 26688, 30720, 47297, 47489, 31040, 47873, 31680, 31360, 47681, 48641, 32448, 32640, 48961, 32e3, 48577, 48257, 31808, 46081, 29888, 30080, 46401, 30464, 47041, 46721, 30272, 29184, 45761, 45953, 29504, 45313, 29120, 28800, 45121, 20480, 37057, 37249, 20800, 37633, 21440, 21120, 37441, 38401, 22208, 22400, 38721, 21760, 38337, 38017, 21568, 39937, 23744, 23936, 40257, 24320, 40897, 40577, 24128, 23040, 39617, 39809, 23360, 39169, 22976, 22656, 38977, 34817, 18624, 18816, 35137, 19200, 35777, 35457, 19008, 19968, 36545, 36737, 20288, 36097, 19904, 19584, 35905, 17408, 33985, 34177, 17728, 34561, 18368, 18048, 34369, 33281, 17088, 17280, 33601, 16640, 33217, 32897, 16448];
typeof Int32Array < "u" && (Tb = new Int32Array(Tb));
const X1e = (t3, e = 0) => {
  let n = ~~e;
  for (let r = 0; r < t3.length; r++) n = (Tb[(n ^ t3[r]) & 255] ^ n >> 8) & 65535;
  return n;
};
let Db = [0, 7, 14, 9, 28, 27, 18, 21, 56, 63, 54, 49, 36, 35, 42, 45, 112, 119, 126, 121, 108, 107, 98, 101, 72, 79, 70, 65, 84, 83, 90, 93, 224, 231, 238, 233, 252, 251, 242, 245, 216, 223, 214, 209, 196, 195, 202, 205, 144, 151, 158, 153, 140, 139, 130, 133, 168, 175, 166, 161, 180, 179, 186, 189, 199, 192, 201, 206, 219, 220, 213, 210, 255, 248, 241, 246, 227, 228, 237, 234, 183, 176, 185, 190, 171, 172, 165, 162, 143, 136, 129, 134, 147, 148, 157, 154, 39, 32, 41, 46, 59, 60, 53, 50, 31, 24, 17, 22, 3, 4, 13, 10, 87, 80, 89, 94, 75, 76, 69, 66, 111, 104, 97, 102, 115, 116, 125, 122, 137, 142, 135, 128, 149, 146, 155, 156, 177, 182, 191, 184, 173, 170, 163, 164, 249, 254, 247, 240, 229, 226, 235, 236, 193, 198, 207, 200, 221, 218, 211, 212, 105, 110, 103, 96, 117, 114, 123, 124, 81, 86, 95, 88, 77, 74, 67, 68, 25, 30, 23, 16, 5, 2, 11, 12, 33, 38, 47, 40, 61, 58, 51, 52, 78, 73, 64, 71, 82, 85, 92, 91, 118, 113, 120, 127, 106, 109, 100, 99, 62, 57, 48, 55, 34, 37, 44, 43, 6, 1, 8, 15, 26, 29, 20, 19, 174, 169, 160, 167, 178, 181, 188, 187, 150, 145, 152, 159, 138, 141, 132, 131, 222, 217, 208, 215, 194, 197, 204, 203, 230, 225, 232, 239, 250, 253, 244, 243];
typeof Int32Array < "u" && (Db = new Int32Array(Db));
const ege = (t3, e = 0) => {
  let n = ~~e;
  for (let r = 0; r < t3.length; r++) n = Db[(n ^ t3[r]) & 255] & 255;
  return n;
};
let Rb = [0, 8801531, 9098509, 825846, 9692897, 1419802, 1651692, 10452759, 10584377, 2608578, 2839604, 11344079, 3303384, 11807523, 12104405, 4128302, 12930697, 4391538, 5217156, 13227903, 5679208, 13690003, 14450021, 5910942, 6606768, 14844747, 15604413, 6837830, 16197969, 7431594, 8256604, 16494759, 840169, 9084178, 8783076, 18463, 10434312, 1670131, 1434117, 9678590, 11358416, 2825259, 2590173, 10602790, 4109873, 12122826, 11821884, 3289031, 13213536, 5231515, 4409965, 12912278, 5929345, 14431610, 13675660, 5693559, 6823513, 15618722, 14863188, 6588335, 16513208, 8238147, 7417269, 16212302, 1680338, 10481449, 9664223, 1391140, 9061683, 788936, 36926, 8838341, 12067563, 4091408, 3340262, 11844381, 2868234, 11372785, 10555655, 2579964, 14478683, 5939616, 5650518, 13661357, 5180346, 13190977, 12967607, 4428364, 8219746, 16457881, 16234863, 7468436, 15633027, 6866552, 6578062, 14816117, 1405499, 9649856, 10463030, 1698765, 8819930, 55329, 803287, 9047340, 11858690, 3325945, 4072975, 12086004, 2561507, 10574104, 11387118, 2853909, 13647026, 5664841, 5958079, 14460228, 4446803, 12949160, 13176670, 5194661, 7454091, 16249200, 16476294, 8201341, 14834538, 6559633, 6852199, 15647388, 3360676, 11864927, 12161705, 4185682, 10527045, 2551230, 2782280, 11286707, 9619101, 1346150, 1577872, 10379115, 73852, 8875143, 9172337, 899466, 16124205, 7357910, 8182816, 16421083, 6680524, 14918455, 15678145, 6911546, 5736468, 13747439, 14507289, 5968354, 12873461, 4334094, 5159928, 13170435, 4167245, 12180150, 11879232, 3346363, 11301036, 2767959, 2532769, 10545498, 10360692, 1596303, 1360505, 9604738, 913813, 9157998, 8856728, 92259, 16439492, 8164415, 7343561, 16138546, 6897189, 15692510, 14936872, 6662099, 5986813, 14488838, 13733104, 5750795, 13156124, 5174247, 4352529, 12855018, 2810998, 11315341, 10498427, 2522496, 12124823, 4148844, 3397530, 11901793, 9135439, 862644, 110658, 8912057, 1606574, 10407765, 9590435, 1317464, 15706879, 6940164, 6651890, 14889737, 8145950, 16384229, 16161043, 7394792, 5123014, 13133629, 12910283, 4370992, 14535975, 5997020, 5707818, 13718737, 2504095, 10516836, 11329682, 2796649, 11916158, 3383173, 4130419, 12143240, 8893606, 129117, 876971, 9121104, 1331783, 9576124, 10389322, 1625009, 14908182, 6633453, 6925851, 15721184, 7380471, 16175372, 16402682, 8127489, 4389423, 12891860, 13119266, 5137369, 13704398, 5722165, 6015427, 14517560];
typeof Int32Array < "u" && (Rb = new Int32Array(Rb));
const tge = (t3, e) => {
  let n = typeof e < "u" ? ~~e : 11994318;
  for (let r = 0; r < t3.length; r++) n = (Rb[(n >> 16 ^ t3[r]) & 255] ^ n << 8) & 16777215;
  return n;
}, nB = { "CRC-8/SMBUS": { func: ege, width: 2 }, "CRC-16/ARC": { func: X1e, width: 4 }, "CRC-24/OPENPGP": { func: tge, width: 6 }, "CRC-32/ISO-HDLC": { func: null, width: 8 }, "CRC-64/ECMA-182": { func: HF.crc_64_ecma_182, width: 16 } };
function rge(t3, e, n = "utf-8") {
  var _a2;
  if (!t3) throw new Error("Please enter some text.");
  let r;
  try {
    r = ps(t3, n);
  } catch (o) {
    throw new Error(o.message);
  }
  let s = "";
  if (e === "CRC-32/ISO-HDLC") s = (Z1e.buf(r) >>> 0).toString(16);
  else if (e === "CRC-64/ECMA-182") s = HF.crc_64_ecma_182(r);
  else {
    const o = nB[e];
    if (!o) throw new Error(`Algorithm "${e}" is not supported.`);
    s = o.func(r).toString(16);
  }
  const i = ((_a2 = nB[e]) == null ? void 0 : _a2.width) || 8, a = s.padStart(i, "0");
  return { hex: a, integer: BigInt("0x" + a).toString() };
}
function nge(t3) {
  let e;
  return { c() {
    e = we("Calculate Checksum");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function ige(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function iB(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[5]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 32 && Ze(n, r[5]);
  }, d(r) {
    r && D(e);
  } };
}
function sB(t3) {
  let e, n, r, s;
  return e = new et({ props: { label: t3[1] + " Hex:", value: t3[4].hex, readonly: true, expandable: false, withCopy: true } }), r = new et({ props: { label: "Decimal Value:", value: t3[4].integer, readonly: true, expandable: false, withCopy: true } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, a) {
    const o = {};
    a & 2 && (o.label = i[1] + " Hex:"), a & 16 && (o.value = i[4].hex), e.$set(o);
    const f = {};
    a & 16 && (f.value = i[4].integer), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function sge(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U;
  function Q(E) {
    t3[9](E);
  }
  let P = { label: "Algorithm:", options: t3[6] };
  t3[1] !== void 0 && (P.value = t3[1]), n = new Ht({ props: P }), Qe.push(() => ze(n, "value", Q));
  function N(E) {
    t3[10](E);
  }
  let L = { label: "Input Encoding:", options: gs.map(fge) };
  t3[2] !== void 0 && (L.value = t3[2]), i = new Ht({ props: L }), Qe.push(() => ze(i, "value", N));
  function B(E) {
    t3[11](E);
  }
  let u = { label: "Input Data:", expandable: true, placeholder: t3[2] === "hex" ? "e.g. 4a 1b..." : "Type text here..." };
  t3[0] !== void 0 && (u.value = t3[0]), f = new et({ props: u }), Qe.push(() => ze(f, "value", B)), m = new ut({ props: { $$slots: { default: [nge] }, $$scope: { ctx: t3 } } }), m.$on("click", t3[7]), b = new ut({ props: { variant: "secondary", $$slots: { default: [ige] }, $$scope: { ctx: t3 } } }), b.$on("click", t3[12]);
  function p(E) {
    t3[13](E);
  }
  let d = {};
  t3[3] !== void 0 && (d.checked = t3[3]), C = new xr({ props: d }), Qe.push(() => ze(C, "checked", p));
  let y = t3[5] && iB(t3), w = t3[4] && sB(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), fe(i.$$.fragment), o = z(), fe(f.$$.fragment), l = z(), h = H("div"), fe(m.$$.fragment), v = z(), fe(b.$$.fragment), A = z(), _ = H("div"), fe(C.$$.fragment), S = z(), y && y.c(), $ = z(), w && w.c(), F = Lt(), V(e, "class", "controls-row"), St(_, "margin-left", "auto"), V(h, "class", "button-row");
  }, m(E, M) {
    R(E, e, M), ae(n, e, null), q(e, s), ae(i, e, null), R(E, o, M), ae(f, E, M), R(E, l, M), R(E, h, M), ae(m, h, null), q(h, v), ae(b, h, null), q(h, A), q(h, _), ae(C, _, null), R(E, S, M), y && y.m(E, M), R(E, $, M), w && w.m(E, M), R(E, F, M), U = true;
  }, p(E, M) {
    const x = {};
    !r && M & 2 && (r = true, x.value = E[1], qe(() => r = false)), n.$set(x);
    const g = {};
    !a && M & 4 && (a = true, g.value = E[2], qe(() => a = false)), i.$set(g);
    const k = {};
    M & 4 && (k.placeholder = E[2] === "hex" ? "e.g. 4a 1b..." : "Type text here..."), !c && M & 1 && (c = true, k.value = E[0], qe(() => c = false)), f.$set(k);
    const T = {};
    M & 16384 && (T.$$scope = { dirty: M, ctx: E }), m.$set(T);
    const O = {};
    M & 16384 && (O.$$scope = { dirty: M, ctx: E }), b.$set(O);
    const K = {};
    !I && M & 8 && (I = true, K.checked = E[3], qe(() => I = false)), C.$set(K), E[5] ? y ? y.p(E, M) : (y = iB(E), y.c(), y.m($.parentNode, $)) : y && (y.d(1), y = null), E[4] ? w ? (w.p(E, M), M & 16 && W(w, 1)) : (w = sB(E), w.c(), W(w, 1), w.m(F.parentNode, F)) : w && (Xt(), j(w, 1, 1, () => {
      w = null;
    }), er());
  }, i(E) {
    U || (W(n.$$.fragment, E), W(i.$$.fragment, E), W(f.$$.fragment, E), W(m.$$.fragment, E), W(b.$$.fragment, E), W(C.$$.fragment, E), W(w), U = true);
  }, o(E) {
    j(n.$$.fragment, E), j(i.$$.fragment, E), j(f.$$.fragment, E), j(m.$$.fragment, E), j(b.$$.fragment, E), j(C.$$.fragment, E), j(w), U = false;
  }, d(E) {
    E && (D(e), D(o), D(l), D(h), D(S), D($), D(F)), oe(n), oe(i), oe(f, E), oe(m), oe(b), oe(C), y && y.d(E), w && w.d(E);
  } };
}
function age(t3) {
  let e, n, r, s, i;
  return { c() {
    e = H("p"), e.innerHTML = "<strong>CRC (Cyclic Redundancy Check)</strong> is an error-detecting code commonly used in digital networks and storage devices to detect accidental changes to raw data.", n = z(), r = H("p"), r.innerHTML = `<strong>Not for Security:</strong> CRCs are <strong>not</strong> cryptographic hash functions. 
    They are designed to detect accidental errors (like bit flips), not malicious tampering. 
    It is very easy to generate a collision (two different files with the same CRC). 
    Do not use CRC for passwords or digital signatures.`, s = z(), i = H("ul"), i.innerHTML = "<li><strong>CRC-32:</strong> Used in Ethernet, Gzip, and PNG files.</li> <li><strong>CRC-64:</strong> Used in ISO 3309 and certain database systems.</li> <li><strong>CRC-16:</strong> Commonly used in USB and Modbus.</li>", V(r, "class", "warning");
  }, m(a, o) {
    R(a, e, o), R(a, n, o), R(a, r, o), R(a, s, o), R(a, i, o);
  }, p: dt, d(a) {
    a && (D(e), D(n), D(r), D(s), D(i));
  } };
}
function oge(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "CRC Calculator", $$slots: { default: [sge] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About CRC", links: t3[8], $$slots: { default: [age] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 16447 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 16384 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
const fge = (t3) => t3.value;
function lge(t3, e, n) {
  let r = "", s = "CRC-32/ISO-HDLC", i = "utf-8", a = null, o = "", f = true;
  const c = ["CRC-8/SMBUS", "CRC-16/ARC", "CRC-24/OPENPGP", "CRC-32/ISO-HDLC", "CRC-64/ECMA-182"];
  function l() {
    if (!r) {
      n(4, a = null), n(5, o = "");
      return;
    }
    n(5, o = ""), n(4, a = null);
    try {
      n(4, a = rge(r, s, i));
    } catch (C) {
      n(5, o = C.message);
    }
  }
  const h = [{ text: "NPM: crc", url: "https://www.npmjs.com/package/crc" }, { text: "NPM: crc-32", url: "https://www.npmjs.com/package/crc-32" }, { text: "NPM: js-crc", url: "https://www.npmjs.com/package/js-crc" }];
  function m(C) {
    s = C, n(1, s);
  }
  function v(C) {
    i = C, n(2, i);
  }
  function b(C) {
    r = C, n(0, r);
  }
  const A = () => {
    n(0, r = ""), n(4, a = null);
  };
  function _(C) {
    f = C, n(3, f);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 15 && f && (r || s || i) && l();
  }, [r, s, i, f, a, o, c, l, h, m, v, b, A, _];
}
class uge extends xt {
  constructor(e) {
    super(), wt(this, e, lge, oge, At, {});
  }
}
function bh(t3, e, n, r) {
  function s(i) {
    return i instanceof n ? i : new n(function(a) {
      a(i);
    });
  }
  return new (n || (n = Promise))(function(i, a) {
    function o(l) {
      try {
        c(r.next(l));
      } catch (h) {
        a(h);
      }
    }
    function f(l) {
      try {
        c(r.throw(l));
      } catch (h) {
        a(h);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(o, f);
    }
    c((r = r.apply(t3, [])).next());
  });
}
class Ln {
  constructor() {
    this.mutex = Promise.resolve();
  }
  lock() {
    let e = () => {
    };
    return this.mutex = this.mutex.then(() => new Promise(e)), new Promise((n) => {
      e = n;
    });
  }
  dispatch(e) {
    return bh(this, void 0, void 0, function* () {
      const n = yield this.lock();
      try {
        return yield Promise.resolve(e());
      } finally {
        n();
      }
    });
  }
}
var wy;
function cge() {
  return typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : $y;
}
const Fb = cge(), xy = (wy = Fb.Buffer) !== null && wy !== void 0 ? wy : null, hge = Fb.TextEncoder ? new Fb.TextEncoder() : null;
function qF(t3, e) {
  return (t3 & 15) + (t3 >> 6 | t3 >> 3 & 8) << 4 | (e & 15) + (e >> 6 | e >> 3 & 8);
}
function dge(t3, e) {
  const n = e.length >> 1;
  for (let r = 0; r < n; r++) {
    const s = r << 1;
    t3[r] = qF(e.charCodeAt(s), e.charCodeAt(s + 1));
  }
}
function pge(t3, e) {
  if (t3.length !== e.length * 2) return false;
  for (let n = 0; n < e.length; n++) {
    const r = n << 1;
    if (e[n] !== qF(t3.charCodeAt(r), t3.charCodeAt(r + 1))) return false;
  }
  return true;
}
const aB = 87, oB = 48;
function fB(t3, e, n) {
  let r = 0;
  for (let s = 0; s < n; s++) {
    let i = e[s] >>> 4;
    t3[r++] = i > 9 ? i + aB : i + oB, i = e[s] & 15, t3[r++] = i > 9 ? i + aB : i + oB;
  }
  return String.fromCharCode.apply(null, t3);
}
const lB = xy !== null ? (t3) => {
  if (typeof t3 == "string") {
    const e = xy.from(t3, "utf8");
    return new Uint8Array(e.buffer, e.byteOffset, e.length);
  }
  if (xy.isBuffer(t3)) return new Uint8Array(t3.buffer, t3.byteOffset, t3.length);
  if (ArrayBuffer.isView(t3)) return new Uint8Array(t3.buffer, t3.byteOffset, t3.byteLength);
  throw new Error("Invalid data type!");
} : (t3) => {
  if (typeof t3 == "string") return hge.encode(t3);
  if (ArrayBuffer.isView(t3)) return new Uint8Array(t3.buffer, t3.byteOffset, t3.byteLength);
  throw new Error("Invalid data type!");
}, uB = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", nh = new Uint8Array(256);
for (let t3 = 0; t3 < uB.length; t3++) nh[uB.charCodeAt(t3)] = t3;
function gge(t3) {
  let e = Math.floor(t3.length * 0.75);
  const n = t3.length;
  return t3[n - 1] === "=" && (e -= 1, t3[n - 2] === "=" && (e -= 1)), e;
}
function mge(t3) {
  const e = gge(t3), n = t3.length, r = new Uint8Array(e);
  let s = 0;
  for (let i = 0; i < n; i += 4) {
    const a = nh[t3.charCodeAt(i)], o = nh[t3.charCodeAt(i + 1)], f = nh[t3.charCodeAt(i + 2)], c = nh[t3.charCodeAt(i + 3)];
    r[s] = a << 2 | o >> 4, s += 1, r[s] = (o & 15) << 4 | f >> 2, s += 1, r[s] = (f & 3) << 6 | c & 63, s += 1;
  }
  return r;
}
const hp = 16 * 1024, Uc = 4, vge = new Ln(), _y = /* @__PURE__ */ new Map();
function yge(t3, e) {
  return bh(this, void 0, void 0, function* () {
    let n = null, r = null, s = false;
    if (typeof WebAssembly > "u") throw new Error("WebAssembly is not supported in this environment!");
    const i = (U, Q = 0) => {
      r.set(U, Q);
    }, a = () => r, o = () => n.exports, f = (U) => {
      n.exports.Hash_SetMemorySize(U);
      const Q = n.exports.Hash_GetBuffer(), P = n.exports.memory.buffer;
      r = new Uint8Array(P, Q, U);
    }, c = () => new DataView(n.exports.memory.buffer).getUint32(n.exports.STATE_SIZE, true), l = vge.dispatch(() => bh(this, void 0, void 0, function* () {
      if (!_y.has(t3.name)) {
        const Q = mge(t3.data), P = WebAssembly.compile(Q);
        _y.set(t3.name, P);
      }
      const U = yield _y.get(t3.name);
      n = yield WebAssembly.instantiate(U, {});
    })), h = () => bh(this, void 0, void 0, function* () {
      n || (yield l);
      const U = n.exports.Hash_GetBuffer(), Q = n.exports.memory.buffer;
      r = new Uint8Array(Q, U, hp);
    }), m = (U = null) => {
      s = true, n.exports.Hash_Init(U);
    }, v = (U) => {
      let Q = 0;
      for (; Q < U.length; ) {
        const P = U.subarray(Q, Q + hp);
        Q += P.length, r.set(P), n.exports.Hash_Update(P.length);
      }
    }, b = (U) => {
      if (!s) throw new Error("update() called before init()");
      const Q = lB(U);
      v(Q);
    }, A = new Uint8Array(e * 2), _ = (U, Q = null) => {
      if (!s) throw new Error("digest() called before init()");
      return s = false, n.exports.Hash_Final(Q), U === "binary" ? r.slice(0, e) : fB(A, r, e);
    }, C = () => {
      if (!s) throw new Error("save() can only be called after init() and before digest()");
      const U = n.exports.Hash_GetState(), Q = c(), P = n.exports.memory.buffer, N = new Uint8Array(P, U, Q), L = new Uint8Array(Uc + Q);
      return dge(L, t3.hash), L.set(N, Uc), L;
    }, I = (U) => {
      if (!(U instanceof Uint8Array)) throw new Error("load() expects an Uint8Array generated by save()");
      const Q = n.exports.Hash_GetState(), P = c(), N = Uc + P, L = n.exports.memory.buffer;
      if (U.length !== N) throw new Error(`Bad state length (expected ${N} bytes, got ${U.length})`);
      if (!pge(t3.hash, U.subarray(0, Uc))) throw new Error("This state was written by an incompatible hash implementation");
      const B = U.subarray(Uc);
      new Uint8Array(L, Q, P).set(B), s = true;
    }, S = (U) => typeof U == "string" ? U.length < hp / 4 : U.byteLength < hp;
    let $ = S;
    switch (t3.name) {
      case "argon2":
      case "scrypt":
        $ = () => true;
        break;
      case "blake2b":
      case "blake2s":
        $ = (U, Q) => Q <= 512 && S(U);
        break;
      case "blake3":
        $ = (U, Q) => Q === 0 && S(U);
        break;
      case "xxhash64":
      case "xxhash3":
      case "xxhash128":
      case "crc64":
        $ = () => false;
        break;
    }
    const F = (U, Q = null, P = null) => {
      if (!$(U, Q)) return m(Q), b(U), _("hex", P);
      const N = lB(U);
      return r.set(N), n.exports.Hash_Calculate(N.length, Q, P), fB(A, r, e);
    };
    return yield h(), { getMemory: a, writeMemory: i, getExports: o, setMemorySize: f, init: m, update: b, digest: _, save: C, load: I, calculate: F, hashLength: e };
  });
}
function z4(t3, e, n) {
  return bh(this, void 0, void 0, function* () {
    const r = yield t3.lock(), s = yield yge(e, n);
    return r(), s;
  });
}
new Ln();
new Ln();
new Ln();
new Ln();
new Ln();
new Ln();
var bge = "md4", Age = "AGFzbQEAAAABEgRgAAF/YAAAYAF/AGACf38BfwMIBwABAgMBAAIFBAEBAgIGDgJ/AUGgigULfwBBgAgLB3AIBm1lbW9yeQIADkhhc2hfR2V0QnVmZmVyAAAJSGFzaF9Jbml0AAELSGFzaF9VcGRhdGUAAgpIYXNoX0ZpbmFsAAQNSGFzaF9HZXRTdGF0ZQAFDkhhc2hfQ2FsY3VsYXRlAAYKU1RBVEVfU0laRQMBCucUBwUAQYAJCy0AQQBC/rnrxemOlZkQNwKQiQFBAEKBxpS6lvHq5m83AoiJAUEAQgA3AoCJAQu+BQEHf0EAQQAoAoCJASIBIABqQf////8BcSICNgKAiQFBAEEAKAKEiQEgAiABSWogAEEddmo2AoSJAQJAAkACQAJAAkACQCABQT9xIgMNAEGACSEEDAELIABBwAAgA2siBUkNASAFQQNxIQZBACEBAkAgA0E/c0EDSQ0AIANBgIkBaiEEIAVB/ABxIQdBACEBA0AgBCABaiICQRhqIAFBgAlqLQAAOgAAIAJBGWogAUGBCWotAAA6AAAgAkEaaiABQYIJai0AADoAACACQRtqIAFBgwlqLQAAOgAAIAcgAUEEaiIBRw0ACwsCQCAGRQ0AIANBmIkBaiECA0AgAiABaiABQYAJai0AADoAACABQQFqIQEgBkF/aiIGDQALC0GYiQFBwAAQAxogACAFayEAIAVBgAlqIQQLIABBwABPDQEgACECDAILIABFDQIgAEEDcSEGQQAhAQJAIABBBEkNACADQYCJAWohBCAAQXxxIQBBACEBA0AgBCABaiICQRhqIAFBgAlqLQAAOgAAIAJBGWogAUGBCWotAAA6AAAgAkEaaiABQYIJai0AADoAACACQRtqIAFBgwlqLQAAOgAAIAAgAUEEaiIBRw0ACwsgBkUNAiADQZiJAWohAgNAIAIgAWogAUGACWotAAA6AAAgAUEBaiEBIAZBf2oiBg0ADAMLCyAAQT9xIQIgBCAAQUBxEAMhBAsgAkUNACACQQNxIQZBACEBAkAgAkEESQ0AIAJBPHEhAEEAIQEDQCABQZiJAWogBCABaiICLQAAOgAAIAFBmYkBaiACQQFqLQAAOgAAIAFBmokBaiACQQJqLQAAOgAAIAFBm4kBaiACQQNqLQAAOgAAIAAgAUEEaiIBRw0ACwsgBkUNAANAIAFBmIkBaiAEIAFqLQAAOgAAIAFBAWohASAGQX9qIgYNAAsLC+sKARd/QQAoApSJASECQQAoApCJASEDQQAoAoyJASEEQQAoAoiJASEFA0AgACgCHCIGIAAoAhQiByAAKAIYIgggACgCECIJIAAoAiwiCiAAKAIoIgsgACgCJCIMIAAoAiAiDSALIAggACgCCCIOIANqIAAoAgQiDyACaiAEIAMgAnNxIAJzIAVqIAAoAgAiEGpBA3ciESAEIANzcSADc2pBB3ciEiARIARzcSAEc2pBC3ciE2ogEiAHaiAJIBFqIAAoAgwiFCAEaiATIBIgEXNxIBFzakETdyIRIBMgEnNxIBJzakEDdyISIBEgE3NxIBNzakEHdyITIBIgEXNxIBFzakELdyIVaiATIAxqIBIgDWogESAGaiAVIBMgEnNxIBJzakETdyIRIBUgE3NxIBNzakEDdyISIBEgFXNxIBVzakEHdyITIBIgEXNxIBFzakELdyIVIAAoAjgiFmogEyAAKAI0IhdqIBIgACgCMCIYaiARIApqIBUgEyASc3EgEnNqQRN3IhIgFSATc3EgE3NqQQN3IhMgEiAVc3EgFXNqQQd3IhUgEyASc3EgEnNqQQt3IhFqIAkgFWogECATaiASIAAoAjwiCWogESAVIBNzcSATc2pBE3ciEiARIBVycSARIBVxcmpBmfOJ1AVqQQN3IhMgEiARcnEgEiARcXJqQZnzidQFakEFdyIRIBMgEnJxIBMgEnFyakGZ84nUBWpBCXciFWogByARaiAPIBNqIBggEmogFSARIBNycSARIBNxcmpBmfOJ1AVqQQ13IhIgFSARcnEgFSARcXJqQZnzidQFakEDdyIRIBIgFXJxIBIgFXFyakGZ84nUBWpBBXciEyARIBJycSARIBJxcmpBmfOJ1AVqQQl3IhVqIAggE2ogDiARaiAXIBJqIBUgEyARcnEgEyARcXJqQZnzidQFakENdyIRIBUgE3JxIBUgE3FyakGZ84nUBWpBA3ciEiARIBVycSARIBVxcmpBmfOJ1AVqQQV3IhMgEiARcnEgEiARcXJqQZnzidQFakEJdyIVaiAGIBNqIBQgEmogFiARaiAVIBMgEnJxIBMgEnFyakGZ84nUBWpBDXciESAVIBNycSAVIBNxcmpBmfOJ1AVqQQN3IhIgESAVcnEgESAVcXJqQZnzidQFakEFdyITIBIgEXJxIBIgEXFyakGZ84nUBWpBCXciFWogECASaiAJIBFqIBUgEyAScnEgEyAScXJqQZnzidQFakENdyIGIBVzIhIgE3NqQaHX5/YGakEDdyIRIAZzIA0gE2ogEiARc2pBodfn9gZqQQl3IhJzakGh1+f2BmpBC3ciE2ogDiARaiATIBJzIBggBmogEiARcyATc2pBodfn9gZqQQ93IhFzakGh1+f2BmpBA3ciFSARcyALIBJqIBEgE3MgFXNqQaHX5/YGakEJdyISc2pBodfn9gZqQQt3IhNqIA8gFWogEyAScyAWIBFqIBIgFXMgE3NqQaHX5/YGakEPdyIRc2pBodfn9gZqQQN3IhUgEXMgDCASaiARIBNzIBVzakGh1+f2BmpBCXciEnNqQaHX5/YGakELdyITaiAUIBVqIBMgEnMgFyARaiASIBVzIBNzakGh1+f2BmpBD3ciEXNqQaHX5/YGakEDdyIVIBFzIAogEmogESATcyAVc2pBodfn9gZqQQl3IhJzakGh1+f2BmpBC3ciEyADaiEDIAkgEWogEiAVcyATc2pBodfn9gZqQQ93IARqIQQgEiACaiECIBUgBWohBSAAQcAAaiEAIAFBQGoiAQ0AC0EAIAI2ApSJAUEAIAM2ApCJAUEAIAQ2AoyJAUEAIAU2AoiJASAAC8gDAQV/QQAoAoCJAUE/cSIAQZiJAWpBgAE6AAAgAEEBaiEBAkACQAJAAkAgAEE/cyICQQdLDQAgAkUNASABQZiJAWpBADoAACACQQFGDQEgAEGaiQFqQQA6AAAgAkECRg0BIABBm4kBakEAOgAAIAJBA0YNASAAQZyJAWpBADoAACACQQRGDQEgAEGdiQFqQQA6AAAgAkEFRg0BIABBnokBakEAOgAAIAJBBkYNASAAQZ+JAWpBADoAAAwBCyACQQhGDQJBNiAAayIDIQQCQCACQQNxIgBFDQBBACAAayEEQQAhAANAIABBz4kBakEAOgAAIAQgAEF/aiIARw0ACyADIABqIQQLIANBA0kNAgwBC0GYiQFBwAAQAxpBACEBQTchBAsgAUGAiQFqIQBBfyECA0AgACAEakEVakEANgAAIABBfGohACAEIAJBBGoiAkcNAAsLQQBBACgChIkBNgLUiQFBAEEAKAKAiQEiAEEVdjoA04kBQQAgAEENdjoA0okBQQAgAEEFdjoA0YkBQQAgAEEDdCIAOgDQiQFBACAANgKAiQFBmIkBQcAAEAMaQQBBACkCiIkBNwOACUEAQQApApCJATcDiAkLBgBBgIkBCzMAQQBC/rnrxemOlZkQNwKQiQFBAEKBxpS6lvHq5m83AoiJAUEAQgA3AoCJASAAEAIQBAsLCwEAQYAICwSYAAAA", wge = "bd8ce7c7", xge = { name: bge, data: Age, hash: wge };
const _ge = new Ln();
let dp = null;
function Ege(t3) {
  if (dp === null) return z4(_ge, xge, 16).then((e) => (dp = e, dp.calculate(t3)));
  try {
    const e = dp.calculate(t3);
    return Promise.resolve(e);
  } catch (e) {
    return Promise.reject(e);
  }
}
var Bge = "md5", Cge = "AGFzbQEAAAABEgRgAAF/YAAAYAF/AGACf38BfwMIBwABAgMBAAIFBAEBAgIGDgJ/AUGgigULfwBBgAgLB3AIBm1lbW9yeQIADkhhc2hfR2V0QnVmZmVyAAAJSGFzaF9Jbml0AAELSGFzaF9VcGRhdGUAAgpIYXNoX0ZpbmFsAAQNSGFzaF9HZXRTdGF0ZQAFDkhhc2hfQ2FsY3VsYXRlAAYKU1RBVEVfU0laRQMBCoMaBwUAQYAJCy0AQQBC/rnrxemOlZkQNwKQiQFBAEKBxpS6lvHq5m83AoiJAUEAQgA3AoCJAQu+BQEHf0EAQQAoAoCJASIBIABqQf////8BcSICNgKAiQFBAEEAKAKEiQEgAiABSWogAEEddmo2AoSJAQJAAkACQAJAAkACQCABQT9xIgMNAEGACSEEDAELIABBwAAgA2siBUkNASAFQQNxIQZBACEBAkAgA0E/c0EDSQ0AIANBgIkBaiEEIAVB/ABxIQdBACEBA0AgBCABaiICQRhqIAFBgAlqLQAAOgAAIAJBGWogAUGBCWotAAA6AAAgAkEaaiABQYIJai0AADoAACACQRtqIAFBgwlqLQAAOgAAIAcgAUEEaiIBRw0ACwsCQCAGRQ0AIANBmIkBaiECA0AgAiABaiABQYAJai0AADoAACABQQFqIQEgBkF/aiIGDQALC0GYiQFBwAAQAxogACAFayEAIAVBgAlqIQQLIABBwABPDQEgACECDAILIABFDQIgAEEDcSEGQQAhAQJAIABBBEkNACADQYCJAWohBCAAQXxxIQBBACEBA0AgBCABaiICQRhqIAFBgAlqLQAAOgAAIAJBGWogAUGBCWotAAA6AAAgAkEaaiABQYIJai0AADoAACACQRtqIAFBgwlqLQAAOgAAIAAgAUEEaiIBRw0ACwsgBkUNAiADQZiJAWohAgNAIAIgAWogAUGACWotAAA6AAAgAUEBaiEBIAZBf2oiBg0ADAMLCyAAQT9xIQIgBCAAQUBxEAMhBAsgAkUNACACQQNxIQZBACEBAkAgAkEESQ0AIAJBPHEhAEEAIQEDQCABQZiJAWogBCABaiICLQAAOgAAIAFBmYkBaiACQQFqLQAAOgAAIAFBmokBaiACQQJqLQAAOgAAIAFBm4kBaiACQQNqLQAAOgAAIAAgAUEEaiIBRw0ACwsgBkUNAANAIAFBmIkBaiAEIAFqLQAAOgAAIAFBAWohASAGQX9qIgYNAAsLC4cQARl/QQAoApSJASECQQAoApCJASEDQQAoAoyJASEEQQAoAoiJASEFA0AgACgCCCIGIAAoAhgiByAAKAIoIgggACgCOCIJIAAoAjwiCiAAKAIMIgsgACgCHCIMIAAoAiwiDSAMIAsgCiANIAkgCCAHIAMgBmogAiAAKAIEIg5qIAUgBCACIANzcSACc2ogACgCACIPakH4yKq7fWpBB3cgBGoiECAEIANzcSADc2pB1u6exn5qQQx3IBBqIhEgECAEc3EgBHNqQdvhgaECakERdyARaiISaiAAKAIUIhMgEWogACgCECIUIBBqIAQgC2ogEiARIBBzcSAQc2pB7p33jXxqQRZ3IBJqIhAgEiARc3EgEXNqQa+f8Kt/akEHdyAQaiIRIBAgEnNxIBJzakGqjJ+8BGpBDHcgEWoiEiARIBBzcSAQc2pBk4zBwXpqQRF3IBJqIhVqIAAoAiQiFiASaiAAKAIgIhcgEWogDCAQaiAVIBIgEXNxIBFzakGBqppqakEWdyAVaiIQIBUgEnNxIBJzakHYsYLMBmpBB3cgEGoiESAQIBVzcSAVc2pBr++T2nhqQQx3IBFqIhIgESAQc3EgEHNqQbG3fWpBEXcgEmoiFWogACgCNCIYIBJqIAAoAjAiGSARaiANIBBqIBUgEiARc3EgEXNqQb6v88p4akEWdyAVaiIQIBUgEnNxIBJzakGiosDcBmpBB3cgEGoiESAQIBVzcSAVc2pBk+PhbGpBDHcgEWoiFSARIBBzcSAQc2pBjofls3pqQRF3IBVqIhJqIAcgFWogDiARaiAKIBBqIBIgFSARc3EgEXNqQaGQ0M0EakEWdyASaiIQIBJzIBVxIBJzakHiyviwf2pBBXcgEGoiESAQcyAScSAQc2pBwOaCgnxqQQl3IBFqIhIgEXMgEHEgEXNqQdG0+bICakEOdyASaiIVaiAIIBJqIBMgEWogDyAQaiAVIBJzIBFxIBJzakGqj9vNfmpBFHcgFWoiECAVcyAScSAVc2pB3aC8sX1qQQV3IBBqIhEgEHMgFXEgEHNqQdOokBJqQQl3IBFqIhIgEXMgEHEgEXNqQYHNh8V9akEOdyASaiIVaiAJIBJqIBYgEWogFCAQaiAVIBJzIBFxIBJzakHI98++fmpBFHcgFWoiECAVcyAScSAVc2pB5puHjwJqQQV3IBBqIhEgEHMgFXEgEHNqQdaP3Jl8akEJdyARaiISIBFzIBBxIBFzakGHm9Smf2pBDncgEmoiFWogBiASaiAYIBFqIBcgEGogFSAScyARcSASc2pB7anoqgRqQRR3IBVqIhAgFXMgEnEgFXNqQYXSj896akEFdyAQaiIRIBBzIBVxIBBzakH4x75nakEJdyARaiISIBFzIBBxIBFzakHZhby7BmpBDncgEmoiFWogFyASaiATIBFqIBkgEGogFSAScyARcSASc2pBipmp6XhqQRR3IBVqIhAgFXMiFSASc2pBwvJoakEEdyAQaiIRIBVzakGB7ce7eGpBC3cgEWoiEiARcyIaIBBzakGiwvXsBmpBEHcgEmoiFWogFCASaiAOIBFqIAkgEGogFSAac2pBjPCUb2pBF3cgFWoiECAVcyIVIBJzakHE1PulempBBHcgEGoiESAVc2pBqZ/73gRqQQt3IBFqIhIgEXMiCSAQc2pB4JbttX9qQRB3IBJqIhVqIA8gEmogGCARaiAIIBBqIBUgCXNqQfD4/vV7akEXdyAVaiIQIBVzIhUgEnNqQcb97cQCakEEdyAQaiIRIBVzakH6z4TVfmpBC3cgEWoiEiARcyIIIBBzakGF4bynfWpBEHcgEmoiFWogGSASaiAWIBFqIAcgEGogFSAIc2pBhbqgJGpBF3cgFWoiESAVcyIQIBJzakG5oNPOfWpBBHcgEWoiEiAQc2pB5bPutn5qQQt3IBJqIhUgEnMiByARc2pB+PmJ/QFqQRB3IBVqIhBqIAwgFWogDyASaiAGIBFqIBAgB3NqQeWssaV8akEXdyAQaiIRIBVBf3NyIBBzakHExKShf2pBBncgEWoiEiAQQX9zciARc2pBl/+rmQRqQQp3IBJqIhAgEUF/c3IgEnNqQafH0Nx6akEPdyAQaiIVaiALIBBqIBkgEmogEyARaiAVIBJBf3NyIBBzakG5wM5kakEVdyAVaiIRIBBBf3NyIBVzakHDs+2qBmpBBncgEWoiECAVQX9zciARc2pBkpmz+HhqQQp3IBBqIhIgEUF/c3IgEHNqQf3ov39qQQ93IBJqIhVqIAogEmogFyAQaiAOIBFqIBUgEEF/c3IgEnNqQdG7kax4akEVdyAVaiIQIBJBf3NyIBVzakHP/KH9BmpBBncgEGoiESAVQX9zciAQc2pB4M2zcWpBCncgEWoiEiAQQX9zciARc2pBlIaFmHpqQQ93IBJqIhVqIA0gEmogFCARaiAYIBBqIBUgEUF/c3IgEnNqQaGjoPAEakEVdyAVaiIQIBJBf3NyIBVzakGC/c26f2pBBncgEGoiESAVQX9zciAQc2pBteTr6XtqQQp3IBFqIhIgEEF/c3IgEXNqQbul39YCakEPdyASaiIVIARqIBYgEGogFSARQX9zciASc2pBkaeb3H5qQRV3aiEEIBUgA2ohAyASIAJqIQIgESAFaiEFIABBwABqIQAgAUFAaiIBDQALQQAgAjYClIkBQQAgAzYCkIkBQQAgBDYCjIkBQQAgBTYCiIkBIAALyAMBBX9BACgCgIkBQT9xIgBBmIkBakGAAToAACAAQQFqIQECQAJAAkACQCAAQT9zIgJBB0sNACACRQ0BIAFBmIkBakEAOgAAIAJBAUYNASAAQZqJAWpBADoAACACQQJGDQEgAEGbiQFqQQA6AAAgAkEDRg0BIABBnIkBakEAOgAAIAJBBEYNASAAQZ2JAWpBADoAACACQQVGDQEgAEGeiQFqQQA6AAAgAkEGRg0BIABBn4kBakEAOgAADAELIAJBCEYNAkE2IABrIgMhBAJAIAJBA3EiAEUNAEEAIABrIQRBACEAA0AgAEHPiQFqQQA6AAAgBCAAQX9qIgBHDQALIAMgAGohBAsgA0EDSQ0CDAELQZiJAUHAABADGkEAIQFBNyEECyABQYCJAWohAEF/IQIDQCAAIARqQRVqQQA2AAAgAEF8aiEAIAQgAkEEaiICRw0ACwtBAEEAKAKEiQE2AtSJAUEAQQAoAoCJASIAQRV2OgDTiQFBACAAQQ12OgDSiQFBACAAQQV2OgDRiQFBACAAQQN0IgA6ANCJAUEAIAA2AoCJAUGYiQFBwAAQAxpBAEEAKQKIiQE3A4AJQQBBACkCkIkBNwOICQsGAEGAiQELMwBBAEL+uevF6Y6VmRA3ApCJAUEAQoHGlLqW8ermbzcCiIkBQQBCADcCgIkBIAAQAhAECwsLAQBBgAgLBJgAAAA=", kge = "e6508e4b", Ige = { name: Bge, data: Cge, hash: kge };
const Sge = new Ln();
let pp = null;
function Mge(t3) {
  if (pp === null) return z4(Sge, Ige, 16).then((e) => (pp = e, pp.calculate(t3)));
  try {
    const e = pp.calculate(t3);
    return Promise.resolve(e);
  } catch (e) {
    return Promise.reject(e);
  }
}
new Ln();
new Ln();
new Ln();
new Ln();
new Ln();
new Ln();
new Ln();
new Ln();
new Ln();
new Ln();
new Ln();
new Ln();
var $ge = "whirlpool", Tge = "AGFzbQEAAAABEQRgAAF/YAF/AGACf38AYAAAAwkIAAECAwEDAAEFBAEBAgIGDgJ/AUHQmwULfwBBgAgLB3AIBm1lbW9yeQIADkhhc2hfR2V0QnVmZmVyAAAJSGFzaF9Jbml0AAMLSGFzaF9VcGRhdGUABApIYXNoX0ZpbmFsAAUNSGFzaF9HZXRTdGF0ZQAGDkhhc2hfQ2FsY3VsYXRlAAcKU1RBVEVfU0laRQMBCu0bCAUAQYAZC8wGAQl+IAApAwAhAUEAQQApA4CbASICNwPAmQEgACkDGCEDIAApAxAhBCAAKQMIIQVBAEEAKQOYmwEiBjcD2JkBQQBBACkDkJsBIgc3A9CZAUEAQQApA4ibASIINwPImQFBACABIAKFNwOAmgFBACAFIAiFNwOImgFBACAEIAeFNwOQmgFBACADIAaFNwOYmgEgACkDICEDQQBBACkDoJsBIgE3A+CZAUEAIAMgAYU3A6CaASAAKQMoIQRBAEEAKQOomwEiAzcD6JkBQQAgBCADhTcDqJoBIAApAzAhBUEAQQApA7CbASIENwPwmQFBACAFIASFNwOwmgEgACkDOCEJQQBBACkDuJsBIgU3A/iZAUEAIAkgBYU3A7iaAUEAQpjGmMb+kO6AzwA3A4CZAUHAmQFBgJkBEAJBgJoBQcCZARACQQBCtszKrp/v28jSADcDgJkBQcCZAUGAmQEQAkGAmgFBwJkBEAJBAELg+O70uJTDvTU3A4CZAUHAmQFBgJkBEAJBgJoBQcCZARACQQBCncDfluzlkv/XADcDgJkBQcCZAUGAmQEQAkGAmgFBwJkBEAJBAEKV7t2p/pO8pVo3A4CZAUHAmQFBgJkBEAJBgJoBQcCZARACQQBC2JKn0ZCW6LWFfzcDgJkBQcCZAUGAmQEQAkGAmgFBwJkBEAJBAEK9u8Ggv9nPgucANwOAmQFBwJkBQYCZARACQYCaAUHAmQEQAkEAQuTPhNr4tN/KWDcDgJkBQcCZAUGAmQEQAkGAmgFBwJkBEAJBAEL73fOz1vvFo55/NwOAmQFBwJkBQYCZARACQYCaAUHAmQEQAkEAQsrb/L3Q1dbBMzcDgJkBQcCZAUGAmQEQAkGAmgFBwJkBEAJBACACQQApA4CaASAAKQMAhYU3A4CbAUEAIAhBACkDiJoBIAApAwiFhTcDiJsBQQAgB0EAKQOQmgEgACkDEIWFNwOQmwFBACAGQQApA5iaASAAKQMYhYU3A5ibAUEAIAFBACkDoJoBIAApAyCFhTcDoJsBQQAgA0EAKQOomgEgACkDKIWFNwOomwFBACAEQQApA7CaASAAKQMwhYU3A7CbAUEAIAVBACkDuJoBIAApAziFhTcDuJsBC4YMCgF+AX8BfgF/AX4BfwF+AX8EfgN/IAAgACkDACICpyIDQf8BcUEDdEGQCGopAwBCOIkgACkDOCIEpyIFQQV2QfgPcUGQCGopAwCFQjiJIAApAzAiBqciB0ENdkH4D3FBkAhqKQMAhUI4iSAAKQMoIginIglBFXZB+A9xQZAIaikDAIVCOIkgACkDICIKQiCIp0H/AXFBA3RBkAhqKQMAhUI4iSAAKQMYIgtCKIinQf8BcUEDdEGQCGopAwCFQjiJIAApAxAiDEIwiKdB/wFxQQN0QZAIaikDAIVCOIkgACkDCCINQjiIp0EDdEGQCGopAwCFQjiJIAEpAwCFNwMAIAAgDaciDkH/AXFBA3RBkAhqKQMAQjiJIANBBXZB+A9xQZAIaikDAIVCOIkgBUENdkH4D3FBkAhqKQMAhUI4iSAHQRV2QfgPcUGQCGopAwCFQjiJIAhCIIinQf8BcUEDdEGQCGopAwCFQjiJIApCKIinQf8BcUEDdEGQCGopAwCFQjiJIAtCMIinQf8BcUEDdEGQCGopAwCFQjiJIAxCOIinQQN0QZAIaikDAIVCOIkgASkDCIU3AwggACAMpyIPQf8BcUEDdEGQCGopAwBCOIkgDkEFdkH4D3FBkAhqKQMAhUI4iSADQQ12QfgPcUGQCGopAwCFQjiJIAVBFXZB+A9xQZAIaikDAIVCOIkgBkIgiKdB/wFxQQN0QZAIaikDAIVCOIkgCEIoiKdB/wFxQQN0QZAIaikDAIVCOIkgCkIwiKdB/wFxQQN0QZAIaikDAIVCOIkgC0I4iKdBA3RBkAhqKQMAhUI4iSABKQMQhTcDECAAIAunIhBB/wFxQQN0QZAIaikDAEI4iSAPQQV2QfgPcUGQCGopAwCFQjiJIA5BDXZB+A9xQZAIaikDAIVCOIkgA0EVdkH4D3FBkAhqKQMAhUI4iSAEQiCIp0H/AXFBA3RBkAhqKQMAhUI4iSAGQiiIp0H/AXFBA3RBkAhqKQMAhUI4iSAIQjCIp0H/AXFBA3RBkAhqKQMAhUI4iSAKQjiIp0EDdEGQCGopAwCFQjiJIAEpAxiFNwMYIAAgCqciA0H/AXFBA3RBkAhqKQMAQjiJIBBBBXZB+A9xQZAIaikDAIVCOIkgD0ENdkH4D3FBkAhqKQMAhUI4iSAOQRV2QfgPcUGQCGopAwCFQjiJIAJCIIinQf8BcUEDdEGQCGopAwCFQjiJIARCKIinQf8BcUEDdEGQCGopAwCFQjiJIAZCMIinQf8BcUEDdEGQCGopAwCFQjiJIAhCOIinQQN0QZAIaikDAIVCOIkgASkDIIU3AyAgACAJQf8BcUEDdEGQCGopAwBCOIkgA0EFdkH4D3FBkAhqKQMAhUI4iSAQQQ12QfgPcUGQCGopAwCFQjiJIA9BFXZB+A9xQZAIaikDAIVCOIkgDUIgiKdB/wFxQQN0QZAIaikDAIVCOIkgAkIoiKdB/wFxQQN0QZAIaikDAIVCOIkgBEIwiKdB/wFxQQN0QZAIaikDAIVCOIkgBkI4iKdBA3RBkAhqKQMAhUI4iSABKQMohTcDKCAAIAdB/wFxQQN0QZAIaikDAEI4iSAJQQV2QfgPcUGQCGopAwCFQjiJIANBDXZB+A9xQZAIaikDAIVCOIkgEEEVdkH4D3FBkAhqKQMAhUI4iSAMQiCIp0H/AXFBA3RBkAhqKQMAhUI4iSANQiiIp0H/AXFBA3RBkAhqKQMAhUI4iSACQjCIp0H/AXFBA3RBkAhqKQMAhUI4iSAEQjiIp0EDdEGQCGopAwCFQjiJIAEpAzCFNwMwIAAgBUH/AXFBA3RBkAhqKQMAQjiJIAdBBXZB+A9xQZAIaikDAIVCOIkgCUENdkH4D3FBkAhqKQMAhUI4iSADQRV2QfgPcUGQCGopAwCFQjiJIAtCIIinQf8BcUEDdEGQCGopAwCFQjiJIAxCKIinQf8BcUEDdEGQCGopAwCFQjiJIA1CMIinQf8BcUEDdEGQCGopAwCFQjiJIAJCOIinQQN0QZAIaikDAIVCOIkgASkDOIU3AzgLXABBAEIANwPImwFBAEIANwO4mwFBAEIANwOwmwFBAEIANwOomwFBAEIANwOgmwFBAEIANwOYmwFBAEIANwOQmwFBAEIANwOImwFBAEIANwOAmwFBAEEANgLAmwELxgMBB39BACEBQQBBACkDyJsBIACtfDcDyJsBAkBBACgCwJsBIgJFDQBBACEBAkAgAiAAaiIDQcAAIANBwABJGyIEIAJB/wFxIgVNDQAgBCAFayIBQQNxIQYCQAJAIAQgBUF/c2pBA08NAEEAIQEMAQsgAUF8cSEHQQAhAQNAIAUgAWoiAkHAmgFqIAFBgBlqLQAAOgAAIAJBwZoBaiABQYEZai0AADoAACACQcKaAWogAUGCGWotAAA6AAAgAkHDmgFqIAFBgxlqLQAAOgAAIAcgAUEEaiIBRw0ACyAFIAFqIgUhAgsgBkUNACACQf8BcUEBaiECA0AgBUHAmgFqIAFBgBlqLQAAOgAAIAIiBUEBaiECIAFBAWohASAFIQUgBkF/aiIGDQALCwJAIANBP00NAEHAmgEQAUEAIQQLQQAgBDYCwJsBCwJAIAAgAWsiAkHAAEkNAANAIAFBgBlqEAEgAUHAAGohASACQUBqIgJBP0sNAAsLAkAgASAARg0AQQAgAjYCwJsBIAJFDQBBACECQQAhBQNAIAJBwJoBaiACIAFqQYAZai0AADoAAEEAKALAmwEgBUEBaiIFQf8BcSICSw0ACwsL/wMCBH8BfiMAQcAAayIAJAAgAEE4akIANwMAIABBMGpCADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBGGpCADcDACAAQRBqQgA3AwAgAEIANwMIIABCADcDAEEAIQECQAJAQQAoAsCbASICRQ0AQQAhAwNAIAAgAWogAUHAmgFqLQAAOgAAIAFBAWohASACIANBAWoiA0H/AXFLDQALQQAgAkEBajYCwJsBIAAgAmpBgAE6AAAgAkFgcUEgRw0BIAAQASAAQgA3AxggAEIANwMQIABCADcDCCAAQgA3AwAMAQtBAEEBNgLAmwEgAEGAAToAAAtBACkDyJsBIQRBAEIANwPImwEgAEEAOgA2IABBADYBMiAAQgA3ASogAEEAOgApIABCADcAISAAQQA6ACAgACAEQgWIPAA+IAAgBEINiDwAPSAAIARCFYg8ADwgACAEQh2IPAA7IAAgBEIliDwAOiAAIARCLYg8ADkgACAEQjWIPAA4IAAgBEI9iDwANyAAIASnQQN0OgA/IAAQAUEAQQApA4CbATcDgBlBAEEAKQOImwE3A4gZQQBBACkDkJsBNwOQGUEAQQApA5ibATcDmBlBAEEAKQOgmwE3A6AZQQBBACkDqJsBNwOoGUEAQQApA7CbATcDsBlBAEEAKQO4mwE3A7gZIABBwABqJAALBgBBwJoBC2IAQQBCADcDyJsBQQBCADcDuJsBQQBCADcDsJsBQQBCADcDqJsBQQBCADcDoJsBQQBCADcDmJsBQQBCADcDkJsBQQBCADcDiJsBQQBCADcDgJsBQQBBADYCwJsBIAAQBBAFCwuYEAEAQYAIC5AQkAAAAAAAAAAAAAAAAAAAABgYYBjAeDDYIyOMIwWvRibGxj/GfvmRuOjoh+gTb837h4cmh0yhE8u4uNq4qWJtEQEBBAEIBQIJT08hT0Jung02Ntg2re5sm6amoqZZBFH/0tJv0t69uQz19fP1+wb3Dnl5+XnvgPKWb2+hb1/O3jCRkX6R/O8/bVJSVVKqB6T4YGCdYCf9wEe8vMq8iXZlNZubVpuszSs3jo4CjgSMAYqjo7ajcRVb0gwMMAxgPBhse3vxe/+K9oQ1NdQ1teFqgB0ddB3oaTr14OCn4FNH3bPX13vX9qyzIcLCL8Je7ZmcLi64Lm2WXENLSzFLYnqWKf7+3/6jIeFdV1dBV4IWrtUVFVQVqEEqvXd3wXeftu7oNzfcN6XrbpLl5bPle1bXnp+fRp+M2SMT8PDn8NMX/SNKSjVKan+UINraT9qelalEWFh9WPolsKLJyQPJBsqPzykppClVjVJ8CgooClAiFFqxsf6x4U9/UKCguqBpGl3Ja2uxa3/a1hSFhS6FXKsX2b29zr2Bc2c8XV1pXdI0uo8QEEAQgFAgkPT09/TzA/UHy8sLyxbAi90+Pvg+7cZ80wUFFAUoEQotZ2eBZx/mznjk5Lfkc1PVlycnnCclu04CQUEZQTJYgnOLixaLLJ0Lp6enpqdRAVP2fX3pfc+U+rKVlW6V3Ps3SdjYR9iOn61W+/vL+4sw63Du7p/uI3HBzXx87XzHkfi7ZmaFZhfjzHHd3VPdpo6nexcXXBe4Sy6vR0cBRwJGjkWenkKehNwhGsrKD8oexYnULS20LXWZWli/v8a/kXljLgcHHAc4Gw4/ra2OrQEjR6xaWnVa6i+0sIODNoNstRvvMzPMM4X/ZrZjY5FjP/LGXAICCAIQCgQSqqqSqjk4SZNxcdlxr6ji3sjIB8gOz43GGRlkGch9MtFJSTlJcnCSO9nZQ9mGmq9f8vLv8sMd+THj46vjS0jbqFtbcVviKra5iIgaiDSSDbyamlKapMgpPiYmmCYtvkwLMjLIMo36ZL+wsPqw6Up9Wenpg+kbas/yDw88D3gzHnfV1XPV5qa3M4CAOoB0uh30vr7Cvpl8YSfNzRPNJt6H6zQ00DS95GiJSEg9SHp1kDL//9v/qyTjVHp69Xr3j/SNkJB6kPTqPWRfX2Ffwj6+nSAggCAdoEA9aGi9aGfV0A8aGmga0HI0yq6ugq4ZLEG3tLTqtMledX1UVE1UmhmozpOTdpPs5Tt/IiKIIg2qRC9kZI1kB+nIY/Hx4/HbEv8qc3PRc7+i5swSEkgSkFokgkBAHUA6XYB6CAggCEAoEEjDwyvDVuiblezsl+wze8Xf29tL25aQq02hob6hYR9fwI2NDo0cgweRPT30PfXJesiXl2aXzPEzWwAAAAAAAAAAz88bzzbUg/krK6wrRYdWbnZ2xXaXs+zhgoIygmSwGebW1n/W/qmxKBsbbBvYdzbDtbXutcFbd3Svr4avESlDvmpqtWp339QdUFBdULoNoOpFRQlFEkyKV/Pz6/PLGPs4MDDAMJ3wYK3v75vvK3TDxD8//D/lw37aVVVJVZIcqseiorKieRBZ2+rqj+oDZcnpZWWJZQ/symq6utK6uWhpAy8vvC9lk15KwMAnwE7nnY7e3l/evoGhYBwccBzgbDj8/f3T/bsu50ZNTSlNUmSaH5KScpLk4Dl2dXXJdY+86voGBhgGMB4MNoqKEookmAmusrLysvlAeUvm5r/mY1nRhQ4OOA5wNhx+Hx98H/hjPudiYpViN/fEVdTUd9Tuo7U6qKiaqCkyTYGWlmKWxPQxUvn5w/mbOu9ixcUzxWb2l6MlJZQlNbFKEFlZeVnyILKrhIQqhFSuFdByctVyt6fkxTk55DnV3XLsTEwtTFphmBZeXmVeyju8lHh4/XjnhfCfODjgON3YcOWMjAqMFIYFmNHRY9HGsr8XpaWupUELV+Ti4q/iQ03ZoWFhmWEv+MJOs7P2s/FFe0IhIYQhFaVCNJycSpyU1iUIHh54HvBmPO5DQxFDIlKGYcfHO8d2/JOx/PzX/LMr5U8EBBAEIBQIJFFRWVGyCKLjmZlembzHLyVtbaltT8TaIg0NNA1oORpl+vrP+oM16Xnf31vftoSjaX5+5X7Xm/ypJCSQJD20SBk7O+w7xdd2/qurlqsxPUuazs4fzj7RgfAREUQRiFUimY+PBo8MiQODTk4lTkprnAS3t+a30VFzZuvri+sLYMvgPDzwPP3MeMGBgT6BfL8f/ZSUapTU/jVA9/f79+sM8xy5ud65oWdvGBMTTBOYXyaLLCywLH2cWFHT02vT1ri7Befnu+drXNOMbm6lblfL3DnExDfEbvOVqgMDDAMYDwYbVlZFVooTrNxERA1EGkmIXn9/4X/fnv6gqameqSE3T4gqKqgqTYJUZ7u71ruxbWsKwcEjwUbin4dTU1FTogKm8dzcV9yui6VyCwssC1gnFlOdnU6dnNMnAWxsrWxHwdgrMTHEMZX1YqR0dM10h7no8/b2//bjCfEVRkYFRgpDjEysrIqsCSZFpYmJHok8lw+1FBRQFKBEKLTh4aPhW0LfuhYWWBawTiymOjroOs3SdPdpablpb9DSBgkJJAlILRJBcHDdcKet4Ne2tuK22VRxb9DQZ9DOt70e7e2T7Tt+x9bMzBfMLtuF4kJCFUIqV4RomJhamLTCLSykpKqkSQ5V7SgooChdiFB1XFxtXNoxuIb4+Mf4kz/ta4aGIoZEpBHC", Dge = "8d8f6035", Rge = { name: $ge, data: Tge, hash: Dge };
const Fge = new Ln();
let gp = null;
function Pge(t3) {
  if (gp === null) return z4(Fge, Rge, 64).then((e) => (gp = e, gp.calculate(t3)));
  try {
    const e = gp.calculate(t3);
    return Promise.resolve(e);
  } catch (e) {
    return Promise.reject(e);
  }
}
new Ln();
const Nge = { MD4: Ege, MD5: Mge };
async function Uge(t3, e, n = "utf-8") {
  if (!t3) throw new Error("Please enter some text.");
  const r = Nge[e];
  if (!r) throw new Error(`Algorithm ${e} is not supported.`);
  let s;
  try {
    s = ps(t3, n);
  } catch (o) {
    throw new Error(o.message);
  }
  const i = await r(s), a = Lge(i);
  return { hex: i, base64: a, bitLength: 128 };
}
function Lge(t3) {
  const e = t3.match(/\w{2}/g), n = function* () {
    for (; e.length >= 1; ) yield parseInt(e.shift(), 16);
  }();
  return btoa(String.fromCharCode(...n));
}
function Oge(t3) {
  let e = t3[6] ? "Hashing..." : "Generate Hash", n;
  return { c() {
    n = we(e);
  }, m(r, s) {
    R(r, n, s);
  }, p(r, s) {
    s & 64 && e !== (e = r[6] ? "Hashing..." : "Generate Hash") && Ze(n, e);
  }, d(r) {
    r && D(n);
  } };
}
function Qge(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function cB(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[5]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 32 && Ze(n, r[5]);
  }, d(r) {
    r && D(e);
  } };
}
function hB(t3) {
  let e, n, r, s;
  return e = new et({ props: { label: t3[1] + " Hex:", value: t3[4].hex, readonly: true, expandable: true, withCopy: true } }), r = new et({ props: { label: t3[1] + " Base64:", value: t3[4].base64, readonly: true, expandable: true, withCopy: true } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, a) {
    const o = {};
    a & 2 && (o.label = i[1] + " Hex:"), a & 16 && (o.value = i[4].hex), e.$set(o);
    const f = {};
    a & 2 && (f.label = i[1] + " Base64:"), a & 16 && (f.value = i[4].base64), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function Kge(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U;
  function Q(E) {
    t3[10](E);
  }
  let P = { label: "Algorithm:", options: t3[7] };
  t3[1] !== void 0 && (P.value = t3[1]), n = new Ht({ props: P }), Qe.push(() => ze(n, "value", Q));
  function N(E) {
    t3[11](E);
  }
  let L = { label: "Input Encoding:", options: gs.map(zge) };
  t3[2] !== void 0 && (L.value = t3[2]), i = new Ht({ props: L }), Qe.push(() => ze(i, "value", N));
  function B(E) {
    t3[12](E);
  }
  let u = { label: "Input Data:", expandable: true, placeholder: t3[2] === "hex" ? "e.g. 4a 1b..." : "Type text here..." };
  t3[0] !== void 0 && (u.value = t3[0]), f = new et({ props: u }), Qe.push(() => ze(f, "value", B)), m = new ut({ props: { disabled: t3[6], $$slots: { default: [Oge] }, $$scope: { ctx: t3 } } }), m.$on("click", t3[8]), b = new ut({ props: { variant: "secondary", $$slots: { default: [Qge] }, $$scope: { ctx: t3 } } }), b.$on("click", t3[13]);
  function p(E) {
    t3[14](E);
  }
  let d = {};
  t3[3] !== void 0 && (d.checked = t3[3]), C = new xr({ props: d }), Qe.push(() => ze(C, "checked", p));
  let y = t3[5] && cB(t3), w = t3[4] && hB(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), fe(i.$$.fragment), o = z(), fe(f.$$.fragment), l = z(), h = H("div"), fe(m.$$.fragment), v = z(), fe(b.$$.fragment), A = z(), _ = H("div"), fe(C.$$.fragment), S = z(), y && y.c(), $ = z(), w && w.c(), F = Lt(), V(e, "class", "controls-row"), St(_, "margin-left", "auto"), V(h, "class", "button-row");
  }, m(E, M) {
    R(E, e, M), ae(n, e, null), q(e, s), ae(i, e, null), R(E, o, M), ae(f, E, M), R(E, l, M), R(E, h, M), ae(m, h, null), q(h, v), ae(b, h, null), q(h, A), q(h, _), ae(C, _, null), R(E, S, M), y && y.m(E, M), R(E, $, M), w && w.m(E, M), R(E, F, M), U = true;
  }, p(E, M) {
    const x = {};
    !r && M & 2 && (r = true, x.value = E[1], qe(() => r = false)), n.$set(x);
    const g = {};
    !a && M & 4 && (a = true, g.value = E[2], qe(() => a = false)), i.$set(g);
    const k = {};
    M & 4 && (k.placeholder = E[2] === "hex" ? "e.g. 4a 1b..." : "Type text here..."), !c && M & 1 && (c = true, k.value = E[0], qe(() => c = false)), f.$set(k);
    const T = {};
    M & 64 && (T.disabled = E[6]), M & 32832 && (T.$$scope = { dirty: M, ctx: E }), m.$set(T);
    const O = {};
    M & 32768 && (O.$$scope = { dirty: M, ctx: E }), b.$set(O);
    const K = {};
    !I && M & 8 && (I = true, K.checked = E[3], qe(() => I = false)), C.$set(K), E[5] ? y ? y.p(E, M) : (y = cB(E), y.c(), y.m($.parentNode, $)) : y && (y.d(1), y = null), E[4] ? w ? (w.p(E, M), M & 16 && W(w, 1)) : (w = hB(E), w.c(), W(w, 1), w.m(F.parentNode, F)) : w && (Xt(), j(w, 1, 1, () => {
      w = null;
    }), er());
  }, i(E) {
    U || (W(n.$$.fragment, E), W(i.$$.fragment, E), W(f.$$.fragment, E), W(m.$$.fragment, E), W(b.$$.fragment, E), W(C.$$.fragment, E), W(w), U = true);
  }, o(E) {
    j(n.$$.fragment, E), j(i.$$.fragment, E), j(f.$$.fragment, E), j(m.$$.fragment, E), j(b.$$.fragment, E), j(C.$$.fragment, E), j(w), U = false;
  }, d(E) {
    E && (D(e), D(o), D(l), D(h), D(S), D($), D(F)), oe(n), oe(i), oe(f, E), oe(m), oe(b), oe(C), y && y.d(E), w && w.d(E);
  } };
}
function Hge(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S;
  return { c() {
    e = H("p"), e.innerHTML = `<strong>Security Warning:</strong> Both MD4 and MD5 are <strong>cryptographically broken</strong>. 
    MD4 can be broken in microseconds, and MD5 collisions can be generated in seconds on a standard smartphone.
    These should only be used for integrity checks (like file checksums) or educational purposes, never for security.`, n = z(), r = H("p"), r.innerHTML = `<b>MD4 (Message Digest Algorithm 4)</b> is a cryptographic hash function developed by
    Ronald Rivest in 1990. It is designed to produce a 128-bit hash value and was one of the earliest 
    widely adopted hash algorithms. MD4 laid the foundation for other hash functions such as MD5 and 
    SHA algorithms.`, s = z(), i = H("p"), i.innerHTML = "<strong>Characteristics of MD4:</strong>", a = z(), o = H("ul"), o.innerHTML = "<li>Produces a 128-bit hash value.</li> <li>Utilizes three rounds of computation for generating the hash value.</li> <li>Considered highly efficient but no longer secure for modern cryptographic needs.</li> <li>MD4 is vulnerable to collision attacks, meaning different input data can produce the same hash.</li>", f = z(), c = H("p"), c.textContent = `MD4 was commonly used in applications such as digital signatures and password hashing, 
    but due to its vulnerabilities, it is now considered obsolete for most security purposes. 
    Modern systems have moved to more secure algorithms like SHA-256 or SHA-3.`, l = z(), h = H("p"), h.innerHTML = `<b>MD5 (Message Digest Algorithm 5)</b> is a widely known cryptographic hash function developed 
    by Ronald Rivest in 1991 as an improvement over MD4. It generates a 128-bit hash value, typically 
    represented as a 32-character hexadecimal number. MD5 was once widely used for data integrity 
    checks and cryptographic applications.`, m = z(), v = H("p"), v.innerHTML = "<strong>Characteristics of MD5:</strong>", b = z(), A = H("ul"), A.innerHTML = "<li>Produces a 128-bit hash value.</li> <li>Uses four rounds of computation to generate the hash.</li> <li>Efficient and relatively fast in generating hash values.</li> <li>MD5 is no longer considered secure due to its vulnerability to collision and pre-image attacks.</li>", _ = z(), C = H("p"), C.textContent = `Although MD5 is faster than more secure algorithms, it is not suitable for use in secure applications 
    like SSL certificates or digital signatures. Security researchers have demonstrated that attackers can generate
    different input data that results in the same MD5 hash value (collisions), significantly compromising its reliability.`, I = z(), S = H("p"), S.textContent = `MD5 is still used for checksums to verify data integrity in non-security-critical applications, 
    but it is strongly recommended to use more secure hash functions, such as SHA-256, for any cryptographic use.`, V(e, "class", "warning");
  }, m($, F) {
    R($, e, F), R($, n, F), R($, r, F), R($, s, F), R($, i, F), R($, a, F), R($, o, F), R($, f, F), R($, c, F), R($, l, F), R($, h, F), R($, m, F), R($, v, F), R($, b, F), R($, A, F), R($, _, F), R($, C, F), R($, I, F), R($, S, F);
  }, p: dt, d($) {
    $ && (D(e), D(n), D(r), D(s), D(i), D(a), D(o), D(f), D(c), D(l), D(h), D(m), D(v), D(b), D(A), D(_), D(C), D(I), D(S));
  } };
}
function qge(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Message Digest Family", $$slots: { default: [Kge] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Message Digest", links: t3[9], $$slots: { default: [Hge] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 32895 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 32768 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
const zge = (t3) => t3.value;
function Gge(t3, e, n) {
  let r = "", s = "MD4", i = "utf-8", a = null, o = "", f = false, c = true;
  const l = ["MD4", "MD5"];
  async function h() {
    if (!r) {
      n(4, a = null), n(5, o = "");
      return;
    }
    n(5, o = ""), n(4, a = null), n(6, f = true);
    try {
      n(4, a = await Uge(r, s, i));
    } catch (I) {
      n(5, o = I.message);
    } finally {
      n(6, f = false);
    }
  }
  const m = [{ text: "NPM: hash-wasm", url: "https://www.npmjs.com/package/hash-wasm" }, { text: "MD5 Collision Demo", url: "https://www.mscs.dal.ca/~selinger/md5collision/" }, { text: "Wikipedia: MD5", url: "https://en.wikipedia.org/wiki/MD5" }, { text: "Wikipedia: MD4", url: "https://en.wikipedia.org/wiki/MD4" }];
  function v(I) {
    s = I, n(1, s);
  }
  function b(I) {
    i = I, n(2, i);
  }
  function A(I) {
    r = I, n(0, r);
  }
  const _ = () => {
    n(0, r = ""), n(4, a = null);
  };
  function C(I) {
    c = I, n(3, c);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 15 && c && (r || s || i) && h();
  }, [r, s, i, c, a, o, f, l, h, m, v, b, A, _, C];
}
class Vge extends xt {
  constructor(e) {
    super(), wt(this, e, Gge, qge, At, {});
  }
}
const Yge = Uint8Array.from([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]), zF = Uint8Array.from(new Array(16).fill(0).map((t3, e) => e)), Wge = zF.map((t3) => (9 * t3 + 5) % 16), GF = (() => {
  const n = [[zF], [Wge]];
  for (let r = 0; r < 4; r++) for (let s of n) s.push(s[r].map((i) => Yge[i]));
  return n;
})(), VF = GF[0], YF = GF[1], WF = [[11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8], [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7], [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9], [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6], [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]].map((t3) => Uint8Array.from(t3)), Jge = VF.map((t3, e) => t3.map((n) => WF[e][n])), Zge = YF.map((t3, e) => t3.map((n) => WF[e][n])), jge = Uint32Array.from([0, 1518500249, 1859775393, 2400959708, 2840853838]), Xge = Uint32Array.from([1352829926, 1548603684, 1836072691, 2053994217, 0]);
function dB(t3, e, n, r) {
  return t3 === 0 ? e ^ n ^ r : t3 === 1 ? e & n | ~e & r : t3 === 2 ? (e | ~n) ^ r : t3 === 3 ? e & r | n & ~r : e ^ (n | ~r);
}
const mp = new Uint32Array(16);
class eme extends L4 {
  constructor() {
    super(64, 20, 8, true), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
  }
  get() {
    const { h0: e, h1: n, h2: r, h3: s, h4: i } = this;
    return [e, n, r, s, i];
  }
  set(e, n, r, s, i) {
    this.h0 = e | 0, this.h1 = n | 0, this.h2 = r | 0, this.h3 = s | 0, this.h4 = i | 0;
  }
  process(e, n) {
    for (let v = 0; v < 16; v++, n += 4) mp[v] = e.getUint32(n, true);
    let r = this.h0 | 0, s = r, i = this.h1 | 0, a = i, o = this.h2 | 0, f = o, c = this.h3 | 0, l = c, h = this.h4 | 0, m = h;
    for (let v = 0; v < 5; v++) {
      const b = 4 - v, A = jge[v], _ = Xge[v], C = VF[v], I = YF[v], S = Jge[v], $ = Zge[v];
      for (let F = 0; F < 16; F++) {
        const U = up(r + dB(v, i, o, c) + mp[C[F]] + A, S[F]) + h | 0;
        r = h, h = c, c = up(o, 10) | 0, o = i, i = U;
      }
      for (let F = 0; F < 16; F++) {
        const U = up(s + dB(b, a, f, l) + mp[I[F]] + _, $[F]) + m | 0;
        s = m, m = l, l = up(f, 10) | 0, f = a, a = U;
      }
    }
    this.set(this.h1 + o + l | 0, this.h2 + c + m | 0, this.h3 + h + s | 0, this.h4 + r + a | 0, this.h0 + i + f | 0);
  }
  roundClean() {
    Li(mp);
  }
  destroy() {
    this.destroyed = true, Li(this.buffer), this.set(0, 0, 0, 0, 0);
  }
}
const tme = hc(() => new eme());
function rme(t3, e = "utf-8") {
  if (!t3) throw new Error("Please enter some text.");
  let n;
  try {
    n = ps(t3, e);
  } catch (a) {
    throw new Error(a.message);
  }
  const r = tme(n), s = Al(r), i = btoa(String.fromCharCode(...r));
  return { hex: s, base64: i };
}
function nme(t3) {
  let e;
  return { c() {
    e = we("Generate Hash");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function ime(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function pB(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[4]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 16 && Ze(n, r[4]);
  }, d(r) {
    r && D(e);
  } };
}
function gB(t3) {
  let e, n, r, s;
  return e = new et({ props: { label: "Hex digest:", value: t3[3].hex, readonly: true, expandable: true, withCopy: true } }), r = new et({ props: { label: "Base64 digest:", value: t3[3].base64, readonly: true, expandable: true, withCopy: true } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, a) {
    const o = {};
    a & 8 && (o.value = i[3].hex), e.$set(o);
    const f = {};
    a & 8 && (f.value = i[3].base64), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function sme(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I;
  function S(B) {
    t3[7](B);
  }
  let $ = { label: "Input Encoding:", options: gs.map(fme) };
  t3[1] !== void 0 && ($.value = t3[1]), e = new Ht({ props: $ }), Qe.push(() => ze(e, "value", S));
  function F(B) {
    t3[8](B);
  }
  let U = { label: "Enter text:", placeholder: "Type here...", expandable: true };
  t3[0] !== void 0 && (U.value = t3[0]), s = new et({ props: U }), Qe.push(() => ze(s, "value", F)), f = new ut({ props: { $$slots: { default: [nme] }, $$scope: { ctx: t3 } } }), f.$on("click", t3[5]), l = new ut({ props: { variant: "secondary", $$slots: { default: [ime] }, $$scope: { ctx: t3 } } }), l.$on("click", t3[9]);
  function Q(B) {
    t3[10](B);
  }
  let P = {};
  t3[2] !== void 0 && (P.checked = t3[2]), v = new xr({ props: P }), Qe.push(() => ze(v, "checked", Q));
  let N = t3[4] && pB(t3), L = t3[3] && gB(t3);
  return { c() {
    fe(e.$$.fragment), r = z(), fe(s.$$.fragment), a = z(), o = H("div"), fe(f.$$.fragment), c = z(), fe(l.$$.fragment), h = z(), m = H("div"), fe(v.$$.fragment), A = z(), N && N.c(), _ = z(), L && L.c(), C = Lt(), St(m, "margin-left", "auto"), V(o, "class", "button-row");
  }, m(B, u) {
    ae(e, B, u), R(B, r, u), ae(s, B, u), R(B, a, u), R(B, o, u), ae(f, o, null), q(o, c), ae(l, o, null), q(o, h), q(o, m), ae(v, m, null), R(B, A, u), N && N.m(B, u), R(B, _, u), L && L.m(B, u), R(B, C, u), I = true;
  }, p(B, u) {
    const p = {};
    !n && u & 2 && (n = true, p.value = B[1], qe(() => n = false)), e.$set(p);
    const d = {};
    !i && u & 1 && (i = true, d.value = B[0], qe(() => i = false)), s.$set(d);
    const y = {};
    u & 2048 && (y.$$scope = { dirty: u, ctx: B }), f.$set(y);
    const w = {};
    u & 2048 && (w.$$scope = { dirty: u, ctx: B }), l.$set(w);
    const E = {};
    !b && u & 4 && (b = true, E.checked = B[2], qe(() => b = false)), v.$set(E), B[4] ? N ? N.p(B, u) : (N = pB(B), N.c(), N.m(_.parentNode, _)) : N && (N.d(1), N = null), B[3] ? L ? (L.p(B, u), u & 8 && W(L, 1)) : (L = gB(B), L.c(), W(L, 1), L.m(C.parentNode, C)) : L && (Xt(), j(L, 1, 1, () => {
      L = null;
    }), er());
  }, i(B) {
    I || (W(e.$$.fragment, B), W(s.$$.fragment, B), W(f.$$.fragment, B), W(l.$$.fragment, B), W(v.$$.fragment, B), W(L), I = true);
  }, o(B) {
    j(e.$$.fragment, B), j(s.$$.fragment, B), j(f.$$.fragment, B), j(l.$$.fragment, B), j(v.$$.fragment, B), j(L), I = false;
  }, d(B) {
    B && (D(r), D(a), D(o), D(A), D(_), D(C)), oe(e, B), oe(s, B), oe(f), oe(l), oe(v), N && N.d(B), L && L.d(B);
  } };
}
function ame(t3) {
  let e, n, r, s, i, a, o, f, c;
  return { c() {
    e = H("p"), e.textContent = `RIPEMD-160 (RACE Integrity Primitives Evaluation Message Digest) is a cryptographic hash function 
    developed in 1996 by Hans Dobbertin, Antoon Bosselaers, and Bart Preneel. It was designed as a stronger 
    alternative to the original RIPEMD, which was based on the MD4 family of hash functions. RIPEMD-160 generates 
    a 160-bit hash value and is known for its strong resistance to collision and pre-image attacks.`, n = z(), r = H("p"), r.innerHTML = "<strong>Characteristics of RIPEMD-160:</strong>", s = z(), i = H("ul"), i.innerHTML = "<li>Produces a 160-bit hash value, typically represented as a 40-character hexadecimal string.</li> <li>Based on a design principle similar to MD4 and MD5 but with more robustness.</li> <li>Performs two parallel lines of computation to ensure enhanced security.</li> <li>RIPEMD-160 is slower compared to MD5 and SHA-1 but provides better security.</li>", a = z(), o = H("p"), o.textContent = `RIPEMD-160 is primarily used in cryptographic applications where higher security is needed. While it has not 
    been as widely adopted as SHA-256 or SHA-3, it remains a reliable option for applications that require a secure 
    hash function. RIPEMD-160 has been successfully used in cryptocurrency protocols, such as Bitcoin, to generate 
    public key hashes.`, f = z(), c = H("p"), c.textContent = `Despite being secure, newer hash functions like SHA-256 are generally preferred today due to better overall 
    support and integration in modern security systems.`;
  }, m(l, h) {
    R(l, e, h), R(l, n, h), R(l, r, h), R(l, s, h), R(l, i, h), R(l, a, h), R(l, o, h), R(l, f, h), R(l, c, h);
  }, p: dt, d(l) {
    l && (D(e), D(n), D(r), D(s), D(i), D(a), D(o), D(f), D(c));
  } };
}
function ome(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "RIPEMD-160 (RACE Integrity Primitives Evaluation Message Digest)", $$slots: { default: [sme] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About RIPEMD-160", links: t3[6], $$slots: { default: [ame] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 2079 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 2048 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
const fme = (t3) => t3.value;
function lme(t3, e, n) {
  let r = "", s = "utf-8", i = null, a = "", o = true;
  function f() {
    if (!r) {
      n(3, i = null), n(4, a = "");
      return;
    }
    n(4, a = ""), n(3, i = null);
    try {
      n(3, i = rme(r, s));
    } catch (b) {
      n(4, a = b.message);
    }
  }
  const c = [{ text: "@noble/hashes NPM", url: "https://www.npmjs.com/package/@noble/hashes" }, { text: "RIPEMD - Wikipedia", url: "https://en.wikipedia.org/wiki/RIPEMD" }];
  function l(b) {
    s = b, n(1, s);
  }
  function h(b) {
    r = b, n(0, r);
  }
  const m = () => {
    n(0, r = ""), n(3, i = null);
  };
  function v(b) {
    o = b, n(2, o);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 7 && o && (r || s) && f();
  }, [r, s, o, i, a, f, c, l, h, m, v];
}
class ume extends xt {
  constructor(e) {
    super(), wt(this, e, lme, ome, At, {});
  }
}
const cme = { "Keccak-224": jpe, "Keccak-256": Xpe, "Keccak-384": e1e, "Keccak-512": t1e };
function hme(t3, e, n = "utf-8") {
  if (!t3) throw new Error("Please enter some text.");
  const r = cme[e];
  if (!r) throw new Error(`Algorithm ${e} is not supported.`);
  let s;
  try {
    s = ps(t3, n);
  } catch (f) {
    throw new Error(f.message);
  }
  const i = r(s), a = Al(i), o = btoa(String.fromCharCode(...i));
  return { hex: a, base64: o, bitLength: i.length * 8 };
}
function dme(t3) {
  let e;
  return { c() {
    e = we("Generate Hash");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function pme(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function mB(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[5]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 32 && Ze(n, r[5]);
  }, d(r) {
    r && D(e);
  } };
}
function vB(t3) {
  let e, n, r, s;
  return e = new et({ props: { label: "Hex Digest (" + t3[4].bitLength + " bits):", value: t3[4].hex, readonly: true, expandable: false, withCopy: true } }), r = new et({ props: { label: "Base64 Digest:", value: t3[4].base64, readonly: true, expandable: false, withCopy: true } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, a) {
    const o = {};
    a & 16 && (o.label = "Hex Digest (" + i[4].bitLength + " bits):"), a & 16 && (o.value = i[4].hex), e.$set(o);
    const f = {};
    a & 16 && (f.value = i[4].base64), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function gme(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U;
  function Q(E) {
    t3[9](E);
  }
  let P = { label: "Variant:", options: t3[6] };
  t3[3] !== void 0 && (P.value = t3[3]), n = new Ht({ props: P }), Qe.push(() => ze(n, "value", Q));
  function N(E) {
    t3[10](E);
  }
  let L = { label: "Input Encoding:", options: gs.map(yme) };
  t3[1] !== void 0 && (L.value = t3[1]), i = new Ht({ props: L }), Qe.push(() => ze(i, "value", N));
  function B(E) {
    t3[11](E);
  }
  let u = { label: "Input Data:", expandable: true, placeholder: t3[1] === "hex" ? "e.g. 4a 1b..." : "Type text here..." };
  t3[0] !== void 0 && (u.value = t3[0]), f = new et({ props: u }), Qe.push(() => ze(f, "value", B)), m = new ut({ props: { $$slots: { default: [dme] }, $$scope: { ctx: t3 } } }), m.$on("click", t3[7]), b = new ut({ props: { variant: "secondary", $$slots: { default: [pme] }, $$scope: { ctx: t3 } } }), b.$on("click", t3[12]);
  function p(E) {
    t3[13](E);
  }
  let d = {};
  t3[2] !== void 0 && (d.checked = t3[2]), C = new xr({ props: d }), Qe.push(() => ze(C, "checked", p));
  let y = t3[5] && mB(t3), w = t3[4] && vB(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), fe(i.$$.fragment), o = z(), fe(f.$$.fragment), l = z(), h = H("div"), fe(m.$$.fragment), v = z(), fe(b.$$.fragment), A = z(), _ = H("div"), fe(C.$$.fragment), S = z(), y && y.c(), $ = z(), w && w.c(), F = Lt(), V(e, "class", "controls-row"), St(_, "margin-left", "auto"), V(h, "class", "button-row");
  }, m(E, M) {
    R(E, e, M), ae(n, e, null), q(e, s), ae(i, e, null), R(E, o, M), ae(f, E, M), R(E, l, M), R(E, h, M), ae(m, h, null), q(h, v), ae(b, h, null), q(h, A), q(h, _), ae(C, _, null), R(E, S, M), y && y.m(E, M), R(E, $, M), w && w.m(E, M), R(E, F, M), U = true;
  }, p(E, M) {
    const x = {};
    !r && M & 8 && (r = true, x.value = E[3], qe(() => r = false)), n.$set(x);
    const g = {};
    !a && M & 2 && (a = true, g.value = E[1], qe(() => a = false)), i.$set(g);
    const k = {};
    M & 2 && (k.placeholder = E[1] === "hex" ? "e.g. 4a 1b..." : "Type text here..."), !c && M & 1 && (c = true, k.value = E[0], qe(() => c = false)), f.$set(k);
    const T = {};
    M & 16384 && (T.$$scope = { dirty: M, ctx: E }), m.$set(T);
    const O = {};
    M & 16384 && (O.$$scope = { dirty: M, ctx: E }), b.$set(O);
    const K = {};
    !I && M & 4 && (I = true, K.checked = E[2], qe(() => I = false)), C.$set(K), E[5] ? y ? y.p(E, M) : (y = mB(E), y.c(), y.m($.parentNode, $)) : y && (y.d(1), y = null), E[4] ? w ? (w.p(E, M), M & 16 && W(w, 1)) : (w = vB(E), w.c(), W(w, 1), w.m(F.parentNode, F)) : w && (Xt(), j(w, 1, 1, () => {
      w = null;
    }), er());
  }, i(E) {
    U || (W(n.$$.fragment, E), W(i.$$.fragment, E), W(f.$$.fragment, E), W(m.$$.fragment, E), W(b.$$.fragment, E), W(C.$$.fragment, E), W(w), U = true);
  }, o(E) {
    j(n.$$.fragment, E), j(i.$$.fragment, E), j(f.$$.fragment, E), j(m.$$.fragment, E), j(b.$$.fragment, E), j(C.$$.fragment, E), j(w), U = false;
  }, d(E) {
    E && (D(e), D(o), D(l), D(h), D(S), D($), D(F)), oe(n), oe(i), oe(f, E), oe(m), oe(b), oe(C), y && y.d(E), w && w.d(E);
  } };
}
function mme(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m;
  return { c() {
    e = H("p"), e.innerHTML = `Keccak is a family of cryptographic hash functions and the basis of the SHA-3 standard. It&#39;s widely known for its use in 
    <strong>Ethereum</strong> and other blockchain technologies.`, n = z(), r = H("p"), r.innerHTML = `<strong>Important Distinction:</strong> Although Keccak won the competition to become SHA-3, the final NIST standard (SHA3-256) 
        changed the padding slightly. Therefore, <strong>Keccak-256 \u2260 SHA3-256</strong>. This tool generates the original Keccak hash 
        used by Ethereum (eth_hash).`, s = z(), i = H("p"), i.textContent = `This tool allows you to generate Keccak hashes of input text using various digest lengths: 
        224, 256, 384, or 512 bits.`, a = z(), o = H("b"), o.textContent = "Features:", f = z(), c = H("ul"), c.innerHTML = "<li>Choose your preferred hash bit length</li> <li>Support for legacy text encodings (Windows, ISO, Mac)</li> <li>View the resulting hash in Base64 and hexadecimal.</li>", l = we(`
        Use this tool for educational purposes or verifying data integrity.`), h = H("br"), m = H("br");
  }, m(v, b) {
    R(v, e, b), R(v, n, b), R(v, r, b), R(v, s, b), R(v, i, b), R(v, a, b), R(v, o, b), R(v, f, b), R(v, c, b), R(v, l, b), R(v, h, b), R(v, m, b);
  }, p: dt, d(v) {
    v && (D(e), D(n), D(r), D(s), D(i), D(a), D(o), D(f), D(c), D(l), D(h), D(m));
  } };
}
function vme(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Keccak", $$slots: { default: [gme] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Keccak", links: t3[8], $$slots: { default: [mme] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 16447 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 16384 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
const yme = (t3) => t3.value;
function bme(t3, e, n) {
  let r = "", s = "Keccak-256", i = "utf-8", a = null, o = "", f = true;
  const c = ["Keccak-224", "Keccak-256", "Keccak-384", "Keccak-512"];
  function l() {
    if (!r) {
      n(4, a = null), n(5, o = "");
      return;
    }
    n(5, o = ""), n(4, a = null);
    try {
      n(4, a = hme(r, s, i));
    } catch (C) {
      n(5, o = C.message);
    }
  }
  const h = [{ text: "@noble/hashes NPM", url: "https://www.npmjs.com/package/@noble/hashes" }, { text: "Keccak Team", url: "https://keccak.team/keccak.html" }];
  function m(C) {
    s = C, n(3, s);
  }
  function v(C) {
    i = C, n(1, i);
  }
  function b(C) {
    r = C, n(0, r);
  }
  const A = () => {
    n(0, r = ""), n(4, a = null);
  };
  function _(C) {
    f = C, n(2, f);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 7 && f && (r || i) && l();
  }, [r, i, f, s, a, o, c, l, h, m, v, b, A, _];
}
class Ame extends xt {
  constructor(e) {
    super(), wt(this, e, bme, vme, At, {});
  }
}
async function wme(t3, e = "utf-8") {
  if (!t3) throw new Error("Please enter some text.");
  let n;
  try {
    n = ps(t3, e);
  } catch (i) {
    throw new Error(i.message);
  }
  const r = await Pge(n), s = xme(r);
  return { hex: r, base64: s, bitLength: 512 };
}
function xme(t3) {
  const e = t3.match(/\w{2}/g), n = function* () {
    for (; e.length >= 1; ) yield parseInt(e.shift(), 16);
  }();
  return btoa(String.fromCharCode(...n));
}
function _me(t3) {
  let e = t3[5] ? "Hashing..." : "Generate Hash", n;
  return { c() {
    n = we(e);
  }, m(r, s) {
    R(r, n, s);
  }, p(r, s) {
    s & 32 && e !== (e = r[5] ? "Hashing..." : "Generate Hash") && Ze(n, e);
  }, d(r) {
    r && D(n);
  } };
}
function Eme(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function yB(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[4]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 16 && Ze(n, r[4]);
  }, d(r) {
    r && D(e);
  } };
}
function bB(t3) {
  let e, n, r, s;
  return e = new et({ props: { label: "Hex digest:", value: t3[3].hex, readonly: true, expandable: true, withCopy: true } }), r = new et({ props: { label: "Base64 digest:", value: t3[3].base64, readonly: true, expandable: true, withCopy: true } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, a) {
    const o = {};
    a & 8 && (o.value = i[3].hex), e.$set(o);
    const f = {};
    a & 8 && (f.value = i[3].base64), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function Bme(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S;
  function $(u) {
    t3[8](u);
  }
  let F = { label: "Input Encoding:", options: gs.map(Ime) };
  t3[1] !== void 0 && (F.value = t3[1]), n = new Ht({ props: F }), Qe.push(() => ze(n, "value", $));
  function U(u) {
    t3[9](u);
  }
  let Q = { label: "Input Data:", expandable: true, placeholder: t3[1] === "hex" ? "e.g. 4a 1b..." : "Type text here..." };
  t3[0] !== void 0 && (Q.value = t3[0]), i = new et({ props: Q }), Qe.push(() => ze(i, "value", U)), c = new ut({ props: { disabled: t3[5], $$slots: { default: [_me] }, $$scope: { ctx: t3 } } }), c.$on("click", t3[6]), h = new ut({ props: { variant: "secondary", $$slots: { default: [Eme] }, $$scope: { ctx: t3 } } }), h.$on("click", t3[10]);
  function P(u) {
    t3[11](u);
  }
  let N = {};
  t3[2] !== void 0 && (N.checked = t3[2]), b = new xr({ props: N }), Qe.push(() => ze(b, "checked", P));
  let L = t3[4] && yB(t3), B = t3[3] && bB(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), fe(i.$$.fragment), o = z(), f = H("div"), fe(c.$$.fragment), l = z(), fe(h.$$.fragment), m = z(), v = H("div"), fe(b.$$.fragment), _ = z(), L && L.c(), C = z(), B && B.c(), I = Lt(), V(e, "class", "controls-row"), St(v, "margin-left", "auto"), V(f, "class", "button-row");
  }, m(u, p) {
    R(u, e, p), ae(n, e, null), R(u, s, p), ae(i, u, p), R(u, o, p), R(u, f, p), ae(c, f, null), q(f, l), ae(h, f, null), q(f, m), q(f, v), ae(b, v, null), R(u, _, p), L && L.m(u, p), R(u, C, p), B && B.m(u, p), R(u, I, p), S = true;
  }, p(u, p) {
    const d = {};
    !r && p & 2 && (r = true, d.value = u[1], qe(() => r = false)), n.$set(d);
    const y = {};
    p & 2 && (y.placeholder = u[1] === "hex" ? "e.g. 4a 1b..." : "Type text here..."), !a && p & 1 && (a = true, y.value = u[0], qe(() => a = false)), i.$set(y);
    const w = {};
    p & 32 && (w.disabled = u[5]), p & 4128 && (w.$$scope = { dirty: p, ctx: u }), c.$set(w);
    const E = {};
    p & 4096 && (E.$$scope = { dirty: p, ctx: u }), h.$set(E);
    const M = {};
    !A && p & 4 && (A = true, M.checked = u[2], qe(() => A = false)), b.$set(M), u[4] ? L ? L.p(u, p) : (L = yB(u), L.c(), L.m(C.parentNode, C)) : L && (L.d(1), L = null), u[3] ? B ? (B.p(u, p), p & 8 && W(B, 1)) : (B = bB(u), B.c(), W(B, 1), B.m(I.parentNode, I)) : B && (Xt(), j(B, 1, 1, () => {
      B = null;
    }), er());
  }, i(u) {
    S || (W(n.$$.fragment, u), W(i.$$.fragment, u), W(c.$$.fragment, u), W(h.$$.fragment, u), W(b.$$.fragment, u), W(B), S = true);
  }, o(u) {
    j(n.$$.fragment, u), j(i.$$.fragment, u), j(c.$$.fragment, u), j(h.$$.fragment, u), j(b.$$.fragment, u), j(B), S = false;
  }, d(u) {
    u && (D(e), D(s), D(o), D(f), D(_), D(C), D(I)), oe(n), oe(i, u), oe(c), oe(h), oe(b), L && L.d(u), B && B.d(u);
  } };
}
function Cme(t3) {
  let e, n, r, s, i, a, o;
  return { c() {
    e = H("p"), e.innerHTML = `<strong>Whirlpool</strong> is a cryptographic hash function designed by Vincent Rijmen and Paulo Barreto. 
    It produces a fixed <strong>512-bit (64-byte)</strong> hash value, making it comparable to SHA-512 in terms of output size.`, n = z(), r = H("p"), r.innerHTML = "<strong>Key Characteristics:</strong>", s = z(), i = H("ul"), i.innerHTML = `<li>It uses a modified version of the Advanced Encryption Standard (AES) block cipher logic. 
      Specifically, it uses a 512-bit block size rather than AES&#39;s 128-bit size.</li> <li>It is part of the ISO/IEC 10118-3 standard and is completely free of patents.</li> <li><strong>Security:</strong> Whirlpool is considered highly secure. It has not been broken by any practical attack, 
      and its large 512-bit output makes it extremely resistant to collision attacks (birthday paradox).</li>`, a = z(), o = H("p"), o.textContent = "It is often used in combination with other hashes in software like VeraCrypt for key derivation.";
  }, m(f, c) {
    R(f, e, c), R(f, n, c), R(f, r, c), R(f, s, c), R(f, i, c), R(f, a, c), R(f, o, c);
  }, p: dt, d(f) {
    f && (D(e), D(n), D(r), D(s), D(i), D(a), D(o));
  } };
}
function kme(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Whirlpool hash function", $$slots: { default: [Bme] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Whirlpool", links: t3[7], $$slots: { default: [Cme] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 4159 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 4096 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
const Ime = (t3) => t3.value;
function Sme(t3, e, n) {
  let r = "", s = "utf-8", i = null, a = "", o = false, f = true;
  async function c() {
    if (!r) {
      n(3, i = null), n(4, a = "");
      return;
    }
    n(4, a = ""), n(5, o = true);
    try {
      n(3, i = await wme(r, s));
    } catch (A) {
      n(4, a = A.message);
    } finally {
      n(5, o = false);
    }
  }
  const l = [{ text: "NPM: hash-wasm", url: "https://www.npmjs.com/package/hash-wasm" }, { text: "Wikipedia: Whirlpool", url: "https://en.wikipedia.org/wiki/Whirlpool_(hash_function)" }];
  function h(A) {
    s = A, n(1, s);
  }
  function m(A) {
    r = A, n(0, r);
  }
  const v = () => {
    n(0, r = ""), n(3, i = null);
  };
  function b(A) {
    f = A, n(2, f);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 7 && f && (r || s) && c();
  }, [r, s, f, i, a, o, c, l, h, m, v, b];
}
class Mme extends xt {
  constructor(e) {
    super(), wt(this, e, Sme, kme, At, {});
  }
}
const $me = { SHAKE128: r1e, SHAKE256: n1e };
function Tme(t3, e, n = 256, r = "utf-8") {
  if (!t3) throw new Error("Please enter some text.");
  const s = Number(n);
  if (isNaN(s) || s <= 0) throw new Error("Output bit length must be a positive number.");
  if (s % 8 !== 0) throw new Error("Output bit length must be a multiple of 8.");
  const i = $me[e];
  if (!i) throw new Error(`Algorithm ${e} is not supported.`);
  let a;
  try {
    a = ps(t3, r);
  } catch (h) {
    throw new Error(h.message);
  }
  const o = s / 8, f = i(a, { dkLen: o }), c = Al(f), l = btoa(String.fromCharCode(...f));
  return { hex: c, base64: l, actualBits: f.length * 8 };
}
function Dme(t3) {
  let e;
  return { c() {
    e = we("Generate Hash");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function Rme(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function AB(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[6]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 64 && Ze(n, r[6]);
  }, d(r) {
    r && D(e);
  } };
}
function wB(t3) {
  let e, n, r, s;
  return e = new et({ props: { label: t3[1] + " Hex (" + t3[5].actualBits + " bits):", value: t3[5].hex, readonly: true, expandable: true, withCopy: true } }), r = new et({ props: { label: t3[1] + " Base64:", value: t3[5].base64, readonly: true, expandable: true, withCopy: true } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, a) {
    const o = {};
    a & 34 && (o.label = i[1] + " Hex (" + i[5].actualBits + " bits):"), a & 32 && (o.value = i[5].hex), e.$set(o);
    const f = {};
    a & 2 && (f.label = i[1] + " Base64:"), a & 32 && (f.value = i[5].base64), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function Fme(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U, Q, P, N;
  function L(T) {
    t3[10](T);
  }
  let B = { label: "Algorithm:", options: t3[7] };
  t3[1] !== void 0 && (B.value = t3[1]), n = new Ht({ props: B }), Qe.push(() => ze(n, "value", L));
  function u(T) {
    t3[11](T);
  }
  let p = { label: "Input Encoding:", options: gs.map(Ume) };
  t3[2] !== void 0 && (p.value = t3[2]), i = new Ht({ props: p }), Qe.push(() => ze(i, "value", u));
  function d(T) {
    t3[12](T);
  }
  let y = { label: "Output Bits:", suffix: "Bits", min: "8", step: "8" };
  t3[3] !== void 0 && (y.value = t3[3]), f = new U4({ props: y }), Qe.push(() => ze(f, "value", d)), f.$on("input", t3[13]);
  function w(T) {
    t3[14](T);
  }
  let E = { label: "Input Data:", placeholder: t3[2] === "hex" ? "e.g. 4a 1b..." : "Type text here...", expandable: true };
  t3[0] !== void 0 && (E.value = t3[0]), h = new et({ props: E }), Qe.push(() => ze(h, "value", w)), A = new ut({ props: { $$slots: { default: [Dme] }, $$scope: { ctx: t3 } } }), A.$on("click", t3[8]), C = new ut({ props: { variant: "secondary", $$slots: { default: [Rme] }, $$scope: { ctx: t3 } } }), C.$on("click", t3[15]);
  function M(T) {
    t3[16](T);
  }
  let x = {};
  t3[4] !== void 0 && (x.checked = t3[4]), $ = new xr({ props: x }), Qe.push(() => ze($, "checked", M));
  let g = t3[6] && AB(t3), k = t3[5] && wB(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), fe(i.$$.fragment), o = z(), fe(f.$$.fragment), l = z(), fe(h.$$.fragment), v = z(), b = H("div"), fe(A.$$.fragment), _ = z(), fe(C.$$.fragment), I = z(), S = H("div"), fe($.$$.fragment), U = z(), g && g.c(), Q = z(), k && k.c(), P = Lt(), V(e, "class", "controls-row"), St(S, "margin-left", "auto"), V(b, "class", "button-row");
  }, m(T, O) {
    R(T, e, O), ae(n, e, null), q(e, s), ae(i, e, null), R(T, o, O), ae(f, T, O), R(T, l, O), ae(h, T, O), R(T, v, O), R(T, b, O), ae(A, b, null), q(b, _), ae(C, b, null), q(b, I), q(b, S), ae($, S, null), R(T, U, O), g && g.m(T, O), R(T, Q, O), k && k.m(T, O), R(T, P, O), N = true;
  }, p(T, O) {
    const K = {};
    !r && O & 2 && (r = true, K.value = T[1], qe(() => r = false)), n.$set(K);
    const Y = {};
    !a && O & 4 && (a = true, Y.value = T[2], qe(() => a = false)), i.$set(Y);
    const J = {};
    !c && O & 8 && (c = true, J.value = T[3], qe(() => c = false)), f.$set(J);
    const G = {};
    O & 4 && (G.placeholder = T[2] === "hex" ? "e.g. 4a 1b..." : "Type text here..."), !m && O & 1 && (m = true, G.value = T[0], qe(() => m = false)), h.$set(G);
    const X = {};
    O & 131072 && (X.$$scope = { dirty: O, ctx: T }), A.$set(X);
    const ie = {};
    O & 131072 && (ie.$$scope = { dirty: O, ctx: T }), C.$set(ie);
    const de = {};
    !F && O & 16 && (F = true, de.checked = T[4], qe(() => F = false)), $.$set(de), T[6] ? g ? g.p(T, O) : (g = AB(T), g.c(), g.m(Q.parentNode, Q)) : g && (g.d(1), g = null), T[5] ? k ? (k.p(T, O), O & 32 && W(k, 1)) : (k = wB(T), k.c(), W(k, 1), k.m(P.parentNode, P)) : k && (Xt(), j(k, 1, 1, () => {
      k = null;
    }), er());
  }, i(T) {
    N || (W(n.$$.fragment, T), W(i.$$.fragment, T), W(f.$$.fragment, T), W(h.$$.fragment, T), W(A.$$.fragment, T), W(C.$$.fragment, T), W($.$$.fragment, T), W(k), N = true);
  }, o(T) {
    j(n.$$.fragment, T), j(i.$$.fragment, T), j(f.$$.fragment, T), j(h.$$.fragment, T), j(A.$$.fragment, T), j(C.$$.fragment, T), j($.$$.fragment, T), j(k), N = false;
  }, d(T) {
    T && (D(e), D(o), D(l), D(v), D(b), D(U), D(Q), D(P)), oe(n), oe(i), oe(f, T), oe(h, T), oe(A), oe(C), oe($), g && g.d(T), k && k.d(T);
  } };
}
function Pme(t3) {
  let e, n, r, s, i, a, o, f, c;
  return { c() {
    e = H("p"), e.textContent = `SHAKE is a cryptographic hash function based on the Keccak family. 
    It is designed to be secure and efficient, providing variable-length output.
    SHAKE supports two main variants: SHAKE128 and SHAKE256, which differ in their security levels and output lengths.
    SHAKE is widely used in various applications, including digital signatures, message authentication codes, 
    and key derivation functions, due to its flexibility and security properties.`, n = z(), r = H("p"), r.innerHTML = `<strong>XOF (Extensible Output Function):</strong>
    Standard hashes (like SHA-256) have a fixed length. You can turn it on and squeeze out as many 
    bits as you need. You can generate a 128-bit hash, a 512-bit hash, or even a 10,000-bit stream from the same input.`, s = z(), i = H("p"), i.innerHTML = "<strong>SHAKE128 vs SHAKE256:</strong>", a = z(), o = H("ul"), o.innerHTML = "<li>These numbers refer to the <strong>security strength</strong>, not the output length.</li> <li><strong>SHAKE128</strong> provides 128 bits of security against collisions (roughly equivalent to SHA-256).</li> <li><strong>SHAKE256</strong> provides 256 bits of security (roughly equivalent to SHA-512).</li>", f = z(), c = H("p"), c.textContent = "SHAKE is widely used in newer cryptographic protocols, such as Post-Quantum Cryptography (Kyber, Dilithium), because of its versatility.";
  }, m(l, h) {
    R(l, e, h), R(l, n, h), R(l, r, h), R(l, s, h), R(l, i, h), R(l, a, h), R(l, o, h), R(l, f, h), R(l, c, h);
  }, p: dt, d(l) {
    l && (D(e), D(n), D(r), D(s), D(i), D(a), D(o), D(f), D(c));
  } };
}
function Nme(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "SHAKE hash", $$slots: { default: [Fme] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About SHAKE", links: t3[9], $$slots: { default: [Pme] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 131199 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 131072 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
const Ume = (t3) => t3.value;
function Lme(t3, e, n) {
  let r = "", s = "SHAKE128", i = "utf-8", a = 256, o = null, f = "", c = true;
  const l = ["SHAKE128", "SHAKE256"];
  function h() {
    if (!r) {
      n(5, o = null), n(6, f = "");
      return;
    }
    n(6, f = ""), n(5, o = null);
    try {
      n(5, o = Tme(r, s, a, i));
    } catch ($) {
      n(6, f = $.message);
    }
  }
  const m = [{ text: "@noble/hashes NPM", url: "https://www.npmjs.com/package/@noble/hashes" }, { text: "SHA-3 / SHAKE Standard (NIST)", url: "https://csrc.nist.gov/pubs/fips/202/final" }, { text: "Wikipedia: SHA-3", url: "https://en.wikipedia.org/wiki/SHA-3#Instances" }];
  function v($) {
    s = $, n(1, s);
  }
  function b($) {
    i = $, n(2, i);
  }
  function A($) {
    a = $, n(3, a);
  }
  const _ = () => {
    c && h();
  };
  function C($) {
    r = $, n(0, r);
  }
  const I = () => {
    n(0, r = ""), n(5, o = null);
  };
  function S($) {
    c = $, n(4, c);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 31 && c && (r || s || i || a) && h();
  }, [r, s, i, a, c, o, f, l, h, m, v, b, A, _, C, I, S];
}
class Ome extends xt {
  constructor(e) {
    super(), wt(this, e, Lme, Nme, At, {});
  }
}
const j1 = BigInt(8), xB = BigInt(255);
function Ey(t3) {
  t3 = BigInt(t3);
  const e = [Number(t3 & xB)];
  for (t3 >>= j1; t3 > 0; t3 >>= j1) e.unshift(Number(t3 & xB));
  return e.unshift(e.length), new Uint8Array(e);
}
function Qme(t3, e) {
  return t3.dkLen === void 0 ? e : t3.dkLen;
}
const _B = (t3) => t3 === void 0 ? Uint8Array.of() : rs(t3), Kme = (t3, e) => new Uint8Array((e - t3 % e) % e);
function Hme(t3, e = {}) {
  if (!e || !e.personalization && !e.NISTfn) return t3;
  const n = Ey(t3.blockLen), r = _B(e.NISTfn), s = Ey(j1 * BigInt(r.length)), i = _B(e.personalization), a = Ey(j1 * BigInt(i.length));
  if (!r.length && !i.length) return t3;
  t3.suffix = 4, t3.update(n).update(s).update(r).update(a).update(i);
  let o = n.length + s.length + r.length + a.length + i.length;
  return t3.update(Kme(o, t3.blockLen)), t3;
}
const JF = (t3, e, n) => N4((r = {}) => Hme(new K4(e, t3, Qme(r, n), true), r)), qme = JF(31, 168, 128 / 8), zme = JF(31, 136, 256 / 8), Gme = { cSHAKE128: qme, cSHAKE256: zme };
function Vme(t3, e, n = 256, r = "utf-8", s = "", i = "") {
  if (!t3) throw new Error("Please enter some text.");
  const a = Number(n);
  if (isNaN(a) || a <= 0) throw new Error("Output bit length must be positive.");
  if (a % 8 !== 0) throw new Error("Output bit length must be a multiple of 8.");
  const o = Gme[e];
  if (!o) throw new Error(`Algorithm ${e} is not supported.`);
  let f;
  try {
    f = ps(t3, r);
  } catch (C) {
    throw new Error(C.message);
  }
  const c = a / 8, l = new TextEncoder(), h = s ? l.encode(s) : new Uint8Array(0), m = i ? l.encode(i) : new Uint8Array(0), b = o(f, { dkLen: c, personalization: h, NISTfn: m }), A = Al(b), _ = btoa(String.fromCharCode(...b));
  return { hex: A, base64: _, actualBits: b.length * 8 };
}
function Yme(t3) {
  let e;
  return { c() {
    e = we("Generate Hash");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function Wme(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function EB(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[8]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 256 && Ze(n, r[8]);
  }, d(r) {
    r && D(e);
  } };
}
function BB(t3) {
  let e, n, r, s;
  return e = new et({ props: { label: t3[1] + " Hex:", value: t3[7].hex, readonly: true, expandable: true, withCopy: true } }), r = new et({ props: { label: t3[1] + " Base64:", value: t3[7].base64, readonly: true, expandable: true, withCopy: true } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, a) {
    const o = {};
    a & 2 && (o.label = i[1] + " Hex:"), a & 128 && (o.value = i[7].hex), e.$set(o);
    const f = {};
    a & 2 && (f.label = i[1] + " Base64:"), a & 128 && (f.value = i[7].base64), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function Jme(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U, Q, P, N, L, B, u, p, d, y, w;
  function E(le) {
    t3[12](le);
  }
  let M = { label: "Algorithm:", options: t3[9] };
  t3[1] !== void 0 && (M.value = t3[1]), n = new Ht({ props: M }), Qe.push(() => ze(n, "value", E));
  function x(le) {
    t3[13](le);
  }
  let g = { label: "Input Encoding:", options: gs.map(Xme) };
  t3[2] !== void 0 && (g.value = t3[2]), i = new Ht({ props: g }), Qe.push(() => ze(i, "value", x));
  function k(le) {
    t3[14](le);
  }
  let T = { label: "Customization string (S):", expandable: true, placeholder: t3[2] === "hex" ? "e.g. 4a 1b..." : "e.g. MyAppv1" };
  t3[4] !== void 0 && (T.value = t3[4]), c = new et({ props: T }), Qe.push(() => ze(c, "value", k));
  function O(le) {
    t3[15](le);
  }
  let K = { label: "Function Name (N):", expandable: true, placeholder: t3[2] === "hex" ? "e.g. 4a 1b..." : "Optional" };
  t3[5] !== void 0 && (K.value = t3[5]), m = new et({ props: K }), Qe.push(() => ze(m, "value", O));
  function Y(le) {
    t3[16](le);
  }
  let J = { label: "Output Bits:", suffix: "Bits", min: "8", step: "8" };
  t3[3] !== void 0 && (J.value = t3[3]), A = new U4({ props: J }), Qe.push(() => ze(A, "value", Y)), A.$on("input", t3[17]);
  function G(le) {
    t3[18](le);
  }
  let X = { label: "Input Data:", placeholder: t3[2] === "hex" ? "e.g. 4a 1b..." : "Type text here...", expandable: true };
  t3[0] !== void 0 && (X.value = t3[0]), I = new et({ props: X }), Qe.push(() => ze(I, "value", G)), U = new ut({ props: { $$slots: { default: [Yme] }, $$scope: { ctx: t3 } } }), U.$on("click", t3[10]), P = new ut({ props: { variant: "secondary", $$slots: { default: [Wme] }, $$scope: { ctx: t3 } } }), P.$on("click", t3[19]);
  function ie(le) {
    t3[20](le);
  }
  let de = {};
  t3[6] !== void 0 && (de.checked = t3[6]), B = new xr({ props: de }), Qe.push(() => ze(B, "checked", ie));
  let se = t3[8] && EB(t3), te = t3[7] && BB(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), fe(i.$$.fragment), o = z(), f = H("div"), fe(c.$$.fragment), h = z(), fe(m.$$.fragment), b = z(), fe(A.$$.fragment), C = z(), fe(I.$$.fragment), $ = z(), F = H("div"), fe(U.$$.fragment), Q = z(), fe(P.$$.fragment), N = z(), L = H("div"), fe(B.$$.fragment), p = z(), se && se.c(), d = z(), te && te.c(), y = Lt(), V(e, "class", "controls-row"), V(f, "class", "controls-row"), St(L, "margin-left", "auto"), V(F, "class", "button-row");
  }, m(le, Z) {
    R(le, e, Z), ae(n, e, null), q(e, s), ae(i, e, null), R(le, o, Z), R(le, f, Z), ae(c, f, null), q(f, h), ae(m, f, null), R(le, b, Z), ae(A, le, Z), R(le, C, Z), ae(I, le, Z), R(le, $, Z), R(le, F, Z), ae(U, F, null), q(F, Q), ae(P, F, null), q(F, N), q(F, L), ae(B, L, null), R(le, p, Z), se && se.m(le, Z), R(le, d, Z), te && te.m(le, Z), R(le, y, Z), w = true;
  }, p(le, Z) {
    const ve = {};
    !r && Z & 2 && (r = true, ve.value = le[1], qe(() => r = false)), n.$set(ve);
    const he = {};
    !a && Z & 4 && (a = true, he.value = le[2], qe(() => a = false)), i.$set(he);
    const me = {};
    Z & 4 && (me.placeholder = le[2] === "hex" ? "e.g. 4a 1b..." : "e.g. MyAppv1"), !l && Z & 16 && (l = true, me.value = le[4], qe(() => l = false)), c.$set(me);
    const ce = {};
    Z & 4 && (ce.placeholder = le[2] === "hex" ? "e.g. 4a 1b..." : "Optional"), !v && Z & 32 && (v = true, ce.value = le[5], qe(() => v = false)), m.$set(ce);
    const ye = {};
    !_ && Z & 8 && (_ = true, ye.value = le[3], qe(() => _ = false)), A.$set(ye);
    const Oe = {};
    Z & 4 && (Oe.placeholder = le[2] === "hex" ? "e.g. 4a 1b..." : "Type text here..."), !S && Z & 1 && (S = true, Oe.value = le[0], qe(() => S = false)), I.$set(Oe);
    const Se = {};
    Z & 2097152 && (Se.$$scope = { dirty: Z, ctx: le }), U.$set(Se);
    const Ce = {};
    Z & 2097152 && (Ce.$$scope = { dirty: Z, ctx: le }), P.$set(Ce);
    const Ne = {};
    !u && Z & 64 && (u = true, Ne.checked = le[6], qe(() => u = false)), B.$set(Ne), le[8] ? se ? se.p(le, Z) : (se = EB(le), se.c(), se.m(d.parentNode, d)) : se && (se.d(1), se = null), le[7] ? te ? (te.p(le, Z), Z & 128 && W(te, 1)) : (te = BB(le), te.c(), W(te, 1), te.m(y.parentNode, y)) : te && (Xt(), j(te, 1, 1, () => {
      te = null;
    }), er());
  }, i(le) {
    w || (W(n.$$.fragment, le), W(i.$$.fragment, le), W(c.$$.fragment, le), W(m.$$.fragment, le), W(A.$$.fragment, le), W(I.$$.fragment, le), W(U.$$.fragment, le), W(P.$$.fragment, le), W(B.$$.fragment, le), W(te), w = true);
  }, o(le) {
    j(n.$$.fragment, le), j(i.$$.fragment, le), j(c.$$.fragment, le), j(m.$$.fragment, le), j(A.$$.fragment, le), j(I.$$.fragment, le), j(U.$$.fragment, le), j(P.$$.fragment, le), j(B.$$.fragment, le), j(te), w = false;
  }, d(le) {
    le && (D(e), D(o), D(f), D(b), D(C), D($), D(F), D(p), D(d), D(y)), oe(n), oe(i), oe(c), oe(m), oe(A, le), oe(I, le), oe(U), oe(P), oe(B), se && se.d(le), te && te.d(le);
  } };
}
function Zme(t3) {
  let e, n, r, s, i;
  return { c() {
    e = H("p"), e.innerHTML = `<strong>cSHAKE (Customizable SHAKE)</strong> is defined in NIST SP 800-185. It is identical to SHAKE, 
    but adds a mechanism to &quot;personalize&quot; the hash function using two extra strings:`, n = z(), r = H("ul"), r.innerHTML = `<li><strong>Customization String (S):</strong> A user-defined string. If you hash the text &quot;hello&quot; with S=&quot;Email&quot;, 
      you get a completely different result than hashing &quot;hello&quot; with S=&quot;Payment&quot;. This is useful for separating different parts of an application protocol.</li> <li><strong>Function Name (N):</strong> Reserved for official NIST-defined functions (like KMAC). For general use, this is usually left empty.</li>`, s = z(), i = H("p"), i.innerHTML = "<strong>Note:</strong> If both S and N are empty, cSHAKE collapses exactly into standard SHAKE.", V(i, "class", "warning");
  }, m(a, o) {
    R(a, e, o), R(a, n, o), R(a, r, o), R(a, s, o), R(a, i, o);
  }, p: dt, d(a) {
    a && (D(e), D(n), D(r), D(s), D(i));
  } };
}
function jme(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "cSHAKE", $$slots: { default: [Jme] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About cSHAKE", links: t3[11], $$slots: { default: [Zme] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 2097663 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 2097152 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
const Xme = (t3) => t3.value;
function e2e(t3, e, n) {
  let r = "", s = "cSHAKE128", i = "utf-8", a = 256, o = "", f = "", c = null, l = "", h = true;
  const m = ["cSHAKE128", "cSHAKE256"];
  function v() {
    if (!r) {
      n(7, c = null), n(8, l = "");
      return;
    }
    n(8, l = "");
    try {
      n(7, c = Vme(r, s, a, i, o, f));
    } catch (P) {
      n(8, l = P.message);
    }
  }
  const b = [{ text: "@noble/hashes NPM", url: "https://www.npmjs.com/package/@noble/hashes" }, { text: "NIST SP 800-185 (cSHAKE Spec)", url: "https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-185.pdf" }];
  function A(P) {
    s = P, n(1, s);
  }
  function _(P) {
    i = P, n(2, i);
  }
  function C(P) {
    o = P, n(4, o);
  }
  function I(P) {
    f = P, n(5, f);
  }
  function S(P) {
    a = P, n(3, a);
  }
  const $ = () => {
    h && v();
  };
  function F(P) {
    r = P, n(0, r);
  }
  const U = () => {
    n(0, r = ""), n(4, o = ""), n(5, f = ""), n(7, c = null);
  };
  function Q(P) {
    h = P, n(6, h);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 127 && h && (r || s || i || a || o || f) && v();
  }, [r, s, i, a, o, f, h, c, l, m, v, b, A, _, C, I, S, $, F, U, Q];
}
class t2e extends xt {
  constructor(e) {
    super(), wt(this, e, e2e, jme, At, {});
  }
}
function r2e(t3) {
  if (t3 < 0n) throw new Error("Negative number");
  if (t3 < 2n) return t3;
  let e = t3, n = (e + 1n) / 2n;
  for (; n < e; ) e = n, n = (e + t3 / e) / 2n;
  return e;
}
function n2e(t3, e) {
  const n = [];
  let r = t3, s = e, i = 0;
  for (; s > 0n && i < 1e4; ) {
    const a = r / s, o = r % s;
    n.push(a), r = s, s = o, i++;
  }
  return n;
}
function i2e(t3) {
  const e = [];
  let n = 1n, r = 0n, s = 0n, i = 1n;
  for (const a of t3) {
    const o = a * n + r, f = a * s + i;
    e.push({ k: o, d: f }), r = n, n = o, i = s, s = f;
  }
  return e;
}
function s2e(t3, e) {
  try {
    const n = BigInt(t3), r = BigInt(e), s = n2e(n, r), i = i2e(s);
    let a = null, o = null, f = null, c = null;
    for (const l of i) {
      const h = l.k, m = l.d;
      if (h === 0n) continue;
      const v = n * m - 1n;
      if (v % h !== 0n) continue;
      const b = v / h, A = -(r - b + 1n), _ = A * A - 4n * r;
      if (_ >= 0n) {
        const C = r2e(_);
        if (C * C === _) {
          const I = (-A + C) / 2n, S = (-A - C) / 2n;
          if (I * S === r) {
            a = m, o = b, f = I, c = S;
            break;
          }
        }
      }
    }
    return { success: !!a, continuedFractions: s.map((l) => l.toString()), convergents: i.map((l) => ({ k: l.k.toString(), d: l.d.toString() })), d: a ? a.toString() : null, phi: o ? o.toString() : null, p: f ? f.toString() : null, q: c ? c.toString() : null };
  } catch (n) {
    throw new Error(n.message || "Invalid Input");
  }
}
function CB(t3, e, n) {
  const r = t3.slice();
  return r[11] = e[n], r;
}
function a2e(t3) {
  let e;
  return { c() {
    e = we("Launch Attack");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function o2e(t3) {
  let e;
  return { c() {
    e = we("Load Example");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function f2e(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function kB(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[3]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 8 && Ze(n, r[3]);
  }, d(r) {
    r && D(e);
  } };
}
function IB(t3) {
  let e, n, r, s;
  const i = [u2e, l2e], a = [];
  function o(f, c) {
    return f[2].success ? 0 : 1;
  }
  return n = o(t3), r = a[n] = i[n](t3), { c() {
    e = H("div"), r.c(), V(e, "class", "results-area svelte-jtdcoc");
  }, m(f, c) {
    R(f, e, c), a[n].m(e, null), s = true;
  }, p(f, c) {
    let l = n;
    n = o(f), n === l ? a[n].p(f, c) : (Xt(), j(a[l], 1, 1, () => {
      a[l] = null;
    }), er(), r = a[n], r ? r.p(f, c) : (r = a[n] = i[n](f), r.c()), W(r, 1), r.m(e, null));
  }, i(f) {
    s || (W(r), s = true);
  }, o(f) {
    j(r), s = false;
  }, d(f) {
    f && D(e), a[n].d();
  } };
}
function l2e(t3) {
  let e, n, r, s;
  return r = new et({ props: { label: "Continued Fraction Expansion (Computed):", value: `[${t3[2].continuedFractions.join(", ")}]`, readonly: true } }), { c() {
    e = H("div"), e.textContent = `Attack Failed. The private key 'd' is likely not small enough for Wiener's Attack ($d > \\frac13 N^${0.25}$).`, n = z(), fe(r.$$.fragment), V(e, "class", "msg error");
  }, m(i, a) {
    R(i, e, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, a) {
    const o = {};
    a & 4 && (o.value = `[${i[2].continuedFractions.join(", ")}]`), r.$set(o);
  }, i(i) {
    s || (W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && (D(e), D(n)), oe(r, i);
  } };
}
function u2e(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U, Q;
  s = new sd({ props: { data: t3[4], zipName: "wiener_attack_results.zip", label: "Download Recovered Data" } }), o = new et({ props: { label: "Recovered Private Key (d):", value: t3[2].d, readonly: true, withCopy: true } }), c = new et({ props: { label: "Euler's Totient \u03C6(N):", value: t3[2].phi, readonly: true, withCopy: true } }), m = new et({ props: { label: "Prime Factor (p):", value: t3[2].p, readonly: true, withCopy: true } }), b = new et({ props: { label: "Prime Factor (q):", value: t3[2].q, readonly: true, withCopy: true } }), C = new et({ props: { label: "Continued Fraction Expansion [e/N]:", value: `[${t3[2].continuedFractions.join(", ")}]`, readonly: true, expandable: true, rows: 2 } });
  let P = Mr(t3[2].convergents), N = [];
  for (let L = 0; L < P.length; L += 1) N[L] = SB(CB(t3, P, L));
  return { c() {
    e = H("div"), e.innerHTML = `<strong>VULNERABILITY FOUND!</strong><br/>
                Private Key recovered successfully.`, n = z(), r = H("div"), fe(s.$$.fragment), i = z(), a = H("div"), fe(o.$$.fragment), f = z(), fe(c.$$.fragment), l = z(), h = H("div"), fe(m.$$.fragment), v = z(), fe(b.$$.fragment), A = z(), _ = H("div"), fe(C.$$.fragment), I = z(), S = H("div"), $ = H("label"), $.textContent = "Convergents Checked (k/d):", F = z(), U = H("div");
    for (let L = 0; L < N.length; L += 1) N[L].c();
    V(e, "class", "success-banner svelte-jtdcoc"), St(r, "display", "flex"), St(r, "justify-content", "center"), St(r, "margin-bottom", "1.5rem"), V(a, "class", "grid-2 svelte-jtdcoc"), V(h, "class", "grid-2 svelte-jtdcoc"), V($, "class", "svelte-jtdcoc"), V(U, "class", "tags svelte-jtdcoc"), V(S, "class", "convergents-box svelte-jtdcoc"), V(_, "class", "math-details svelte-jtdcoc");
  }, m(L, B) {
    R(L, e, B), R(L, n, B), R(L, r, B), ae(s, r, null), R(L, i, B), R(L, a, B), ae(o, a, null), q(a, f), ae(c, a, null), R(L, l, B), R(L, h, B), ae(m, h, null), q(h, v), ae(b, h, null), R(L, A, B), R(L, _, B), ae(C, _, null), q(_, I), q(_, S), q(S, $), q(S, F), q(S, U);
    for (let u = 0; u < N.length; u += 1) N[u] && N[u].m(U, null);
    Q = true;
  }, p(L, B) {
    const u = {};
    B & 16 && (u.data = L[4]), s.$set(u);
    const p = {};
    B & 4 && (p.value = L[2].d), o.$set(p);
    const d = {};
    B & 4 && (d.value = L[2].phi), c.$set(d);
    const y = {};
    B & 4 && (y.value = L[2].p), m.$set(y);
    const w = {};
    B & 4 && (w.value = L[2].q), b.$set(w);
    const E = {};
    if (B & 4 && (E.value = `[${L[2].continuedFractions.join(", ")}]`), C.$set(E), B & 4) {
      P = Mr(L[2].convergents);
      let M;
      for (M = 0; M < P.length; M += 1) {
        const x = CB(L, P, M);
        N[M] ? N[M].p(x, B) : (N[M] = SB(x), N[M].c(), N[M].m(U, null));
      }
      for (; M < N.length; M += 1) N[M].d(1);
      N.length = P.length;
    }
  }, i(L) {
    Q || (W(s.$$.fragment, L), W(o.$$.fragment, L), W(c.$$.fragment, L), W(m.$$.fragment, L), W(b.$$.fragment, L), W(C.$$.fragment, L), Q = true);
  }, o(L) {
    j(s.$$.fragment, L), j(o.$$.fragment, L), j(c.$$.fragment, L), j(m.$$.fragment, L), j(b.$$.fragment, L), j(C.$$.fragment, L), Q = false;
  }, d(L) {
    L && (D(e), D(n), D(r), D(i), D(a), D(l), D(h), D(A), D(_)), oe(s), oe(o), oe(c), oe(m), oe(b), oe(C), jn(N, L);
  } };
}
function SB(t3) {
  let e, n = t3[11].k + "", r, s, i = t3[11].d + "", a, o;
  return { c() {
    e = H("span"), r = we(n), s = we("/"), a = we(i), o = z(), V(e, "class", "tag svelte-jtdcoc"), Zt(e, "highlight", t3[11].d === t3[2].d);
  }, m(f, c) {
    R(f, e, c), q(e, r), q(e, s), q(e, a), q(e, o);
  }, p(f, c) {
    c & 4 && n !== (n = f[11].k + "") && Ze(r, n), c & 4 && i !== (i = f[11].d + "") && Ze(a, i), c & 4 && Zt(e, "highlight", f[11].d === f[2].d);
  }, d(f) {
    f && D(e);
  } };
}
function c2e(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C;
  function I(P) {
    t3[8](P);
  }
  let S = { label: "Public Exponent (e):", placeholder: "e.g. 17993" };
  t3[0] !== void 0 && (S.value = t3[0]), n = new et({ props: S }), Qe.push(() => ze(n, "value", I));
  function $(P) {
    t3[9](P);
  }
  let F = { label: "Modulus (N):", placeholder: "e.g. 90581" };
  t3[1] !== void 0 && (F.value = t3[1]), i = new et({ props: F }), Qe.push(() => ze(i, "value", $)), c = new ut({ props: { $$slots: { default: [a2e] }, $$scope: { ctx: t3 } } }), c.$on("click", t3[5]), h = new ut({ props: { variant: "secondary", $$slots: { default: [o2e] }, $$scope: { ctx: t3 } } }), h.$on("click", t3[6]), v = new ut({ props: { variant: "secondary", $$slots: { default: [f2e] }, $$scope: { ctx: t3 } } }), v.$on("click", t3[10]);
  let U = t3[3] && kB(t3), Q = t3[2] && IB(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), fe(i.$$.fragment), o = z(), f = H("div"), fe(c.$$.fragment), l = z(), fe(h.$$.fragment), m = z(), fe(v.$$.fragment), b = z(), U && U.c(), A = z(), Q && Q.c(), _ = Lt(), V(e, "class", "input-row svelte-jtdcoc"), V(f, "class", "button-row");
  }, m(P, N) {
    R(P, e, N), ae(n, e, null), q(e, s), ae(i, e, null), R(P, o, N), R(P, f, N), ae(c, f, null), q(f, l), ae(h, f, null), q(f, m), ae(v, f, null), R(P, b, N), U && U.m(P, N), R(P, A, N), Q && Q.m(P, N), R(P, _, N), C = true;
  }, p(P, N) {
    const L = {};
    !r && N & 1 && (r = true, L.value = P[0], qe(() => r = false)), n.$set(L);
    const B = {};
    !a && N & 2 && (a = true, B.value = P[1], qe(() => a = false)), i.$set(B);
    const u = {};
    N & 16384 && (u.$$scope = { dirty: N, ctx: P }), c.$set(u);
    const p = {};
    N & 16384 && (p.$$scope = { dirty: N, ctx: P }), h.$set(p);
    const d = {};
    N & 16384 && (d.$$scope = { dirty: N, ctx: P }), v.$set(d), P[3] ? U ? U.p(P, N) : (U = kB(P), U.c(), U.m(A.parentNode, A)) : U && (U.d(1), U = null), P[2] ? Q ? (Q.p(P, N), N & 4 && W(Q, 1)) : (Q = IB(P), Q.c(), W(Q, 1), Q.m(_.parentNode, _)) : Q && (Xt(), j(Q, 1, 1, () => {
      Q = null;
    }), er());
  }, i(P) {
    C || (W(n.$$.fragment, P), W(i.$$.fragment, P), W(c.$$.fragment, P), W(h.$$.fragment, P), W(v.$$.fragment, P), W(Q), C = true);
  }, o(P) {
    j(n.$$.fragment, P), j(i.$$.fragment, P), j(c.$$.fragment, P), j(h.$$.fragment, P), j(v.$$.fragment, P), j(Q), C = false;
  }, d(P) {
    P && (D(e), D(o), D(f), D(b), D(A), D(_)), oe(n), oe(i), oe(c), oe(h), oe(v), U && U.d(P), Q && Q.d(P);
  } };
}
function h2e(t3) {
  let e, n, r, s, i, a;
  return { c() {
    e = H("p"), e.textContent = `This application implements the RSA Wiener Attack, a cryptanalysis method that can break RSA encryption 
    when the private key is vulnerable due to a small private exponent (d). This is achieved by exploiting 
    properties of continued fractions and the public exponent (e) relative to the modulus (n).`, n = z(), r = H("b"), r.textContent = "Features:", s = H("br"), i = z(), a = H("ul"), a.innerHTML = "<li><b>Prime Factorization:</b> Attempts to factorize the modulus n into primes p and q using trial division.</li> <li><b>\u03C6(N) Calculation:</b> Computes Euler&#39;s Totient function \u03C6(N) based on the found p and q values.</li> <li><b>Continued Fractions:</b> Generates the continued fraction expansion of e/n to approximate the fraction.</li> <li><b>Convergents:</b> Computes the convergents of the continued fraction, providing candidates for the private key d.</li> <li><b>Secret Key (d) Discovery:</b> Identifies the private exponent d by solving a quadratic equation using the approximations.</li>";
  }, m(o, f) {
    R(o, e, f), R(o, n, f), R(o, r, f), R(o, s, f), R(o, i, f), R(o, a, f);
  }, p: dt, d(o) {
    o && (D(e), D(n), D(r), D(s), D(i), D(a));
  } };
}
function d2e(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "RSA Wiener Attack", $$slots: { default: [c2e] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Wiener's Attack", links: t3[7], $$slots: { default: [h2e] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 16415 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 16384 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function p2e(t3, e, n) {
  let r, s = "", i = "", a = null, o = "";
  function f() {
    if (!s || !i) {
      n(3, o = "Please provide both e and N.");
      return;
    }
    n(3, o = ""), n(2, a = null);
    try {
      n(2, a = s2e(s, i));
    } catch (b) {
      n(3, o = "Error: " + b.message);
    }
  }
  function c() {
    n(0, s = "17993"), n(1, i = "90581"), f();
  }
  const l = [{ text: "Wikipedia: Wiener's Attack", url: "https://en.wikipedia.org/wiki/Wiener%27s_attack" }, { text: "Continued Fractions", url: "https://en.wikipedia.org/wiki/Continued_fraction" }, { text: "RSA Algorithm", url: "https://en.wikipedia.org/wiki/RSA_(cryptosystem)" }];
  function h(b) {
    s = b, n(0, s);
  }
  function m(b) {
    i = b, n(1, i);
  }
  const v = () => {
    n(0, s = ""), n(1, i = ""), n(2, a = null);
  };
  return t3.$$.update = () => {
    t3.$$.dirty & 7 && n(4, r = a && a.success ? [{ name: "private_key_d.txt", content: a.d }, { name: "prime_p.txt", content: a.p }, { name: "prime_q.txt", content: a.q }, { name: "analysis.txt", content: `e: ${s}
n: ${i}
phi: ${a.phi}` }] : []);
  }, [s, i, a, o, r, f, c, l, h, m, v];
}
class g2e extends xt {
  constructor(e) {
    super(), wt(this, e, p2e, d2e, At, {});
  }
}
function m2e(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U, Q, P, N, L, B, u, p, d, y, w, E, M, x, g, k;
  return { c() {
    e = we(`This type of attack involves comparing pairs of plaintexts and their corresponding ciphertexts 
    to find patterns in the encryption algorithm. It can be effective against block ciphers (with certain properties) 
    and some stream ciphers. It was publicly introduced by `), n = H("a"), n.textContent = "Eli Biham", r = we(` 
    and `), s = H("a"), s.textContent = "Adi Shamir", i = we(` in the late 1980s but was known to the National 
    Security Agency (NSA) much earlier.
    `), a = H("ul"), a.innerHTML = "<li>The attacker selects pairs of plaintexts with a specific difference (XOR difference).</li> <li>The attacker studies how these input differences propagate through the encryption rounds.</li> <li>Some differences appear more frequently at certain points in the cipher, revealing patterns.</li> <li>By analyzing these biases, the attacker can deduce parts of the key and gradually recover the full key.</li>", o = z(), f = H("b"), f.textContent = "Example: Attack on a simple Feister Cipher", c = H("br"), l = we(`
    Assume we have a 4-round Feistel cipher with `), h = H("b"), h.textContent = "64-bit plaintext, 32-bit Feistel function F and XOR operation.", m = H("br"), v = we(`
    We choose two plaintexts P and P' that have a specific XOR difference. Let's say:
    `), b = H("ul"), b.innerHTML = "<li>P = (Lo, Ro) and P&#39; = (L&#39;o, R&#39;o)</li> <li><b>Input Difference:</b> \u0394Ro = R0 \u2295 R&#39;o (chosen by attacker)</li> <li>\u0394Lo = 0 (no difference in Lo)</li>", A = z(), _ = H("b"), _.textContent = "For the first round:", C = we(` (K1=key)
    `), I = H("ul"), I.innerHTML = "<li>Compute L1 = Ro</li> <li>Compute R1 = Lo \u2295 F(Ro, K1)</li>", S = z(), $ = H("b"), $.textContent = "For the second plaintext:", F = z(), U = H("ul"), U.innerHTML = "<li>Compute L&#39;1 = R&#39;o</li> <li>Compute R&#39;1 = L&#39;o \u2295 F(R&#39;o, K1)</li>", Q = z(), P = H("b"), P.textContent = "Taking the XOR difference:", N = H("br"), L = we(`
    \u0394L1 = L1 \u2295 L'1 = Ro \u2295 R'o = \u0394Ro  `), B = H("b"), B.textContent = "and", u = we(" \u0394R1 = R1 \u2295 R'1 = F(Ro, K1) \u2295 F(R'o, K1)"), p = H("br"), d = H("br"), y = we(`
    Since the attacker chooses \u0394Ro, they can analyze how the Feistel function F propagates differences.
    If `), w = H("b"), w.textContent = "F", E = we(" has a predictable differential pattern, "), M = H("b"), M.textContent = "the attacker can guess parts of the key K1.", x = we(` 
    By repeating this attack with many plaintext pairs, the attacker can determine which key bits 
    are more likely, eventually recovering the full key.`), g = H("br"), k = H("br"), V(n, "href", "https://en.wikipedia.org/wiki/Eli_Biham"), V(s, "href", "https://en.wikipedia.org/wiki/Adi_Shamir");
  }, m(T, O) {
    R(T, e, O), R(T, n, O), R(T, r, O), R(T, s, O), R(T, i, O), R(T, a, O), R(T, o, O), R(T, f, O), R(T, c, O), R(T, l, O), R(T, h, O), R(T, m, O), R(T, v, O), R(T, b, O), R(T, A, O), R(T, _, O), R(T, C, O), R(T, I, O), R(T, S, O), R(T, $, O), R(T, F, O), R(T, U, O), R(T, Q, O), R(T, P, O), R(T, N, O), R(T, L, O), R(T, B, O), R(T, u, O), R(T, p, O), R(T, d, O), R(T, y, O), R(T, w, O), R(T, E, O), R(T, M, O), R(T, x, O), R(T, g, O), R(T, k, O);
  }, p: dt, d(T) {
    T && (D(e), D(n), D(r), D(s), D(i), D(a), D(o), D(f), D(c), D(l), D(h), D(m), D(v), D(b), D(A), D(_), D(C), D(I), D(S), D($), D(F), D(U), D(Q), D(P), D(N), D(L), D(B), D(u), D(p), D(d), D(y), D(w), D(E), D(M), D(x), D(g), D(k));
  } };
}
function v2e(t3) {
  let e, n;
  return e = new Rt({ props: { title: "About Differential Cryptanalysis", links: t3[0], $$slots: { default: [m2e] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, [s]) {
    const i = {};
    s & 2 && (i.$$scope = { dirty: s, ctx: r }), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function y2e(t3) {
  return [[{ text: "Wikipedia", url: "https://en.wikipedia.org/wiki/Differential_cryptanalysis" }, { text: "Geeks for Geeks", url: "https://www.geeksforgeeks.org/differential-and-linear-cryptanalysis/" }, { text: "Amazing King", url: "http://www.theamazingking.com/crypto-diff.php" }]];
}
class b2e extends xt {
  constructor(e) {
    super(), wt(this, e, y2e, v2e, At, {});
  }
}
function A2e(t3) {
  let e, n, r, s, i, a, o, f, c, l;
  return { c() {
    e = H("b"), e.textContent = "Linear cryptanalysis", n = we(` is an attack method used to break block ciphers and stream ciphers. 
    Linear cryptanalysis and differential cryptanalysis are the two most widely used attacks on block ciphers. 
    Linear cryptanalysis was discovered by `), r = H("a"), r.textContent = "Mitsuru Matsui", s = we(` 
    in 1992 and was successfully used to attack the `), i = H("a"), i.textContent = "Data Encryption Standard (DES)", a = we(". "), o = H("br"), f = we(`
    Linear cryptanalysis exploits statistical biases in the linear approximations of the cipher\u2019s operations. It relies
    on finding linear relationships between plaintext bits, ciphertext bits, and key bits that hold with a probability 
    significantly different from 50%. These biases allow an attacker to deduce information about the secret key after 
    analyzing a large number of plaintext-ciphertext pairs. `), c = H("br"), l = H("br"), V(r, "href", "https://en.wikipedia.org/wiki/Mitsuru_Matsui"), V(i, "href", "https://en.wikipedia.org/wiki/Data_Encryption_Standard");
  }, m(h, m) {
    R(h, e, m), R(h, n, m), R(h, r, m), R(h, s, m), R(h, i, m), R(h, a, m), R(h, o, m), R(h, f, m), R(h, c, m), R(h, l, m);
  }, p: dt, d(h) {
    h && (D(e), D(n), D(r), D(s), D(i), D(a), D(o), D(f), D(c), D(l));
  } };
}
function w2e(t3) {
  let e, n;
  return e = new Rt({ props: { title: "About Linear Cryptanalysis", links: t3[0], $$slots: { default: [A2e] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, [s]) {
    const i = {};
    s & 2 && (i.$$scope = { dirty: s, ctx: r }), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function x2e(t3) {
  return [[{ text: "Wikipedia", url: "https://en.wikipedia.org/wiki/Linear_cryptanalysis" }, { text: "Geeks for Geeks", url: "https://www.geeksforgeeks.org/differential-and-linear-cryptanalysis/" }, { text: "Amazing King", url: "http://www.theamazingking.com/crypto-linear.php" }]];
}
class _2e extends xt {
  constructor(e) {
    super(), wt(this, e, x2e, w2e, At, {});
  }
}
function E2e(t3) {
  let e, n, r, s, i, a, o;
  return { c() {
    e = we(`A Boomerang Attack is a cryptanalysis technique used to attack block ciphers. 
    The boomerang attack is based on `), n = H("a"), n.textContent = "differential cryptanalysis", r = we(` 
    (basically an extension of differential cryptanalysis). The attack was published in 1999 by `), s = H("a"), s.textContent = "David Wagner", i = we(`, 
    who used it to break the COCONUT98 cipher. `), a = H("br"), o = H("br"), V(n, "href", "https://en.wikipedia.org/wiki/Differential_cryptanalysis"), V(s, "href", "https://en.wikipedia.org/wiki/David_A._Wagner");
  }, m(f, c) {
    R(f, e, c), R(f, n, c), R(f, r, c), R(f, s, c), R(f, i, c), R(f, a, c), R(f, o, c);
  }, p: dt, d(f) {
    f && (D(e), D(n), D(r), D(s), D(i), D(a), D(o));
  } };
}
function B2e(t3) {
  let e, n;
  return e = new Rt({ props: { title: "About Boomerang Attack", links: t3[0], $$slots: { default: [E2e] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, [s]) {
    const i = {};
    s & 2 && (i.$$scope = { dirty: s, ctx: r }), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function C2e(t3) {
  return [[{ text: "Wikipedia", url: "https://en.wikipedia.org/wiki/Boomerang_attack" }, { text: "SpringerLink", url: "https://link.springer.com/chapter/10.1007/3-540-48519-8_12" }, { text: "Cryptology ePrint Archive", url: "https://eprint.iacr.org/2019/1154.pdf" }]];
}
class k2e extends xt {
  constructor(e) {
    super(), wt(this, e, C2e, B2e, At, {});
  }
}
function ZF(t3) {
  return t3 instanceof Map ? t3.clear = t3.delete = t3.set = function() {
    throw new Error("map is read-only");
  } : t3 instanceof Set && (t3.add = t3.clear = t3.delete = function() {
    throw new Error("set is read-only");
  }), Object.freeze(t3), Object.getOwnPropertyNames(t3).forEach((e) => {
    const n = t3[e], r = typeof n;
    (r === "object" || r === "function") && !Object.isFrozen(n) && ZF(n);
  }), t3;
}
let MB = class {
  constructor(e) {
    e.data === void 0 && (e.data = {}), this.data = e.data, this.isMatchIgnored = false;
  }
  ignoreMatch() {
    this.isMatchIgnored = true;
  }
};
function jF(t3) {
  return t3.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
}
function Zf(t3, ...e) {
  const n = /* @__PURE__ */ Object.create(null);
  for (const r in t3) n[r] = t3[r];
  return e.forEach(function(r) {
    for (const s in r) n[s] = r[s];
  }), n;
}
const I2e = "</span>", $B = (t3) => !!t3.scope, S2e = (t3, { prefix: e }) => {
  if (t3.startsWith("language:")) return t3.replace("language:", "language-");
  if (t3.includes(".")) {
    const n = t3.split(".");
    return [`${e}${n.shift()}`, ...n.map((r, s) => `${r}${"_".repeat(s + 1)}`)].join(" ");
  }
  return `${e}${t3}`;
};
class M2e {
  constructor(e, n) {
    this.buffer = "", this.classPrefix = n.classPrefix, e.walk(this);
  }
  addText(e) {
    this.buffer += jF(e);
  }
  openNode(e) {
    if (!$B(e)) return;
    const n = S2e(e.scope, { prefix: this.classPrefix });
    this.span(n);
  }
  closeNode(e) {
    $B(e) && (this.buffer += I2e);
  }
  value() {
    return this.buffer;
  }
  span(e) {
    this.buffer += `<span class="${e}">`;
  }
}
const TB = (t3 = {}) => {
  const e = { children: [] };
  return Object.assign(e, t3), e;
};
class G4 {
  constructor() {
    this.rootNode = TB(), this.stack = [this.rootNode];
  }
  get top() {
    return this.stack[this.stack.length - 1];
  }
  get root() {
    return this.rootNode;
  }
  add(e) {
    this.top.children.push(e);
  }
  openNode(e) {
    const n = TB({ scope: e });
    this.add(n), this.stack.push(n);
  }
  closeNode() {
    if (this.stack.length > 1) return this.stack.pop();
  }
  closeAllNodes() {
    for (; this.closeNode(); ) ;
  }
  toJSON() {
    return JSON.stringify(this.rootNode, null, 4);
  }
  walk(e) {
    return this.constructor._walk(e, this.rootNode);
  }
  static _walk(e, n) {
    return typeof n == "string" ? e.addText(n) : n.children && (e.openNode(n), n.children.forEach((r) => this._walk(e, r)), e.closeNode(n)), e;
  }
  static _collapse(e) {
    typeof e != "string" && e.children && (e.children.every((n) => typeof n == "string") ? e.children = [e.children.join("")] : e.children.forEach((n) => {
      G4._collapse(n);
    }));
  }
}
class $2e extends G4 {
  constructor(e) {
    super(), this.options = e;
  }
  addText(e) {
    e !== "" && this.add(e);
  }
  startScope(e) {
    this.openNode(e);
  }
  endScope() {
    this.closeNode();
  }
  __addSublanguage(e, n) {
    const r = e.root;
    n && (r.scope = `language:${n}`), this.add(r);
  }
  toHTML() {
    return new M2e(this, this.options).value();
  }
  finalize() {
    return this.closeAllNodes(), true;
  }
}
function qh(t3) {
  return t3 ? typeof t3 == "string" ? t3 : t3.source : null;
}
function XF(t3) {
  return k0("(?=", t3, ")");
}
function T2e(t3) {
  return k0("(?:", t3, ")*");
}
function D2e(t3) {
  return k0("(?:", t3, ")?");
}
function k0(...t3) {
  return t3.map((n) => qh(n)).join("");
}
function R2e(t3) {
  const e = t3[t3.length - 1];
  return typeof e == "object" && e.constructor === Object ? (t3.splice(t3.length - 1, 1), e) : {};
}
function V4(...t3) {
  return "(" + (R2e(t3).capture ? "" : "?:") + t3.map((r) => qh(r)).join("|") + ")";
}
function eP(t3) {
  return new RegExp(t3.toString() + "|").exec("").length - 1;
}
function F2e(t3, e) {
  const n = t3 && t3.exec(e);
  return n && n.index === 0;
}
const P2e = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
function Y4(t3, { joinWith: e }) {
  let n = 0;
  return t3.map((r) => {
    n += 1;
    const s = n;
    let i = qh(r), a = "";
    for (; i.length > 0; ) {
      const o = P2e.exec(i);
      if (!o) {
        a += i;
        break;
      }
      a += i.substring(0, o.index), i = i.substring(o.index + o[0].length), o[0][0] === "\\" && o[1] ? a += "\\" + String(Number(o[1]) + s) : (a += o[0], o[0] === "(" && n++);
    }
    return a;
  }).map((r) => `(${r})`).join(e);
}
const N2e = /\b\B/, tP = "[a-zA-Z]\\w*", W4 = "[a-zA-Z_]\\w*", rP = "\\b\\d+(\\.\\d+)?", nP = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", iP = "\\b(0b[01]+)", U2e = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", L2e = (t3 = {}) => {
  const e = /^#![ ]*\//;
  return t3.binary && (t3.begin = k0(e, /.*\b/, t3.binary, /\b.*/)), Zf({ scope: "meta", begin: e, end: /$/, relevance: 0, "on:begin": (n, r) => {
    n.index !== 0 && r.ignoreMatch();
  } }, t3);
}, zh = { begin: "\\\\[\\s\\S]", relevance: 0 }, O2e = { scope: "string", begin: "'", end: "'", illegal: "\\n", contains: [zh] }, Q2e = { scope: "string", begin: '"', end: '"', illegal: "\\n", contains: [zh] }, K2e = { begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/ }, Cm = function(t3, e, n = {}) {
  const r = Zf({ scope: "comment", begin: t3, end: e, contains: [] }, n);
  r.contains.push({ scope: "doctag", begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)", end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/, excludeBegin: true, relevance: 0 });
  const s = V4("I", "a", "is", "so", "us", "to", "at", "if", "in", "it", "on", /[A-Za-z]+['](d|ve|re|ll|t|s|n)/, /[A-Za-z]+[-][a-z]+/, /[A-Za-z][a-z]{2,}/);
  return r.contains.push({ begin: k0(/[ ]+/, "(", s, /[.]?[:]?([.][ ]|[ ])/, "){3}") }), r;
}, H2e = Cm("//", "$"), q2e = Cm("/\\*", "\\*/"), z2e = Cm("#", "$"), G2e = { scope: "number", begin: rP, relevance: 0 }, V2e = { scope: "number", begin: nP, relevance: 0 }, Y2e = { scope: "number", begin: iP, relevance: 0 }, W2e = { scope: "regexp", begin: /\/(?=[^/\n]*\/)/, end: /\/[gimuy]*/, contains: [zh, { begin: /\[/, end: /\]/, relevance: 0, contains: [zh] }] }, J2e = { scope: "title", begin: tP, relevance: 0 }, Z2e = { scope: "title", begin: W4, relevance: 0 }, j2e = { begin: "\\.\\s*" + W4, relevance: 0 }, X2e = function(t3) {
  return Object.assign(t3, { "on:begin": (e, n) => {
    n.data._beginMatch = e[1];
  }, "on:end": (e, n) => {
    n.data._beginMatch !== e[1] && n.ignoreMatch();
  } });
};
var vp = Object.freeze({ __proto__: null, APOS_STRING_MODE: O2e, BACKSLASH_ESCAPE: zh, BINARY_NUMBER_MODE: Y2e, BINARY_NUMBER_RE: iP, COMMENT: Cm, C_BLOCK_COMMENT_MODE: q2e, C_LINE_COMMENT_MODE: H2e, C_NUMBER_MODE: V2e, C_NUMBER_RE: nP, END_SAME_AS_BEGIN: X2e, HASH_COMMENT_MODE: z2e, IDENT_RE: tP, MATCH_NOTHING_RE: N2e, METHOD_GUARD: j2e, NUMBER_MODE: G2e, NUMBER_RE: rP, PHRASAL_WORDS_MODE: K2e, QUOTE_STRING_MODE: Q2e, REGEXP_MODE: W2e, RE_STARTERS_RE: U2e, SHEBANG: L2e, TITLE_MODE: J2e, UNDERSCORE_IDENT_RE: W4, UNDERSCORE_TITLE_MODE: Z2e });
function eve(t3, e) {
  t3.input[t3.index - 1] === "." && e.ignoreMatch();
}
function tve(t3, e) {
  t3.className !== void 0 && (t3.scope = t3.className, delete t3.className);
}
function rve(t3, e) {
  e && t3.beginKeywords && (t3.begin = "\\b(" + t3.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", t3.__beforeBegin = eve, t3.keywords = t3.keywords || t3.beginKeywords, delete t3.beginKeywords, t3.relevance === void 0 && (t3.relevance = 0));
}
function nve(t3, e) {
  Array.isArray(t3.illegal) && (t3.illegal = V4(...t3.illegal));
}
function ive(t3, e) {
  if (t3.match) {
    if (t3.begin || t3.end) throw new Error("begin & end are not supported with match");
    t3.begin = t3.match, delete t3.match;
  }
}
function sve(t3, e) {
  t3.relevance === void 0 && (t3.relevance = 1);
}
const ave = (t3, e) => {
  if (!t3.beforeMatch) return;
  if (t3.starts) throw new Error("beforeMatch cannot be used with starts");
  const n = Object.assign({}, t3);
  Object.keys(t3).forEach((r) => {
    delete t3[r];
  }), t3.keywords = n.keywords, t3.begin = k0(n.beforeMatch, XF(n.begin)), t3.starts = { relevance: 0, contains: [Object.assign(n, { endsParent: true })] }, t3.relevance = 0, delete n.beforeMatch;
}, ove = ["of", "and", "for", "in", "not", "or", "if", "then", "parent", "list", "value"], fve = "keyword";
function sP(t3, e, n = fve) {
  const r = /* @__PURE__ */ Object.create(null);
  return typeof t3 == "string" ? s(n, t3.split(" ")) : Array.isArray(t3) ? s(n, t3) : Object.keys(t3).forEach(function(i) {
    Object.assign(r, sP(t3[i], e, i));
  }), r;
  function s(i, a) {
    e && (a = a.map((o) => o.toLowerCase())), a.forEach(function(o) {
      const f = o.split("|");
      r[f[0]] = [i, lve(f[0], f[1])];
    });
  }
}
function lve(t3, e) {
  return e ? Number(e) : uve(t3) ? 0 : 1;
}
function uve(t3) {
  return ove.includes(t3.toLowerCase());
}
const DB = {}, n0 = (t3) => {
  console.error(t3);
}, RB = (t3, ...e) => {
  console.log(`WARN: ${t3}`, ...e);
}, Q0 = (t3, e) => {
  DB[`${t3}/${e}`] || (console.log(`Deprecated as of ${t3}. ${e}`), DB[`${t3}/${e}`] = true);
}, X1 = new Error();
function aP(t3, e, { key: n }) {
  let r = 0;
  const s = t3[n], i = {}, a = {};
  for (let o = 1; o <= e.length; o++) a[o + r] = s[o], i[o + r] = true, r += eP(e[o - 1]);
  t3[n] = a, t3[n]._emit = i, t3[n]._multi = true;
}
function cve(t3) {
  if (Array.isArray(t3.begin)) {
    if (t3.skip || t3.excludeBegin || t3.returnBegin) throw n0("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), X1;
    if (typeof t3.beginScope != "object" || t3.beginScope === null) throw n0("beginScope must be object"), X1;
    aP(t3, t3.begin, { key: "beginScope" }), t3.begin = Y4(t3.begin, { joinWith: "" });
  }
}
function hve(t3) {
  if (Array.isArray(t3.end)) {
    if (t3.skip || t3.excludeEnd || t3.returnEnd) throw n0("skip, excludeEnd, returnEnd not compatible with endScope: {}"), X1;
    if (typeof t3.endScope != "object" || t3.endScope === null) throw n0("endScope must be object"), X1;
    aP(t3, t3.end, { key: "endScope" }), t3.end = Y4(t3.end, { joinWith: "" });
  }
}
function dve(t3) {
  t3.scope && typeof t3.scope == "object" && t3.scope !== null && (t3.beginScope = t3.scope, delete t3.scope);
}
function pve(t3) {
  dve(t3), typeof t3.beginScope == "string" && (t3.beginScope = { _wrap: t3.beginScope }), typeof t3.endScope == "string" && (t3.endScope = { _wrap: t3.endScope }), cve(t3), hve(t3);
}
function gve(t3) {
  function e(a, o) {
    return new RegExp(qh(a), "m" + (t3.case_insensitive ? "i" : "") + (t3.unicodeRegex ? "u" : "") + (o ? "g" : ""));
  }
  class n {
    constructor() {
      this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
    }
    addRule(o, f) {
      f.position = this.position++, this.matchIndexes[this.matchAt] = f, this.regexes.push([f, o]), this.matchAt += eP(o) + 1;
    }
    compile() {
      this.regexes.length === 0 && (this.exec = () => null);
      const o = this.regexes.map((f) => f[1]);
      this.matcherRe = e(Y4(o, { joinWith: "|" }), true), this.lastIndex = 0;
    }
    exec(o) {
      this.matcherRe.lastIndex = this.lastIndex;
      const f = this.matcherRe.exec(o);
      if (!f) return null;
      const c = f.findIndex((h, m) => m > 0 && h !== void 0), l = this.matchIndexes[c];
      return f.splice(0, c), Object.assign(f, l);
    }
  }
  class r {
    constructor() {
      this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
    }
    getMatcher(o) {
      if (this.multiRegexes[o]) return this.multiRegexes[o];
      const f = new n();
      return this.rules.slice(o).forEach(([c, l]) => f.addRule(c, l)), f.compile(), this.multiRegexes[o] = f, f;
    }
    resumingScanAtSamePosition() {
      return this.regexIndex !== 0;
    }
    considerAll() {
      this.regexIndex = 0;
    }
    addRule(o, f) {
      this.rules.push([o, f]), f.type === "begin" && this.count++;
    }
    exec(o) {
      const f = this.getMatcher(this.regexIndex);
      f.lastIndex = this.lastIndex;
      let c = f.exec(o);
      if (this.resumingScanAtSamePosition() && !(c && c.index === this.lastIndex)) {
        const l = this.getMatcher(0);
        l.lastIndex = this.lastIndex + 1, c = l.exec(o);
      }
      return c && (this.regexIndex += c.position + 1, this.regexIndex === this.count && this.considerAll()), c;
    }
  }
  function s(a) {
    const o = new r();
    return a.contains.forEach((f) => o.addRule(f.begin, { rule: f, type: "begin" })), a.terminatorEnd && o.addRule(a.terminatorEnd, { type: "end" }), a.illegal && o.addRule(a.illegal, { type: "illegal" }), o;
  }
  function i(a, o) {
    const f = a;
    if (a.isCompiled) return f;
    [tve, ive, pve, ave].forEach((l) => l(a, o)), t3.compilerExtensions.forEach((l) => l(a, o)), a.__beforeBegin = null, [rve, nve, sve].forEach((l) => l(a, o)), a.isCompiled = true;
    let c = null;
    return typeof a.keywords == "object" && a.keywords.$pattern && (a.keywords = Object.assign({}, a.keywords), c = a.keywords.$pattern, delete a.keywords.$pattern), c = c || /\w+/, a.keywords && (a.keywords = sP(a.keywords, t3.case_insensitive)), f.keywordPatternRe = e(c, true), o && (a.begin || (a.begin = /\B|\b/), f.beginRe = e(f.begin), !a.end && !a.endsWithParent && (a.end = /\B|\b/), a.end && (f.endRe = e(f.end)), f.terminatorEnd = qh(f.end) || "", a.endsWithParent && o.terminatorEnd && (f.terminatorEnd += (a.end ? "|" : "") + o.terminatorEnd)), a.illegal && (f.illegalRe = e(a.illegal)), a.contains || (a.contains = []), a.contains = [].concat(...a.contains.map(function(l) {
      return mve(l === "self" ? a : l);
    })), a.contains.forEach(function(l) {
      i(l, f);
    }), a.starts && i(a.starts, o), f.matcher = s(f), f;
  }
  if (t3.compilerExtensions || (t3.compilerExtensions = []), t3.contains && t3.contains.includes("self")) throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
  return t3.classNameAliases = Zf(t3.classNameAliases || {}), i(t3);
}
function oP(t3) {
  return t3 ? t3.endsWithParent || oP(t3.starts) : false;
}
function mve(t3) {
  return t3.variants && !t3.cachedVariants && (t3.cachedVariants = t3.variants.map(function(e) {
    return Zf(t3, { variants: null }, e);
  })), t3.cachedVariants ? t3.cachedVariants : oP(t3) ? Zf(t3, { starts: t3.starts ? Zf(t3.starts) : null }) : Object.isFrozen(t3) ? Zf(t3) : t3;
}
var vve = "11.11.1";
class yve extends Error {
  constructor(e, n) {
    super(e), this.name = "HTMLInjectionError", this.html = n;
  }
}
const By = jF, FB = Zf, PB = Symbol("nomatch"), bve = 7, fP = function(t3) {
  const e = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null), r = [];
  let s = true;
  const i = "Could not find the language '{}', did you forget to load/include a language module?", a = { disableAutodetect: true, name: "Plain text", contains: [] };
  let o = { ignoreUnescapedHTML: false, throwUnescapedHTML: false, noHighlightRe: /^(no-?highlight)$/i, languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i, classPrefix: "hljs-", cssSelector: "pre code", languages: null, __emitter: $2e };
  function f(w) {
    return o.noHighlightRe.test(w);
  }
  function c(w) {
    let E = w.className + " ";
    E += w.parentNode ? w.parentNode.className : "";
    const M = o.languageDetectRe.exec(E);
    if (M) {
      const x = P(M[1]);
      return x || (RB(i.replace("{}", M[1])), RB("Falling back to no-highlight mode for this block.", w)), x ? M[1] : "no-highlight";
    }
    return E.split(/\s+/).find((x) => f(x) || P(x));
  }
  function l(w, E, M) {
    let x = "", g = "";
    typeof E == "object" ? (x = w, M = E.ignoreIllegals, g = E.language) : (Q0("10.7.0", "highlight(lang, code, ...args) has been deprecated."), Q0("10.7.0", `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`), g = w, x = E), M === void 0 && (M = true);
    const k = { code: x, language: g };
    d("before:highlight", k);
    const T = k.result ? k.result : h(k.language, k.code, M);
    return T.code = k.code, d("after:highlight", T), T;
  }
  function h(w, E, M, x) {
    const g = /* @__PURE__ */ Object.create(null);
    function k(Ge, Fe) {
      return Ge.keywords[Fe];
    }
    function T() {
      if (!ce.keywords) {
        Oe.addText(Se);
        return;
      }
      let Ge = 0;
      ce.keywordPatternRe.lastIndex = 0;
      let Fe = ce.keywordPatternRe.exec(Se), Ue = "";
      for (; Fe; ) {
        Ue += Se.substring(Ge, Fe.index);
        const kt = ve.case_insensitive ? Fe[0].toLowerCase() : Fe[0], pe = k(ce, kt);
        if (pe) {
          const [re, ue] = pe;
          if (Oe.addText(Ue), Ue = "", g[kt] = (g[kt] || 0) + 1, g[kt] <= bve && (Ce += ue), re.startsWith("_")) Ue += Fe[0];
          else {
            const xe = ve.classNameAliases[re] || re;
            Y(Fe[0], xe);
          }
        } else Ue += Fe[0];
        Ge = ce.keywordPatternRe.lastIndex, Fe = ce.keywordPatternRe.exec(Se);
      }
      Ue += Se.substring(Ge), Oe.addText(Ue);
    }
    function O() {
      if (Se === "") return;
      let Ge = null;
      if (typeof ce.subLanguage == "string") {
        if (!e[ce.subLanguage]) {
          Oe.addText(Se);
          return;
        }
        Ge = h(ce.subLanguage, Se, true, ye[ce.subLanguage]), ye[ce.subLanguage] = Ge._top;
      } else Ge = v(Se, ce.subLanguage.length ? ce.subLanguage : null);
      ce.relevance > 0 && (Ce += Ge.relevance), Oe.__addSublanguage(Ge._emitter, Ge.language);
    }
    function K() {
      ce.subLanguage != null ? O() : T(), Se = "";
    }
    function Y(Ge, Fe) {
      Ge !== "" && (Oe.startScope(Fe), Oe.addText(Ge), Oe.endScope());
    }
    function J(Ge, Fe) {
      let Ue = 1;
      const kt = Fe.length - 1;
      for (; Ue <= kt; ) {
        if (!Ge._emit[Ue]) {
          Ue++;
          continue;
        }
        const pe = ve.classNameAliases[Ge[Ue]] || Ge[Ue], re = Fe[Ue];
        pe ? Y(re, pe) : (Se = re, T(), Se = ""), Ue++;
      }
    }
    function G(Ge, Fe) {
      return Ge.scope && typeof Ge.scope == "string" && Oe.openNode(ve.classNameAliases[Ge.scope] || Ge.scope), Ge.beginScope && (Ge.beginScope._wrap ? (Y(Se, ve.classNameAliases[Ge.beginScope._wrap] || Ge.beginScope._wrap), Se = "") : Ge.beginScope._multi && (J(Ge.beginScope, Fe), Se = "")), ce = Object.create(Ge, { parent: { value: ce } }), ce;
    }
    function X(Ge, Fe, Ue) {
      let kt = F2e(Ge.endRe, Ue);
      if (kt) {
        if (Ge["on:end"]) {
          const pe = new MB(Ge);
          Ge["on:end"](Fe, pe), pe.isMatchIgnored && (kt = false);
        }
        if (kt) {
          for (; Ge.endsParent && Ge.parent; ) Ge = Ge.parent;
          return Ge;
        }
      }
      if (Ge.endsWithParent) return X(Ge.parent, Fe, Ue);
    }
    function ie(Ge) {
      return ce.matcher.regexIndex === 0 ? (Se += Ge[0], 1) : (Re = true, 0);
    }
    function de(Ge) {
      const Fe = Ge[0], Ue = Ge.rule, kt = new MB(Ue), pe = [Ue.__beforeBegin, Ue["on:begin"]];
      for (const re of pe) if (re && (re(Ge, kt), kt.isMatchIgnored)) return ie(Fe);
      return Ue.skip ? Se += Fe : (Ue.excludeBegin && (Se += Fe), K(), !Ue.returnBegin && !Ue.excludeBegin && (Se = Fe)), G(Ue, Ge), Ue.returnBegin ? 0 : Fe.length;
    }
    function se(Ge) {
      const Fe = Ge[0], Ue = E.substring(Ge.index), kt = X(ce, Ge, Ue);
      if (!kt) return PB;
      const pe = ce;
      ce.endScope && ce.endScope._wrap ? (K(), Y(Fe, ce.endScope._wrap)) : ce.endScope && ce.endScope._multi ? (K(), J(ce.endScope, Ge)) : pe.skip ? Se += Fe : (pe.returnEnd || pe.excludeEnd || (Se += Fe), K(), pe.excludeEnd && (Se = Fe));
      do
        ce.scope && Oe.closeNode(), !ce.skip && !ce.subLanguage && (Ce += ce.relevance), ce = ce.parent;
      while (ce !== kt.parent);
      return kt.starts && G(kt.starts, Ge), pe.returnEnd ? 0 : Fe.length;
    }
    function te() {
      const Ge = [];
      for (let Fe = ce; Fe !== ve; Fe = Fe.parent) Fe.scope && Ge.unshift(Fe.scope);
      Ge.forEach((Fe) => Oe.openNode(Fe));
    }
    let le = {};
    function Z(Ge, Fe) {
      const Ue = Fe && Fe[0];
      if (Se += Ge, Ue == null) return K(), 0;
      if (le.type === "begin" && Fe.type === "end" && le.index === Fe.index && Ue === "") {
        if (Se += E.slice(Fe.index, Fe.index + 1), !s) {
          const kt = new Error(`0 width match regex (${w})`);
          throw kt.languageName = w, kt.badRule = le.rule, kt;
        }
        return 1;
      }
      if (le = Fe, Fe.type === "begin") return de(Fe);
      if (Fe.type === "illegal" && !M) {
        const kt = new Error('Illegal lexeme "' + Ue + '" for mode "' + (ce.scope || "<unnamed>") + '"');
        throw kt.mode = ce, kt;
      } else if (Fe.type === "end") {
        const kt = se(Fe);
        if (kt !== PB) return kt;
      }
      if (Fe.type === "illegal" && Ue === "") return Se += `
`, 1;
      if ($e > 1e5 && $e > Fe.index * 3) throw new Error("potential infinite loop, way more iterations than matches");
      return Se += Ue, Ue.length;
    }
    const ve = P(w);
    if (!ve) throw n0(i.replace("{}", w)), new Error('Unknown language: "' + w + '"');
    const he = gve(ve);
    let me = "", ce = x || he;
    const ye = {}, Oe = new o.__emitter(o);
    te();
    let Se = "", Ce = 0, Ne = 0, $e = 0, Re = false;
    try {
      if (ve.__emitTokens) ve.__emitTokens(E, Oe);
      else {
        for (ce.matcher.considerAll(); ; ) {
          $e++, Re ? Re = false : ce.matcher.considerAll(), ce.matcher.lastIndex = Ne;
          const Ge = ce.matcher.exec(E);
          if (!Ge) break;
          const Fe = E.substring(Ne, Ge.index), Ue = Z(Fe, Ge);
          Ne = Ge.index + Ue;
        }
        Z(E.substring(Ne));
      }
      return Oe.finalize(), me = Oe.toHTML(), { language: w, value: me, relevance: Ce, illegal: false, _emitter: Oe, _top: ce };
    } catch (Ge) {
      if (Ge.message && Ge.message.includes("Illegal")) return { language: w, value: By(E), illegal: true, relevance: 0, _illegalBy: { message: Ge.message, index: Ne, context: E.slice(Ne - 100, Ne + 100), mode: Ge.mode, resultSoFar: me }, _emitter: Oe };
      if (s) return { language: w, value: By(E), illegal: false, relevance: 0, errorRaised: Ge, _emitter: Oe, _top: ce };
      throw Ge;
    }
  }
  function m(w) {
    const E = { value: By(w), illegal: false, relevance: 0, _top: a, _emitter: new o.__emitter(o) };
    return E._emitter.addText(w), E;
  }
  function v(w, E) {
    E = E || o.languages || Object.keys(e);
    const M = m(w), x = E.filter(P).filter(L).map((K) => h(K, w, false));
    x.unshift(M);
    const g = x.sort((K, Y) => {
      if (K.relevance !== Y.relevance) return Y.relevance - K.relevance;
      if (K.language && Y.language) {
        if (P(K.language).supersetOf === Y.language) return 1;
        if (P(Y.language).supersetOf === K.language) return -1;
      }
      return 0;
    }), [k, T] = g, O = k;
    return O.secondBest = T, O;
  }
  function b(w, E, M) {
    const x = E && n[E] || M;
    w.classList.add("hljs"), w.classList.add(`language-${x}`);
  }
  function A(w) {
    let E = null;
    const M = c(w);
    if (f(M)) return;
    if (d("before:highlightElement", { el: w, language: M }), w.dataset.highlighted) {
      console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", w);
      return;
    }
    if (w.children.length > 0 && (o.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(w)), o.throwUnescapedHTML)) throw new yve("One of your code blocks includes unescaped HTML.", w.innerHTML);
    E = w;
    const x = E.textContent, g = M ? l(x, { language: M, ignoreIllegals: true }) : v(x);
    w.innerHTML = g.value, w.dataset.highlighted = "yes", b(w, M, g.language), w.result = { language: g.language, re: g.relevance, relevance: g.relevance }, g.secondBest && (w.secondBest = { language: g.secondBest.language, relevance: g.secondBest.relevance }), d("after:highlightElement", { el: w, result: g, text: x });
  }
  function _(w) {
    o = FB(o, w);
  }
  const C = () => {
    $(), Q0("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
  };
  function I() {
    $(), Q0("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
  }
  let S = false;
  function $() {
    function w() {
      $();
    }
    if (document.readyState === "loading") {
      S || window.addEventListener("DOMContentLoaded", w, false), S = true;
      return;
    }
    document.querySelectorAll(o.cssSelector).forEach(A);
  }
  function F(w, E) {
    let M = null;
    try {
      M = E(t3);
    } catch (x) {
      if (n0("Language definition for '{}' could not be registered.".replace("{}", w)), s) n0(x);
      else throw x;
      M = a;
    }
    M.name || (M.name = w), e[w] = M, M.rawDefinition = E.bind(null, t3), M.aliases && N(M.aliases, { languageName: w });
  }
  function U(w) {
    delete e[w];
    for (const E of Object.keys(n)) n[E] === w && delete n[E];
  }
  function Q() {
    return Object.keys(e);
  }
  function P(w) {
    return w = (w || "").toLowerCase(), e[w] || e[n[w]];
  }
  function N(w, { languageName: E }) {
    typeof w == "string" && (w = [w]), w.forEach((M) => {
      n[M.toLowerCase()] = E;
    });
  }
  function L(w) {
    const E = P(w);
    return E && !E.disableAutodetect;
  }
  function B(w) {
    w["before:highlightBlock"] && !w["before:highlightElement"] && (w["before:highlightElement"] = (E) => {
      w["before:highlightBlock"](Object.assign({ block: E.el }, E));
    }), w["after:highlightBlock"] && !w["after:highlightElement"] && (w["after:highlightElement"] = (E) => {
      w["after:highlightBlock"](Object.assign({ block: E.el }, E));
    });
  }
  function u(w) {
    B(w), r.push(w);
  }
  function p(w) {
    const E = r.indexOf(w);
    E !== -1 && r.splice(E, 1);
  }
  function d(w, E) {
    const M = w;
    r.forEach(function(x) {
      x[M] && x[M](E);
    });
  }
  function y(w) {
    return Q0("10.7.0", "highlightBlock will be removed entirely in v12.0"), Q0("10.7.0", "Please use highlightElement now."), A(w);
  }
  Object.assign(t3, { highlight: l, highlightAuto: v, highlightAll: $, highlightElement: A, highlightBlock: y, configure: _, initHighlighting: C, initHighlightingOnLoad: I, registerLanguage: F, unregisterLanguage: U, listLanguages: Q, getLanguage: P, registerAliases: N, autoDetection: L, inherit: FB, addPlugin: u, removePlugin: p }), t3.debugMode = function() {
    s = false;
  }, t3.safeMode = function() {
    s = true;
  }, t3.versionString = vve, t3.regex = { concat: k0, lookahead: XF, either: V4, optional: D2e, anyNumberOfTimes: T2e };
  for (const w in vp) typeof vp[w] == "object" && ZF(vp[w]);
  return Object.assign(t3, vp), t3;
}, Ou = fP({});
Ou.newInstance = () => fP({});
var Ave = Ou;
Ou.HighlightJS = Ou;
Ou.default = Ou;
const NB = Fa(Ave);
function wve(t3) {
  const e = t3.regex, n = new RegExp("[\\p{XID_Start}_]\\p{XID_Continue}*", "u"), r = ["and", "as", "assert", "async", "await", "break", "case", "class", "continue", "def", "del", "elif", "else", "except", "finally", "for", "from", "global", "if", "import", "in", "is", "lambda", "match", "nonlocal|10", "not", "or", "pass", "raise", "return", "try", "while", "with", "yield"], o = { $pattern: /[A-Za-z]\w+|__\w+__/, keyword: r, built_in: ["__import__", "abs", "all", "any", "ascii", "bin", "bool", "breakpoint", "bytearray", "bytes", "callable", "chr", "classmethod", "compile", "complex", "delattr", "dict", "dir", "divmod", "enumerate", "eval", "exec", "filter", "float", "format", "frozenset", "getattr", "globals", "hasattr", "hash", "help", "hex", "id", "input", "int", "isinstance", "issubclass", "iter", "len", "list", "locals", "map", "max", "memoryview", "min", "next", "object", "oct", "open", "ord", "pow", "print", "property", "range", "repr", "reversed", "round", "set", "setattr", "slice", "sorted", "staticmethod", "str", "sum", "super", "tuple", "type", "vars", "zip"], literal: ["__debug__", "Ellipsis", "False", "None", "NotImplemented", "True"], type: ["Any", "Callable", "Coroutine", "Dict", "List", "Literal", "Generic", "Optional", "Sequence", "Set", "Tuple", "Type", "Union"] }, f = { className: "meta", begin: /^(>>>|\.\.\.) / }, c = { className: "subst", begin: /\{/, end: /\}/, keywords: o, illegal: /#/ }, l = { begin: /\{\{/, relevance: 0 }, h = { className: "string", contains: [t3.BACKSLASH_ESCAPE], variants: [{ begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/, end: /'''/, contains: [t3.BACKSLASH_ESCAPE, f], relevance: 10 }, { begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/, end: /"""/, contains: [t3.BACKSLASH_ESCAPE, f], relevance: 10 }, { begin: /([fF][rR]|[rR][fF]|[fF])'''/, end: /'''/, contains: [t3.BACKSLASH_ESCAPE, f, l, c] }, { begin: /([fF][rR]|[rR][fF]|[fF])"""/, end: /"""/, contains: [t3.BACKSLASH_ESCAPE, f, l, c] }, { begin: /([uU]|[rR])'/, end: /'/, relevance: 10 }, { begin: /([uU]|[rR])"/, end: /"/, relevance: 10 }, { begin: /([bB]|[bB][rR]|[rR][bB])'/, end: /'/ }, { begin: /([bB]|[bB][rR]|[rR][bB])"/, end: /"/ }, { begin: /([fF][rR]|[rR][fF]|[fF])'/, end: /'/, contains: [t3.BACKSLASH_ESCAPE, l, c] }, { begin: /([fF][rR]|[rR][fF]|[fF])"/, end: /"/, contains: [t3.BACKSLASH_ESCAPE, l, c] }, t3.APOS_STRING_MODE, t3.QUOTE_STRING_MODE] }, m = "[0-9](_?[0-9])*", v = `(\\b(${m}))?\\.(${m})|\\b(${m})\\.`, b = `\\b|${r.join("|")}`, A = { className: "number", relevance: 0, variants: [{ begin: `(\\b(${m})|(${v}))[eE][+-]?(${m})[jJ]?(?=${b})` }, { begin: `(${v})[jJ]?` }, { begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${b})` }, { begin: `\\b0[bB](_?[01])+[lL]?(?=${b})` }, { begin: `\\b0[oO](_?[0-7])+[lL]?(?=${b})` }, { begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${b})` }, { begin: `\\b(${m})[jJ](?=${b})` }] }, _ = { className: "comment", begin: e.lookahead(/# type:/), end: /$/, keywords: o, contains: [{ begin: /# type:/ }, { begin: /#/, end: /\b\B/, endsWithParent: true }] }, C = { className: "params", variants: [{ className: "", begin: /\(\s*\)/, skip: true }, { begin: /\(/, end: /\)/, excludeBegin: true, excludeEnd: true, keywords: o, contains: ["self", f, A, h, t3.HASH_COMMENT_MODE] }] };
  return c.contains = [h, A, f], { name: "Python", aliases: ["py", "gyp", "ipython"], unicodeRegex: true, keywords: o, illegal: /(<\/|\?)|=>/, contains: [f, A, { scope: "variable.language", match: /\bself\b/ }, { beginKeywords: "if", relevance: 0 }, { match: /\bor\b/, scope: "keyword" }, h, _, t3.HASH_COMMENT_MODE, { match: [/\bdef/, /\s+/, n], scope: { 1: "keyword", 3: "title.function" }, contains: [C] }, { variants: [{ match: [/\bclass/, /\s+/, n, /\s*/, /\(\s*/, n, /\s*\)/] }, { match: [/\bclass/, /\s+/, n] }], scope: { 1: "keyword", 3: "title.class", 6: "title.class.inherited" } }, { className: "meta", begin: /^[\t ]*@/, end: /(?=#)|$/, contains: [A, C, h] }] };
}
function xve(t3) {
  let e, n, r;
  return { c() {
    e = H("p"), e.textContent = `This attack involves trying every possible key until the correct one is found. 
        While this attack is simple to implement, it can be time-consuming and computationally expensive, 
        especially for longer keys. I implemented a simple Python code simulating a brute force attack:`, n = z(), r = H("pre"), r.innerHTML = `<code class="language-python" style="border-radius: 8px;">
import itertools, string

target_password = &quot;abc&quot;
characters = string.ascii_lowercase

def brute_force_attack():
    # Trying passwords of length 1 to 4
    for length in range(1, 5):
        for guess in itertools.product(characters, repeat=length):
            guess = &quot;&quot;.join(guess)
            
            print(f&quot;Trying: {guess}&quot;) 
            
            if guess == target_password:
                print(f&quot;Password found: {guess}&quot;)
                return

    print(&quot;Password not found.&quot;)

brute_force_attack()
    </code>`, V(r, "class", "svelte-10ygu6");
  }, m(s, i) {
    R(s, e, i), R(s, n, i), R(s, r, i);
  }, p: dt, d(s) {
    s && (D(e), D(n), D(r));
  } };
}
function _ve(t3) {
  let e, n;
  return e = new Rt({ props: { title: "About Brute Force Attack", links: t3[0], $$slots: { default: [xve] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, [s]) {
    const i = {};
    s & 2 && (i.$$scope = { dirty: s, ctx: r }), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function Eve(t3) {
  return NB.registerLanguage("python", wve), qb(() => {
    NB.highlightAll();
  }), [[{ text: "Wikipedia", url: "https://en.wikipedia.org/wiki/Brute-force_attack" }, { text: "Cybernews", url: "https://cybernews.com/security/what-is-a-brute-force-attack/" }]];
}
class Bve extends xt {
  constructor(e) {
    super(), wt(this, e, Eve, _ve, At, {});
  }
}
function Cve(t3) {
  let e, n, r;
  return { c() {
    e = we(`This attack is similar to Chosen-Plaintext Attack (CPA) 
    but more powerful. Here, the attacker requests the cipher texts of 
    additional plaintexts after they have ciphertexts for some texts. `), n = H("br"), r = H("br");
  }, m(s, i) {
    R(s, e, i), R(s, n, i), R(s, r, i);
  }, p: dt, d(s) {
    s && (D(e), D(n), D(r));
  } };
}
function kve(t3) {
  let e, n;
  return e = new Rt({ props: { title: "About Adaptive Chosen-Plaintext Attack", links: t3[0], $$slots: { default: [Cve] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, [s]) {
    const i = {};
    s & 2 && (i.$$scope = { dirty: s, ctx: r }), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function Ive(t3) {
  return [[{ text: "Stackexchange", url: "https://crypto.stackexchange.com/questions/24791/what-is-the-difference-between-chosen-plaintext-attack-and-adaptive-chosen-plain" }]];
}
class Sve extends xt {
  constructor(e) {
    super(), wt(this, e, Ive, kve, At, {});
  }
}
function Mve(t3) {
  let e, n;
  return { c() {
    e = we(`This attack exploits the probability of two or more individuals sharing 
    the same birthday in a group of people. In cryptography, this attack is used to find 
    collisions in hash functions and digital signatures. It relies on the statistical principle 
    that in a sufficiently large set of randomly chosen items, the probability of two items 
    colliding is higher than intuition suggests. For example, in a group of 23 people, there's a 50% 
    chance that two people share the same birthday. This is much lower than the expected 183 people 
    needed if checking one-by-one (365/2). Similarly, in cryptographic hash functions: 
    `), n = H("ul"), n.innerHTML = "<li>Used against <b>hash functions</b> (MD5, SHA-1, etc.) to find two inputs that produce the same hash.</li> <li>If a hash function produces <b>n-bit outputs</b>, then brute-force searching for a collision takes <b>2<sup>n</sup> operations.</b></li> <li>Using the birthday paradox, a collision can be found in approximately <b>2<sup>(n/2)</sup> operations</b> (much faster).</li> <li>Can weaken <b>digital signatures</b> by creating two different messages with the same hash.</li>";
  }, m(r, s) {
    R(r, e, s), R(r, n, s);
  }, p: dt, d(r) {
    r && (D(e), D(n));
  } };
}
function $ve(t3) {
  let e, n;
  return e = new Rt({ props: { title: "About Birthday Attack", links: t3[0], $$slots: { default: [Mve] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, [s]) {
    const i = {};
    s & 2 && (i.$$scope = { dirty: s, ctx: r }), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function Tve(t3) {
  return [[{ text: "Wikipedia", url: "https://en.wikipedia.org/wiki/Birthday_attack" }, { text: "Shree Learning Academy - YTB video", url: "https://www.youtube.com/watch?v=tkFeRAyePAI" }, { text: "Geeks for Geeks", url: "https://www.geeksforgeeks.org/birthday-attack-in-cryptography/" }, { text: "Twingate", url: "https://www.twingate.com/blog/glossary/birthday%20attack" }]];
}
class Dve extends xt {
  constructor(e) {
    super(), wt(this, e, Tve, $ve, At, {});
  }
}
function Rve(t3) {
  let e, n;
  return { c() {
    e = we(`Black-bag cryptanalysis refers to the practice of gaining access 
    to encrypted information by physically compromising the system rather than breaking 
    the encryption mathematically. This typically involves covert operations like: 
    `), n = H("ul"), n.innerHTML = `<li><b>Physical Theft or Covert Entry: </b>Physically stealing a device, hard drive, or security token to extract cryptographic keys.</li> <li><b>Hardware Implants &amp; Keyloggers: </b>Installing hidden hardware that captures passwords or encryption keys as they are entered 
    (or trojan horse software or hardware installed on (or near to) target computers).</li> <li><b>Cold Boot Attacks: </b>Extracting encryption keys from RAM before data fades after a reboot.</li> <li><b>Side-Channel Attacks: </b>Monitoring power consumption, electromagnetic radiation, or acoustic signals to infer encryption keys.</li> <li><b>Social Engineering: </b>Tricking users into revealing passwords, using phishing or pretexting.</li>`;
  }, m(r, s) {
    R(r, e, s), R(r, n, s);
  }, p: dt, d(r) {
    r && (D(e), D(n));
  } };
}
function Fve(t3) {
  let e, n;
  return e = new Rt({ props: { title: "About Black Bag Cryptanalysis", links: t3[0], $$slots: { default: [Rve] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, [s]) {
    const i = {};
    s & 2 && (i.$$scope = { dirty: s, ctx: r }), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function Pve(t3) {
  return [[{ text: "Wikipedia", url: "https://en.wikipedia.org/wiki/Black-bag_cryptanalysis" }]];
}
class Nve extends xt {
  constructor(e) {
    super(), wt(this, e, Pve, Fve, At, {});
  }
}
function Uve(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U;
  return { c() {
    e = we(`In this type of attack, only some cipher-text is known and the attacker 
    tries to find the corresponding encryption key and plaintext. Its the hardest to implement 
    but is the most probable attack as only ciphertext is required. Most common methods used in 
    a ciphertext-only attack are: frequency analysis, statistical analysis, dictionary attacks.
    `), n = H("ul"), n.innerHTML = "<li>The attacker has no knowledge of the plaintext or the encryption key.</li> <li>The only available information is one or more ciphertexts.</li> <li>The goal is to infer information about the plaintexts or recover the encryption key.</li>", r = z(), s = H("b"), s.textContent = "Example: Ciphertext-only attack with frequency analysis", i = H("br"), a = we(`
    Let's say Eve (the attacker) intercepts the encrypted message: `), o = H("b"), o.textContent = "WKH HDJOH KDV ODQGHG", f = we(`. 
    She does not know the plaintext or the encryption key, she only has the ciphertext. 
    She suspects Caesar Cipher is used and she is going to analyze the ciphertext. 
    Eve applies frequency analysis. The most common letter in English is `), c = H("b"), c.textContent = "E", l = we(", followed by "), h = H("b"), h.textContent = "T, A, O, I, N ,S.", m = we(` 
    By checking which letters appear most frequently in the ciphertext, Eve can guess the shift. 
    If we analyze the ciphertext and assume that the letter `), v = H("b"), v.textContent = "E", b = we(" maps to "), A = H("b"), A.textContent = "H", _ = we(", that suggests a shift of "), C = H("b"), C.textContent = "+3.", I = we(` 
    Since we suspect a shift of +3, shifting each letter backward by 3 in the alphabet gives: `), S = H("b"), S.textContent = "THE EAGLE HAS LANDED", $ = we("."), F = H("br"), U = H("br");
  }, m(Q, P) {
    R(Q, e, P), R(Q, n, P), R(Q, r, P), R(Q, s, P), R(Q, i, P), R(Q, a, P), R(Q, o, P), R(Q, f, P), R(Q, c, P), R(Q, l, P), R(Q, h, P), R(Q, m, P), R(Q, v, P), R(Q, b, P), R(Q, A, P), R(Q, _, P), R(Q, C, P), R(Q, I, P), R(Q, S, P), R(Q, $, P), R(Q, F, P), R(Q, U, P);
  }, p: dt, d(Q) {
    Q && (D(e), D(n), D(r), D(s), D(i), D(a), D(o), D(f), D(c), D(l), D(h), D(m), D(v), D(b), D(A), D(_), D(C), D(I), D(S), D($), D(F), D(U));
  } };
}
function Lve(t3) {
  let e, n;
  return e = new Rt({ props: { title: "About Ciphertext-Only Analysis", links: t3[0], $$slots: { default: [Uve] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, [s]) {
    const i = {};
    s & 2 && (i.$$scope = { dirty: s, ctx: r }), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function Ove(t3) {
  return [[{ text: "Wikipedia", url: "https://en.wikipedia.org/wiki/Ciphertext-only_attack" }, { text: "Kinda Technical", url: "https://kindatechnical.com/cryptography/lesson-34-ciphertext-only-attack.html" }]];
}
class Qve extends xt {
  constructor(e) {
    super(), wt(this, e, Ove, Lve, At, {});
  }
}
function Kve(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b;
  return { c() {
    e = we(`In this type of attack the attacker can choose arbitrary plaintexts and obtain their corresponding 
    ciphertexts. This capability allows the attacker to analyze how the encryption algorithm processes different inputs 
    , potentially revealing weaknesses in the encryption scheme. Its very simple to implement like 
    `), n = H("a"), n.textContent = "KPA", r = we(` but the success rate 
    is quite low. The attacker has the ability to select plaintexts and observe their encrypted outputs. Information about the 
    encryption key and the structure of the encryption algorithm can be uncovered. `), s = H("br"), i = H("br"), a = z(), o = H("b"), o.textContent = "Example: Chosen-Plaintext attack on Caesar Cipher", f = z(), c = H("br"), l = we(`
    Let's say Eve (the attacker) suspects a system is using Caesar Cipher for encryption. Eve can input plaintext messages and 
    observe their encrypted versions. She selects the plaintext: ABCDEFGHIJKLMNOPQRSTUVWXYZ and then the system encrypts this 
    plaintext and returns the output: CIPHERTEXT:  DEFGHIJKLMNOPQRSTUVWXYZABC. `), h = H("br"), m = we(`
    Eve then analyzes the output by comparing the plaintext to the ciphertext and she deduces the shift: A->D, B->E, C->F, etc.
    Since the shift is consistent for every letter, Eve determines that the encryption uses a Caesar cipher with a shift of 3. `), v = H("br"), b = H("br"), V(n, "href", "https://cointelegraph.com/explained/known-plaintext-attacks-explained");
  }, m(A, _) {
    R(A, e, _), R(A, n, _), R(A, r, _), R(A, s, _), R(A, i, _), R(A, a, _), R(A, o, _), R(A, f, _), R(A, c, _), R(A, l, _), R(A, h, _), R(A, m, _), R(A, v, _), R(A, b, _);
  }, p: dt, d(A) {
    A && (D(e), D(n), D(r), D(s), D(i), D(a), D(o), D(f), D(c), D(l), D(h), D(m), D(v), D(b));
  } };
}
function Hve(t3) {
  let e, n;
  return e = new Rt({ props: { title: "About Chosen-Plaintext Analysis", links: t3[0], $$slots: { default: [Kve] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, [s]) {
    const i = {};
    s & 2 && (i.$$scope = { dirty: s, ctx: r }), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function qve(t3) {
  return [[{ text: "Wikipedia", url: "https://en.wikipedia.org/wiki/Chosen-plaintext_attack" }, { text: "Baeldung", url: "https://www.baeldung.com/cs/cryptography-known-plaintext-attack-vs-chosen-plaintext-attack" }, { text: "NordVPN", url: "https://nordvpn.com/cybersecurity/glossary/chosen-plaintext-attack/" }]];
}
class zve extends xt {
  constructor(e) {
    super(), wt(this, e, qve, Hve, At, {});
  }
}
function Gve(t3) {
  let e, n, r, s, i, a, o, f, c, l, h;
  return { c() {
    e = we(`The Davies attack is a method used to break the Data Encryption Standard (DES). 
    It was created in 1987 by Donald Davies and works by studying patterns in how DES processes data. `), n = H("br"), r = we(`
    The attack takes advantage of weaknesses in the way DES mixes and transforms data, specifically 
    in certain parts of its internal structure called S-boxes. By analyzing a large number of encrypted 
    messages alongside their original unencrypted versions (known-plaintext attack), the attacker can 
    find clues about the encryption key. `), s = H("br"), i = we(`
    With enough data\u2014about 2`), a = H("sup"), a.textContent = "25", o = we(` of these message pairs\u2014the attacker can figure out almost 
    half of the key (24 out of 56 bits). The rest of the key can then be found by brute force, which means 
    trying all possible combinations until the correct one is found. `), f = H("br"), c = we(`
    This technique isn\u2019t just for DES; similar methods have been used to test the security of other 
    encryption systems that use a similar design. `), l = H("br"), h = H("br");
  }, m(m, v) {
    R(m, e, v), R(m, n, v), R(m, r, v), R(m, s, v), R(m, i, v), R(m, a, v), R(m, o, v), R(m, f, v), R(m, c, v), R(m, l, v), R(m, h, v);
  }, p: dt, d(m) {
    m && (D(e), D(n), D(r), D(s), D(i), D(a), D(o), D(f), D(c), D(l), D(h));
  } };
}
function Vve(t3) {
  let e, n;
  return e = new Rt({ props: { title: "About Davies' Attack", links: t3[0], $$slots: { default: [Gve] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, [s]) {
    const i = {};
    s & 2 && (i.$$scope = { dirty: s, ctx: r }), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function Yve(t3) {
  return [[{ text: "Wikipedia", url: "https://en.wikipedia.org/wiki/Davies_attack" }, { text: "ResearchGate", url: "https://www.researchgate.net/publication/2386605_An_improvement_of_Davies%27_attack_on_DES" }, { text: "Springer", url: "https://link.springer.com/content/pdf/10.1007/s001459900027.pdf" }]];
}
class Wve extends xt {
  constructor(e) {
    super(), wt(this, e, Yve, Vve, At, {});
  }
}
function Jve(t3) {
  let e, n, r, s;
  return { c() {
    e = we(`Harvest Now, Decrypt Later (HNDL) Attacks refer to a cybersecurity threat 
    where attackers collect and store encrypted data today with the expectation that future 
    advancements\u2014particularly in `), n = H("a"), n.textContent = "quantum computing", r = we(`-
    will allow them to decrypt it later. This is a major concern for organizations handling sensitive data, as 
    encryption methods that are secure today may become obsolete in the future. 
    `), s = H("ul"), s.innerHTML = "<li>Attackers intercept and store encrypted data through network eavesdropping, cyber espionage, or breaches.</li> <li>The encrypted data is kept for years or even decades.</li> <li>When quantum computers become powerful enough, they can break widely used encryption algorithms (like <b>RSA</b> and <b>ECC</b>) using algorithms such as <b>Shor&#39;s algorithm</b>.</li> <li>Once decryption is feasible, attackers access sensitive information, which could include government secrets, financial records, intellectual property, or personal data.</li>", V(n, "href", "https://en.wikipedia.org/wiki/Quantum_computing");
  }, m(i, a) {
    R(i, e, a), R(i, n, a), R(i, r, a), R(i, s, a);
  }, p: dt, d(i) {
    i && (D(e), D(n), D(r), D(s));
  } };
}
function Zve(t3) {
  let e, n;
  return e = new Rt({ props: { title: "About Harvest now, Decrypt later", links: t3[0], $$slots: { default: [Jve] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, [s]) {
    const i = {};
    s & 2 && (i.$$scope = { dirty: s, ctx: r }), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function jve(t3) {
  return [[{ text: "Wikipedia", url: "https://en.wikipedia.org/wiki/Harvest_now,_decrypt_later" }, { text: "VentureBeat", url: "https://venturebeat.com/security/harvest-now-decrypt-later-why-hackers-are-waiting-for-quantum-computing/" }, { text: "Tech Monitor", url: "https://www.techmonitor.ai/hardware/quantum/harvest-now-decrypt-later-cyberattack-quantum-computer" }, { text: "Security Boulevard", url: "https://securityboulevard.com/2024/10/what-you-need-to-know-about-harvest-now-decrypt-later-attacks/" }]];
}
class Xve extends xt {
  constructor(e) {
    super(), wt(this, e, jve, Zve, At, {});
  }
}
function eye(t3) {
  let e, n, r;
  return { c() {
    e = we(`Integral cryptanalysis is a cryptanalytic attack used in the cryptanalysis of 
    block ciphers, particularly those based on substitution-permutation networks (SPNs). 
    It was first introduced by Lars Knudsen and is considered an extension of differential cryptanalysis. `), n = H("br"), r = H("br");
  }, m(s, i) {
    R(s, e, i), R(s, n, i), R(s, r, i);
  }, p: dt, d(s) {
    s && (D(e), D(n), D(r));
  } };
}
function tye(t3) {
  let e, n;
  return e = new Rt({ props: { title: "About Integral Cryptanalysis", links: t3[0], $$slots: { default: [eye] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, [s]) {
    const i = {};
    s & 2 && (i.$$scope = { dirty: s, ctx: r }), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function rye(t3) {
  return [[{ text: "Wikipedia", url: "https://en.wikipedia.org/wiki/Integral_cryptanalysis" }, { text: "SpringerLink", url: "https://link.springer.com/chapter/10.1007/3-540-45661-9_9" }, { text: "The International Association for Cryptologic Research", url: "https://iacr.org/submit/files/slides/2024/asiacrypt/asiacrypt2024/145/145_slides.pdf" }]];
}
class nye extends xt {
  constructor(e) {
    super(), wt(this, e, rye, tye, At, {});
  }
}
function iye(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F;
  return { c() {
    e = we(`In this type of attack, some plaintext-ciphertext pairs are already known. 
    Attacker maps them in order to find the encryption algorithm or the encryption key. This attack 
    is easier to use as a lot of information is already available. To exploit plaintext and ciphertext 
    two common techniques are used: `), n = H("a"), n.textContent = "frequency analysis", r = we(` 
    and `), s = H("a"), s.textContent = "pattern matching", i = we(". "), a = H("br"), o = H("br"), f = z(), c = H("b"), c.textContent = "Example: Known-Plaintext attack in Caesar Cipher", l = H("br"), h = we(`
    Let's say Alice and Bob are communicating using a Caesar cipher, and Eve, 
    the attacker, intercepts some encrypted messages. Eve also manages to obtain the original plaintext of one message. 
    She uses this information to decrypt other messages. `), m = H("br"), v = H("br"), b = we(`
    Eve intercepts this ciphertext message: Wklv lv d vhfuhw phvvdjh. She also somehow acquires the corresponding plaintext: 
    This is a secret message. `), A = H("br"), _ = H("br"), C = we(`
    By comparing plaintext and ciphertext, Eve deduces the shift: `), I = H("br"), S = we(`
    T -> W, h -> k, i -> l, s -> v, etc. Each letter is shifted +3 positions in the alphabet, meaning Caesar cipher 
    with a shift of 3 was used. Now, for each ciphertext message Eve intercepts, she will shift back -3 to decrypt. `), $ = H("br"), F = H("br"), V(n, "href", "https://en.wikipedia.org/wiki/Frequency_analysis"), V(s, "href", "https://en.wikipedia.org/wiki/Pattern_matching");
  }, m(U, Q) {
    R(U, e, Q), R(U, n, Q), R(U, r, Q), R(U, s, Q), R(U, i, Q), R(U, a, Q), R(U, o, Q), R(U, f, Q), R(U, c, Q), R(U, l, Q), R(U, h, Q), R(U, m, Q), R(U, v, Q), R(U, b, Q), R(U, A, Q), R(U, _, Q), R(U, C, Q), R(U, I, Q), R(U, S, Q), R(U, $, Q), R(U, F, Q);
  }, p: dt, d(U) {
    U && (D(e), D(n), D(r), D(s), D(i), D(a), D(o), D(f), D(c), D(l), D(h), D(m), D(v), D(b), D(A), D(_), D(C), D(I), D(S), D($), D(F));
  } };
}
function sye(t3) {
  let e, n;
  return e = new Rt({ props: { title: "About Known-Plaintext Analysis", links: t3[0], $$slots: { default: [iye] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, [s]) {
    const i = {};
    s & 2 && (i.$$scope = { dirty: s, ctx: r }), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function aye(t3) {
  return [[{ text: "Wikipedia", url: "https://en.wikipedia.org/wiki/Known-plaintext_attack" }, { text: "Cointelegraph", url: "https://cointelegraph.com/explained/known-plaintext-attacks-explained" }, { text: "veritasprotocol", url: "https://docs.veritasprotocol.com/guides/understanding-known-plaintext-attacks-and-how-to-prevent-them" }]];
}
class oye extends xt {
  constructor(e) {
    super(), wt(this, e, aye, sye, At, {});
  }
}
function fye(t3) {
  let e, n, r, s, i, a;
  return { c() {
    e = we(`In this type of attack, the attacker secretly intercepts the message/key and 
    potentially alters communication between two communicating parties (without their knowledge) 
    through a secured channel. The attacker positions themselves between the sender and receiver, 
    making it seem like a normal exchange while secretly eavesdropping or manipulating the data. 
    `), n = H("ul"), n.innerHTML = "<li>The attacker intercepts communication between two parties (e.g., a user and a website, or two devices in a network).</li> <li>The attacker may decrypt, alter, or log the transmitted data before forwarding it to the intended recipient.</li> <li>The attacker can impersonate one or both parties, tricking them into thinking they are communicating directly.</li>", r = z(), s = H("b"), s.textContent = "Common MITM Attack Techniques:", i = z(), a = H("ul"), a.innerHTML = "<li><b>Wi-Fi Eavesdropping:</b> Attackers set up fake public Wi-Fi networks to capture user data.</li> <li><b>DNS Spoofing:</b> Redirecting users to a fake website by manipulating DNS records.</li> <li><b>ARP Spoofing:</b> Manipulating the Address Resolution Protocol (ARP) to reroute network traffic.</li>";
  }, m(o, f) {
    R(o, e, f), R(o, n, f), R(o, r, f), R(o, s, f), R(o, i, f), R(o, a, f);
  }, p: dt, d(o) {
    o && (D(e), D(n), D(r), D(s), D(i), D(a));
  } };
}
function lye(t3) {
  let e, n;
  return e = new Rt({ props: { title: "About Man-in-the-middle Attack", links: t3[0], $$slots: { default: [fye] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, [s]) {
    const i = {};
    s & 2 && (i.$$scope = { dirty: s, ctx: r }), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function uye(t3) {
  return [[{ text: "Wikipedia", url: "https://en.wikipedia.org/wiki/Man-in-the-middle_attack" }, { text: "Geeks for Geeks", url: "https://www.geeksforgeeks.org/man-in-the-middle-attack-in-diffie-hellman-key-exchange/" }, { text: "Geekflare", url: "https://geekflare.com/cybersecurity/mitm-attack-tools/" }, { text: "Computerphile - YTB video", url: "https://www.youtube.com/watch?v=-enHfpHMBo4" }]];
}
class cye extends xt {
  constructor(e) {
    super(), wt(this, e, uye, lye, At, {});
  }
}
function hye(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U, Q, P, N, L, B, u;
  return { c() {
    e = we(`Mod N cryptanalysis is an attack that exploits modular arithmetic properties in cryptographic\\n
    algorithms and is applicable to `), n = H("a"), n.textContent = "block", r = we(` and 
    `), s = H("a"), s.textContent = "stream ciphers", i = we(`. It is primarily used to attack cryptographic 
    schemes that rely on modular exponentiation or modular reductions (such as RSA). It was first introduced in 1999 
    by `), a = H("a"), a.textContent = "John Kelsey", o = we(`, 
    `), f = H("a"), f.textContent = "Bruce Schneier", c = we(`, 
    and `), l = H("a"), l.textContent = "David Wagner", h = we(`.
    `), m = H("br"), v = H("br"), b = z(), A = H("b"), A.textContent = "Example: Mod n cryptanalysis in RC5", _ = z(), C = H("br"), I = we(`
    RC5 operates on 32-bit words (or 16/64 bit words) and relies on modular addition, xor operation, and left rotation. An attacker can exploit the 
    structure of modular addition for cryptanalysis
    `), S = H("p"), S.innerHTML = `In RC5, the round function includes: A = (A <span>\u2295</span> B) <span>\u22D8</span> B <b>and</b> B = (B <span>\u2295</span> A) <span>\u22D8</span> A. 
    However, before rotation, modular addition introduces carry bits that may leak information. A cryptanalyst might exploit how carry propagation behaves under mod 2<sup>w</sup> 
    (where w is the word size/bits).`, $ = z(), F = H("p"), F.innerHTML = `If two plaintexts differ by a multiple of 2<sup>w</sup>, their encryption outputs might reveal a pattern. By choosing plaintext pairs where differences cancel out modulo 
    2<sup>w</sup>, an attacker can detect when a carry occurs, reducing key search space. If we analyze modular addition carry propagation, we can find differential pairs that 
    remain unchanged mod 2<sup>w</sup>.`, U = z(), Q = H("ul"), Q.innerHTML = "<li>Choose plaintexts P1,P2 where P1\u2261P2 mod 2<sup>w</sup>.</li> <li>Observe output difference C1-C2 mod 2<sup>w</sup>.</li> <li>If no carry is introduced, we can predict part of the round function behavior.</li> <li>Repeat this to recover key bits by solving for when modular carries occur.</li>", P = we(`
    RC5 is designed to resist most modular arithmetic attacks, but mod 2`), N = H("sup"), N.textContent = "w", L = we(` cryptanalysis can reveal patterns in modular addition 
    carry propagation, assist in differential cryptanalysis and reduce key search space using modular equivalence. `), B = H("br"), u = H("br"), V(n, "href", "https://en.wikipedia.org/wiki/Block_cipher"), V(s, "href", "https://en.wikipedia.org/wiki/Stream_cipher"), V(a, "href", "https://en.wikipedia.org/wiki/John_Kelsey_(cryptanalyst)"), V(f, "href", "https://en.wikipedia.org/wiki/Bruce_Schneier"), V(l, "href", "https://en.wikipedia.org/wiki/David_A._Wagner");
  }, m(p, d) {
    R(p, e, d), R(p, n, d), R(p, r, d), R(p, s, d), R(p, i, d), R(p, a, d), R(p, o, d), R(p, f, d), R(p, c, d), R(p, l, d), R(p, h, d), R(p, m, d), R(p, v, d), R(p, b, d), R(p, A, d), R(p, _, d), R(p, C, d), R(p, I, d), R(p, S, d), R(p, $, d), R(p, F, d), R(p, U, d), R(p, Q, d), R(p, P, d), R(p, N, d), R(p, L, d), R(p, B, d), R(p, u, d);
  }, p: dt, d(p) {
    p && (D(e), D(n), D(r), D(s), D(i), D(a), D(o), D(f), D(c), D(l), D(h), D(m), D(v), D(b), D(A), D(_), D(C), D(I), D(S), D($), D(F), D(U), D(Q), D(P), D(N), D(L), D(B), D(u));
  } };
}
function dye(t3) {
  let e, n;
  return e = new Rt({ props: { title: "About Modulo N Cryptanalysis", links: t3[0], $$slots: { default: [hye] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, [s]) {
    const i = {};
    s & 2 && (i.$$scope = { dirty: s, ctx: r }), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function pye(t3) {
  return [[{ text: "Wikipedia", url: "https://en.wikipedia.org/wiki/Mod_n_cryptanalysis" }, { text: "Mod n cryptanalysis, with Applications against RC5P and M6", url: "https://link.springer.com/chapter/10.1007/3-540-48519-8_11" }, { text: "Schneier on Security", url: "https://www.schneier.com/academic/archives/1999/05/mod_n_cryptanalysis.html" }]];
}
class gye extends xt {
  constructor(e) {
    super(), wt(this, e, pye, dye, At, {});
  }
}
function mye(t3) {
  let e, n, r;
  return { c() {
    e = H("b"), e.textContent = "Power Analysis", n = we(` is a type of side-channel attack that exploits variations 
    in the power consumption of a cryptographic device, like a smartcard, CPU, or other hardware, during 
    cryptographic operations (such as encryption or decryption). The goal is to extract sensitive information
    like cryptographic keys by analyzing how the device's power usage changes while performing operations. 
    This method of attack is powerful because it doesn't require access to the device's internal memory or code; 
    instead, it leverages information that can be obtained from the physical device, making it a significant 
    concern in secure hardware design. There are 3 types of power analysis: 
    `), r = H("ol"), r.innerHTML = `<li><b>Simple Power Analysis (SPA): </b>SPA involves directly observing the power consumption of a device during cryptographic operations.</li> <li><b>Differential Power Analysis (DPA): </b>DPA is a more advanced and sophisticated form of power analysis. 
    It involves statistically analyzing the power consumption during multiple cryptographic operations and comparing power traces taken from different inputs or states.</li> <li><b>Higher-Order Differential Power Analysis (HO-DPA): </b>HO-DPA is an advanced form of DPA attack, but is less widely practiced than SPA and DPA.</li>`;
  }, m(s, i) {
    R(s, e, i), R(s, n, i), R(s, r, i);
  }, p: dt, d(s) {
    s && (D(e), D(n), D(r));
  } };
}
function vye(t3) {
  let e, n;
  return e = new Rt({ props: { title: "About Power Analysis", links: t3[0], $$slots: { default: [mye] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, [s]) {
    const i = {};
    s & 2 && (i.$$scope = { dirty: s, ctx: r }), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function yye(t3) {
  return [[{ text: "Wikipedia", url: "https://en.wikipedia.org/wiki/Power_analysis" }, { text: "AllAboutCircuits", url: "https://www.allaboutcircuits.com/technical-articles/a-basic-introduction-to-power-based-side-channel-attacks/" }, { text: "MDPI", url: "https://www.mdpi.com/2410-387X/4/2/15" }]];
}
class bye extends xt {
  constructor(e) {
    super(), wt(this, e, yye, vye, At, {});
  }
}
function Aye(t3) {
  let e, n, r, s;
  return { c() {
    e = we("A "), n = H("b"), n.textContent = "Rainbow Table", r = we(` is a cryptographic attack technique used for cracking password 
    hashes efficiently. It is a precomputed table of hash values for different possible passwords, 
    allowing an attacker to quickly reverse a hash back into its original password without brute-forcing
    each possibility in real-time. 
    `), s = H("ul"), s.innerHTML = `<li>A large table is generated, mapping plaintext passwords to their corresponding hash values.</li> <li>Instead of storing every possible hash, <b>rainbow tables use chains</b> to reduce space usage. 
    Each chain starts with an initial plaintext password, repeatedly hashed and reduced to a new plaintext until a final hash is stored.</li> <li>When an attacker obtains a hashed password (e.g., from a database breach), they can compare it against the table to find a match, then use the chain to recover the original password.</li> <li>It is faster than brute-force attacks since hashes are precomputed.</li> <li>It is more efficient than a direct lookup table because it uses chains to reduce storage size.</li>`;
  }, m(i, a) {
    R(i, e, a), R(i, n, a), R(i, r, a), R(i, s, a);
  }, p: dt, d(i) {
    i && (D(e), D(n), D(r), D(s));
  } };
}
function wye(t3) {
  let e, n;
  return e = new Rt({ props: { title: "About Rainbow Table Attack", links: t3[0], $$slots: { default: [Aye] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, [s]) {
    const i = {};
    s & 2 && (i.$$scope = { dirty: s, ctx: r }), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function xye(t3) {
  return [[{ text: "Wikipedia", url: "https://en.wikipedia.org/wiki/Rainbow_table" }, { text: "Geeks for Geeks", url: "https://www.geeksforgeeks.org/understanding-rainbow-table-attack/" }, { text: "CrackStation", url: "https://crackstation.net/" }, { text: "RainbowCrack", url: "http://project-rainbowcrack.com/table.htm" }]];
}
class _ye extends xt {
  constructor(e) {
    super(), wt(this, e, xye, wye, At, {});
  }
}
function Eye(t3) {
  let e, n, r, s;
  return { c() {
    e = we("A "), n = H("b"), n.textContent = "replay attack", r = we(` is a type of network attack where an attacker intercepts 
    and retransmits valid data (such as authentication tokens or encrypted messages) to gain 
    unauthorized access or disrupt communication. Since the attacker does not need to decrypt 
    or modify the intercepted data, replay attacks can be effective even against encrypted 
    communication. Steps of how this attack works: 
    `), s = H("ol"), s.innerHTML = `<li>The attacker <b>eavesdrops</b> on a legitimate communication between a user and a server.</li> <li>They <b>capture a valid request or authentication message</b> (e.g., login credentials, 
    digital signatures, session tokens, hashed passwords).</li> <li>The attacker <b>replays</b> this captured message to trick the system into granting access or 
    performing an unintended action.</li>`;
  }, m(i, a) {
    R(i, e, a), R(i, n, a), R(i, r, a), R(i, s, a);
  }, p: dt, d(i) {
    i && (D(e), D(n), D(r), D(s));
  } };
}
function Bye(t3) {
  let e, n;
  return e = new Rt({ props: { title: "About Replay Attack", links: t3[0], $$slots: { default: [Eye] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, [s]) {
    const i = {};
    s & 2 && (i.$$scope = { dirty: s, ctx: r }), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function Cye(t3) {
  return [[{ text: "Wikipedia", url: "https://en.wikipedia.org/wiki/Replay_attack" }, { text: "Geeks for Geeks", url: "https://www.geeksforgeeks.org/replay-attack/" }, { text: "Cyber Security for me", url: "https://cybersecurityforme.com/replay-attack/" }]];
}
class kye extends xt {
  constructor(e) {
    super(), wt(this, e, Cye, Bye, At, {});
  }
}
function Iye(t3) {
  let e, n, r, s, i, a, o, f;
  return { c() {
    e = we("A "), n = H("b"), n.textContent = "related-key attack", r = we(` is a type of cryptanalysis that exploits predictable 
    relationships between multiple encryption keys used in a cryptographic system. Instead of 
    attacking a cipher with a single known key, an attacker analyzes how the algorithm behaves 
    under different but related keys to extract information about the secret key or plaintext. 
    `), s = H("ul"), s.innerHTML = "<li>The attacker gains access to encryptions (or decryptions) performed with multiple keys that have some known mathematical relationship.</li> <li>By studying the patterns or differences in output, they try to deduce the structure of the secret key or find weaknesses in the encryption algorithm.</li> <li>If successful, they can recover parts of the secret key or reduce the effective security of the encryption scheme.</li>", i = z(), a = H("b"), a.textContent = "The Related-Key Attack:", o = z(), f = H("ul"), f.innerHTML = "<li><b>Exploits relationships between keys</b> rather than direct brute-force or statistical analysis of ciphertexts.</li> <li><b>Is more effective on weak key scheduling algorithms</b> (e.g., ciphers where small changes in the key lead to predictable changes in encryption output).</li> <li><b>Is particularly dangerous for block ciphers</b> with poor key expansion functions.</li>";
  }, m(c, l) {
    R(c, e, l), R(c, n, l), R(c, r, l), R(c, s, l), R(c, i, l), R(c, a, l), R(c, o, l), R(c, f, l);
  }, p: dt, d(c) {
    c && (D(e), D(n), D(r), D(s), D(i), D(a), D(o), D(f));
  } };
}
function Sye(t3) {
  let e, n;
  return e = new Rt({ props: { title: "About Related-Key Attack", links: t3[0], $$slots: { default: [Iye] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, [s]) {
    const i = {};
    s & 2 && (i.$$scope = { dirty: s, ctx: r }), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function Mye(t3) {
  return [[{ text: "Wikipedia", url: "https://en.wikipedia.org/wiki/Related-key_attack" }, { text: "Cryptology ePrint Archive", url: "https://eprint.iacr.org/2009/317.pdf" }, { text: "Schneier on Security", url: "https://www.schneier.com/wp-content/uploads/2016/02/paper-relatedkey.pdf" }]];
}
class $ye extends xt {
  constructor(e) {
    super(), wt(this, e, Mye, Sye, At, {});
  }
}
function Tye(t3) {
  let e, n, r, s, i;
  return { c() {
    e = H("b"), e.textContent = "Rubber-hose cryptanalysis", n = we(` is the practice of extracting cryptographic secrets 
    through coercion, such as threats, torture, or intimidation, rather than using mathematical or 
    computational attacks. It is a play on words, implying that instead of using advanced cryptanalysis, 
    an attacker could simply beat the keyholder with a rubber hose until they reveal the decryption key.`), r = H("br"), s = we(`
    Deniable encryption is specifically designed to counter rubber-hose cryptanalysis by allowing users 
    to plausibly deny the existence of sensitive data. Here's how: 
    `), i = H("ul"), i.innerHTML = "<li>A <b>deniable encryption system</b> allows the same encrypted data to be decrypted into different plaintexts depending on the key used.</li> <li>If forced to reveal a key, the user can provide a decoy key that decrypts to harmless data, making it impossible to prove whether additional hidden data exists.</li> <li>Systems like <b>VeraCrypt\u2019s hidden volumes</b> allow users to store sensitive files inside an encrypted container that itself contains a visible, less important set of files.</li> <li>Even if coerced to provide a password, the user can reveal only the decoy container while keeping the true hidden volume secret.</li> <li>Some deniable encryption schemes are used in secure messaging protocols to ensure that even if a user is forced to decrypt a message, they can plausibly claim that the decrypted text was the only message.</li>";
  }, m(a, o) {
    R(a, e, o), R(a, n, o), R(a, r, o), R(a, s, o), R(a, i, o);
  }, p: dt, d(a) {
    a && (D(e), D(n), D(r), D(s), D(i));
  } };
}
function Dye(t3) {
  let e, n;
  return e = new Rt({ props: { title: "About Rubber Hose Cryptanalysis (Deniable Encryption)", links: t3[0], $$slots: { default: [Tye] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, [s]) {
    const i = {};
    s & 2 && (i.$$scope = { dirty: s, ctx: r }), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function Rye(t3) {
  return [[{ text: "Wikipedia", url: "https://en.wikipedia.org/wiki/Deniable_encryption" }, { text: "Schneier on Security", url: "https://www.schneier.com/blog/archives/2008/10/rubber_hose_cry.html" }]];
}
class Fye extends xt {
  constructor(e) {
    super(), wt(this, e, Rye, Dye, At, {});
  }
}
function Pye(t3) {
  let e;
  return { c() {
    e = we(`This type of attack is based on information obtained from the physical 
    implementation of the cryptographic system, rather than on weaknesses in the algorithm 
    itself. Side-channel attacks include timing attacks, power analysis attacks, electromagnetic 
    attacks, and others. In other words, it can exploit unintended information leakage from a 
    system rather than breaking cryptographic algorithms directly. These attacks take advantage of 
    physical characteristics or indirect outputs.`);
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function Nye(t3) {
  let e, n;
  return e = new Rt({ props: { title: "About Side-Channel Attack", links: t3[0], $$slots: { default: [Pye] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, [s]) {
    const i = {};
    s & 2 && (i.$$scope = { dirty: s, ctx: r }), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function Uye(t3) {
  return [[{ text: "Wikipedia", url: "https://en.wikipedia.org/wiki/Side-channel_attack" }, { text: "All about circuits", url: "https://www.allaboutcircuits.com/technical-articles/understanding-side-channel-attack-basics/" }]];
}
class Lye extends xt {
  constructor(e) {
    super(), wt(this, e, Uye, Nye, At, {});
  }
}
function Oye(t3) {
  let e, n, r;
  return { c() {
    e = we("A "), n = H("b"), n.textContent = "slide attack", r = we(` is a cryptographic technique used to analyze the key schedule 
    of a block cipher and exploit weaknesses to break the cipher. The attack exploits the similarity 
    between different rounds of encryption. The slide attack gets its name from the way it exploits 
    the repeated structure of a block cipher to 'slide' one encryption step over another. It works 
    by finding pairs of inputs (P,P\u2032) and outputs (C,C\u2032) that are related in a way that 
    'slides' one round into the next. Imagine you have a deck of cards with the same sequence of
    suits repeating every few cards. If you take two cards at different points in the deck and 
    'slide' one over the other, you might see that the same pattern emerges, helping you predict 
    what comes next. The slide attack works in a similar way, but with encryption rounds instead of cards.`);
  }, m(s, i) {
    R(s, e, i), R(s, n, i), R(s, r, i);
  }, p: dt, d(s) {
    s && (D(e), D(n), D(r));
  } };
}
function Qye(t3) {
  let e, n;
  return e = new Rt({ props: { title: "About Slide Attack", links: t3[0], $$slots: { default: [Oye] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, [s]) {
    const i = {};
    s & 2 && (i.$$scope = { dirty: s, ctx: r }), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function Kye(t3) {
  return [[{ text: "Wikipedia", url: "https://en.wikipedia.org/wiki/Slide_attack" }, { text: "Springer", url: "https://link.springer.com/chapter/10.1007/3-540-48519-8_18" }, { text: "Cryptology ePrint Archive", url: "https://eprint.iacr.org/2016/1177.pdf" }]];
}
class Hye extends xt {
  constructor(e) {
    super(), wt(this, e, Kye, Qye, At, {});
  }
}
function qye(t3) {
  let e, n, r;
  return { c() {
    e = H("b"), e.textContent = "Timing analysis", n = we(` (a side-channel attack) is the process of evaluating the time required for different 
    cryptographic algorithms (or operations/events) in a system. Information can leak from a system through measurement of 
    the time it takes to respond to certain queries. It is commonly used in various fields, including: 
    `), r = H("ul"), r.innerHTML = "<li><b>Digital Circuit Design (Static Timing Analysis - STA)</b>: Ensures a circuit meets timing constraints (setup and hold times).</li> <li><b>Embedded Systems &amp; Real-Time Systems:</b> Includes <b>Worst-Case Execution Time (WCET)</b> analysis.</li> <li><b>Performance Analysis in Software &amp; Algorithms:</b> Used for optimization (e.g., Big-O analysis, profiling).</li> <li><b>Mechanical &amp; Physical Systems:</b> Used in robotics and automation to ensure precise timing.</li>";
  }, m(s, i) {
    R(s, e, i), R(s, n, i), R(s, r, i);
  }, p: dt, d(s) {
    s && (D(e), D(n), D(r));
  } };
}
function zye(t3) {
  let e, n;
  return e = new Rt({ props: { title: "About Timing Analysis Attack", links: t3[0], $$slots: { default: [qye] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, [s]) {
    const i = {};
    s & 2 && (i.$$scope = { dirty: s, ctx: r }), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function Gye(t3) {
  return [[{ text: "Wikipedia", url: "https://en.wikipedia.org/wiki/Timing_attack" }, { text: "Synopsys", url: "https://www.synopsys.com/glossary/what-is-static-timing-analysis.html" }, { text: "Advanced Digital Systems Design", url: "https://schaumont.dyn.wpi.edu/ece574f23/06timing.html" }]];
}
class Vye extends xt {
  constructor(e) {
    super(), wt(this, e, Gye, zye, At, {});
  }
}
function Yye(t3) {
  let e, n, r;
  return { c() {
    e = we("The "), n = H("b"), n.textContent = "eXtended Sparse Linearization (XSL) attack", r = we(` is a theoretical method 
    designed to break certain block ciphers, including AES, by exploiting their algebraic structure. 
    It works by rewriting the encryption process as a system of quadratic equations, which, in theory, 
    could be solved to recover the secret key. 
    The idea behind XSL builds on an earlier method called eXtended Linearization (XL), which attempts 
    to solve multivariate quadratic (MQ) equations by introducing extra equations. However, XSL takes 
    this a step further by choosing equations more selectively, aiming to keep the system manageable and solvable.
    One of the main advantages of XSL (if it were practical) is that it doesn't require massive amounts of 
    plaintext-ciphertext pairs, unlike differential or linear cryptanalysis. Instead, it focuses on the 
    mathematical properties of the cipher itself. 
    That said, most cryptographers remain skeptical about its feasibility. The method relies on assumptions 
    about how many independent equations can be generated, and in practice, it seems that there aren't enough 
    to fully break AES or other ciphers. So while it's an interesting concept, it's never been successfully 
    used to crack real-world encryption.`);
  }, m(s, i) {
    R(s, e, i), R(s, n, i), R(s, r, i);
  }, p: dt, d(s) {
    s && (D(e), D(n), D(r));
  } };
}
function Wye(t3) {
  let e, n;
  return e = new Rt({ props: { title: "About eXtended Sparse Linearization Attack", links: t3[0], $$slots: { default: [Yye] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, [s]) {
    const i = {};
    s & 2 && (i.$$scope = { dirty: s, ctx: r }), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function Jye(t3) {
  return [[{ text: "Wikipedia", url: "https://en.wikipedia.org/wiki/XSL_attack" }, { text: "Cryptology ePrint Archive", url: "https://eprint.iacr.org/2023/151.pdf" }, { text: "DBpedia Association", url: "https://dbpedia.org/page/XSL_attack" }]];
}
class Zye extends xt {
  constructor(e) {
    super(), wt(this, e, Jye, Wye, At, {});
  }
}
class lP extends Bm {
  constructor(e, n) {
    super(), this.finished = false, this.destroyed = false, T0e(e);
    const r = rs(n);
    if (this.iHash = e.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const s = this.blockLen, i = new Uint8Array(s);
    i.set(r.length > s ? e.create().update(r).digest() : r);
    for (let a = 0; a < i.length; a++) i[a] ^= 54;
    this.iHash.update(i), this.oHash = e.create();
    for (let a = 0; a < i.length; a++) i[a] ^= 106;
    this.oHash.update(i), Li(i);
  }
  update(e) {
    return lf(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    lf(this), Ra(e, this.outputLen), this.finished = true, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n, iHash: r, finished: s, destroyed: i, blockLen: a, outputLen: o } = this;
    return e = e, e.finished = s, e.destroyed = i, e.blockLen = a, e.outputLen = o, e.oHash = n._cloneInto(e.oHash), e.iHash = r._cloneInto(e.iHash), e;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
}
const uP = (t3, e, n) => new lP(t3, e).update(n).digest();
uP.create = (t3, e) => new lP(t3, e);
const jye = { "SHA-256": SF, "SHA-512": MF, "SHA-224": Spe, "SHA-384": $F };
function Xye(t3, e, n) {
  if (!t3) throw new Error("Please enter a message.");
  if (!e) throw new Error("Please enter a secret key.");
  const r = jye[n];
  if (!r) throw new Error("Invalid algorithm selected.");
  const s = new TextEncoder(), i = s.encode(e), a = s.encode(t3), o = uP(r, i, a), f = Al(o), c = btoa(String.fromCharCode(...o));
  return { hex: f, base64: c };
}
function e3e(t3) {
  let e;
  return { c() {
    e = we("Generate HMAC");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function t3e(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function UB(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[4]), V(e, "class", "msg error svelte-305b3i");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 16 && Ze(n, r[4]);
  }, d(r) {
    r && D(e);
  } };
}
function LB(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A;
  return { c() {
    e = H("div"), n = H("div"), r = H("label"), s = we("HMAC ("), i = we(t3[2]), a = we(") Hex:"), o = z(), f = H("textarea"), l = z(), h = H("div"), m = H("label"), m.textContent = "Base64:", v = z(), b = H("textarea"), V(r, "class", "svelte-305b3i"), f.readOnly = true, f.value = c = t3[3].hex, V(f, "class", "svelte-305b3i"), V(n, "class", "result-box svelte-305b3i"), V(m, "class", "svelte-305b3i"), b.readOnly = true, b.value = A = t3[3].base64, V(b, "class", "svelte-305b3i"), V(h, "class", "result-box svelte-305b3i"), V(e, "class", "result-section");
  }, m(_, C) {
    R(_, e, C), q(e, n), q(n, r), q(r, s), q(r, i), q(r, a), q(n, o), q(n, f), q(e, l), q(e, h), q(h, m), q(h, v), q(h, b);
  }, p(_, C) {
    C & 4 && Ze(i, _[2]), C & 8 && c !== (c = _[3].hex) && (f.value = c), C & 8 && A !== (A = _[3].base64) && (b.value = A);
  }, d(_) {
    _ && D(e);
  } };
}
function r3e(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C;
  function I(L) {
    t3[8](L);
  }
  let S = { label: "Hashing Algorithm:", options: t3[5] };
  t3[2] !== void 0 && (S.value = t3[2]), e = new Ht({ props: S }), Qe.push(() => ze(e, "value", I));
  function $(L) {
    t3[9](L);
  }
  let F = { label: "Message / Data:", placeholder: "e.g. The quick brown fox..." };
  t3[0] !== void 0 && (F.value = t3[0]), s = new et({ props: F }), Qe.push(() => ze(s, "value", $));
  function U(L) {
    t3[10](L);
  }
  let Q = { label: "Secret Key:", type: "password", placeholder: "e.g. MySecretKey123" };
  t3[1] !== void 0 && (Q.value = t3[1]), o = new et({ props: Q }), Qe.push(() => ze(o, "value", U)), h = new ut({ props: { $$slots: { default: [e3e] }, $$scope: { ctx: t3 } } }), h.$on("click", t3[6]), v = new ut({ props: { variant: "secondary", $$slots: { default: [t3e] }, $$scope: { ctx: t3 } } }), v.$on("click", t3[11]);
  let P = t3[4] && UB(t3), N = t3[3] && LB(t3);
  return { c() {
    fe(e.$$.fragment), r = z(), fe(s.$$.fragment), a = z(), fe(o.$$.fragment), c = z(), l = H("div"), fe(h.$$.fragment), m = z(), fe(v.$$.fragment), b = z(), P && P.c(), A = z(), N && N.c(), _ = Lt(), V(l, "class", "button-row svelte-305b3i");
  }, m(L, B) {
    ae(e, L, B), R(L, r, B), ae(s, L, B), R(L, a, B), ae(o, L, B), R(L, c, B), R(L, l, B), ae(h, l, null), q(l, m), ae(v, l, null), R(L, b, B), P && P.m(L, B), R(L, A, B), N && N.m(L, B), R(L, _, B), C = true;
  }, p(L, B) {
    const u = {};
    !n && B & 4 && (n = true, u.value = L[2], qe(() => n = false)), e.$set(u);
    const p = {};
    !i && B & 1 && (i = true, p.value = L[0], qe(() => i = false)), s.$set(p);
    const d = {};
    !f && B & 2 && (f = true, d.value = L[1], qe(() => f = false)), o.$set(d);
    const y = {};
    B & 4096 && (y.$$scope = { dirty: B, ctx: L }), h.$set(y);
    const w = {};
    B & 4096 && (w.$$scope = { dirty: B, ctx: L }), v.$set(w), L[4] ? P ? P.p(L, B) : (P = UB(L), P.c(), P.m(A.parentNode, A)) : P && (P.d(1), P = null), L[3] ? N ? N.p(L, B) : (N = LB(L), N.c(), N.m(_.parentNode, _)) : N && (N.d(1), N = null);
  }, i(L) {
    C || (W(e.$$.fragment, L), W(s.$$.fragment, L), W(o.$$.fragment, L), W(h.$$.fragment, L), W(v.$$.fragment, L), C = true);
  }, o(L) {
    j(e.$$.fragment, L), j(s.$$.fragment, L), j(o.$$.fragment, L), j(h.$$.fragment, L), j(v.$$.fragment, L), C = false;
  }, d(L) {
    L && (D(r), D(a), D(c), D(l), D(b), D(A), D(_)), oe(e, L), oe(s, L), oe(o, L), oe(h), oe(v), P && P.d(L), N && N.d(L);
  } };
}
function n3e(t3) {
  let e, n, r, s, i, a, o, f, c, l, h;
  return { c() {
    e = H("p"), e.textContent = `HMAC (Hash-based Message Authentication Code) is a widely used cryptographic technique that provides message integrity and authenticity. 
    It combines a cryptographic hash function (such as SHA-256 or MD5) with a secret key to generate a unique message authentication code. This 
    code ensures that the message has not been tampered with and verifies the identity of the sender.`, n = z(), r = H("p"), r.textContent = `HMAC is commonly used in network security protocols, such as TLS, IPsec, and in API authentication mechanisms, where it helps protect against 
    man-in-the-middle attacks and message alteration.`, s = z(), i = H("p"), i.innerHTML = "<strong>How HMAC Works:</strong>", a = z(), o = H("ol"), o.innerHTML = `<li>The message to be authenticated is combined with a secret key using a hashing algorithm (like SHA-256 or SHA-512).</li> <li>HMAC applies the hashing function twice: once to a modified version of the message combined with the key (inner hash), and then again 
    to another modified version of the key combined with the result of the inner hash (outer hash).</li> <li>The final output is the HMAC value, which is used as a signature to authenticate the message.</li>`, f = z(), c = H("p"), c.innerHTML = "<strong>Characteristics of HMAC:</strong>", l = z(), h = H("ul"), h.innerHTML = `<li><strong>Message Integrity:</strong> HMAC ensures that the message has not been modified during transmission. If any part of the message changes, 
    the HMAC value will also change, allowing the recipient to detect tampering.</li> <li><strong>Message Authenticity:</strong> Because HMAC uses a secret key, only those who have the key can generate a valid HMAC. This provides assurance 
    of the sender&#39;s authenticity.</li> <li><strong>Resilience to Cryptographic Attacks:</strong> HMAC is designed to be secure even when the underlying hash function has some vulnerabilities. 
    The use of a secret key adds an additional layer of protection.</li>`;
  }, m(m, v) {
    R(m, e, v), R(m, n, v), R(m, r, v), R(m, s, v), R(m, i, v), R(m, a, v), R(m, o, v), R(m, f, v), R(m, c, v), R(m, l, v), R(m, h, v);
  }, p: dt, d(m) {
    m && (D(e), D(n), D(r), D(s), D(i), D(a), D(o), D(f), D(c), D(l), D(h));
  } };
}
function i3e(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "HMAC Generator", $$slots: { default: [r3e] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About HMAC", links: t3[7], $$slots: { default: [n3e] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 4127 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 4096 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function s3e(t3, e, n) {
  let r = "", s = "", i = "SHA-256", a = null, o = "";
  const f = ["SHA-256", "SHA-512", "SHA-224", "SHA-384"];
  function c() {
    n(4, o = ""), n(3, a = null);
    try {
      n(3, a = Xye(r, s, i));
    } catch (A) {
      n(4, o = A.message);
    }
  }
  const l = [{ text: "HMAC - Wikipedia", url: "https://en.wikipedia.org/wiki/HMAC" }, { text: "@noble/hashes - NPM Package", url: "https://www.npmjs.com/package/@noble/hashes#hmac" }];
  function h(A) {
    i = A, n(2, i);
  }
  function m(A) {
    r = A, n(0, r);
  }
  function v(A) {
    s = A, n(1, s);
  }
  return [r, s, i, a, o, f, c, l, h, m, v, () => {
    n(0, r = ""), n(1, s = ""), n(3, a = null);
  }];
}
class a3e extends xt {
  constructor(e) {
    super(), wt(this, e, s3e, i3e, At, {});
  }
}
function o3e(t3) {
  if (!t3) throw new Error("Please enter text to analyze.");
  const e = t3.toLowerCase().replace(/[^a-z]/g, ""), n = e.length;
  if (n === 0) throw new Error("No alphabetic characters found in the text.");
  const r = {};
  for (const a of e) r[a] = (r[a] || 0) + 1;
  const s = Object.keys(r).map((a) => {
    const o = r[a];
    return { char: a, count: o, percent: o / n * 100 };
  }).sort((a, o) => o.count - a.count), i = s.length > 0 ? s[0] : null;
  return { totalChars: n, uniqueChars: s.length, mostCommon: i, data: s };
}
function OB(t3, e, n) {
  const r = t3.slice();
  return r[14] = e[n], r;
}
function QB(t3, e, n) {
  const r = t3.slice();
  return r[17] = e[n], r;
}
function KB(t3, e, n) {
  const r = t3.slice();
  return r[17] = e[n], r;
}
function f3e(t3) {
  let e;
  return { c() {
    e = we("Analyze Frequency");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function l3e(t3) {
  let e;
  return { c() {
    e = we("Load Example");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function u3e(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function HB(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[3]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 8 && Ze(n, r[3]);
  }, d(r) {
    r && D(e);
  } };
}
function qB(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F = t3[1].totalChars + "", U, Q, P, N, L, B, u = t3[1].uniqueChars + "", p, d, y, w, E, M, x = t3[1].mostCommon.char.toUpperCase() + "", g, k, T = t3[1].mostCommon.percent.toFixed(2) + "", O, K, Y = Mr(t3[5]), J = [];
  for (let se = 0; se < Y.length; se += 1) J[se] = zB(KB(t3, Y, se));
  let G = Mr(t3[5]), X = [];
  for (let se = 0; se < G.length; se += 1) X[se] = GB(QB(t3, G, se));
  let ie = Mr(t3[4]), de = [];
  for (let se = 0; se < ie.length; se += 1) de[se] = VB(OB(t3, ie, se));
  return { c() {
    e = H("div"), n = H("div"), r = H("h3"), r.textContent = "Character Frequency Histogram", s = z(), i = Nr("svg"), a = Nr("g");
    for (let se = 0; se < J.length; se += 1) J[se].c();
    o = Nr("line"), f = Nr("line"), c = Nr("g"), l = Nr("text"), h = we("Frequency");
    for (let se = 0; se < X.length; se += 1) X[se].c();
    m = Nr("g");
    for (let se = 0; se < de.length; se += 1) de[se].c();
    v = Nr("text"), b = we("Characters"), A = z(), _ = H("div"), C = H("div"), I = H("span"), I.textContent = "Total Characters:", S = z(), $ = H("strong"), U = we(F), Q = z(), P = H("div"), N = H("span"), N.textContent = "Unique:", L = z(), B = H("strong"), p = we(u), d = z(), y = H("div"), w = H("span"), w.textContent = "Most Common:", E = z(), M = H("strong"), g = we(x), k = we(" ("), O = we(T), K = we("%)"), V(r, "class", "chart-title svelte-14jfzdb"), V(a, "class", "grid"), V(o, "x1", t3[6].left), V(o, "y1", t3[6].top), V(o, "x2", t3[6].left), V(o, "y2", zo - t3[6].bottom), V(o, "stroke", "#334155"), V(o, "stroke-width", "1"), V(f, "x1", t3[6].left), V(f, "y1", zo - t3[6].bottom), V(f, "x2", Ah - t3[6].right), V(f, "y2", zo - t3[6].bottom), V(f, "stroke", "#334155"), V(f, "stroke-width", "1"), V(l, "x", "15"), V(l, "y", zo / 2), V(l, "transform", "rotate(-90, 15, " + zo / 2 + ")"), V(l, "text-anchor", "middle"), V(l, "class", "axis-title svelte-14jfzdb"), V(c, "class", "y-labels"), V(m, "class", "bars svelte-14jfzdb"), V(v, "x", Ah / 2), V(v, "y", zo - 5), V(v, "text-anchor", "middle"), V(v, "class", "axis-title svelte-14jfzdb"), V(i, "viewBox", "0 0 " + Ah + " " + zo), V(i, "class", "chart-svg svelte-14jfzdb"), V(n, "class", "chart-container svelte-14jfzdb"), V(C, "class", "stat-row svelte-14jfzdb"), V(P, "class", "stat-row svelte-14jfzdb"), V(y, "class", "stat-row svelte-14jfzdb"), V(_, "class", "stats-panel svelte-14jfzdb"), V(e, "class", "results-area svelte-14jfzdb");
  }, m(se, te) {
    R(se, e, te), q(e, n), q(n, r), q(n, s), q(n, i), q(i, a);
    for (let le = 0; le < J.length; le += 1) J[le] && J[le].m(a, null);
    q(i, o), q(i, f), q(i, c), q(c, l), q(l, h);
    for (let le = 0; le < X.length; le += 1) X[le] && X[le].m(c, null);
    q(i, m);
    for (let le = 0; le < de.length; le += 1) de[le] && de[le].m(m, null);
    q(i, v), q(v, b), q(e, A), q(e, _), q(_, C), q(C, I), q(C, S), q(C, $), q($, U), q(_, Q), q(_, P), q(P, N), q(P, L), q(P, B), q(B, p), q(_, d), q(_, y), q(y, w), q(y, E), q(y, M), q(M, g), q(M, k), q(M, O), q(M, K);
  }, p(se, te) {
    if (te & 96) {
      Y = Mr(se[5]);
      let le;
      for (le = 0; le < Y.length; le += 1) {
        const Z = KB(se, Y, le);
        J[le] ? J[le].p(Z, te) : (J[le] = zB(Z), J[le].c(), J[le].m(a, null));
      }
      for (; le < J.length; le += 1) J[le].d(1);
      J.length = Y.length;
    }
    if (te & 96) {
      G = Mr(se[5]);
      let le;
      for (le = 0; le < G.length; le += 1) {
        const Z = QB(se, G, le);
        X[le] ? X[le].p(Z, te) : (X[le] = GB(Z), X[le].c(), X[le].m(c, null));
      }
      for (; le < X.length; le += 1) X[le].d(1);
      X.length = G.length;
    }
    if (te & 80) {
      ie = Mr(se[4]);
      let le;
      for (le = 0; le < ie.length; le += 1) {
        const Z = OB(se, ie, le);
        de[le] ? de[le].p(Z, te) : (de[le] = VB(Z), de[le].c(), de[le].m(m, null));
      }
      for (; le < de.length; le += 1) de[le].d(1);
      de.length = ie.length;
    }
    te & 2 && F !== (F = se[1].totalChars + "") && Ze(U, F), te & 2 && u !== (u = se[1].uniqueChars + "") && Ze(p, u), te & 2 && x !== (x = se[1].mostCommon.char.toUpperCase() + "") && Ze(g, x), te & 2 && T !== (T = se[1].mostCommon.percent.toFixed(2) + "") && Ze(O, T);
  }, d(se) {
    se && D(e), jn(J, se), jn(X, se), jn(de, se);
  } };
}
function zB(t3) {
  let e, n, r;
  return { c() {
    e = Nr("line"), V(e, "x1", t3[6].left), V(e, "y1", n = t3[17].y), V(e, "x2", Ah - t3[6].right), V(e, "y2", r = t3[17].y), V(e, "stroke", "#e2e8f0"), V(e, "stroke-dasharray", "4");
  }, m(s, i) {
    R(s, e, i);
  }, p(s, i) {
    i & 32 && n !== (n = s[17].y) && V(e, "y1", n), i & 32 && r !== (r = s[17].y) && V(e, "y2", r);
  }, d(s) {
    s && D(e);
  } };
}
function GB(t3) {
  let e, n = t3[17].label + "", r, s;
  return { c() {
    e = Nr("text"), r = we(n), V(e, "x", t3[6].left - 10), V(e, "y", s = t3[17].y + 4), V(e, "text-anchor", "end"), V(e, "class", "tick-label svelte-14jfzdb");
  }, m(i, a) {
    R(i, e, a), q(e, r);
  }, p(i, a) {
    a & 32 && n !== (n = i[17].label + "") && Ze(r, n), a & 32 && s !== (s = i[17].y + 4) && V(e, "y", s);
  }, d(i) {
    i && D(e);
  } };
}
function VB(t3) {
  let e, n, r = t3[14].label + "", s, i, a = t3[14].value.toFixed(2) + "", o, f, c = t3[14].count + "", l, h, m, v, b, A, _, C = t3[14].label + "", I, S;
  return { c() {
    e = Nr("rect"), n = Nr("title"), s = we(r), i = we(": "), o = we(a), f = we("% ("), l = we(c), h = we(")"), _ = Nr("text"), I = we(C), V(e, "x", m = t3[14].x), V(e, "y", v = t3[14].y), V(e, "width", b = t3[14].width), V(e, "height", A = t3[14].height), V(e, "fill", "#4169E1"), V(e, "stroke", "#2b50c0"), V(e, "stroke-width", "1"), V(e, "rx", "2"), V(e, "class", "svelte-14jfzdb"), V(_, "x", S = t3[14].x + t3[14].width / 2), V(_, "y", zo - t3[6].bottom + 15), V(_, "text-anchor", "middle"), V(_, "class", "tick-label-x svelte-14jfzdb");
  }, m($, F) {
    R($, e, F), q(e, n), q(n, s), q(n, i), q(n, o), q(n, f), q(n, l), q(n, h), R($, _, F), q(_, I);
  }, p($, F) {
    F & 16 && r !== (r = $[14].label + "") && Ze(s, r), F & 16 && a !== (a = $[14].value.toFixed(2) + "") && Ze(o, a), F & 16 && c !== (c = $[14].count + "") && Ze(l, c), F & 16 && m !== (m = $[14].x) && V(e, "x", m), F & 16 && v !== (v = $[14].y) && V(e, "y", v), F & 16 && b !== (b = $[14].width) && V(e, "width", b), F & 16 && A !== (A = $[14].height) && V(e, "height", A), F & 16 && C !== (C = $[14].label + "") && Ze(I, C), F & 16 && S !== (S = $[14].x + $[14].width / 2) && V(_, "x", S);
  }, d($) {
    $ && (D(e), D(_));
  } };
}
function c3e(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C;
  function I(P) {
    t3[10](P);
  }
  let S = { label: "Input Text:", placeholder: "Paste text to analyze here...", expandable: true, rows: 6 };
  t3[0] !== void 0 && (S.value = t3[0]), e = new et({ props: S }), Qe.push(() => ze(e, "value", I)), i = new ut({ props: { $$slots: { default: [f3e] }, $$scope: { ctx: t3 } } }), i.$on("click", t3[7]), o = new ut({ props: { variant: "secondary", $$slots: { default: [l3e] }, $$scope: { ctx: t3 } } }), o.$on("click", t3[8]), c = new ut({ props: { variant: "secondary", $$slots: { default: [u3e] }, $$scope: { ctx: t3 } } }), c.$on("click", t3[11]);
  function $(P) {
    t3[12](P);
  }
  let F = {};
  t3[2] !== void 0 && (F.checked = t3[2]), m = new xr({ props: F }), Qe.push(() => ze(m, "checked", $));
  let U = t3[3] && HB(t3), Q = t3[1] && qB(t3);
  return { c() {
    fe(e.$$.fragment), r = z(), s = H("div"), fe(i.$$.fragment), a = z(), fe(o.$$.fragment), f = z(), fe(c.$$.fragment), l = z(), h = H("div"), fe(m.$$.fragment), b = z(), U && U.c(), A = z(), Q && Q.c(), _ = Lt(), St(h, "margin-left", "auto"), V(s, "class", "button-row svelte-14jfzdb");
  }, m(P, N) {
    ae(e, P, N), R(P, r, N), R(P, s, N), ae(i, s, null), q(s, a), ae(o, s, null), q(s, f), ae(c, s, null), q(s, l), q(s, h), ae(m, h, null), R(P, b, N), U && U.m(P, N), R(P, A, N), Q && Q.m(P, N), R(P, _, N), C = true;
  }, p(P, N) {
    const L = {};
    !n && N & 1 && (n = true, L.value = P[0], qe(() => n = false)), e.$set(L);
    const B = {};
    N & 4194304 && (B.$$scope = { dirty: N, ctx: P }), i.$set(B);
    const u = {};
    N & 4194304 && (u.$$scope = { dirty: N, ctx: P }), o.$set(u);
    const p = {};
    N & 4194304 && (p.$$scope = { dirty: N, ctx: P }), c.$set(p);
    const d = {};
    !v && N & 4 && (v = true, d.checked = P[2], qe(() => v = false)), m.$set(d), P[3] ? U ? U.p(P, N) : (U = HB(P), U.c(), U.m(A.parentNode, A)) : U && (U.d(1), U = null), P[1] ? Q ? Q.p(P, N) : (Q = qB(P), Q.c(), Q.m(_.parentNode, _)) : Q && (Q.d(1), Q = null);
  }, i(P) {
    C || (W(e.$$.fragment, P), W(i.$$.fragment, P), W(o.$$.fragment, P), W(c.$$.fragment, P), W(m.$$.fragment, P), C = true);
  }, o(P) {
    j(e.$$.fragment, P), j(i.$$.fragment, P), j(o.$$.fragment, P), j(c.$$.fragment, P), j(m.$$.fragment, P), C = false;
  }, d(P) {
    P && (D(r), D(s), D(b), D(A), D(_)), oe(e, P), oe(i), oe(o), oe(c), oe(m), U && U.d(P), Q && Q.d(P);
  } };
}
function h3e(t3) {
  let e, n, r, s, i, a, o;
  return { c() {
    e = H("p"), e.innerHTML = `This tool helps in performing <b>frequency analysis</b> on a given text. 
    Frequency analysis is a method for analyzing the frequency of letters in a text, 
    which is often used in cryptography to break substitution ciphers.`, n = z(), r = H("p"), r.textContent = "Features include:", s = z(), i = H("ul"), i.innerHTML = "<li>Displaying a frequency table of characters</li> <li>Identifying the most common character</li> <li>Generating a histogram to visualize character frequencies</li>", a = z(), o = H("p"), o.innerHTML = "In English, <strong>E</strong> is usually the most common letter (~12.7%), followed by <strong>T</strong>, <strong>A</strong>, and <strong>O</strong>.";
  }, m(f, c) {
    R(f, e, c), R(f, n, c), R(f, r, c), R(f, s, c), R(f, i, c), R(f, a, c), R(f, o, c);
  }, p: dt, d(f) {
    f && (D(e), D(n), D(r), D(s), D(i), D(a), D(o));
  } };
}
function d3e(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Frequency Analysis", $$slots: { default: [c3e] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Frequency Analysis", links: t3[9], $$slots: { default: [h3e] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 4194367 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 4194304 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
let Ah = 600, zo = 300;
function p3e(t3, e, n) {
  let r = "", s = null, i = "", a = true;
  const o = { top: 20, right: 20, bottom: 40, left: 50 };
  let f = [], c = [];
  function l() {
    n(3, i = ""), n(1, s = null);
    try {
      n(1, s = o3e(r));
    } catch (C) {
      n(3, i = C.message);
    }
  }
  function h() {
    n(0, r = "The quick brown fox jumps over the lazy dog. This sentence contains every letter of the alphabet at least once!"), l();
  }
  function m(C) {
    const I = Ah - o.left - o.right, S = zo - o.top - o.bottom, $ = Math.max(...C.map((B) => B.percent)), F = Math.ceil($ / 5) * 5, U = (B) => S - B / F * S, Q = 5, P = I / C.length, N = P - Q;
    n(4, f = C.map((B, u) => {
      const p = o.left + u * P + Q / 2, d = o.top + U(B.percent), y = S - U(B.percent);
      return { x: p, y: d, width: N, height: y, label: B.char.toUpperCase(), value: B.percent, count: B.count };
    })), n(5, c = []);
    const L = 5;
    for (let B = 0; B <= L; B++) {
      const u = F / L * B;
      c.push({ val: u, y: o.top + U(u), label: u.toFixed(0) + "%" });
    }
  }
  const v = [{ text: "Wikipedia: Frequency Analysis", url: "https://en.wikipedia.org/wiki/Frequency_analysis" }, { text: "Geeks for Geeks", url: "https://www.geeksforgeeks.org/frequency-analysis/" }];
  function b(C) {
    r = C, n(0, r);
  }
  const A = () => {
    n(0, r = ""), n(1, s = null);
  };
  function _(C) {
    a = C, n(2, a);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 2 && s && s.data.length > 0 && m(s.data), t3.$$.dirty & 5 && a && r && l();
  }, [r, s, a, i, f, c, o, l, h, v, b, A, _];
}
class g3e extends xt {
  constructor(e) {
    super(), wt(this, e, p3e, d3e, At, {});
  }
}
function m3e(t3, e = 10) {
  if (t3 <= 1n) return false;
  if (t3 <= 3n) return true;
  if (t3 % 2n === 0n) return false;
  let n = 0n, r = t3 - 1n;
  for (; r % 2n === 0n; ) r /= 2n, n += 1n;
  for (let s = 0; s < e; s++) {
    const i = BigInt(2) + v3e(t3 - 4n);
    let a = YB(i, r, t3);
    if (a === 1n || a === t3 - 1n) continue;
    let o = false;
    for (let f = 0n; f < n - 1n; f++) if (a = YB(a, 2n, t3), a === t3 - 1n) {
      o = true;
      break;
    }
    if (!o) return false;
  }
  return true;
}
function YB(t3, e, n) {
  let r = 1n;
  for (t3 = t3 % n; e > 0n; ) e % 2n === 1n && (r = r * t3 % n), t3 = t3 * t3 % n, e /= 2n;
  return r;
}
function v3e(t3) {
  const e = t3.toString(2).length;
  let n;
  do {
    let r = "";
    const s = Math.ceil(e / 8), i = new Uint8Array(s);
    window.crypto.getRandomValues(i);
    for (let a of i) r += a.toString(16).padStart(2, "0");
    n = BigInt("0x" + r);
  } while (n >= t3);
  return n;
}
function y3e(t3) {
  const e = Math.ceil(t3 / 8), n = new Uint8Array(e);
  window.crypto.getRandomValues(n);
  let r = "";
  for (let o of n) r += o.toString(16).padStart(2, "0");
  let s = BigInt("0x" + r);
  const i = 1n << BigInt(t3 - 1);
  s |= i, s |= 1n;
  const a = (1n << BigInt(t3)) - 1n;
  return s &= a, s |= i, s;
}
async function b3e(t3, e) {
  const n = [], r = 1e3 * t3;
  let s = 0;
  for (; n.length < t3 && s < r; ) {
    s++;
    const i = y3e(e);
    m3e(i) && n.push(i.toString()), s % 10 === 0 && await new Promise((a) => setTimeout(a, 0));
  }
  if (n.length < t3) throw new Error("Timeout: Could not generate enough primes in time.");
  return n;
}
function WB(t3, e, n) {
  const r = t3.slice();
  return r[10] = e[n], r;
}
function A3e(t3) {
  let e;
  return { c() {
    e = we("Generate Primes");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function w3e(t3) {
  let e;
  return { c() {
    e = we("Generating...");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function x3e(t3) {
  let e;
  function n(i, a) {
    return i[3] ? w3e : A3e;
  }
  let r = n(t3), s = r(t3);
  return { c() {
    s.c(), e = Lt();
  }, m(i, a) {
    s.m(i, a), R(i, e, a);
  }, p(i, a) {
    r !== (r = n(i)) && (s.d(1), s = r(i), s && (s.c(), s.m(e.parentNode, e)));
  }, d(i) {
    i && D(e), s.d(i);
  } };
}
function JB(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[4]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 16 && Ze(n, r[4]);
  }, d(r) {
    r && D(e);
  } };
}
function ZB(t3) {
  let e, n, r, s, i = t3[2].length + "", a, o, f, c, l, h, m, v, b, A = Mr(t3[2]), _ = [];
  for (let I = 0; I < A.length; I += 1) _[I] = jB(WB(t3, A, I));
  const C = (I) => j(_[I], 1, 1, () => {
    _[I] = null;
  });
  return { c() {
    e = H("div"), n = H("div"), r = H("strong"), s = we("Generated "), a = we(i), o = we(" Primes:"), f = z(), c = H("button"), c.textContent = "Download List (.txt)", l = z(), h = H("div");
    for (let I = 0; I < _.length; I += 1) _[I].c();
    V(c, "class", "link-btn svelte-1w1w7u3"), V(n, "class", "results-header"), V(h, "class", "prime-list svelte-1w1w7u3"), V(e, "class", "results-area");
  }, m(I, S) {
    R(I, e, S), q(e, n), q(n, r), q(r, s), q(r, a), q(r, o), q(n, f), q(n, c), q(e, l), q(e, h);
    for (let $ = 0; $ < _.length; $ += 1) _[$] && _[$].m(h, null);
    m = true, v || (b = Kt(c, "click", t3[6]), v = true);
  }, p(I, S) {
    if ((!m || S & 4) && i !== (i = I[2].length + "") && Ze(a, i), S & 4) {
      A = Mr(I[2]);
      let $;
      for ($ = 0; $ < A.length; $ += 1) {
        const F = WB(I, A, $);
        _[$] ? (_[$].p(F, S), W(_[$], 1)) : (_[$] = jB(F), _[$].c(), W(_[$], 1), _[$].m(h, null));
      }
      for (Xt(), $ = A.length; $ < _.length; $ += 1) C($);
      er();
    }
  }, i(I) {
    if (!m) {
      for (let S = 0; S < A.length; S += 1) W(_[S]);
      m = true;
    }
  }, o(I) {
    _ = _.filter(Boolean);
    for (let S = 0; S < _.length; S += 1) j(_[S]);
    m = false;
  }, d(I) {
    I && D(e), jn(_, I), v = false, b();
  } };
}
function jB(t3) {
  let e, n;
  return e = new et({ props: { value: t3[10], readonly: true, expandable: false, withCopy: true } }), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p(r, s) {
    const i = {};
    s & 4 && (i.value = r[10]), e.$set(i);
  }, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function _3e(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S;
  v = new ut({ props: { disabled: t3[3], $$slots: { default: [x3e] }, $$scope: { ctx: t3 } } }), v.$on("click", t3[5]);
  let $ = t3[4] && JB(t3), F = t3[2].length > 0 && ZB(t3);
  return { c() {
    e = H("div"), n = H("div"), r = H("label"), r.textContent = "Quantity:", s = z(), i = H("input"), a = z(), o = H("div"), f = H("label"), f.textContent = "Bit Length:", c = z(), l = H("input"), h = z(), m = H("div"), fe(v.$$.fragment), b = z(), $ && $.c(), A = z(), F && F.c(), _ = Lt(), V(r, "for", "count"), V(r, "class", "svelte-1w1w7u3"), V(i, "id", "count"), V(i, "type", "number"), V(i, "min", "1"), V(i, "max", "1000"), V(i, "class", "svelte-1w1w7u3"), V(n, "class", "input-group svelte-1w1w7u3"), V(f, "for", "bits"), V(f, "class", "svelte-1w1w7u3"), V(l, "id", "bits"), V(l, "type", "number"), V(l, "min", "2"), V(l, "max", "2048"), V(l, "class", "svelte-1w1w7u3"), V(o, "class", "input-group svelte-1w1w7u3"), V(e, "class", "controls-row svelte-1w1w7u3"), V(m, "class", "button-row"), St(m, "justify-content", "center");
  }, m(U, Q) {
    R(U, e, Q), q(e, n), q(n, r), q(n, s), q(n, i), yr(i, t3[0]), q(e, a), q(e, o), q(o, f), q(o, c), q(o, l), yr(l, t3[1]), R(U, h, Q), R(U, m, Q), ae(v, m, null), R(U, b, Q), $ && $.m(U, Q), R(U, A, Q), F && F.m(U, Q), R(U, _, Q), C = true, I || (S = [Kt(i, "input", t3[8]), Kt(l, "input", t3[9])], I = true);
  }, p(U, Q) {
    Q & 1 && Nn(i.value) !== U[0] && yr(i, U[0]), Q & 2 && Nn(l.value) !== U[1] && yr(l, U[1]);
    const P = {};
    Q & 8 && (P.disabled = U[3]), Q & 8200 && (P.$$scope = { dirty: Q, ctx: U }), v.$set(P), U[4] ? $ ? $.p(U, Q) : ($ = JB(U), $.c(), $.m(A.parentNode, A)) : $ && ($.d(1), $ = null), U[2].length > 0 ? F ? (F.p(U, Q), Q & 4 && W(F, 1)) : (F = ZB(U), F.c(), W(F, 1), F.m(_.parentNode, _)) : F && (Xt(), j(F, 1, 1, () => {
      F = null;
    }), er());
  }, i(U) {
    C || (W(v.$$.fragment, U), W(F), C = true);
  }, o(U) {
    j(v.$$.fragment, U), j(F), C = false;
  }, d(U) {
    U && (D(e), D(h), D(m), D(b), D(A), D(_)), oe(v), $ && $.d(U), F && F.d(U), I = false, Mn(S);
  } };
}
function E3e(t3) {
  let e, n, r, s, i;
  return { c() {
    e = H("p"), e.innerHTML = `This tool allows users to generate a specified number of prime numbers, each with a defined bit length.
        <strong>Prime Numbers</strong> are integers greater than 1 that have no divisors other than 1 and themselves.
    It uses the Miller-Rabin primality test to ensure the generated numbers are truly prime, and provides an easy-to-use 
    interface for both beginners and experts. Applications include cryptography, random key generation, and mathematical exploration.
    Simply input the number of primes you wish to generate, specify their bit length, and let the tool do the work!`, n = z(), r = H("p"), r.innerHTML = "Large prime numbers are the backbone of modern cryptography (like RSA). This tool uses the <strong>Miller-Rabin primality test</strong>, a probabilistic algorithm that is extremely accurate for determining if very large numbers are prime.", s = z(), i = H("ul"), i.innerHTML = "<li><strong>64-bit:</strong> Standard large integers.</li> <li><strong>256-bit+:</strong> Used in Elliptic Curve Cryptography.</li> <li><strong>1024-bit+:</strong> Used in RSA encryption.</li>";
  }, m(a, o) {
    R(a, e, o), R(a, n, o), R(a, r, o), R(a, s, o), R(a, i, o);
  }, p: dt, d(a) {
    a && (D(e), D(n), D(r), D(s), D(i));
  } };
}
function B3e(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Prime Number Generator", $$slots: { default: [_3e] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Prime Numbers", links: t3[7], $$slots: { default: [E3e] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 8223 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 8192 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function C3e(t3, e, n) {
  let r = 5, s = 64, i = [], a = false, o = "";
  async function f() {
    if (r <= 0 || s <= 1) {
      n(4, o = "Please enter valid parameters (Count > 0, Bits > 1).");
      return;
    }
    if (r > 1e3) {
      n(4, o = "Max 1000 numbers at a time.");
      return;
    }
    n(4, o = ""), n(2, i = []), n(3, a = true);
    try {
      await new Promise((v) => setTimeout(v, 50)), n(2, i = await b3e(r, s));
    } catch (v) {
      n(4, o = v.message);
    } finally {
      n(3, a = false);
    }
  }
  function c() {
    if (i.length === 0) return;
    const v = i.join(`
`), b = new Blob([v], { type: "text/plain" }), A = URL.createObjectURL(b), _ = document.createElement("a");
    _.href = A, _.download = `primes_${s}bit_${i.length}.txt`, document.body.appendChild(_), _.click(), document.body.removeChild(_);
  }
  const l = [{ text: "Prime Numbers - Wikipedia", url: "https://en.wikipedia.org/wiki/Prime_number" }];
  function h() {
    r = Nn(this.value), n(0, r);
  }
  function m() {
    s = Nn(this.value), n(1, s);
  }
  return [r, s, i, a, o, f, c, l, h, m];
}
class k3e extends xt {
  constructor(e) {
    super(), wt(this, e, C3e, B3e, At, {});
  }
}
class I3e {
  constructor(e) {
    this.m = 4294967296n, this.a = 1664525n, this.c = 1013904223n, this.state = BigInt(e);
  }
  next() {
    return this.state = (this.a * this.state + this.c) % this.m, Number(this.state);
  }
  random() {
    return this.next() / Number(this.m);
  }
}
function S3e(t3, e) {
  if (isNaN(t3) || isNaN(e)) throw new Error("Invalid input.");
  const n = new I3e(t3), r = [], s = [];
  for (let i = 0; i < e; i++) {
    const a = n.next();
    r.push(a), s.push(a / 4294967296);
  }
  return { integers: r, floats: s };
}
function M3e(t3) {
  let e;
  return { c() {
    e = we("Generate Sequence");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function $3e(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function XB(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[4]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 16 && Ze(n, r[4]);
  }, d(r) {
    r && D(e);
  } };
}
function eC(t3) {
  let e, n, r, s, i;
  return n = new et({ props: { label: "Generated Integers:", value: t3[2], readonly: true, expandable: true, withCopy: true, rows: 4 } }), s = new et({ props: { label: "Generated Floats [0-1):", value: t3[3], readonly: true, expandable: true, withCopy: true, rows: 4 } }), { c() {
    e = H("div"), fe(n.$$.fragment), r = z(), fe(s.$$.fragment), V(e, "class", "results-area svelte-13hobg4");
  }, m(a, o) {
    R(a, e, o), ae(n, e, null), q(e, r), ae(s, e, null), i = true;
  }, p(a, o) {
    const f = {};
    o & 4 && (f.value = a[2]), n.$set(f);
    const c = {};
    o & 8 && (c.value = a[3]), s.$set(c);
  }, i(a) {
    i || (W(n.$$.fragment, a), W(s.$$.fragment, a), i = true);
  }, o(a) {
    j(n.$$.fragment, a), j(s.$$.fragment, a), i = false;
  }, d(a) {
    a && D(e), oe(n), oe(s);
  } };
}
function T3e(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U, Q;
  A = new ut({ props: { $$slots: { default: [M3e] }, $$scope: { ctx: t3 } } }), A.$on("click", t3[5]), C = new ut({ props: { variant: "secondary", $$slots: { default: [$3e] }, $$scope: { ctx: t3 } } }), C.$on("click", t3[9]);
  let P = t3[4] && XB(t3), N = t3[2] && eC(t3);
  return { c() {
    e = H("div"), n = H("div"), r = H("label"), r.textContent = "Seed Value:", s = z(), i = H("input"), a = z(), o = H("small"), o.textContent = "The starting point of the sequence.", f = z(), c = H("div"), l = H("label"), l.textContent = "Quantity:", h = z(), m = H("input"), v = z(), b = H("div"), fe(A.$$.fragment), _ = z(), fe(C.$$.fragment), I = z(), P && P.c(), S = z(), N && N.c(), $ = Lt(), V(r, "for", "seed"), V(r, "class", "svelte-13hobg4"), V(i, "id", "seed"), V(i, "type", "number"), V(i, "placeholder", "e.g. 12345"), V(i, "class", "svelte-13hobg4"), V(o, "class", "hint svelte-13hobg4"), V(n, "class", "input-group svelte-13hobg4"), V(l, "for", "count"), V(l, "class", "svelte-13hobg4"), V(m, "id", "count"), V(m, "type", "number"), V(m, "min", "1"), V(m, "max", "1000"), V(m, "class", "svelte-13hobg4"), V(c, "class", "input-group svelte-13hobg4"), V(e, "class", "controls-row svelte-13hobg4"), V(b, "class", "button-row svelte-13hobg4");
  }, m(L, B) {
    R(L, e, B), q(e, n), q(n, r), q(n, s), q(n, i), yr(i, t3[0]), q(n, a), q(n, o), q(e, f), q(e, c), q(c, l), q(c, h), q(c, m), yr(m, t3[1]), R(L, v, B), R(L, b, B), ae(A, b, null), q(b, _), ae(C, b, null), R(L, I, B), P && P.m(L, B), R(L, S, B), N && N.m(L, B), R(L, $, B), F = true, U || (Q = [Kt(i, "input", t3[7]), Kt(m, "input", t3[8])], U = true);
  }, p(L, B) {
    B & 1 && Nn(i.value) !== L[0] && yr(i, L[0]), B & 2 && Nn(m.value) !== L[1] && yr(m, L[1]);
    const u = {};
    B & 1024 && (u.$$scope = { dirty: B, ctx: L }), A.$set(u);
    const p = {};
    B & 1024 && (p.$$scope = { dirty: B, ctx: L }), C.$set(p), L[4] ? P ? P.p(L, B) : (P = XB(L), P.c(), P.m(S.parentNode, S)) : P && (P.d(1), P = null), L[2] ? N ? (N.p(L, B), B & 4 && W(N, 1)) : (N = eC(L), N.c(), W(N, 1), N.m($.parentNode, $)) : N && (Xt(), j(N, 1, 1, () => {
      N = null;
    }), er());
  }, i(L) {
    F || (W(A.$$.fragment, L), W(C.$$.fragment, L), W(N), F = true);
  }, o(L) {
    j(A.$$.fragment, L), j(C.$$.fragment, L), j(N), F = false;
  }, d(L) {
    L && (D(e), D(v), D(b), D(I), D(S), D($)), oe(A), oe(C), P && P.d(L), N && N.d(L), U = false, Mn(Q);
  } };
}
function D3e(t3) {
  let e, n, r, s, i, a, o, f, c, l, h;
  return { c() {
    e = H("p"), e.innerHTML = `A <b>Pseudo Random Number Generator (PRNG)</b> is an algorithm used to generate 
    a sequence of numbers that approximates the properties of random numbers. 
    Although the sequence appears random, it is actually determined by an initial value called the <b>seed</b>.`, n = z(), r = H("h3"), r.textContent = "Key Features:", s = z(), i = H("ul"), i.innerHTML = "<li>Deterministic: Given the same seed, a PRNG will always produce the same sequence of numbers.</li> <li>Efficient: Generates random numbers quickly and efficiently.</li> <li>Periodicity: The sequence eventually repeats after a fixed number of iterations, called the period.</li>", a = z(), o = H("h3"), o.textContent = "Applications:", f = z(), c = H("ul"), c.innerHTML = "<li>Simulations and Modeling</li> <li>Cryptography</li> <li>Game Development</li> <li>Statistical Sampling</li>", l = z(), h = H("p"), h.innerHTML = `This tool application uses a <b>Linear Congruential Generator (LCG)</b>, which is a simple yet widely used PRNG algorithm. 
    You can input a seed and specify the number of pseudo-random integers and floats to generate. 
    The output demonstrates the deterministic nature of PRNGs while showcasing their versatility.`;
  }, m(m, v) {
    R(m, e, v), R(m, n, v), R(m, r, v), R(m, s, v), R(m, i, v), R(m, a, v), R(m, o, v), R(m, f, v), R(m, c, v), R(m, l, v), R(m, h, v);
  }, p: dt, d(m) {
    m && (D(e), D(n), D(r), D(s), D(i), D(a), D(o), D(f), D(c), D(l), D(h));
  } };
}
function R3e(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Pseudo-Random Number Generator", $$slots: { default: [T3e] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About PRNGs", links: t3[6], $$slots: { default: [D3e] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 1055 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 1024 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function F3e(t3, e, n) {
  let r = "12345", s = "10", i = "", a = "", o = "";
  function f() {
    n(4, o = ""), n(2, i = ""), n(3, a = "");
    const v = parseInt(r), b = parseInt(s);
    if (isNaN(v)) return n(4, o = "Please enter a numeric seed.");
    if (isNaN(b) || b <= 0) return n(4, o = "Please enter a valid count (>0).");
    if (b > 1e4) return n(4, o = "Max limit is 10,000 numbers to prevent freezing.");
    try {
      const { integers: A, floats: _ } = S3e(v, b);
      n(2, i = A.join(", ")), n(3, a = _.map((C) => C.toFixed(6)).join(", "));
    } catch (A) {
      n(4, o = A.message);
    }
  }
  const c = [{ text: "PRNG - Wikipedia", url: "https://en.wikipedia.org/wiki/Pseudorandom_number_generator" }];
  function l() {
    r = Nn(this.value), n(0, r);
  }
  function h() {
    s = Nn(this.value), n(1, s);
  }
  return [r, s, i, a, o, f, c, l, h, () => {
    n(0, r = ""), n(2, i = ""), n(3, a = "");
  }];
}
class P3e extends xt {
  constructor(e) {
    super(), wt(this, e, F3e, R3e, At, {});
  }
}
var cP = { exports: {} };
(function(t3, e) {
  (function(n, r) {
    t3.exports = r();
  })(mt, function() {
    var n = function(r, s) {
      var i = Array.prototype.concat, a = Array.prototype.slice, o = Object.prototype.toString;
      function f(I, S) {
        var $ = I > S ? I : S;
        return r.pow(10, 17 - ~~(r.log($ > 0 ? $ : -$) * r.LOG10E));
      }
      var c = Array.isArray || function(S) {
        return o.call(S) === "[object Array]";
      };
      function l(I) {
        return o.call(I) === "[object Function]";
      }
      function h(I) {
        return typeof I == "number" ? I - I === 0 : false;
      }
      function m(I) {
        return i.apply([], I);
      }
      function v() {
        return new v._init(arguments);
      }
      v.fn = v.prototype, v._init = function(S) {
        if (c(S[0])) if (c(S[0][0])) {
          l(S[1]) && (S[0] = v.map(S[0], S[1]));
          for (var $ = 0; $ < S[0].length; $++) this[$] = S[0][$];
          this.length = S[0].length;
        } else this[0] = l(S[1]) ? v.map(S[0], S[1]) : S[0], this.length = 1;
        else if (h(S[0])) this[0] = v.seq.apply(null, S), this.length = 1;
        else {
          if (S[0] instanceof v) return v(S[0].toArray());
          this[0] = [], this.length = 1;
        }
        return this;
      }, v._init.prototype = v.prototype, v._init.constructor = v, v.utils = { calcRdx: f, isArray: c, isFunction: l, isNumber: h, toVector: m }, v._random_fn = r.random, v.setRandom = function(S) {
        if (typeof S != "function") throw new TypeError("fn is not a function");
        v._random_fn = S;
      }, v.extend = function(S) {
        var $, F;
        if (arguments.length === 1) {
          for (F in S) v[F] = S[F];
          return this;
        }
        for ($ = 1; $ < arguments.length; $++) for (F in arguments[$]) S[F] = arguments[$][F];
        return S;
      }, v.rows = function(S) {
        return S.length || 1;
      }, v.cols = function(S) {
        return S[0].length || 1;
      }, v.dimensions = function(S) {
        return { rows: v.rows(S), cols: v.cols(S) };
      }, v.row = function(S, $) {
        return c($) ? $.map(function(F) {
          return v.row(S, F);
        }) : S[$];
      }, v.rowa = function(S, $) {
        return v.row(S, $);
      }, v.col = function(S, $) {
        if (c($)) {
          var F = v.arange(S.length).map(function() {
            return new Array($.length);
          });
          return $.forEach(function(P, N) {
            v.arange(S.length).forEach(function(L) {
              F[L][N] = S[L][P];
            });
          }), F;
        }
        for (var U = new Array(S.length), Q = 0; Q < S.length; Q++) U[Q] = [S[Q][$]];
        return U;
      }, v.cola = function(S, $) {
        return v.col(S, $).map(function(F) {
          return F[0];
        });
      }, v.diag = function(S) {
        for (var $ = v.rows(S), F = new Array($), U = 0; U < $; U++) F[U] = [S[U][U]];
        return F;
      }, v.antidiag = function(S) {
        for (var $ = v.rows(S) - 1, F = new Array($), U = 0; $ >= 0; $--, U++) F[U] = [S[U][$]];
        return F;
      }, v.transpose = function(S) {
        var $ = [], F, U, Q, P, N;
        for (c(S[0]) || (S = [S]), U = S.length, Q = S[0].length, N = 0; N < Q; N++) {
          for (F = new Array(U), P = 0; P < U; P++) F[P] = S[P][N];
          $.push(F);
        }
        return $.length === 1 ? $[0] : $;
      }, v.map = function(S, $, F) {
        var U, Q, P, N, L;
        for (c(S[0]) || (S = [S]), Q = S.length, P = S[0].length, N = F ? S : new Array(Q), U = 0; U < Q; U++) for (N[U] || (N[U] = new Array(P)), L = 0; L < P; L++) N[U][L] = $(S[U][L], U, L);
        return N.length === 1 ? N[0] : N;
      }, v.cumreduce = function(S, $, F) {
        var U, Q, P, N, L;
        for (c(S[0]) || (S = [S]), Q = S.length, P = S[0].length, N = F ? S : new Array(Q), U = 0; U < Q; U++) for (N[U] || (N[U] = new Array(P)), P > 0 && (N[U][0] = S[U][0]), L = 1; L < P; L++) N[U][L] = $(N[U][L - 1], S[U][L]);
        return N.length === 1 ? N[0] : N;
      }, v.alter = function(S, $) {
        return v.map(S, $, true);
      }, v.create = function(S, $, F) {
        var U = new Array(S), Q, P;
        for (l($) && (F = $, $ = S), Q = 0; Q < S; Q++) for (U[Q] = new Array($), P = 0; P < $; P++) U[Q][P] = F(Q, P);
        return U;
      };
      function b() {
        return 0;
      }
      v.zeros = function(S, $) {
        return h($) || ($ = S), v.create(S, $, b);
      };
      function A() {
        return 1;
      }
      v.ones = function(S, $) {
        return h($) || ($ = S), v.create(S, $, A);
      }, v.rand = function(S, $) {
        return h($) || ($ = S), v.create(S, $, v._random_fn);
      };
      function _(I, S) {
        return I === S ? 1 : 0;
      }
      v.identity = function(S, $) {
        return h($) || ($ = S), v.create(S, $, _);
      }, v.symmetric = function(S) {
        var $ = S.length, F, U;
        if (S.length !== S[0].length) return false;
        for (F = 0; F < $; F++) for (U = 0; U < $; U++) if (S[U][F] !== S[F][U]) return false;
        return true;
      }, v.clear = function(S) {
        return v.alter(S, b);
      }, v.seq = function(S, $, F, U) {
        l(U) || (U = false);
        var Q = [], P = f(S, $), N = ($ * P - S * P) / ((F - 1) * P), L = S, B;
        for (B = 0; L <= $ && B < F; B++, L = (S * P + N * P * B) / P) Q.push(U ? U(L, B) : L);
        return Q;
      }, v.arange = function(S, $, F) {
        var U = [], Q;
        if (F = F || 1, $ === s && ($ = S, S = 0), S === $ || F === 0) return [];
        if (S < $ && F < 0) return [];
        if (S > $ && F > 0) return [];
        if (F > 0) for (Q = S; Q < $; Q += F) U.push(Q);
        else for (Q = S; Q > $; Q += F) U.push(Q);
        return U;
      }, v.slice = /* @__PURE__ */ function() {
        function I($, F, U, Q) {
          var P, N = [], L = $.length;
          if (F === s && U === s && Q === s) return v.copy($);
          if (F = F || 0, U = U || $.length, F = F >= 0 ? F : L + F, U = U >= 0 ? U : L + U, Q = Q || 1, F === U || Q === 0) return [];
          if (F < U && Q < 0) return [];
          if (F > U && Q > 0) return [];
          if (Q > 0) for (P = F; P < U; P += Q) N.push($[P]);
          else for (P = F; P > U; P += Q) N.push($[P]);
          return N;
        }
        function S($, F) {
          var U, Q;
          if (F = F || {}, h(F.row)) {
            if (h(F.col)) return $[F.row][F.col];
            var P = v.rowa($, F.row);
            return U = F.col || {}, I(P, U.start, U.end, U.step);
          }
          if (h(F.col)) {
            var N = v.cola($, F.col);
            return Q = F.row || {}, I(N, Q.start, Q.end, Q.step);
          }
          Q = F.row || {}, U = F.col || {};
          var L = I($, Q.start, Q.end, Q.step);
          return L.map(function(B) {
            return I(B, U.start, U.end, U.step);
          });
        }
        return S;
      }(), v.sliceAssign = function(S, $, F) {
        var U, Q;
        if (h($.row)) {
          if (h($.col)) return S[$.row][$.col] = F;
          $.col = $.col || {}, $.col.start = $.col.start || 0, $.col.end = $.col.end || S[0].length, $.col.step = $.col.step || 1, U = v.arange($.col.start, r.min(S.length, $.col.end), $.col.step);
          var P = $.row;
          return U.forEach(function(L, B) {
            S[P][L] = F[B];
          }), S;
        }
        if (h($.col)) {
          $.row = $.row || {}, $.row.start = $.row.start || 0, $.row.end = $.row.end || S.length, $.row.step = $.row.step || 1, Q = v.arange($.row.start, r.min(S[0].length, $.row.end), $.row.step);
          var N = $.col;
          return Q.forEach(function(L, B) {
            S[L][N] = F[B];
          }), S;
        }
        return F[0].length === s && (F = [F]), $.row.start = $.row.start || 0, $.row.end = $.row.end || S.length, $.row.step = $.row.step || 1, $.col.start = $.col.start || 0, $.col.end = $.col.end || S[0].length, $.col.step = $.col.step || 1, Q = v.arange($.row.start, r.min(S.length, $.row.end), $.row.step), U = v.arange($.col.start, r.min(S[0].length, $.col.end), $.col.step), Q.forEach(function(L, B) {
          U.forEach(function(u, p) {
            S[L][u] = F[B][p];
          });
        }), S;
      }, v.diagonal = function(S) {
        var $ = v.zeros(S.length, S.length);
        return S.forEach(function(F, U) {
          $[U][U] = F;
        }), $;
      }, v.copy = function(S) {
        return S.map(function($) {
          return h($) ? $ : $.map(function(F) {
            return F;
          });
        });
      };
      var C = v.prototype;
      return C.length = 0, C.push = Array.prototype.push, C.sort = Array.prototype.sort, C.splice = Array.prototype.splice, C.slice = Array.prototype.slice, C.toArray = function() {
        return this.length > 1 ? a.call(this) : a.call(this)[0];
      }, C.map = function(S, $) {
        return v(v.map(this, S, $));
      }, C.cumreduce = function(S, $) {
        return v(v.cumreduce(this, S, $));
      }, C.alter = function(S) {
        return v.alter(this, S), this;
      }, function(I) {
        for (var S = 0; S < I.length; S++) (function($) {
          C[$] = function(F) {
            var U = this, Q;
            return F ? (setTimeout(function() {
              F.call(U, C[$].call(U));
            }), this) : (Q = v[$](this), c(Q) ? v(Q) : Q);
          };
        })(I[S]);
      }("transpose clear symmetric rows cols dimensions diag antidiag".split(" ")), function(I) {
        for (var S = 0; S < I.length; S++) (function($) {
          C[$] = function(F, U) {
            var Q = this;
            return U ? (setTimeout(function() {
              U.call(Q, C[$].call(Q, F));
            }), this) : v(v[$](this, F));
          };
        })(I[S]);
      }("row col".split(" ")), function(I) {
        for (var S = 0; S < I.length; S++) (function($) {
          C[$] = function() {
            return v(v[$].apply(null, arguments));
          };
        })(I[S]);
      }("create zeros ones rand identity".split(" ")), v;
    }(Math);
    return function(r, s) {
      var i = r.utils.isFunction;
      function a(c, l) {
        return c - l;
      }
      function o(c, l, h) {
        return s.max(l, s.min(c, h));
      }
      r.sum = function(l) {
        for (var h = 0, m = l.length; --m >= 0; ) h += l[m];
        return h;
      }, r.sumsqrd = function(l) {
        for (var h = 0, m = l.length; --m >= 0; ) h += l[m] * l[m];
        return h;
      }, r.sumsqerr = function(l) {
        for (var h = r.mean(l), m = 0, v = l.length, b; --v >= 0; ) b = l[v] - h, m += b * b;
        return m;
      }, r.sumrow = function(l) {
        for (var h = 0, m = l.length; --m >= 0; ) h += l[m];
        return h;
      }, r.product = function(l) {
        for (var h = 1, m = l.length; --m >= 0; ) h *= l[m];
        return h;
      }, r.min = function(l) {
        for (var h = l[0], m = 0; ++m < l.length; ) l[m] < h && (h = l[m]);
        return h;
      }, r.max = function(l) {
        for (var h = l[0], m = 0; ++m < l.length; ) l[m] > h && (h = l[m]);
        return h;
      }, r.unique = function(l) {
        for (var h = {}, m = [], v = 0; v < l.length; v++) h[l[v]] || (h[l[v]] = true, m.push(l[v]));
        return m;
      }, r.mean = function(l) {
        return r.sum(l) / l.length;
      }, r.meansqerr = function(l) {
        return r.sumsqerr(l) / l.length;
      }, r.geomean = function(l) {
        var h = l.map(s.log), m = r.mean(h);
        return s.exp(m);
      }, r.median = function(l) {
        var h = l.length, m = l.slice().sort(a);
        return h & 1 ? m[h / 2 | 0] : (m[h / 2 - 1] + m[h / 2]) / 2;
      }, r.cumsum = function(l) {
        return r.cumreduce(l, function(h, m) {
          return h + m;
        });
      }, r.cumprod = function(l) {
        return r.cumreduce(l, function(h, m) {
          return h * m;
        });
      }, r.diff = function(l) {
        var h = [], m = l.length, v;
        for (v = 1; v < m; v++) h.push(l[v] - l[v - 1]);
        return h;
      }, r.rank = function(c) {
        var l, h = [], m = {};
        for (l = 0; l < c.length; l++) {
          var v = c[l];
          m[v] ? m[v]++ : (m[v] = 1, h.push(v));
        }
        var b = h.sort(a), A = {}, _ = 1;
        for (l = 0; l < b.length; l++) {
          var v = b[l], C = m[v], I = _, S = _ + C - 1, $ = (I + S) / 2;
          A[v] = $, _ += C;
        }
        return c.map(function(F) {
          return A[F];
        });
      }, r.mode = function(l) {
        var h = l.length, m = l.slice().sort(a), v = 1, b = 0, A = 0, _ = [], C;
        for (C = 0; C < h; C++) m[C] === m[C + 1] ? v++ : (v > b ? (_ = [m[C]], b = v, A = 0) : v === b && (_.push(m[C]), A++), v = 1);
        return A === 0 ? _[0] : _;
      }, r.range = function(l) {
        return r.max(l) - r.min(l);
      }, r.variance = function(l, h) {
        return r.sumsqerr(l) / (l.length - (h ? 1 : 0));
      }, r.pooledvariance = function(l) {
        var h = l.reduce(function(v, b) {
          return v + r.sumsqerr(b);
        }, 0), m = l.reduce(function(v, b) {
          return v + b.length;
        }, 0);
        return h / (m - l.length);
      }, r.deviation = function(c) {
        for (var l = r.mean(c), h = c.length, m = new Array(h), v = 0; v < h; v++) m[v] = c[v] - l;
        return m;
      }, r.stdev = function(l, h) {
        return s.sqrt(r.variance(l, h));
      }, r.pooledstdev = function(l) {
        return s.sqrt(r.pooledvariance(l));
      }, r.meandev = function(l) {
        for (var h = r.mean(l), m = [], v = l.length - 1; v >= 0; v--) m.push(s.abs(l[v] - h));
        return r.mean(m);
      }, r.meddev = function(l) {
        for (var h = r.median(l), m = [], v = l.length - 1; v >= 0; v--) m.push(s.abs(l[v] - h));
        return r.median(m);
      }, r.coeffvar = function(l) {
        return r.stdev(l) / r.mean(l);
      }, r.quartiles = function(l) {
        var h = l.length, m = l.slice().sort(a);
        return [m[s.round(h / 4) - 1], m[s.round(h / 2) - 1], m[s.round(h * 3 / 4) - 1]];
      }, r.quantiles = function(l, h, m, v) {
        var b = l.slice().sort(a), A = [h.length], _ = l.length, C, I, S, $, F, U;
        for (typeof m > "u" && (m = 3 / 8), typeof v > "u" && (v = 3 / 8), C = 0; C < h.length; C++) I = h[C], S = m + I * (1 - m - v), $ = _ * I + S, F = s.floor(o($, 1, _ - 1)), U = o($ - F, 0, 1), A[C] = (1 - U) * b[F - 1] + U * b[F];
        return A;
      }, r.percentile = function(l, h, m) {
        var v = l.slice().sort(a), b = h * (v.length + (m ? 1 : -1)) + (m ? 0 : 1), A = parseInt(b), _ = b - A;
        return A + 1 < v.length ? v[A - 1] + _ * (v[A] - v[A - 1]) : v[A - 1];
      }, r.percentileOfScore = function(l, h, m) {
        var v = 0, b = l.length, A = false, _, C;
        for (m === "strict" && (A = true), C = 0; C < b; C++) _ = l[C], (A && _ < h || !A && _ <= h) && v++;
        return v / b;
      }, r.histogram = function(l, h) {
        h = h || 4;
        var m = r.min(l), v = (r.max(l) - m) / h, b = l.length, A = [], _;
        for (_ = 0; _ < h; _++) A[_] = 0;
        for (_ = 0; _ < b; _++) A[s.min(s.floor((l[_] - m) / v), h - 1)] += 1;
        return A;
      }, r.covariance = function(l, h) {
        var m = r.mean(l), v = r.mean(h), b = l.length, A = new Array(b), _;
        for (_ = 0; _ < b; _++) A[_] = (l[_] - m) * (h[_] - v);
        return r.sum(A) / (b - 1);
      }, r.corrcoeff = function(l, h) {
        return r.covariance(l, h) / r.stdev(l, 1) / r.stdev(h, 1);
      }, r.spearmancoeff = function(c, l) {
        return c = r.rank(c), l = r.rank(l), r.corrcoeff(c, l);
      }, r.stanMoment = function(l, h) {
        for (var m = r.mean(l), v = r.stdev(l), b = l.length, A = 0, _ = 0; _ < b; _++) A += s.pow((l[_] - m) / v, h);
        return A / l.length;
      }, r.skewness = function(l) {
        return r.stanMoment(l, 3);
      }, r.kurtosis = function(l) {
        return r.stanMoment(l, 4) - 3;
      };
      var f = r.prototype;
      (function(c) {
        for (var l = 0; l < c.length; l++) (function(h) {
          f[h] = function(m, v) {
            var b = [], A = 0, _ = this;
            if (i(m) && (v = m, m = false), v) return setTimeout(function() {
              v.call(_, f[h].call(_, m));
            }), this;
            if (this.length > 1) {
              for (_ = m === true ? this : this.transpose(); A < _.length; A++) b[A] = r[h](_[A]);
              return b;
            }
            return r[h](this[0], m);
          };
        })(c[l]);
      })("cumsum cumprod".split(" ")), function(c) {
        for (var l = 0; l < c.length; l++) (function(h) {
          f[h] = function(m, v) {
            var b = [], A = 0, _ = this;
            if (i(m) && (v = m, m = false), v) return setTimeout(function() {
              v.call(_, f[h].call(_, m));
            }), this;
            if (this.length > 1) {
              for (h !== "sumrow" && (_ = m === true ? this : this.transpose()); A < _.length; A++) b[A] = r[h](_[A]);
              return m === true ? r[h](r.utils.toVector(b)) : b;
            }
            return r[h](this[0], m);
          };
        })(c[l]);
      }("sum sumsqrd sumsqerr sumrow product min max unique mean meansqerr geomean median diff rank mode range variance deviation stdev meandev meddev coeffvar quartiles histogram skewness kurtosis".split(" ")), function(c) {
        for (var l = 0; l < c.length; l++) (function(h) {
          f[h] = function() {
            var m = [], v = 0, b = this, A = Array.prototype.slice.call(arguments), _;
            if (i(A[A.length - 1])) {
              _ = A[A.length - 1];
              var C = A.slice(0, A.length - 1);
              return setTimeout(function() {
                _.call(b, f[h].apply(b, C));
              }), this;
            } else {
              _ = void 0;
              var I = function($) {
                return r[h].apply(b, [$].concat(A));
              };
            }
            if (this.length > 1) {
              for (b = b.transpose(); v < b.length; v++) m[v] = I(b[v]);
              return m;
            }
            return I(this[0]);
          };
        })(c[l]);
      }("quantiles percentileOfScore".split(" "));
    }(n, Math), function(r, s) {
      r.gammaln = function(a) {
        var o = 0, f = [76.18009172947146, -86.50532032941678, 24.01409824083091, -1.231739572450155, 0.001208650973866179, -5395239384953e-18], c = 1.000000000190015, l, h, m;
        for (m = (h = l = a) + 5.5, m -= (l + 0.5) * s.log(m); o < 6; o++) c += f[o] / ++h;
        return s.log(2.5066282746310007 * c / l) - m;
      }, r.loggam = function(a) {
        var o, f, c, l, h, m, v, b = [0.08333333333333333, -0.002777777777777778, 7936507936507937e-19, -5952380952380952e-19, 8417508417508418e-19, -0.001917526917526918, 0.00641025641025641, -0.02955065359477124, 0.1796443723688307, -1.3924322169059];
        if (o = a, v = 0, a == 1 || a == 2) return 0;
        for (a <= 7 && (v = s.floor(7 - a), o = a + v), f = 1 / (o * o), c = 2 * s.PI, h = b[9], m = 8; m >= 0; m--) h *= f, h += b[m];
        if (l = h / o + 0.5 * s.log(c) + (o - 0.5) * s.log(o) - o, a <= 7) for (m = 1; m <= v; m++) l -= s.log(o - 1), o -= 1;
        return l;
      }, r.gammafn = function(a) {
        var o = [-1.716185138865495, 24.76565080557592, -379.80425647094563, 629.3311553128184, 866.9662027904133, -31451.272968848367, -36144.413418691176, 66456.14382024054], f = [-30.8402300119739, 315.35062697960416, -1015.1563674902192, -3107.771671572311, 22538.11842098015, 4755.846277527881, -134659.9598649693, -115132.2596755535], c = false, l = 0, h = 0, m = 0, v = a, b, A, _, C;
        if (a > 171.6243769536076) return 1 / 0;
        if (v <= 0) if (C = v % 1 + 36e-17, C) c = (v & 1 ? -1 : 1) * s.PI / s.sin(s.PI * C), v = 1 - v;
        else return 1 / 0;
        for (_ = v, v < 1 ? A = v++ : A = (v -= l = (v | 0) - 1) - 1, b = 0; b < 8; ++b) m = (m + o[b]) * A, h = h * A + f[b];
        if (C = m / h + 1, _ < v) C /= _;
        else if (_ > v) for (b = 0; b < l; ++b) C *= v, v++;
        return c && (C = c / C), C;
      }, r.gammap = function(a, o) {
        return r.lowRegGamma(a, o) * r.gammafn(a);
      }, r.lowRegGamma = function(a, o) {
        var f = r.gammaln(a), c = a, l = 1 / a, h = l, m = o + 1 - a, v = 1 / 1e-30, b = 1 / m, A = b, _ = 1, C = -~(s.log(a >= 1 ? a : 1 / a) * 8.5 + a * 0.4 + 17), I;
        if (o < 0 || a <= 0) return NaN;
        if (o < a + 1) {
          for (; _ <= C; _++) l += h *= o / ++c;
          return l * s.exp(-o + a * s.log(o) - f);
        }
        for (; _ <= C; _++) I = -_ * (_ - a), m += 2, b = I * b + m, v = m + I / v, b = 1 / b, A *= b * v;
        return 1 - A * s.exp(-o + a * s.log(o) - f);
      }, r.factorialln = function(a) {
        return a < 0 ? NaN : r.gammaln(a + 1);
      }, r.factorial = function(a) {
        return a < 0 ? NaN : r.gammafn(a + 1);
      }, r.combination = function(a, o) {
        return a > 170 || o > 170 ? s.exp(r.combinationln(a, o)) : r.factorial(a) / r.factorial(o) / r.factorial(a - o);
      }, r.combinationln = function(a, o) {
        return r.factorialln(a) - r.factorialln(o) - r.factorialln(a - o);
      }, r.permutation = function(a, o) {
        return r.factorial(a) / r.factorial(a - o);
      }, r.betafn = function(a, o) {
        if (!(a <= 0 || o <= 0)) return a + o > 170 ? s.exp(r.betaln(a, o)) : r.gammafn(a) * r.gammafn(o) / r.gammafn(a + o);
      }, r.betaln = function(a, o) {
        return r.gammaln(a) + r.gammaln(o) - r.gammaln(a + o);
      }, r.betacf = function(a, o, f) {
        var c = 1e-30, l = 1, h = o + f, m = o + 1, v = o - 1, b = 1, A = 1 - h * a / m, _, C, I, S;
        for (s.abs(A) < c && (A = c), A = 1 / A, S = A; l <= 100 && (_ = 2 * l, C = l * (f - l) * a / ((v + _) * (o + _)), A = 1 + C * A, s.abs(A) < c && (A = c), b = 1 + C / b, s.abs(b) < c && (b = c), A = 1 / A, S *= A * b, C = -(o + l) * (h + l) * a / ((o + _) * (m + _)), A = 1 + C * A, s.abs(A) < c && (A = c), b = 1 + C / b, s.abs(b) < c && (b = c), A = 1 / A, I = A * b, S *= I, !(s.abs(I - 1) < 3e-7)); l++) ;
        return S;
      }, r.gammapinv = function(a, o) {
        var f = 0, c = o - 1, l = 1e-8, h = r.gammaln(o), m, v, b, A, _, C, I;
        if (a >= 1) return s.max(100, o + 100 * s.sqrt(o));
        if (a <= 0) return 0;
        for (o > 1 ? (C = s.log(c), I = s.exp(c * (C - 1) - h), _ = a < 0.5 ? a : 1 - a, b = s.sqrt(-2 * s.log(_)), m = (2.30753 + b * 0.27061) / (1 + b * (0.99229 + b * 0.04481)) - b, a < 0.5 && (m = -m), m = s.max(1e-3, o * s.pow(1 - 1 / (9 * o) - m / (3 * s.sqrt(o)), 3))) : (b = 1 - o * (0.253 + o * 0.12), a < b ? m = s.pow(a / b, 1 / o) : m = 1 - s.log(1 - (a - b) / (1 - b))); f < 12; f++) {
          if (m <= 0) return 0;
          if (v = r.lowRegGamma(o, m) - a, o > 1 ? b = I * s.exp(-(m - c) + c * (s.log(m) - C)) : b = s.exp(-m + c * s.log(m) - h), A = v / b, m -= b = A / (1 - 0.5 * s.min(1, A * ((o - 1) / m - 1))), m <= 0 && (m = 0.5 * (m + b)), s.abs(b) < l * m) break;
        }
        return m;
      }, r.erf = function(a) {
        var o = [-1.3026537197817094, 0.6419697923564902, 0.019476473204185836, -0.00956151478680863, -946595344482036e-18, 366839497852761e-18, 42523324806907e-18, -20278578112534e-18, -1624290004647e-18, 130365583558e-17, 15626441722e-18, -85238095915e-18, 6529054439e-18, 5059343495e-18, -991364156e-18, -227365122e-18, 96467911e-18, 2394038e-18, -6886027e-18, 894487e-18, 313092e-18, -112708e-18, 381e-18, 7106e-18, -1523e-18, -94e-18, 121e-18, -28e-18], f = o.length - 1, c = false, l = 0, h = 0, m, v, b, A;
        for (a < 0 && (a = -a, c = true), m = 2 / (2 + a), v = 4 * m - 2; f > 0; f--) b = l, l = v * l - h + o[f], h = b;
        return A = m * s.exp(-a * a + 0.5 * (o[0] + v * l) - h), c ? A - 1 : 1 - A;
      }, r.erfc = function(a) {
        return 1 - r.erf(a);
      }, r.erfcinv = function(a) {
        var o = 0, f, c, l, h;
        if (a >= 2) return -100;
        if (a <= 0) return 100;
        for (h = a < 1 ? a : 2 - a, l = s.sqrt(-2 * s.log(h / 2)), f = -0.70711 * ((2.30753 + l * 0.27061) / (1 + l * (0.99229 + l * 0.04481)) - l); o < 2; o++) c = r.erfc(f) - h, f += c / (1.1283791670955126 * s.exp(-f * f) - f * c);
        return a < 1 ? f : -f;
      }, r.ibetainv = function(a, o, f) {
        var c = 1e-8, l = o - 1, h = f - 1, m = 0, v, b, A, _, C, I, S, $, F, U, Q;
        if (a <= 0) return 0;
        if (a >= 1) return 1;
        for (o >= 1 && f >= 1 ? (A = a < 0.5 ? a : 1 - a, _ = s.sqrt(-2 * s.log(A)), S = (2.30753 + _ * 0.27061) / (1 + _ * (0.99229 + _ * 0.04481)) - _, a < 0.5 && (S = -S), $ = (S * S - 3) / 6, F = 2 / (1 / (2 * o - 1) + 1 / (2 * f - 1)), U = S * s.sqrt($ + F) / F - (1 / (2 * f - 1) - 1 / (2 * o - 1)) * ($ + 5 / 6 - 2 / (3 * F)), S = o / (o + f * s.exp(2 * U))) : (v = s.log(o / (o + f)), b = s.log(f / (o + f)), _ = s.exp(o * v) / o, C = s.exp(f * b) / f, U = _ + C, a < _ / U ? S = s.pow(o * U * a, 1 / o) : S = 1 - s.pow(f * U * (1 - a), 1 / f)), Q = -r.gammaln(o) - r.gammaln(f) + r.gammaln(o + f); m < 10; m++) {
          if (S === 0 || S === 1) return S;
          if (I = r.ibeta(S, o, f) - a, _ = s.exp(l * s.log(S) + h * s.log(1 - S) + Q), C = I / _, S -= _ = C / (1 - 0.5 * s.min(1, C * (l / S - h / (1 - S)))), S <= 0 && (S = 0.5 * (S + _)), S >= 1 && (S = 0.5 * (S + _ + 1)), s.abs(_) < c * S && m > 0) break;
        }
        return S;
      }, r.ibeta = function(a, o, f) {
        var c = a === 0 || a === 1 ? 0 : s.exp(r.gammaln(o + f) - r.gammaln(o) - r.gammaln(f) + o * s.log(a) + f * s.log(1 - a));
        return a < 0 || a > 1 ? false : a < (o + 1) / (o + f + 2) ? c * r.betacf(a, o, f) / o : 1 - c * r.betacf(1 - a, f, o) / f;
      }, r.randn = function(a, o) {
        var f, c, l, h, m;
        if (o || (o = a), a) return r.create(a, o, function() {
          return r.randn();
        });
        do
          f = r._random_fn(), c = 1.7156 * (r._random_fn() - 0.5), l = f - 0.449871, h = s.abs(c) + 0.386595, m = l * l + h * (0.196 * h - 0.25472 * l);
        while (m > 0.27597 && (m > 0.27846 || c * c > -4 * s.log(f) * f * f));
        return c / f;
      }, r.randg = function(a, o, f) {
        var c = a, l, h, m, v, b, A;
        if (f || (f = o), a || (a = 1), o) return A = r.zeros(o, f), A.alter(function() {
          return r.randg(a);
        }), A;
        a < 1 && (a += 1), l = a - 1 / 3, h = 1 / s.sqrt(9 * l);
        do {
          do
            b = r.randn(), v = 1 + h * b;
          while (v <= 0);
          v = v * v * v, m = r._random_fn();
        } while (m > 1 - 0.331 * s.pow(b, 4) && s.log(m) > 0.5 * b * b + l * (1 - v + s.log(v)));
        if (a == c) return l * v;
        do
          m = r._random_fn();
        while (m === 0);
        return s.pow(m, 1 / c) * l * v;
      }, function(i) {
        for (var a = 0; a < i.length; a++) (function(o) {
          r.fn[o] = function() {
            return r(r.map(this, function(f) {
              return r[o](f);
            }));
          };
        })(i[a]);
      }("gammaln gammafn factorial factorialln".split(" ")), function(i) {
        for (var a = 0; a < i.length; a++) (function(o) {
          r.fn[o] = function() {
            return r(r[o].apply(null, arguments));
          };
        })(i[a]);
      }("randn".split(" "));
    }(n, Math), function(r, s) {
      (function(c) {
        for (var l = 0; l < c.length; l++) (function(h) {
          r[h] = function m(v, b, A) {
            return this instanceof m ? (this._a = v, this._b = b, this._c = A, this) : new m(v, b, A);
          }, r.fn[h] = function(m, v, b) {
            var A = r[h](m, v, b);
            return A.data = this, A;
          }, r[h].prototype.sample = function(m) {
            var v = this._a, b = this._b, A = this._c;
            return m ? r.alter(m, function() {
              return r[h].sample(v, b, A);
            }) : r[h].sample(v, b, A);
          }, function(m) {
            for (var v = 0; v < m.length; v++) (function(b) {
              r[h].prototype[b] = function(A) {
                var _ = this._a, C = this._b, I = this._c;
                return !A && A !== 0 && (A = this.data), typeof A != "number" ? r.fn.map.call(A, function(S) {
                  return r[h][b](S, _, C, I);
                }) : r[h][b](A, _, C, I);
              };
            })(m[v]);
          }("pdf cdf inv".split(" ")), function(m) {
            for (var v = 0; v < m.length; v++) (function(b) {
              r[h].prototype[b] = function() {
                return r[h][b](this._a, this._b, this._c);
              };
            })(m[v]);
          }("mean median mode variance".split(" "));
        })(c[l]);
      })("beta centralF cauchy chisquare exponential gamma invgamma kumaraswamy laplace lognormal noncentralt normal pareto studentt weibull uniform binomial negbin hypgeom poisson triangular tukey arcsine".split(" ")), r.extend(r.beta, { pdf: function(l, h, m) {
        return l > 1 || l < 0 ? 0 : h == 1 && m == 1 ? 1 : h < 512 && m < 512 ? s.pow(l, h - 1) * s.pow(1 - l, m - 1) / r.betafn(h, m) : s.exp((h - 1) * s.log(l) + (m - 1) * s.log(1 - l) - r.betaln(h, m));
      }, cdf: function(l, h, m) {
        return l > 1 || l < 0 ? (l > 1) * 1 : r.ibeta(l, h, m);
      }, inv: function(l, h, m) {
        return r.ibetainv(l, h, m);
      }, mean: function(l, h) {
        return l / (l + h);
      }, median: function(l, h) {
        return r.ibetainv(0.5, l, h);
      }, mode: function(l, h) {
        return (l - 1) / (l + h - 2);
      }, sample: function(l, h) {
        var m = r.randg(l);
        return m / (m + r.randg(h));
      }, variance: function(l, h) {
        return l * h / (s.pow(l + h, 2) * (l + h + 1));
      } }), r.extend(r.centralF, { pdf: function(l, h, m) {
        var v, b, A;
        return l < 0 ? 0 : h <= 2 ? l === 0 && h < 2 ? 1 / 0 : l === 0 && h === 2 ? 1 : 1 / r.betafn(h / 2, m / 2) * s.pow(h / m, h / 2) * s.pow(l, h / 2 - 1) * s.pow(1 + h / m * l, -(h + m) / 2) : (v = h * l / (m + l * h), b = m / (m + l * h), A = h * b / 2, A * r.binomial.pdf((h - 2) / 2, (h + m - 2) / 2, v));
      }, cdf: function(l, h, m) {
        return l < 0 ? 0 : r.ibeta(h * l / (h * l + m), h / 2, m / 2);
      }, inv: function(l, h, m) {
        return m / (h * (1 / r.ibetainv(l, h / 2, m / 2) - 1));
      }, mean: function(l, h) {
        return h > 2 ? h / (h - 2) : void 0;
      }, mode: function(l, h) {
        return l > 2 ? h * (l - 2) / (l * (h + 2)) : void 0;
      }, sample: function(l, h) {
        var m = r.randg(l / 2) * 2, v = r.randg(h / 2) * 2;
        return m / l / (v / h);
      }, variance: function(l, h) {
        if (!(h <= 4)) return 2 * h * h * (l + h - 2) / (l * (h - 2) * (h - 2) * (h - 4));
      } }), r.extend(r.cauchy, { pdf: function(l, h, m) {
        return m < 0 ? 0 : m / (s.pow(l - h, 2) + s.pow(m, 2)) / s.PI;
      }, cdf: function(l, h, m) {
        return s.atan((l - h) / m) / s.PI + 0.5;
      }, inv: function(c, l, h) {
        return l + h * s.tan(s.PI * (c - 0.5));
      }, median: function(l) {
        return l;
      }, mode: function(l) {
        return l;
      }, sample: function(l, h) {
        return r.randn() * s.sqrt(1 / (2 * r.randg(0.5))) * h + l;
      } }), r.extend(r.chisquare, { pdf: function(l, h) {
        return l < 0 ? 0 : l === 0 && h === 2 ? 0.5 : s.exp((h / 2 - 1) * s.log(l) - l / 2 - h / 2 * s.log(2) - r.gammaln(h / 2));
      }, cdf: function(l, h) {
        return l < 0 ? 0 : r.lowRegGamma(h / 2, l / 2);
      }, inv: function(c, l) {
        return 2 * r.gammapinv(c, 0.5 * l);
      }, mean: function(c) {
        return c;
      }, median: function(l) {
        return l * s.pow(1 - 2 / (9 * l), 3);
      }, mode: function(l) {
        return l - 2 > 0 ? l - 2 : 0;
      }, sample: function(l) {
        return r.randg(l / 2) * 2;
      }, variance: function(l) {
        return 2 * l;
      } }), r.extend(r.exponential, { pdf: function(l, h) {
        return l < 0 ? 0 : h * s.exp(-h * l);
      }, cdf: function(l, h) {
        return l < 0 ? 0 : 1 - s.exp(-h * l);
      }, inv: function(c, l) {
        return -s.log(1 - c) / l;
      }, mean: function(c) {
        return 1 / c;
      }, median: function(c) {
        return 1 / c * s.log(2);
      }, mode: function() {
        return 0;
      }, sample: function(l) {
        return -1 / l * s.log(r._random_fn());
      }, variance: function(c) {
        return s.pow(c, -2);
      } }), r.extend(r.gamma, { pdf: function(l, h, m) {
        return l < 0 ? 0 : l === 0 && h === 1 ? 1 / m : s.exp((h - 1) * s.log(l) - l / m - r.gammaln(h) - h * s.log(m));
      }, cdf: function(l, h, m) {
        return l < 0 ? 0 : r.lowRegGamma(h, l / m);
      }, inv: function(c, l, h) {
        return r.gammapinv(c, l) * h;
      }, mean: function(c, l) {
        return c * l;
      }, mode: function(l, h) {
        if (l > 1) return (l - 1) * h;
      }, sample: function(l, h) {
        return r.randg(l) * h;
      }, variance: function(l, h) {
        return l * h * h;
      } }), r.extend(r.invgamma, { pdf: function(l, h, m) {
        return l <= 0 ? 0 : s.exp(-(h + 1) * s.log(l) - m / l - r.gammaln(h) + h * s.log(m));
      }, cdf: function(l, h, m) {
        return l <= 0 ? 0 : 1 - r.lowRegGamma(h, m / l);
      }, inv: function(c, l, h) {
        return h / r.gammapinv(1 - c, l);
      }, mean: function(c, l) {
        return c > 1 ? l / (c - 1) : void 0;
      }, mode: function(l, h) {
        return h / (l + 1);
      }, sample: function(l, h) {
        return h / r.randg(l);
      }, variance: function(l, h) {
        if (!(l <= 2)) return h * h / ((l - 1) * (l - 1) * (l - 2));
      } }), r.extend(r.kumaraswamy, { pdf: function(l, h, m) {
        return l === 0 && h === 1 ? m : l === 1 && m === 1 ? h : s.exp(s.log(h) + s.log(m) + (h - 1) * s.log(l) + (m - 1) * s.log(1 - s.pow(l, h)));
      }, cdf: function(l, h, m) {
        return l < 0 ? 0 : l > 1 ? 1 : 1 - s.pow(1 - s.pow(l, h), m);
      }, inv: function(l, h, m) {
        return s.pow(1 - s.pow(1 - l, 1 / m), 1 / h);
      }, mean: function(c, l) {
        return l * r.gammafn(1 + 1 / c) * r.gammafn(l) / r.gammafn(1 + 1 / c + l);
      }, median: function(l, h) {
        return s.pow(1 - s.pow(2, -1 / h), 1 / l);
      }, mode: function(l, h) {
        if (l >= 1 && h >= 1 && l !== 1 && h !== 1) return s.pow((l - 1) / (l * h - 1), 1 / l);
      }, variance: function() {
        throw new Error("variance not yet implemented");
      } }), r.extend(r.lognormal, { pdf: function(l, h, m) {
        return l <= 0 ? 0 : s.exp(-s.log(l) - 0.5 * s.log(2 * s.PI) - s.log(m) - s.pow(s.log(l) - h, 2) / (2 * m * m));
      }, cdf: function(l, h, m) {
        return l < 0 ? 0 : 0.5 + 0.5 * r.erf((s.log(l) - h) / s.sqrt(2 * m * m));
      }, inv: function(c, l, h) {
        return s.exp(-1.4142135623730951 * h * r.erfcinv(2 * c) + l);
      }, mean: function(l, h) {
        return s.exp(l + h * h / 2);
      }, median: function(l) {
        return s.exp(l);
      }, mode: function(l, h) {
        return s.exp(l - h * h);
      }, sample: function(l, h) {
        return s.exp(r.randn() * h + l);
      }, variance: function(l, h) {
        return (s.exp(h * h) - 1) * s.exp(2 * l + h * h);
      } }), r.extend(r.noncentralt, { pdf: function(l, h, m) {
        var v = 1e-14;
        return s.abs(m) < v ? r.studentt.pdf(l, h) : s.abs(l) < v ? s.exp(r.gammaln((h + 1) / 2) - m * m / 2 - 0.5 * s.log(s.PI * h) - r.gammaln(h / 2)) : h / l * (r.noncentralt.cdf(l * s.sqrt(1 + 2 / h), h + 2, m) - r.noncentralt.cdf(l, h, m));
      }, cdf: function(l, h, m) {
        var v = 1e-14, b = 200;
        if (s.abs(m) < v) return r.studentt.cdf(l, h);
        var A = false;
        l < 0 && (A = true, m = -m);
        for (var _ = r.normal.cdf(-m, 0, 1), C = v + 1, I = C, S = l * l / (l * l + h), $ = 0, F = s.exp(-m * m / 2), U = s.exp(-m * m / 2 - 0.5 * s.log(2) - r.gammaln(3 / 2)) * m; $ < b || I > v || C > v; ) I = C, $ > 0 && (F *= m * m / (2 * $), U *= m * m / (2 * ($ + 1 / 2))), C = F * r.beta.cdf(S, $ + 0.5, h / 2) + U * r.beta.cdf(S, $ + 1, h / 2), _ += 0.5 * C, $++;
        return A ? 1 - _ : _;
      } }), r.extend(r.normal, { pdf: function(l, h, m) {
        return s.exp(-0.5 * s.log(2 * s.PI) - s.log(m) - s.pow(l - h, 2) / (2 * m * m));
      }, cdf: function(l, h, m) {
        return 0.5 * (1 + r.erf((l - h) / s.sqrt(2 * m * m)));
      }, inv: function(c, l, h) {
        return -1.4142135623730951 * h * r.erfcinv(2 * c) + l;
      }, mean: function(c) {
        return c;
      }, median: function(l) {
        return l;
      }, mode: function(c) {
        return c;
      }, sample: function(l, h) {
        return r.randn() * h + l;
      }, variance: function(c, l) {
        return l * l;
      } }), r.extend(r.pareto, { pdf: function(l, h, m) {
        return l < h ? 0 : m * s.pow(h, m) / s.pow(l, m + 1);
      }, cdf: function(l, h, m) {
        return l < h ? 0 : 1 - s.pow(h / l, m);
      }, inv: function(l, h, m) {
        return h / s.pow(1 - l, 1 / m);
      }, mean: function(l, h) {
        if (!(h <= 1)) return h * s.pow(l, h) / (h - 1);
      }, median: function(l, h) {
        return l * (h * s.SQRT2);
      }, mode: function(l) {
        return l;
      }, variance: function(c, l) {
        if (!(l <= 2)) return c * c * l / (s.pow(l - 1, 2) * (l - 2));
      } }), r.extend(r.studentt, { pdf: function(l, h) {
        return h = h > 1e100 ? 1e100 : h, 1 / (s.sqrt(h) * r.betafn(0.5, h / 2)) * s.pow(1 + l * l / h, -((h + 1) / 2));
      }, cdf: function(l, h) {
        var m = h / 2;
        return r.ibeta((l + s.sqrt(l * l + h)) / (2 * s.sqrt(l * l + h)), m, m);
      }, inv: function(c, l) {
        var h = r.ibetainv(2 * s.min(c, 1 - c), 0.5 * l, 0.5);
        return h = s.sqrt(l * (1 - h) / h), c > 0.5 ? h : -h;
      }, mean: function(l) {
        return l > 1 ? 0 : void 0;
      }, median: function() {
        return 0;
      }, mode: function() {
        return 0;
      }, sample: function(l) {
        return r.randn() * s.sqrt(l / (2 * r.randg(l / 2)));
      }, variance: function(l) {
        return l > 2 ? l / (l - 2) : l > 1 ? 1 / 0 : void 0;
      } }), r.extend(r.weibull, { pdf: function(l, h, m) {
        return l < 0 || h < 0 || m < 0 ? 0 : m / h * s.pow(l / h, m - 1) * s.exp(-s.pow(l / h, m));
      }, cdf: function(l, h, m) {
        return l < 0 ? 0 : 1 - s.exp(-s.pow(l / h, m));
      }, inv: function(c, l, h) {
        return l * s.pow(-s.log(1 - c), 1 / h);
      }, mean: function(c, l) {
        return c * r.gammafn(1 + 1 / l);
      }, median: function(l, h) {
        return l * s.pow(s.log(2), 1 / h);
      }, mode: function(l, h) {
        return h <= 1 ? 0 : l * s.pow((h - 1) / h, 1 / h);
      }, sample: function(l, h) {
        return l * s.pow(-s.log(r._random_fn()), 1 / h);
      }, variance: function(l, h) {
        return l * l * r.gammafn(1 + 2 / h) - s.pow(r.weibull.mean(l, h), 2);
      } }), r.extend(r.uniform, { pdf: function(l, h, m) {
        return l < h || l > m ? 0 : 1 / (m - h);
      }, cdf: function(l, h, m) {
        return l < h ? 0 : l < m ? (l - h) / (m - h) : 1;
      }, inv: function(c, l, h) {
        return l + c * (h - l);
      }, mean: function(l, h) {
        return 0.5 * (l + h);
      }, median: function(l, h) {
        return r.mean(l, h);
      }, mode: function() {
        throw new Error("mode is not yet implemented");
      }, sample: function(l, h) {
        return l / 2 + h / 2 + (h / 2 - l / 2) * (2 * r._random_fn() - 1);
      }, variance: function(l, h) {
        return s.pow(h - l, 2) / 12;
      } });
      function i(c, l, h, m) {
        for (var v = 0, b = 1, A = 1, _ = 1, C = 0, I = 0, S; s.abs((A - I) / A) > m; ) I = A, S = -(l + C) * (l + h + C) * c / (l + 2 * C) / (l + 2 * C + 1), v = A + S * v, b = _ + S * b, C = C + 1, S = C * (h - C) * c / (l + 2 * C - 1) / (l + 2 * C), A = v + S * A, _ = b + S * _, v = v / _, b = b / _, A = A / _, _ = 1;
        return A / l;
      }
      r.extend(r.binomial, { pdf: function(l, h, m) {
        return m === 0 || m === 1 ? h * m === l ? 1 : 0 : r.combination(h, l) * s.pow(m, l) * s.pow(1 - m, h - l);
      }, cdf: function(l, h, m) {
        var v, b = 1e-10;
        if (l < 0) return 0;
        if (l >= h) return 1;
        if (m < 0 || m > 1 || h <= 0) return NaN;
        l = s.floor(l);
        var A = m, _ = l + 1, C = h - l, I = _ + C, S = s.exp(r.gammaln(I) - r.gammaln(C) - r.gammaln(_) + _ * s.log(A) + C * s.log(1 - A));
        return A < (_ + 1) / (I + 2) ? v = S * i(A, _, C, b) : v = 1 - S * i(1 - A, C, _, b), s.round((1 - v) * (1 / b)) / (1 / b);
      } }), r.extend(r.negbin, { pdf: function(l, h, m) {
        return l !== l >>> 0 ? false : l < 0 ? 0 : r.combination(l + h - 1, h - 1) * s.pow(1 - m, l) * s.pow(m, h);
      }, cdf: function(l, h, m) {
        var v = 0, b = 0;
        if (l < 0) return 0;
        for (; b <= l; b++) v += r.negbin.pdf(b, h, m);
        return v;
      } }), r.extend(r.hypgeom, { pdf: function(l, h, m, v) {
        if (l !== l | 0) return false;
        if (l < 0 || l < m - (h - v)) return 0;
        if (l > v || l > m) return 0;
        if (m * 2 > h) return v * 2 > h ? r.hypgeom.pdf(h - m - v + l, h, h - m, h - v) : r.hypgeom.pdf(v - l, h, h - m, v);
        if (v * 2 > h) return r.hypgeom.pdf(m - l, h, m, h - v);
        if (m < v) return r.hypgeom.pdf(l, h, v, m);
        for (var b = 1, A = 0, _ = 0; _ < l; _++) {
          for (; b > 1 && A < v; ) b *= 1 - m / (h - A), A++;
          b *= (v - _) * (m - _) / ((_ + 1) * (h - m - v + _ + 1));
        }
        for (; A < v; A++) b *= 1 - m / (h - A);
        return s.min(1, s.max(0, b));
      }, cdf: function(l, h, m, v) {
        if (l < 0 || l < m - (h - v)) return 0;
        if (l >= v || l >= m) return 1;
        if (m * 2 > h) return v * 2 > h ? r.hypgeom.cdf(h - m - v + l, h, h - m, h - v) : 1 - r.hypgeom.cdf(v - l - 1, h, h - m, v);
        if (v * 2 > h) return 1 - r.hypgeom.cdf(m - l - 1, h, m, h - v);
        if (m < v) return r.hypgeom.cdf(l, h, v, m);
        for (var b = 1, A = 1, _ = 0, C = 0; C < l; C++) {
          for (; b > 1 && _ < v; ) {
            var I = 1 - m / (h - _);
            A *= I, b *= I, _++;
          }
          A *= (v - C) * (m - C) / ((C + 1) * (h - m - v + C + 1)), b += A;
        }
        for (; _ < v; _++) b *= 1 - m / (h - _);
        return s.min(1, s.max(0, b));
      } }), r.extend(r.poisson, { pdf: function(l, h) {
        return h < 0 || l % 1 !== 0 || l < 0 ? 0 : s.pow(h, l) * s.exp(-h) / r.factorial(l);
      }, cdf: function(l, h) {
        var m = [], v = 0;
        if (l < 0) return 0;
        for (; v <= l; v++) m.push(r.poisson.pdf(v, h));
        return r.sum(m);
      }, mean: function(c) {
        return c;
      }, variance: function(c) {
        return c;
      }, sampleSmall: function(l) {
        var h = 1, m = 0, v = s.exp(-l);
        do
          m++, h *= r._random_fn();
        while (h > v);
        return m - 1;
      }, sampleLarge: function(l) {
        var h = l, m, v, b, A, _, C, I, S, $, F;
        for (A = s.sqrt(h), _ = s.log(h), I = 0.931 + 2.53 * A, C = -0.059 + 0.02483 * I, S = 1.1239 + 1.1328 / (I - 3.4), $ = 0.9277 - 3.6224 / (I - 2); ; ) {
          if (v = s.random() - 0.5, b = s.random(), F = 0.5 - s.abs(v), m = s.floor((2 * C / F + I) * v + h + 0.43), F >= 0.07 && b <= $) return m;
          if (!(m < 0 || F < 0.013 && b > F) && s.log(b) + s.log(S) - s.log(C / (F * F) + I) <= -h + m * _ - r.loggam(m + 1)) return m;
        }
      }, sample: function(l) {
        return l < 10 ? this.sampleSmall(l) : this.sampleLarge(l);
      } }), r.extend(r.triangular, { pdf: function(l, h, m, v) {
        return m <= h || v < h || v > m ? NaN : l < h || l > m ? 0 : l < v ? 2 * (l - h) / ((m - h) * (v - h)) : l === v ? 2 / (m - h) : 2 * (m - l) / ((m - h) * (m - v));
      }, cdf: function(l, h, m, v) {
        return m <= h || v < h || v > m ? NaN : l <= h ? 0 : l >= m ? 1 : l <= v ? s.pow(l - h, 2) / ((m - h) * (v - h)) : 1 - s.pow(m - l, 2) / ((m - h) * (m - v));
      }, inv: function(l, h, m, v) {
        return m <= h || v < h || v > m ? NaN : l <= (v - h) / (m - h) ? h + (m - h) * s.sqrt(l * ((v - h) / (m - h))) : h + (m - h) * (1 - s.sqrt((1 - l) * (1 - (v - h) / (m - h))));
      }, mean: function(l, h, m) {
        return (l + h + m) / 3;
      }, median: function(l, h, m) {
        if (m <= (l + h) / 2) return h - s.sqrt((h - l) * (h - m)) / s.sqrt(2);
        if (m > (l + h) / 2) return l + s.sqrt((h - l) * (m - l)) / s.sqrt(2);
      }, mode: function(l, h, m) {
        return m;
      }, sample: function(l, h, m) {
        var v = r._random_fn();
        return v < (m - l) / (h - l) ? l + s.sqrt(v * (h - l) * (m - l)) : h - s.sqrt((1 - v) * (h - l) * (h - m));
      }, variance: function(l, h, m) {
        return (l * l + h * h + m * m - l * h - l * m - h * m) / 18;
      } }), r.extend(r.arcsine, { pdf: function(l, h, m) {
        return m <= h ? NaN : l <= h || l >= m ? 0 : 2 / s.PI * s.pow(s.pow(m - h, 2) - s.pow(2 * l - h - m, 2), -0.5);
      }, cdf: function(l, h, m) {
        return l < h ? 0 : l < m ? 2 / s.PI * s.asin(s.sqrt((l - h) / (m - h))) : 1;
      }, inv: function(c, l, h) {
        return l + (0.5 - 0.5 * s.cos(s.PI * c)) * (h - l);
      }, mean: function(l, h) {
        return h <= l ? NaN : (l + h) / 2;
      }, median: function(l, h) {
        return h <= l ? NaN : (l + h) / 2;
      }, mode: function() {
        throw new Error("mode is not yet implemented");
      }, sample: function(l, h) {
        return (l + h) / 2 + (h - l) / 2 * s.sin(2 * s.PI * r.uniform.sample(0, 1));
      }, variance: function(l, h) {
        return h <= l ? NaN : s.pow(h - l, 2) / 8;
      } });
      function a(c) {
        return c / s.abs(c);
      }
      r.extend(r.laplace, { pdf: function(l, h, m) {
        return m <= 0 ? 0 : s.exp(-s.abs(l - h) / m) / (2 * m);
      }, cdf: function(l, h, m) {
        return m <= 0 ? 0 : l < h ? 0.5 * s.exp((l - h) / m) : 1 - 0.5 * s.exp(-(l - h) / m);
      }, mean: function(c) {
        return c;
      }, median: function(c) {
        return c;
      }, mode: function(c) {
        return c;
      }, variance: function(c, l) {
        return 2 * l * l;
      }, sample: function(l, h) {
        var m = r._random_fn() - 0.5;
        return l - h * a(m) * s.log(1 - 2 * s.abs(m));
      } });
      function o(c, l, h) {
        var m = 12, v = 6, b = -30, A = -50, _ = 60, C = 8, I = 3, S = 2, $ = 3, F = [0.9815606342467192, 0.9041172563704749, 0.7699026741943047, 0.5873179542866175, 0.3678314989981802, 0.1252334085114689], U = [0.04717533638651183, 0.10693932599531843, 0.16007832854334622, 0.20316742672306592, 0.2334925365383548, 0.24914704581340277], Q = c * 0.5;
        if (Q >= C) return 1;
        var P = 2 * r.normal.cdf(Q, 0, 1, 1, 0) - 1;
        P >= s.exp(A / h) ? P = s.pow(P, h) : P = 0;
        var N;
        c > I ? N = S : N = $;
        for (var L = Q, B = (C - Q) / N, u = L + B, p = 0, d = h - 1, y = 1; y <= N; y++) {
          for (var w = 0, E = 0.5 * (u + L), M = 0.5 * (u - L), x = 1; x <= m; x++) {
            var g, k;
            v < x ? (g = m - x + 1, k = F[g - 1]) : (g = x, k = -F[g - 1]);
            var T = M * k, O = E + T, K = O * O;
            if (K > _) break;
            var Y = 2 * r.normal.cdf(O, 0, 1, 1, 0), J = 2 * r.normal.cdf(O, c, 1, 1, 0), G = Y * 0.5 - J * 0.5;
            G >= s.exp(b / d) && (G = U[g - 1] * s.exp(-(0.5 * K)) * s.pow(G, d), w += G);
          }
          w *= 2 * M * h / s.sqrt(2 * s.PI), p += w, L = u, u += B;
        }
        return P += p, P <= s.exp(b / l) ? 0 : (P = s.pow(P, l), P >= 1 ? 1 : P);
      }
      function f(c, l, h) {
        var m = 0.322232421088, v = 0.099348462606, b = -1, A = 0.588581570495, _ = -0.342242088547, C = 0.531103462366, I = -0.204231210125, S = 0.10353775285, $ = -453642210148e-16, F = 0.0038560700634, U = 0.8832, Q = 0.2368, P = 1.208, N = 1.4142, L = 120, B = 0.5 - 0.5 * c, u = s.sqrt(s.log(1 / (B * B))), p = u + ((((u * $ + I) * u + _) * u + b) * u + m) / ((((u * F + S) * u + C) * u + A) * u + v);
        h < L && (p += (p * p * p + p) / h / 4);
        var d = U - Q * p;
        return h < L && (d += -1.214 / h + P * p / h), p * (d * s.log(l - 1) + N);
      }
      r.extend(r.tukey, { cdf: function(l, h, m) {
        var v = 1, b = h, A = 16, _ = 8, C = -30, I = 1e-14, S = 100, $ = 800, F = 5e3, U = 25e3, Q = 1, P = 0.5, N = 0.25, L = 0.125, B = [0.9894009349916499, 0.9445750230732326, 0.8656312023878318, 0.755404408355003, 0.6178762444026438, 0.45801677765722737, 0.2816035507792589, 0.09501250983763744], u = [0.027152459411754096, 0.062253523938647894, 0.09515851168249279, 0.12462897125553388, 0.14959598881657674, 0.16915651939500254, 0.18260341504492358, 0.1894506104550685];
        if (l <= 0) return 0;
        if (m < 2 || v < 1 || b < 2) return NaN;
        if (!Number.isFinite(l)) return 1;
        if (m > U) return o(l, v, b);
        var p = m * 0.5, d = p * s.log(m) - m * s.log(2) - r.gammaln(p), y = p - 1, w = m * 0.25, E;
        m <= S ? E = Q : m <= $ ? E = P : m <= F ? E = N : E = L, d += s.log(E);
        for (var M = 0, x = 1; x <= 50; x++) {
          for (var g = 0, k = (2 * x - 1) * E, T = 1; T <= A; T++) {
            var O, K;
            _ < T ? (O = T - _ - 1, K = d + y * s.log(k + B[O] * E) - (B[O] * E + k) * w) : (O = T - 1, K = d + y * s.log(k - B[O] * E) + (B[O] * E - k) * w);
            var Y;
            if (K >= C) {
              _ < T ? Y = l * s.sqrt((B[O] * E + k) * 0.5) : Y = l * s.sqrt((-(B[O] * E) + k) * 0.5);
              var J = o(Y, v, b), G = J * u[O] * s.exp(K);
              g += G;
            }
          }
          if (x * E >= 1 && g <= I) break;
          M += g;
        }
        if (g > I) throw new Error("tukey.cdf failed to converge");
        return M > 1 && (M = 1), M;
      }, inv: function(c, l, h) {
        var m = 1, v = l, b = 1e-4, A = 50;
        if (h < 2 || m < 1 || v < 2) return NaN;
        if (c < 0 || c > 1) return NaN;
        if (c === 0) return 0;
        if (c === 1) return 1 / 0;
        var _ = f(c, v, h), C = r.tukey.cdf(_, l, h) - c, I;
        C > 0 ? I = s.max(0, _ - 1) : I = _ + 1;
        for (var S = r.tukey.cdf(I, l, h) - c, $, F = 1; F < A; F++) {
          $ = I - S * (I - _) / (S - C), C = S, _ = I, $ < 0 && ($ = 0, S = -c), S = r.tukey.cdf($, l, h) - c, I = $;
          var U = s.abs(I - _);
          if (U < b) return $;
        }
        throw new Error("tukey.inv failed to converge");
      } });
    }(n, Math), function(r, s) {
      var i = Array.prototype.push, a = r.utils.isArray;
      function o(f) {
        return a(f) || f instanceof r;
      }
      r.extend({ add: function(c, l) {
        return o(l) ? (o(l[0]) || (l = [l]), r.map(c, function(h, m, v) {
          return h + l[m][v];
        })) : r.map(c, function(h) {
          return h + l;
        });
      }, subtract: function(c, l) {
        return o(l) ? (o(l[0]) || (l = [l]), r.map(c, function(h, m, v) {
          return h - l[m][v] || 0;
        })) : r.map(c, function(h) {
          return h - l;
        });
      }, divide: function(c, l) {
        return o(l) ? (o(l[0]) || (l = [l]), r.multiply(c, r.inv(l))) : r.map(c, function(h) {
          return h / l;
        });
      }, multiply: function(c, l) {
        var h, m, v, b, A, _, C, I;
        if (c.length === void 0 && l.length === void 0) return c * l;
        if (A = c.length, _ = c[0].length, C = r.zeros(A, v = o(l) ? l[0].length : _), I = 0, o(l)) {
          for (; I < v; I++) for (h = 0; h < A; h++) {
            for (b = 0, m = 0; m < _; m++) b += c[h][m] * l[m][I];
            C[h][I] = b;
          }
          return A === 1 && I === 1 ? C[0][0] : C;
        }
        return r.map(c, function(S) {
          return S * l;
        });
      }, outer: function(c, l) {
        return r.multiply(c.map(function(h) {
          return [h];
        }), [l]);
      }, dot: function(c, l) {
        o(c[0]) || (c = [c]), o(l[0]) || (l = [l]);
        for (var h = c[0].length === 1 && c.length !== 1 ? r.transpose(c) : c, m = l[0].length === 1 && l.length !== 1 ? r.transpose(l) : l, v = [], b = 0, A = h.length, _ = h[0].length, C, I; b < A; b++) {
          for (v[b] = [], C = 0, I = 0; I < _; I++) C += h[b][I] * m[b][I];
          v[b] = C;
        }
        return v.length === 1 ? v[0] : v;
      }, pow: function(c, l) {
        return r.map(c, function(h) {
          return s.pow(h, l);
        });
      }, exp: function(c) {
        return r.map(c, function(l) {
          return s.exp(l);
        });
      }, log: function(c) {
        return r.map(c, function(l) {
          return s.log(l);
        });
      }, abs: function(c) {
        return r.map(c, function(l) {
          return s.abs(l);
        });
      }, norm: function(c, l) {
        var h = 0, m = 0;
        for (isNaN(l) && (l = 2), o(c[0]) && (c = c[0]); m < c.length; m++) h += s.pow(s.abs(c[m]), l);
        return s.pow(h, 1 / l);
      }, angle: function(c, l) {
        return s.acos(r.dot(c, l) / (r.norm(c) * r.norm(l)));
      }, aug: function(c, l) {
        var h = [], m;
        for (m = 0; m < c.length; m++) h.push(c[m].slice());
        for (m = 0; m < h.length; m++) i.apply(h[m], l[m]);
        return h;
      }, inv: function(c) {
        for (var l = c.length, h = c[0].length, m = r.identity(l, h), v = r.gauss_jordan(c, m), b = [], A = 0, _; A < l; A++) for (b[A] = [], _ = h; _ < v[0].length; _++) b[A][_ - h] = v[A][_];
        return b;
      }, det: function f(c) {
        if (c.length === 2) return c[0][0] * c[1][1] - c[0][1] * c[1][0];
        for (var l = 0, h = 0; h < c.length; h++) {
          for (var m = [], v = 1; v < c.length; v++) {
            m[v - 1] = [];
            for (var b = 0; b < c.length; b++) b < h ? m[v - 1][b] = c[v][b] : b > h && (m[v - 1][b - 1] = c[v][b]);
          }
          var A = h % 2 ? -1 : 1;
          l += f(m) * c[0][h] * A;
        }
        return l;
      }, gauss_elimination: function(c, l) {
        var h = 0, m = 0, v = c.length, b = c[0].length, A = 1, _ = 0, C = [], I, S, $, F;
        for (c = r.aug(c, l), I = c[0].length, h = 0; h < v; h++) {
          for (S = c[h][h], m = h, F = h + 1; F < b; F++) S < s.abs(c[F][h]) && (S = c[F][h], m = F);
          if (m != h) for (F = 0; F < I; F++) $ = c[h][F], c[h][F] = c[m][F], c[m][F] = $;
          for (m = h + 1; m < v; m++) for (A = c[m][h] / c[h][h], F = h; F < I; F++) c[m][F] = c[m][F] - A * c[h][F];
        }
        for (h = v - 1; h >= 0; h--) {
          for (_ = 0, m = h + 1; m <= v - 1; m++) _ = _ + C[m] * c[h][m];
          C[h] = (c[h][I - 1] - _) / c[h][h];
        }
        return C;
      }, gauss_jordan: function(c, l) {
        var h = r.aug(c, l), m = h.length, v = h[0].length, b = 0, A, _, C;
        for (_ = 0; _ < m; _++) {
          var I = _;
          for (C = _ + 1; C < m; C++) s.abs(h[C][_]) > s.abs(h[I][_]) && (I = C);
          var S = h[_];
          for (h[_] = h[I], h[I] = S, C = _ + 1; C < m; C++) for (b = h[C][_] / h[_][_], A = _; A < v; A++) h[C][A] -= h[_][A] * b;
        }
        for (_ = m - 1; _ >= 0; _--) {
          for (b = h[_][_], C = 0; C < _; C++) for (A = v - 1; A > _ - 1; A--) h[C][A] -= h[_][A] * h[C][_] / b;
          for (h[_][_] /= b, A = m; A < v; A++) h[_][A] /= b;
        }
        return h;
      }, triaUpSolve: function(c, l) {
        var h = c[0].length, m = r.zeros(1, h)[0], v, b = false;
        return l[0].length != null && (l = l.map(function(A) {
          return A[0];
        }), b = true), r.arange(h - 1, -1, -1).forEach(function(A) {
          v = r.arange(A + 1, h).map(function(_) {
            return m[_] * c[A][_];
          }), m[A] = (l[A] - r.sum(v)) / c[A][A];
        }), b ? m.map(function(A) {
          return [A];
        }) : m;
      }, triaLowSolve: function(c, l) {
        var h = c[0].length, m = r.zeros(1, h)[0], v, b = false;
        return l[0].length != null && (l = l.map(function(A) {
          return A[0];
        }), b = true), r.arange(h).forEach(function(A) {
          v = r.arange(A).map(function(_) {
            return c[A][_] * m[_];
          }), m[A] = (l[A] - r.sum(v)) / c[A][A];
        }), b ? m.map(function(A) {
          return [A];
        }) : m;
      }, lu: function(c) {
        var l = c.length, h = r.identity(l), m = r.zeros(c.length, c[0].length), v;
        return r.arange(l).forEach(function(b) {
          m[0][b] = c[0][b];
        }), r.arange(1, l).forEach(function(b) {
          r.arange(b).forEach(function(A) {
            v = r.arange(A).map(function(_) {
              return h[b][_] * m[_][A];
            }), h[b][A] = (c[b][A] - r.sum(v)) / m[A][A];
          }), r.arange(b, l).forEach(function(A) {
            v = r.arange(b).map(function(_) {
              return h[b][_] * m[_][A];
            }), m[b][A] = c[v.length][A] - r.sum(v);
          });
        }), [h, m];
      }, cholesky: function(c) {
        var l = c.length, h = r.zeros(c.length, c[0].length), m;
        return r.arange(l).forEach(function(v) {
          m = r.arange(v).map(function(b) {
            return s.pow(h[v][b], 2);
          }), h[v][v] = s.sqrt(c[v][v] - r.sum(m)), r.arange(v + 1, l).forEach(function(b) {
            m = r.arange(v).map(function(A) {
              return h[v][A] * h[b][A];
            }), h[b][v] = (c[v][b] - r.sum(m)) / h[v][v];
          });
        }), h;
      }, gauss_jacobi: function(c, l, h, m) {
        for (var v = 0, b = 0, A = c.length, _ = [], C = [], I = [], S, $, F, U; v < A; v++) for (_[v] = [], C[v] = [], I[v] = [], b = 0; b < A; b++) v > b ? (_[v][b] = c[v][b], C[v][b] = I[v][b] = 0) : v < b ? (C[v][b] = c[v][b], _[v][b] = I[v][b] = 0) : (I[v][b] = c[v][b], _[v][b] = C[v][b] = 0);
        for (F = r.multiply(r.multiply(r.inv(I), r.add(_, C)), -1), $ = r.multiply(r.inv(I), l), S = h, U = r.add(r.multiply(F, h), $), v = 2; s.abs(r.norm(r.subtract(U, S))) > m; ) S = U, U = r.add(r.multiply(F, S), $), v++;
        return U;
      }, gauss_seidel: function(c, l, h, m) {
        for (var v = 0, b = c.length, A = [], _ = [], C = [], I, S, $, F, U; v < b; v++) for (A[v] = [], _[v] = [], C[v] = [], I = 0; I < b; I++) v > I ? (A[v][I] = c[v][I], _[v][I] = C[v][I] = 0) : v < I ? (_[v][I] = c[v][I], A[v][I] = C[v][I] = 0) : (C[v][I] = c[v][I], A[v][I] = _[v][I] = 0);
        for (F = r.multiply(r.multiply(r.inv(r.add(C, A)), _), -1), $ = r.multiply(r.inv(r.add(C, A)), l), S = h, U = r.add(r.multiply(F, h), $), v = 2; s.abs(r.norm(r.subtract(U, S))) > m; ) S = U, U = r.add(r.multiply(F, S), $), v = v + 1;
        return U;
      }, SOR: function(c, l, h, m, v) {
        for (var b = 0, A = c.length, _ = [], C = [], I = [], S, $, F, U, Q; b < A; b++) for (_[b] = [], C[b] = [], I[b] = [], S = 0; S < A; S++) b > S ? (_[b][S] = c[b][S], C[b][S] = I[b][S] = 0) : b < S ? (C[b][S] = c[b][S], _[b][S] = I[b][S] = 0) : (I[b][S] = c[b][S], _[b][S] = C[b][S] = 0);
        for (U = r.multiply(r.inv(r.add(I, r.multiply(_, v))), r.subtract(r.multiply(I, 1 - v), r.multiply(C, v))), F = r.multiply(r.multiply(r.inv(r.add(I, r.multiply(_, v))), l), v), $ = h, Q = r.add(r.multiply(U, h), F), b = 2; s.abs(r.norm(r.subtract(Q, $))) > m; ) $ = Q, Q = r.add(r.multiply(U, $), F), b++;
        return Q;
      }, householder: function(c) {
        for (var l = c.length, h = c[0].length, m = 0, v = [], b = [], A, _, C, I, S; m < l - 1; m++) {
          for (A = 0, I = m + 1; I < h; I++) A += c[I][m] * c[I][m];
          for (S = c[m + 1][m] > 0 ? -1 : 1, A = S * s.sqrt(A), _ = s.sqrt((A * A - c[m + 1][m] * A) / 2), v = r.zeros(l, 1), v[m + 1][0] = (c[m + 1][m] - A) / (2 * _), C = m + 2; C < l; C++) v[C][0] = c[C][m] / (2 * _);
          b = r.subtract(r.identity(l, h), r.multiply(r.multiply(v, r.transpose(v)), 2)), c = r.multiply(b, r.multiply(c, b));
        }
        return c;
      }, QR: function() {
        var f = r.sum, c = r.arange;
        function l(h) {
          var m = h.length, v = h[0].length, b = r.zeros(v, v);
          h = r.copy(h);
          var A, _, C;
          for (_ = 0; _ < v; _++) {
            for (b[_][_] = s.sqrt(f(c(m).map(function(I) {
              return h[I][_] * h[I][_];
            }))), A = 0; A < m; A++) h[A][_] = h[A][_] / b[_][_];
            for (C = _ + 1; C < v; C++) for (b[_][C] = f(c(m).map(function(I) {
              return h[I][_] * h[I][C];
            })), A = 0; A < m; A++) h[A][C] = h[A][C] - h[A][_] * b[_][C];
          }
          return [h, b];
        }
        return l;
      }(), lstsq: /* @__PURE__ */ function() {
        function f(l) {
          l = r.copy(l);
          var h = l.length, m = r.identity(h);
          return r.arange(h - 1, -1, -1).forEach(function(v) {
            r.sliceAssign(m, { row: v }, r.divide(r.slice(m, { row: v }), l[v][v])), r.sliceAssign(l, { row: v }, r.divide(r.slice(l, { row: v }), l[v][v])), r.arange(v).forEach(function(b) {
              var A = r.multiply(l[b][v], -1), _ = r.slice(l, { row: b }), C = r.multiply(r.slice(l, { row: v }), A);
              r.sliceAssign(l, { row: b }, r.add(_, C));
              var I = r.slice(m, { row: b }), S = r.multiply(r.slice(m, { row: v }), A);
              r.sliceAssign(m, { row: b }, r.add(I, S));
            });
          }), m;
        }
        function c(l, h) {
          var m = false;
          h[0].length === void 0 && (h = h.map(function(U) {
            return [U];
          }), m = true);
          var v = r.QR(l), b = v[0], A = v[1], _ = l[0].length, C = r.slice(b, { col: { end: _ } }), I = r.slice(A, { row: { end: _ } }), S = f(I), $ = r.transpose(C);
          $[0].length === void 0 && ($ = [$]);
          var F = r.multiply(r.multiply(S, $), h);
          return F.length === void 0 && (F = [[F]]), m ? F.map(function(U) {
            return U[0];
          }) : F;
        }
        return c;
      }(), jacobi: function(c) {
        for (var l = 1, h = c.length, m = r.identity(h, h), v = [], b, A, _, C, I, S, $, F; l === 1; ) {
          for (S = c[0][1], C = 0, I = 1, A = 0; A < h; A++) for (_ = 0; _ < h; _++) A != _ && S < s.abs(c[A][_]) && (S = s.abs(c[A][_]), C = A, I = _);
          for (c[C][C] === c[I][I] ? $ = c[C][I] > 0 ? s.PI / 4 : -s.PI / 4 : $ = s.atan(2 * c[C][I] / (c[C][C] - c[I][I])) / 2, F = r.identity(h, h), F[C][C] = s.cos($), F[C][I] = -s.sin($), F[I][C] = s.sin($), F[I][I] = s.cos($), m = r.multiply(m, F), b = r.multiply(r.multiply(r.inv(F), c), F), c = b, l = 0, A = 1; A < h; A++) for (_ = 1; _ < h; _++) A != _ && s.abs(c[A][_]) > 1e-3 && (l = 1);
        }
        for (A = 0; A < h; A++) v.push(c[A][A]);
        return [m, v];
      }, rungekutta: function(c, l, h, m, v, b) {
        var A, _, C, I, S;
        if (b === 2) for (; m <= h; ) A = l * c(m, v), _ = l * c(m + l, v + A), C = v + (A + _) / 2, v = C, m = m + l;
        if (b === 4) for (; m <= h; ) A = l * c(m, v), _ = l * c(m + l / 2, v + A / 2), I = l * c(m + l / 2, v + _ / 2), S = l * c(m + l, v + I), C = v + (A + 2 * _ + 2 * I + S) / 6, v = C, m = m + l;
        return v;
      }, romberg: function(c, l, h, m) {
        for (var v = 0, b = (h - l) / 2, A = [], _ = [], C = [], I, S, $, F, U; v < m / 2; ) {
          for (U = c(l), $ = l, F = 0; $ <= h; $ = $ + b, F++) A[F] = $;
          for (I = A.length, $ = 1; $ < I - 1; $++) U += ($ % 2 !== 0 ? 4 : 2) * c(A[$]);
          U = b / 3 * (U + c(h)), C[v] = U, b /= 2, v++;
        }
        for (S = C.length, I = 1; S !== 1; ) {
          for ($ = 0; $ < S - 1; $++) _[$] = (s.pow(4, I) * C[$ + 1] - C[$]) / (s.pow(4, I) - 1);
          S = _.length, C = _, _ = [], I++;
        }
        return C;
      }, richardson: function(c, l, h, m) {
        function v(Q, P) {
          for (var N = 0, L = Q.length, B; N < L; N++) Q[N] === P && (B = N);
          return B;
        }
        for (var b = s.abs(h - c[v(c, h) + 1]), A = 0, _ = [], C = [], I, S, $, F, U; m >= b; ) I = v(c, h + m), S = v(c, h), _[A] = (l[I] - 2 * l[S] + l[2 * S - I]) / (m * m), m /= 2, A++;
        for (F = _.length, $ = 1; F != 1; ) {
          for (U = 0; U < F - 1; U++) C[U] = (s.pow(4, $) * _[U + 1] - _[U]) / (s.pow(4, $) - 1);
          F = C.length, _ = C, C = [], $++;
        }
        return _;
      }, simpson: function(c, l, h, m) {
        for (var v = (h - l) / m, b = c(l), A = [], _ = l, C = 0, I = 1, S; _ <= h; _ = _ + v, C++) A[C] = _;
        for (S = A.length; I < S - 1; I++) b += (I % 2 !== 0 ? 4 : 2) * c(A[I]);
        return v / 3 * (b + c(h));
      }, hermite: function(c, l, h, m) {
        for (var v = c.length, b = 0, A = 0, _ = [], C = [], I = [], S = [], $; A < v; A++) {
          for (_[A] = 1, $ = 0; $ < v; $++) A != $ && (_[A] *= (m - c[$]) / (c[A] - c[$]));
          for (C[A] = 0, $ = 0; $ < v; $++) A != $ && (C[A] += 1 / (c[A] - c[$]));
          I[A] = (1 - 2 * (m - c[A]) * C[A]) * (_[A] * _[A]), S[A] = (m - c[A]) * (_[A] * _[A]), b += I[A] * l[A] + S[A] * h[A];
        }
        return b;
      }, lagrange: function(c, l, h) {
        for (var m = 0, v = 0, b, A, _ = c.length; v < _; v++) {
          for (A = l[v], b = 0; b < _; b++) v != b && (A *= (h - c[b]) / (c[v] - c[b]));
          m += A;
        }
        return m;
      }, cubic_spline: function(c, l, h) {
        for (var m = c.length, v = 0, b, A = [], _ = [], C = [], I = [], S = [], $ = [], F = []; v < m - 1; v++) S[v] = c[v + 1] - c[v];
        for (C[0] = 0, v = 1; v < m - 1; v++) C[v] = 3 / S[v] * (l[v + 1] - l[v]) - 3 / S[v - 1] * (l[v] - l[v - 1]);
        for (v = 1; v < m - 1; v++) A[v] = [], _[v] = [], A[v][v - 1] = S[v - 1], A[v][v] = 2 * (S[v - 1] + S[v]), A[v][v + 1] = S[v], _[v][0] = C[v];
        for (I = r.multiply(r.inv(A), _), b = 0; b < m - 1; b++) $[b] = (l[b + 1] - l[b]) / S[b] - S[b] * (I[b + 1][0] + 2 * I[b][0]) / 3, F[b] = (I[b + 1][0] - I[b][0]) / (3 * S[b]);
        for (b = 0; b < m && !(c[b] > h); b++) ;
        return b -= 1, l[b] + (h - c[b]) * $[b] + r.sq(h - c[b]) * I[b] + (h - c[b]) * r.sq(h - c[b]) * F[b];
      }, gauss_quadrature: function() {
        throw new Error("gauss_quadrature not yet implemented");
      }, PCA: function(c) {
        var l = c.length, h = c[0].length, m = 0, v, b, A = [], _ = [], C = [], I = [], S = [], $ = [], F = [], U = [], Q = [], P = [];
        for (m = 0; m < l; m++) A[m] = r.sum(c[m]) / h;
        for (m = 0; m < h; m++) for (F[m] = [], v = 0; v < l; v++) F[m][v] = c[v][m] - A[v];
        for (F = r.transpose(F), m = 0; m < l; m++) for (U[m] = [], v = 0; v < l; v++) U[m][v] = r.dot([F[m]], [F[v]]) / (h - 1);
        for (C = r.jacobi(U), Q = C[0], _ = C[1], P = r.transpose(Q), m = 0; m < _.length; m++) for (v = m; v < _.length; v++) _[m] < _[v] && (b = _[m], _[m] = _[v], _[v] = b, I = P[m], P[m] = P[v], P[v] = I);
        for ($ = r.transpose(F), m = 0; m < l; m++) for (S[m] = [], v = 0; v < $.length; v++) S[m][v] = r.dot([P[m]], [$[v]]);
        return [c, _, P, S];
      } }), function(f) {
        for (var c = 0; c < f.length; c++) (function(l) {
          r.fn[l] = function(h, m) {
            var v = this;
            return m ? (setTimeout(function() {
              m.call(v, r.fn[l].call(v, h));
            }, 15), this) : typeof r[l](this, h) == "number" ? r[l](this, h) : r(r[l](this, h));
          };
        })(f[c]);
      }("add divide multiply subtract dot pow exp log abs norm angle".split(" "));
    }(n, Math), function(r, s) {
      var i = [].slice, a = r.utils.isNumber, o = r.utils.isArray;
      r.extend({ zscore: function() {
        var l = i.call(arguments);
        return a(l[1]) ? (l[0] - l[1]) / l[2] : (l[0] - r.mean(l[1])) / r.stdev(l[1], l[2]);
      }, ztest: function() {
        var l = i.call(arguments), h;
        return o(l[1]) ? (h = r.zscore(l[0], l[1], l[3]), l[2] === 1 ? r.normal.cdf(-s.abs(h), 0, 1) : r.normal.cdf(-s.abs(h), 0, 1) * 2) : l.length > 2 ? (h = r.zscore(l[0], l[1], l[2]), l[3] === 1 ? r.normal.cdf(-s.abs(h), 0, 1) : r.normal.cdf(-s.abs(h), 0, 1) * 2) : (h = l[0], l[1] === 1 ? r.normal.cdf(-s.abs(h), 0, 1) : r.normal.cdf(-s.abs(h), 0, 1) * 2);
      } }), r.extend(r.fn, { zscore: function(l, h) {
        return (l - this.mean()) / this.stdev(h);
      }, ztest: function(l, h, m) {
        var v = s.abs(this.zscore(l, m));
        return h === 1 ? r.normal.cdf(-v, 0, 1) : r.normal.cdf(-v, 0, 1) * 2;
      } }), r.extend({ tscore: function() {
        var l = i.call(arguments);
        return l.length === 4 ? (l[0] - l[1]) / (l[2] / s.sqrt(l[3])) : (l[0] - r.mean(l[1])) / (r.stdev(l[1], true) / s.sqrt(l[1].length));
      }, ttest: function() {
        var l = i.call(arguments), h;
        return l.length === 5 ? (h = s.abs(r.tscore(l[0], l[1], l[2], l[3])), l[4] === 1 ? r.studentt.cdf(-h, l[3] - 1) : r.studentt.cdf(-h, l[3] - 1) * 2) : a(l[1]) ? (h = s.abs(l[0]), l[2] == 1 ? r.studentt.cdf(-h, l[1] - 1) : r.studentt.cdf(-h, l[1] - 1) * 2) : (h = s.abs(r.tscore(l[0], l[1])), l[2] == 1 ? r.studentt.cdf(-h, l[1].length - 1) : r.studentt.cdf(-h, l[1].length - 1) * 2);
      } }), r.extend(r.fn, { tscore: function(l) {
        return (l - this.mean()) / (this.stdev(true) / s.sqrt(this.cols()));
      }, ttest: function(l, h) {
        return h === 1 ? 1 - r.studentt.cdf(s.abs(this.tscore(l)), this.cols() - 1) : r.studentt.cdf(-s.abs(this.tscore(l)), this.cols() - 1) * 2;
      } }), r.extend({ anovafscore: function() {
        var l = i.call(arguments), h, m, v, b, A, _, C, I;
        if (l.length === 1) {
          for (A = new Array(l[0].length), C = 0; C < l[0].length; C++) A[C] = l[0][C];
          l = A;
        }
        for (m = new Array(), C = 0; C < l.length; C++) m = m.concat(l[C]);
        for (v = r.mean(m), h = 0, C = 0; C < l.length; C++) h = h + l[C].length * s.pow(r.mean(l[C]) - v, 2);
        for (h /= l.length - 1, _ = 0, C = 0; C < l.length; C++) for (b = r.mean(l[C]), I = 0; I < l[C].length; I++) _ += s.pow(l[C][I] - b, 2);
        return _ /= m.length - l.length, h / _;
      }, anovaftest: function() {
        var l = i.call(arguments), h, m, v, b;
        if (a(l[0])) return 1 - r.centralF.cdf(l[0], l[1], l[2]);
        var A = r.anovafscore(l);
        for (h = l.length - 1, v = 0, b = 0; b < l.length; b++) v = v + l[b].length;
        return m = v - h - 1, 1 - r.centralF.cdf(A, h, m);
      }, ftest: function(l, h, m) {
        return 1 - r.centralF.cdf(l, h, m);
      } }), r.extend(r.fn, { anovafscore: function() {
        return r.anovafscore(this.toArray());
      }, anovaftes: function() {
        var l = 0, h;
        for (h = 0; h < this.length; h++) l = l + this[h].length;
        return r.ftest(this.anovafscore(), this.length - 1, l - this.length);
      } }), r.extend({ qscore: function() {
        var l = i.call(arguments), h, m, v, b, A;
        return a(l[0]) ? (h = l[0], m = l[1], v = l[2], b = l[3], A = l[4]) : (h = r.mean(l[0]), m = r.mean(l[1]), v = l[0].length, b = l[1].length, A = l[2]), s.abs(h - m) / (A * s.sqrt((1 / v + 1 / b) / 2));
      }, qtest: function() {
        var l = i.call(arguments), h;
        l.length === 3 ? (h = l[0], l = l.slice(1)) : l.length === 7 ? (h = r.qscore(l[0], l[1], l[2], l[3], l[4]), l = l.slice(5)) : (h = r.qscore(l[0], l[1], l[2]), l = l.slice(3));
        var m = l[0], v = l[1];
        return 1 - r.tukey.cdf(h, v, m - v);
      }, tukeyhsd: function(l) {
        for (var h = r.pooledstdev(l), m = l.map(function(I) {
          return r.mean(I);
        }), v = l.reduce(function(I, S) {
          return I + S.length;
        }, 0), b = [], A = 0; A < l.length; ++A) for (var _ = A + 1; _ < l.length; ++_) {
          var C = r.qtest(m[A], m[_], l[A].length, l[_].length, h, v, l.length);
          b.push([[A, _], C]);
        }
        return b;
      } }), r.extend({ normalci: function() {
        var l = i.call(arguments), h = new Array(2), m;
        return l.length === 4 ? m = s.abs(r.normal.inv(l[1] / 2, 0, 1) * l[2] / s.sqrt(l[3])) : m = s.abs(r.normal.inv(l[1] / 2, 0, 1) * r.stdev(l[2]) / s.sqrt(l[2].length)), h[0] = l[0] - m, h[1] = l[0] + m, h;
      }, tci: function() {
        var l = i.call(arguments), h = new Array(2), m;
        return l.length === 4 ? m = s.abs(r.studentt.inv(l[1] / 2, l[3] - 1) * l[2] / s.sqrt(l[3])) : m = s.abs(r.studentt.inv(l[1] / 2, l[2].length - 1) * r.stdev(l[2], true) / s.sqrt(l[2].length)), h[0] = l[0] - m, h[1] = l[0] + m, h;
      }, significant: function(l, h) {
        return l < h;
      } }), r.extend(r.fn, { normalci: function(l, h) {
        return r.normalci(l, h, this.toArray());
      }, tci: function(l, h) {
        return r.tci(l, h, this.toArray());
      } });
      function f(c, l, h, m) {
        if (c > 1 || h > 1 || c <= 0 || h <= 0) throw new Error("Proportions should be greater than 0 and less than 1");
        var v = (c * l + h * m) / (l + m), b = s.sqrt(v * (1 - v) * (1 / l + 1 / m));
        return (c - h) / b;
      }
      r.extend(r.fn, { oneSidedDifferenceOfProportions: function(l, h, m, v) {
        var b = f(l, h, m, v);
        return r.ztest(b, 1);
      }, twoSidedDifferenceOfProportions: function(l, h, m, v) {
        var b = f(l, h, m, v);
        return r.ztest(b, 2);
      } });
    }(n, Math), n.models = /* @__PURE__ */ function() {
      function r(f) {
        var c = f[0].length, l = n.arange(c).map(function(h) {
          var m = n.arange(c).filter(function(v) {
            return v !== h;
          });
          return s(n.col(f, h).map(function(v) {
            return v[0];
          }), n.col(f, m));
        });
        return l;
      }
      function s(f, c) {
        var l = f.length, h = c[0].length - 1, m = l - h - 1, v = n.lstsq(c, f), b = n.multiply(c, v.map(function(F) {
          return [F];
        })).map(function(F) {
          return F[0];
        }), A = n.subtract(f, b), _ = n.mean(f), C = n.sum(b.map(function(F) {
          return Math.pow(F - _, 2);
        })), I = n.sum(f.map(function(F, U) {
          return Math.pow(F - b[U], 2);
        })), S = C + I, $ = C / S;
        return { exog: c, endog: f, nobs: l, df_model: h, df_resid: m, coef: v, predict: b, resid: A, ybar: _, SST: S, SSE: C, SSR: I, R2: $ };
      }
      function i(f) {
        var c = r(f.exog), l = Math.sqrt(f.SSR / f.df_resid), h = c.map(function(_) {
          var C = _.SST, I = _.R2;
          return l / Math.sqrt(C * (1 - I));
        }), m = f.coef.map(function(_, C) {
          return (_ - 0) / h[C];
        }), v = m.map(function(_) {
          var C = n.studentt.cdf(_, f.df_resid);
          return (C > 0.5 ? 1 - C : C) * 2;
        }), b = n.studentt.inv(0.975, f.df_resid), A = f.coef.map(function(_, C) {
          var I = b * h[C];
          return [_ - I, _ + I];
        });
        return { se: h, t: m, p: v, sigmaHat: l, interval95: A };
      }
      function a(f) {
        var c = f.R2 / f.df_model / ((1 - f.R2) / f.df_resid), l = function(m, v, b) {
          return n.beta.cdf(m / (b / v + m), v / 2, b / 2);
        }, h = 1 - l(c, f.df_model, f.df_resid);
        return { F_statistic: c, pvalue: h };
      }
      function o(f, c) {
        var l = s(f, c), h = i(l), m = a(l), v = 1 - (1 - l.R2) * ((l.nobs - 1) / l.df_resid);
        return l.t = h, l.f = m, l.adjust_R2 = v, l;
      }
      return { ols: o };
    }(), n.extend({ buildxmatrix: function() {
      for (var s = new Array(arguments.length), i = 0; i < arguments.length; i++) {
        var a = [1];
        s[i] = a.concat(arguments[i]);
      }
      return n(s);
    }, builddxmatrix: function() {
      for (var s = new Array(arguments[0].length), i = 0; i < arguments[0].length; i++) {
        var a = [1];
        s[i] = a.concat(arguments[0][i]);
      }
      return n(s);
    }, buildjxmatrix: function(s) {
      for (var i = new Array(s.length), a = 0; a < s.length; a++) i[a] = s[a];
      return n.builddxmatrix(i);
    }, buildymatrix: function(s) {
      return n(s).transpose();
    }, buildjymatrix: function(s) {
      return s.transpose();
    }, matrixmult: function(s, i) {
      var a, o, f, c, l;
      if (s.cols() == i.rows()) {
        if (i.rows() > 1) {
          for (c = [], a = 0; a < s.rows(); a++) for (c[a] = [], o = 0; o < i.cols(); o++) {
            for (l = 0, f = 0; f < s.cols(); f++) l += s.toArray()[a][f] * i.toArray()[f][o];
            c[a][o] = l;
          }
          return n(c);
        }
        for (c = [], a = 0; a < s.rows(); a++) for (c[a] = [], o = 0; o < i.cols(); o++) {
          for (l = 0, f = 0; f < s.cols(); f++) l += s.toArray()[a][f] * i.toArray()[o];
          c[a][o] = l;
        }
        return n(c);
      }
    }, regress: function(s, i) {
      var a = n.xtranspxinv(s), o = s.transpose(), f = n.matrixmult(n(a), o);
      return n.matrixmult(f, i);
    }, regresst: function(s, i, a) {
      var o = n.regress(s, i), f = {};
      f.anova = {};
      var c = n.jMatYBar(s, o);
      f.yBar = c;
      var l = i.mean();
      f.anova.residuals = n.residuals(i, c), f.anova.ssr = n.ssr(c, l), f.anova.msr = f.anova.ssr / (s[0].length - 1), f.anova.sse = n.sse(i, c), f.anova.mse = f.anova.sse / (i.length - (s[0].length - 1) - 1), f.anova.sst = n.sst(i, l), f.anova.mst = f.anova.sst / (i.length - 1), f.anova.r2 = 1 - f.anova.sse / f.anova.sst, f.anova.r2 < 0 && (f.anova.r2 = 0), f.anova.fratio = f.anova.msr / f.anova.mse, f.anova.pvalue = n.anovaftest(f.anova.fratio, s[0].length - 1, i.length - (s[0].length - 1) - 1), f.anova.rmse = Math.sqrt(f.anova.mse), f.anova.r2adj = 1 - f.anova.mse / f.anova.mst, f.anova.r2adj < 0 && (f.anova.r2adj = 0), f.stats = new Array(s[0].length);
      for (var h = n.xtranspxinv(s), m, v, b, A = 0; A < o.length; A++) m = Math.sqrt(f.anova.mse * Math.abs(h[A][A])), v = Math.abs(o[A] / m), b = n.ttest(v, i.length - s[0].length - 1, a), f.stats[A] = [o[A], m, v, b];
      return f.regress = o, f;
    }, xtranspx: function(s) {
      return n.matrixmult(s.transpose(), s);
    }, xtranspxinv: function(s) {
      var i = n.matrixmult(s.transpose(), s), a = n.inv(i);
      return a;
    }, jMatYBar: function(s, i) {
      var a = n.matrixmult(s, i);
      return new n(a);
    }, residuals: function(s, i) {
      return n.matrixsubtract(s, i);
    }, ssr: function(s, i) {
      for (var a = 0, o = 0; o < s.length; o++) a += Math.pow(s[o] - i, 2);
      return a;
    }, sse: function(s, i) {
      for (var a = 0, o = 0; o < s.length; o++) a += Math.pow(s[o] - i[o], 2);
      return a;
    }, sst: function(s, i) {
      for (var a = 0, o = 0; o < s.length; o++) a += Math.pow(s[o] - i, 2);
      return a;
    }, matrixsubtract: function(s, i) {
      for (var a = new Array(s.length), o = 0; o < s.length; o++) {
        a[o] = new Array(s[o].length);
        for (var f = 0; f < s[o].length; f++) a[o][f] = s[o][f] - i[o][f];
      }
      return n(a);
    } }), n.jStat = n, n;
  });
})(cP);
var N3e = cP.exports;
const U3e = Fa(N3e);
class L3e {
  constructor(e = 10) {
    this.numBins = e;
  }
  testSequence(e) {
    if (!e || e.length === 0) throw new Error("Input sequence is empty.");
    if (!e.every((f) => f >= 0 && f < 1)) throw new Error("All numbers must be in the range [0, 1).");
    const r = e.length / this.numBins, s = new Array(this.numBins).fill(0);
    for (const f of e) {
      const c = Math.floor(f * this.numBins);
      c < this.numBins ? s[c]++ : s[this.numBins - 1]++;
    }
    let i = 0;
    for (const f of s) i += Math.pow(f - r, 2) / r;
    const a = this.numBins - 1, o = 1 - U3e.chisquare.cdf(i, a);
    return { chi2Stat: i, pValue: o, passed: o > 0.05, observed: s, expected: r };
  }
}
function O3e(t3) {
  return t3.trim().split(/\s+/).map(Number).filter((e) => !isNaN(e));
}
function Q3e(t3) {
  let e;
  return { c() {
    e = we("Test Randomness");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function K3e(t3) {
  let e;
  return { c() {
    e = we("Load Random Data");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function H3e(t3) {
  let e;
  return { c() {
    e = we("Load Biased Data");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function q3e(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function tC(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[3]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 8 && Ze(n, r[3]);
  }, d(r) {
    r && D(e);
  } };
}
function rC(t3) {
  let e, n, r, s, i = t3[2].passed ? "PASSED (Random)" : "FAILED (Not Random)", a, o, f, c, l, h, m, v = t3[2].chi2Stat.toFixed(4) + "", b, A, _, C, I, S, $ = t3[2].pValue.toFixed(4) + "", F, U, Q, P, N;
  function L(p, d) {
    return p[2].passed ? G3e : z3e;
  }
  let B = L(t3), u = B(t3);
  return { c() {
    e = H("div"), n = H("div"), r = H("strong"), r.textContent = "Test Result:", s = z(), a = we(i), o = z(), f = H("div"), c = H("div"), l = H("span"), l.textContent = "Chi-Square Stat", h = z(), m = H("span"), b = we(v), A = z(), _ = H("div"), C = H("span"), C.textContent = "P-Value", I = z(), S = H("span"), F = we($), U = z(), Q = H("div"), Q.innerHTML = '<span class="label svelte-eunkir">Significance</span> <span class="value svelte-eunkir">0.05</span>', P = z(), N = H("p"), u.c(), V(n, "class", "status-banner svelte-eunkir"), Zt(n, "pass", t3[2].passed), Zt(n, "fail", !t3[2].passed), V(l, "class", "label svelte-eunkir"), V(m, "class", "value svelte-eunkir"), V(c, "class", "stat-box svelte-eunkir"), V(C, "class", "label svelte-eunkir"), V(S, "class", "value svelte-eunkir"), V(_, "class", "stat-box svelte-eunkir"), V(Q, "class", "stat-box svelte-eunkir"), V(f, "class", "stats-grid svelte-eunkir"), V(N, "class", "explanation svelte-eunkir"), V(e, "class", "results-area svelte-eunkir");
  }, m(p, d) {
    R(p, e, d), q(e, n), q(n, r), q(n, s), q(n, a), q(e, o), q(e, f), q(f, c), q(c, l), q(c, h), q(c, m), q(m, b), q(f, A), q(f, _), q(_, C), q(_, I), q(_, S), q(S, F), q(f, U), q(f, Q), q(e, P), q(e, N), u.m(N, null);
  }, p(p, d) {
    d & 4 && i !== (i = p[2].passed ? "PASSED (Random)" : "FAILED (Not Random)") && Ze(a, i), d & 4 && Zt(n, "pass", p[2].passed), d & 4 && Zt(n, "fail", !p[2].passed), d & 4 && v !== (v = p[2].chi2Stat.toFixed(4) + "") && Ze(b, v), d & 4 && $ !== ($ = p[2].pValue.toFixed(4) + "") && Ze(F, $), B !== (B = L(p)) && (u.d(1), u = B(p), u && (u.c(), u.m(N, null)));
  }, d(p) {
    p && D(e), u.d();
  } };
}
function z3e(t3) {
  let e, n, r;
  return { c() {
    e = we("The P-Value is \u2264 0.05, which suggests the numbers are "), n = H("strong"), n.textContent = "not", r = we(" uniformly distributed.");
  }, m(s, i) {
    R(s, e, i), R(s, n, i), R(s, r, i);
  }, d(s) {
    s && (D(e), D(n), D(r));
  } };
}
function G3e(t3) {
  let e;
  return { c() {
    e = we("The P-Value is > 0.05, which means the distribution looks uniform. We fail to reject the null hypothesis of randomness.");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function V3e(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S;
  function $(L) {
    t3[8](L);
  }
  let F = { label: "Input Sequence (0 to 1):", placeholder: "e.g. 0.12 0.54 0.91 0.33...", expandable: true, rows: 5 };
  t3[0] !== void 0 && (F.value = t3[0]), e = new et({ props: F }), Qe.push(() => ze(e, "value", $)), i = new ut({ props: { $$slots: { default: [Q3e] }, $$scope: { ctx: t3 } } }), i.$on("click", t3[4]), o = new ut({ props: { variant: "secondary", $$slots: { default: [K3e] }, $$scope: { ctx: t3 } } }), o.$on("click", t3[5]), c = new ut({ props: { variant: "secondary", $$slots: { default: [H3e] }, $$scope: { ctx: t3 } } }), c.$on("click", t3[6]), h = new ut({ props: { variant: "secondary", $$slots: { default: [q3e] }, $$scope: { ctx: t3 } } }), h.$on("click", t3[9]);
  function U(L) {
    t3[10](L);
  }
  let Q = {};
  t3[1] !== void 0 && (Q.checked = t3[1]), b = new xr({ props: Q }), Qe.push(() => ze(b, "checked", U));
  let P = t3[3] && tC(t3), N = t3[2] && rC(t3);
  return { c() {
    fe(e.$$.fragment), r = z(), s = H("div"), fe(i.$$.fragment), a = z(), fe(o.$$.fragment), f = z(), fe(c.$$.fragment), l = z(), fe(h.$$.fragment), m = z(), v = H("div"), fe(b.$$.fragment), _ = z(), P && P.c(), C = z(), N && N.c(), I = Lt(), St(v, "margin-left", "auto"), V(s, "class", "button-row svelte-eunkir");
  }, m(L, B) {
    ae(e, L, B), R(L, r, B), R(L, s, B), ae(i, s, null), q(s, a), ae(o, s, null), q(s, f), ae(c, s, null), q(s, l), ae(h, s, null), q(s, m), q(s, v), ae(b, v, null), R(L, _, B), P && P.m(L, B), R(L, C, B), N && N.m(L, B), R(L, I, B), S = true;
  }, p(L, B) {
    const u = {};
    !n && B & 1 && (n = true, u.value = L[0], qe(() => n = false)), e.$set(u);
    const p = {};
    B & 2048 && (p.$$scope = { dirty: B, ctx: L }), i.$set(p);
    const d = {};
    B & 2048 && (d.$$scope = { dirty: B, ctx: L }), o.$set(d);
    const y = {};
    B & 2048 && (y.$$scope = { dirty: B, ctx: L }), c.$set(y);
    const w = {};
    B & 2048 && (w.$$scope = { dirty: B, ctx: L }), h.$set(w);
    const E = {};
    !A && B & 2 && (A = true, E.checked = L[1], qe(() => A = false)), b.$set(E), L[3] ? P ? P.p(L, B) : (P = tC(L), P.c(), P.m(C.parentNode, C)) : P && (P.d(1), P = null), L[2] ? N ? N.p(L, B) : (N = rC(L), N.c(), N.m(I.parentNode, I)) : N && (N.d(1), N = null);
  }, i(L) {
    S || (W(e.$$.fragment, L), W(i.$$.fragment, L), W(o.$$.fragment, L), W(c.$$.fragment, L), W(h.$$.fragment, L), W(b.$$.fragment, L), S = true);
  }, o(L) {
    j(e.$$.fragment, L), j(i.$$.fragment, L), j(o.$$.fragment, L), j(c.$$.fragment, L), j(h.$$.fragment, L), j(b.$$.fragment, L), S = false;
  }, d(L) {
    L && (D(r), D(s), D(_), D(C), D(I)), oe(e, L), oe(i), oe(o), oe(c), oe(h), oe(b), P && P.d(L), N && N.d(L);
  } };
}
function Y3e(t3) {
  let e, n, r, s, i, a;
  return { c() {
    e = H("p"), e.innerHTML = `<b>The Randomness Tester</b> is a tool designed to evaluate the quality of random number sequences. 
    It employs statistical methods, such as the <b>Chi-Square test</b>, to determine whether a given sequence 
    of numbers exhibits properties of randomness. This is particularly useful for testing random number generators 
    used in simulations, cryptography, and other applications.`, n = z(), r = H("b"), r.textContent = "How It Works:", s = z(), i = H("ol"), i.innerHTML = "<li>Input a sequence of random numbers in the range [0, 1), separated by spaces.</li> <li>The tool calculates a Chi-Square statistic based on the distribution of the input numbers.</li> <li>It compares the observed distribution to the expected uniform distribution and computes a p-value.</li> <li>A p-value greater than 0.05 (at the 5% significance level) indicates that the sequence likely passes the randomness test.</li>", a = we(`
    The tool offers a user-friendly interface for inputting data and viewing results in real time.`);
  }, m(o, f) {
    R(o, e, f), R(o, n, f), R(o, r, f), R(o, s, f), R(o, i, f), R(o, a, f);
  }, p: dt, d(o) {
    o && (D(e), D(n), D(r), D(s), D(i), D(a));
  } };
}
function W3e(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Randomness Tester (Chi-Square)", $$slots: { default: [V3e] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Chi-Square Test", links: t3[7], $$slots: { default: [Y3e] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 2063 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 2048 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function J3e(t3, e, n) {
  let r = "", s = null, i = "", a = true;
  function o() {
    n(3, i = ""), n(2, s = null);
    try {
      const b = O3e(r);
      if (b.length < 10) throw new Error("Please enter at least 10 numbers for a meaningful test.");
      const A = new L3e(10);
      n(2, s = A.testSequence(b));
    } catch (b) {
      n(3, i = b.message);
    }
  }
  function f() {
    const b = Array.from({ length: 50 }, () => Math.random().toFixed(4));
    n(0, r = b.join(" ")), o();
  }
  function c() {
    const b = Array.from({ length: 50 }, () => (Math.random() * 0.3).toFixed(4));
    n(0, r = b.join(" ")), o();
  }
  const l = [{ text: "Chi Squared Test: Wikipedia", url: "https://en.wikipedia.org/wiki/Chi-squared_test" }];
  function h(b) {
    r = b, n(0, r);
  }
  const m = () => {
    n(0, r = ""), n(2, s = null);
  };
  function v(b) {
    a = b, n(1, a);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 3 && a && r && o();
  }, [r, a, s, i, o, f, c, l, h, m, v];
}
class Z3e extends xt {
  constructor(e) {
    super(), wt(this, e, J3e, W3e, At, {});
  }
}
function hP(t3) {
  return (1n << BigInt(t3)) - 1n;
}
function j3e(t3, e, n) {
  const r = BigInt(t3), s = BigInt(e) % BigInt(n), i = BigInt(n), a = hP(i), o = r & a;
  let f = o << s | o >> i - s;
  return f &= a, dP(f, i);
}
function X3e(t3, e, n) {
  const r = BigInt(t3), s = BigInt(e) % BigInt(n), i = BigInt(n), a = hP(i), o = r & a;
  let f = o >> s | o << i - s;
  return f &= a, dP(f, i);
}
function dP(t3, e) {
  return { decimal: t3.toString(), binary: t3.toString(2).padStart(Number(e), "0") };
}
function ebe(t3) {
  let e;
  return { c() {
    e = we("Calculate Rotations");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function tbe(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function nC(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[6]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 64 && Ze(n, r[6]);
  }, d(r) {
    r && D(e);
  } };
}
function iC(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U, Q, P, N, L, B;
  return f = new et({ props: { value: t3[4].decimal, readonly: true, withCopy: true } }), v = new et({ props: { value: t3[4].binary, readonly: true, withCopy: true, font: "monospace" } }), F = new et({ props: { value: t3[5].decimal, readonly: true, withCopy: true } }), L = new et({ props: { value: t3[5].binary, readonly: true, withCopy: true, font: "monospace" } }), { c() {
    e = H("div"), n = H("div"), r = H("h4"), r.textContent = "Circular Left Shift (ROL)", s = z(), i = H("div"), a = H("span"), a.textContent = "Decimal:", o = z(), fe(f.$$.fragment), c = z(), l = H("div"), h = H("span"), h.textContent = "Binary:", m = z(), fe(v.$$.fragment), b = z(), A = H("div"), _ = H("h4"), _.textContent = "Circular Right Shift (ROR)", C = z(), I = H("div"), S = H("span"), S.textContent = "Decimal:", $ = z(), fe(F.$$.fragment), U = z(), Q = H("div"), P = H("span"), P.textContent = "Binary:", N = z(), fe(L.$$.fragment), V(a, "class", "label svelte-1wk186x"), V(i, "class", "res-row svelte-1wk186x"), V(h, "class", "label svelte-1wk186x"), V(l, "class", "res-row svelte-1wk186x"), V(n, "class", "result-box"), V(S, "class", "label svelte-1wk186x"), V(I, "class", "res-row svelte-1wk186x"), V(P, "class", "label svelte-1wk186x"), V(Q, "class", "res-row svelte-1wk186x"), V(A, "class", "result-box"), V(e, "class", "results-area");
  }, m(u, p) {
    R(u, e, p), q(e, n), q(n, r), q(n, s), q(n, i), q(i, a), q(i, o), ae(f, i, null), q(n, c), q(n, l), q(l, h), q(l, m), ae(v, l, null), q(e, b), q(e, A), q(A, _), q(A, C), q(A, I), q(I, S), q(I, $), ae(F, I, null), q(A, U), q(A, Q), q(Q, P), q(Q, N), ae(L, Q, null), B = true;
  }, p(u, p) {
    const d = {};
    p & 16 && (d.value = u[4].decimal), f.$set(d);
    const y = {};
    p & 16 && (y.value = u[4].binary), v.$set(y);
    const w = {};
    p & 32 && (w.value = u[5].decimal), F.$set(w);
    const E = {};
    p & 32 && (E.value = u[5].binary), L.$set(E);
  }, i(u) {
    B || (W(f.$$.fragment, u), W(v.$$.fragment, u), W(F.$$.fragment, u), W(L.$$.fragment, u), B = true);
  }, o(u) {
    j(f.$$.fragment, u), j(v.$$.fragment, u), j(F.$$.fragment, u), j(L.$$.fragment, u), B = false;
  }, d(u) {
    u && D(e), oe(f), oe(v), oe(F), oe(L);
  } };
}
function rbe(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U, Q, P, N;
  function L(g) {
    t3[10](g);
  }
  let B = { label: "Number (Decimal):", placeholder: "e.g. 12345", type: "number", min: "0" };
  t3[0] !== void 0 && (B.value = t3[0]), r = new et({ props: B }), Qe.push(() => ze(r, "value", L));
  function u(g) {
    t3[11](g);
  }
  let p = { label: "Shift Amount:", placeholder: "e.g. 4", type: "number", min: "0" };
  t3[1] !== void 0 && (p.value = t3[1]), o = new et({ props: p }), Qe.push(() => ze(o, "value", u));
  function d(g) {
    t3[12](g);
  }
  let y = { label: "Bit Width:", options: t3[7] };
  t3[3] !== void 0 && (y.value = t3[3]), h = new Ht({ props: y }), Qe.push(() => ze(h, "value", d)), A = new ut({ props: { $$slots: { default: [ebe] }, $$scope: { ctx: t3 } } }), A.$on("click", t3[8]), C = new ut({ props: { variant: "secondary", $$slots: { default: [tbe] }, $$scope: { ctx: t3 } } }), C.$on("click", t3[13]);
  function w(g) {
    t3[14](g);
  }
  let E = {};
  t3[2] !== void 0 && (E.checked = t3[2]), $ = new xr({ props: E }), Qe.push(() => ze($, "checked", w));
  let M = t3[6] && nC(t3), x = t3[4] && t3[5] && iC(t3);
  return { c() {
    e = H("div"), n = H("div"), fe(r.$$.fragment), i = z(), a = H("div"), fe(o.$$.fragment), c = z(), l = H("div"), fe(h.$$.fragment), v = z(), b = H("div"), fe(A.$$.fragment), _ = z(), fe(C.$$.fragment), I = z(), S = H("div"), fe($.$$.fragment), U = z(), M && M.c(), Q = z(), x && x.c(), P = Lt(), V(n, "class", "control-item main-input"), V(a, "class", "control-item"), V(l, "class", "control-item"), V(e, "class", "controls-grid svelte-1wk186x"), St(S, "margin-left", "auto"), V(b, "class", "button-row");
  }, m(g, k) {
    R(g, e, k), q(e, n), ae(r, n, null), q(e, i), q(e, a), ae(o, a, null), q(e, c), q(e, l), ae(h, l, null), R(g, v, k), R(g, b, k), ae(A, b, null), q(b, _), ae(C, b, null), q(b, I), q(b, S), ae($, S, null), R(g, U, k), M && M.m(g, k), R(g, Q, k), x && x.m(g, k), R(g, P, k), N = true;
  }, p(g, k) {
    const T = {};
    !s && k & 1 && (s = true, T.value = g[0], qe(() => s = false)), r.$set(T);
    const O = {};
    !f && k & 2 && (f = true, O.value = g[1], qe(() => f = false)), o.$set(O);
    const K = {};
    !m && k & 8 && (m = true, K.value = g[3], qe(() => m = false)), h.$set(K);
    const Y = {};
    k & 32768 && (Y.$$scope = { dirty: k, ctx: g }), A.$set(Y);
    const J = {};
    k & 32768 && (J.$$scope = { dirty: k, ctx: g }), C.$set(J);
    const G = {};
    !F && k & 4 && (F = true, G.checked = g[2], qe(() => F = false)), $.$set(G), g[6] ? M ? M.p(g, k) : (M = nC(g), M.c(), M.m(Q.parentNode, Q)) : M && (M.d(1), M = null), g[4] && g[5] ? x ? (x.p(g, k), k & 48 && W(x, 1)) : (x = iC(g), x.c(), W(x, 1), x.m(P.parentNode, P)) : x && (Xt(), j(x, 1, 1, () => {
      x = null;
    }), er());
  }, i(g) {
    N || (W(r.$$.fragment, g), W(o.$$.fragment, g), W(h.$$.fragment, g), W(A.$$.fragment, g), W(C.$$.fragment, g), W($.$$.fragment, g), W(x), N = true);
  }, o(g) {
    j(r.$$.fragment, g), j(o.$$.fragment, g), j(h.$$.fragment, g), j(A.$$.fragment, g), j(C.$$.fragment, g), j($.$$.fragment, g), j(x), N = false;
  }, d(g) {
    g && (D(e), D(v), D(b), D(U), D(Q), D(P)), oe(r), oe(o), oe(h), oe(A), oe(C), oe($), M && M.d(g), x && x.d(g);
  } };
}
function nbe(t3) {
  let e, n, r, s, i, a, o;
  return { c() {
    e = H("p"), e.innerHTML = `A <b>circular bit shift</b> (also called a cyclic shift or rotation) is a bitwise operation where the bits of a binary number are 
  shifted in a circular manner, meaning that bits that are shifted out of one end are placed back at the opposite end. This differs from the 
  regular bit shift operation where bits shifted out of one end are discarded.`, n = z(), r = H("p"), r.innerHTML = "<strong>Types of Circular Bit Shifts:</strong>", s = z(), i = H("ul"), i.innerHTML = "<li><strong>Circular Left Shift (ROL):</strong> In a circular left shift, the bits are shifted to the left, and the bits that \n  are shifted out from the leftmost position are wrapped around and placed at the rightmost positions. For example, a 3-bit circular left \n  shift of `101` becomes `011`.</li> <li><strong>Circular Right Shift (ROR):</strong> In a circular right shift, the bits are shifted to the right, and the bits that \n  are shifted out from the rightmost position are wrapped around and placed at the leftmost positions. For example, a 3-bit circular right \n  shift of `101` becomes `110`.</li>", a = z(), o = H("p"), o.textContent = `Circular bit shifts are commonly used in cryptography, computer graphics, and low-level programming due to their ability to provide 
  deterministic and reversible bitwise operations that can be useful for tasks like hash functions, encryption algorithms, and pseudorandom number 
  generation.`;
  }, m(f, c) {
    R(f, e, c), R(f, n, c), R(f, r, c), R(f, s, c), R(f, i, c), R(f, a, c), R(f, o, c);
  }, p: dt, d(f) {
    f && (D(e), D(n), D(r), D(s), D(i), D(a), D(o));
  } };
}
function ibe(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Circular Bit Shift", $$slots: { default: [rbe] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Circular Bit Shift", links: t3[9], $$slots: { default: [nbe] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 32895 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 32768 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function sbe(t3, e, n) {
  let r = "", s = "", i = "32", a = null, o = null, f = "", c = true;
  const l = [{ value: "8", label: "8-bit" }, { value: "16", label: "16-bit" }, { value: "32", label: "32-bit" }, { value: "64", label: "64-bit" }];
  function h() {
    if (n(6, f = ""), n(4, a = null), n(5, o = null), !r) return n(6, f = "Please enter a number.");
    if (!s) return n(6, f = "Please enter shift amount.");
    const I = parseInt(i);
    try {
      if (!/^\d+$/.test(r) || !/^\d+$/.test(s)) throw new Error("Inputs must be positive integers.");
      n(4, a = j3e(r, s, I)), n(5, o = X3e(r, s, I));
    } catch (S) {
      n(6, f = S.message);
    }
  }
  const m = [{ text: "Wikipedia", url: "https://en.wikipedia.org/wiki/Circular_shift" }, { text: "Geeks for Geeks", url: "https://www.geeksforgeeks.org/bitwise-operators-in-c-cpp/#circular-shift" }];
  function v(I) {
    r = I, n(0, r);
  }
  function b(I) {
    s = I, n(1, s);
  }
  function A(I) {
    i = I, n(3, i);
  }
  const _ = () => {
    n(0, r = ""), n(1, s = ""), n(4, a = null), n(5, o = null);
  };
  function C(I) {
    c = I, n(2, c);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 7 && c && r && s && h();
  }, [r, s, c, i, a, o, f, l, h, m, v, b, A, _, C];
}
class abe extends xt {
  constructor(e) {
    super(), wt(this, e, sbe, ibe, At, {});
  }
}
class sC {
  constructor(e, n, r = null, s = null) {
    this.char = e, this.freq = n, this.left = r, this.right = s;
  }
}
class obe {
  constructor() {
    this.heap = [];
  }
  push(e) {
    this.heap.push(e), this._bubbleUp(this.heap.length - 1);
  }
  pop() {
    if (this.heap.length === 0) return null;
    const e = this.heap[0], n = this.heap.pop();
    return this.heap.length > 0 && (this.heap[0] = n, this._bubbleDown(0)), e;
  }
  size() {
    return this.heap.length;
  }
  _bubbleUp(e) {
    const n = this.heap[e];
    for (; e > 0; ) {
      let r = Math.floor((e - 1) / 2), s = this.heap[r];
      if (n.freq >= s.freq) break;
      this.heap[e] = s, e = r;
    }
    this.heap[e] = n;
  }
  _bubbleDown(e) {
    const n = this.heap.length, r = this.heap[e];
    for (; ; ) {
      let s = 2 * e + 1, i = 2 * e + 2, a, o, f = null;
      if (s < n && (a = this.heap[s], a.freq < r.freq && (f = s)), i < n && (o = this.heap[i], (f === null && o.freq < r.freq || f !== null && o.freq < a.freq) && (f = i)), f === null) break;
      this.heap[e] = this.heap[f], e = f;
    }
    this.heap[e] = r;
  }
}
class fbe {
  constructor() {
    this.codes = {}, this.reverseCodes = {};
  }
  compress(e) {
    if (!e) return "";
    const n = {};
    for (const i of e) n[i] = (n[i] || 0) + 1;
    const r = new obe();
    for (const [i, a] of Object.entries(n)) r.push(new sC(i, a));
    if (r.size() === 1) {
      const i = r.pop();
      return this.codes[i.char] = "0", this.reverseCodes[0] = i.char, "0".repeat(i.freq);
    }
    for (; r.size() > 1; ) {
      const i = r.pop(), a = r.pop(), o = new sC(null, i.freq + a.freq, i, a);
      r.push(o);
    }
    const s = r.pop();
    return this._generateCodes(s, ""), e.split("").map((i) => this.codes[i]).join("");
  }
  _generateCodes(e, n) {
    if (e) {
      if (e.char !== null) {
        this.codes[e.char] = n, this.reverseCodes[n] = e.char;
        return;
      }
      this._generateCodes(e.left, n + "0"), this._generateCodes(e.right, n + "1");
    }
  }
  getStats(e, n) {
    const r = e.length * 8, s = n.length, i = (1 - s / r) * 100;
    return { originalBits: r, compressedBits: s, ratio: i.toFixed(2) };
  }
}
function lbe(t3) {
  let e;
  return { c() {
    e = we("Compress Data");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function ube(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function aC(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[4]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 16 && Ze(n, r[4]);
  }, d(r) {
    r && D(e);
  } };
}
function oC(t3) {
  let e, n, r, s;
  n = new et({ props: { label: "Compressed Binary Stream:", value: t3[2], readonly: true, expandable: true, withCopy: true, rows: 4, font: "monospace" } });
  let i = t3[3] && fC(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), r = z(), i && i.c(), V(e, "class", "results-area svelte-13p5xta");
  }, m(a, o) {
    R(a, e, o), ae(n, e, null), q(e, r), i && i.m(e, null), s = true;
  }, p(a, o) {
    const f = {};
    o & 4 && (f.value = a[2]), n.$set(f), a[3] ? i ? i.p(a, o) : (i = fC(a), i.c(), i.m(e, null)) : i && (i.d(1), i = null);
  }, i(a) {
    s || (W(n.$$.fragment, a), s = true);
  }, o(a) {
    j(n.$$.fragment, a), s = false;
  }, d(a) {
    a && D(e), oe(n), i && i.d();
  } };
}
function fC(t3) {
  let e, n, r, s, i, a = t3[3].originalBits + "", o, f, c, l, h, m, v, b = t3[3].compressedBits + "", A, _, C, I, S, $, F, U = t3[3].ratio + "", Q, P;
  return { c() {
    e = H("div"), n = H("div"), r = H("span"), r.textContent = "Original Size:", s = z(), i = H("strong"), o = we(a), f = we(" bits"), c = z(), l = H("div"), h = H("span"), h.textContent = "Compressed Size:", m = z(), v = H("strong"), A = we(b), _ = we(" bits"), C = z(), I = H("div"), S = H("span"), S.textContent = "Space Saved:", $ = z(), F = H("strong"), Q = we(U), P = we("%"), V(i, "class", "svelte-13p5xta"), V(n, "class", "stat svelte-13p5xta"), V(v, "class", "svelte-13p5xta"), V(l, "class", "stat svelte-13p5xta"), V(F, "class", "svelte-13p5xta"), V(I, "class", "stat highlight svelte-13p5xta"), V(e, "class", "stats-box svelte-13p5xta");
  }, m(N, L) {
    R(N, e, L), q(e, n), q(n, r), q(n, s), q(n, i), q(i, o), q(i, f), q(e, c), q(e, l), q(l, h), q(l, m), q(l, v), q(v, A), q(v, _), q(e, C), q(e, I), q(I, S), q(I, $), q(I, F), q(F, Q), q(F, P);
  }, p(N, L) {
    L & 8 && a !== (a = N[3].originalBits + "") && Ze(o, a), L & 8 && b !== (b = N[3].compressedBits + "") && Ze(A, b), L & 8 && U !== (U = N[3].ratio + "") && Ze(Q, U);
  }, d(N) {
    N && D(e);
  } };
}
function cbe(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A;
  function _(U) {
    t3[7](U);
  }
  let C = { label: "Input Data:", placeholder: "Enter text to compress...", expandable: true, rows: 4 };
  t3[0] !== void 0 && (C.value = t3[0]), e = new et({ props: C }), Qe.push(() => ze(e, "value", _)), i = new ut({ props: { $$slots: { default: [lbe] }, $$scope: { ctx: t3 } } }), i.$on("click", t3[5]), o = new ut({ props: { variant: "secondary", $$slots: { default: [ube] }, $$scope: { ctx: t3 } } }), o.$on("click", t3[8]);
  function I(U) {
    t3[9](U);
  }
  let S = {};
  t3[1] !== void 0 && (S.checked = t3[1]), l = new xr({ props: S }), Qe.push(() => ze(l, "checked", I));
  let $ = t3[4] && aC(t3), F = t3[2] && oC(t3);
  return { c() {
    fe(e.$$.fragment), r = z(), s = H("div"), fe(i.$$.fragment), a = z(), fe(o.$$.fragment), f = z(), c = H("div"), fe(l.$$.fragment), m = z(), $ && $.c(), v = z(), F && F.c(), b = Lt(), St(c, "margin-left", "auto"), V(s, "class", "button-row svelte-13p5xta");
  }, m(U, Q) {
    ae(e, U, Q), R(U, r, Q), R(U, s, Q), ae(i, s, null), q(s, a), ae(o, s, null), q(s, f), q(s, c), ae(l, c, null), R(U, m, Q), $ && $.m(U, Q), R(U, v, Q), F && F.m(U, Q), R(U, b, Q), A = true;
  }, p(U, Q) {
    const P = {};
    !n && Q & 1 && (n = true, P.value = U[0], qe(() => n = false)), e.$set(P);
    const N = {};
    Q & 1024 && (N.$$scope = { dirty: Q, ctx: U }), i.$set(N);
    const L = {};
    Q & 1024 && (L.$$scope = { dirty: Q, ctx: U }), o.$set(L);
    const B = {};
    !h && Q & 2 && (h = true, B.checked = U[1], qe(() => h = false)), l.$set(B), U[4] ? $ ? $.p(U, Q) : ($ = aC(U), $.c(), $.m(v.parentNode, v)) : $ && ($.d(1), $ = null), U[2] ? F ? (F.p(U, Q), Q & 4 && W(F, 1)) : (F = oC(U), F.c(), W(F, 1), F.m(b.parentNode, b)) : F && (Xt(), j(F, 1, 1, () => {
      F = null;
    }), er());
  }, i(U) {
    A || (W(e.$$.fragment, U), W(i.$$.fragment, U), W(o.$$.fragment, U), W(l.$$.fragment, U), W(F), A = true);
  }, o(U) {
    j(e.$$.fragment, U), j(i.$$.fragment, U), j(o.$$.fragment, U), j(l.$$.fragment, U), j(F), A = false;
  }, d(U) {
    U && (D(r), D(s), D(m), D(v), D(b)), oe(e, U), oe(i), oe(o), oe(l), $ && $.d(U), F && F.d(U);
  } };
}
function hbe(t3) {
  let e, n, r, s, i;
  return { c() {
    e = H("p"), e.innerHTML = `<strong>Huffman Coding</strong> is a popular algorithm used for lossless data compression.
    This tool implements a Huffman-based data compression algorithm. Using the principles of 
    frequency-based encoding, it compresses data efficiently by assigning shorter codes to 
    more frequent characters. You can input any text data, and the tool will provide the compressed version.`, n = z(), r = H("p"), r.textContent = `It works by analyzing the frequency of characters. Frequent characters (like 'e' or 'a') get very 
    short binary codes (e.g., '10'), while rare characters (like 'z' or 'x') get longer codes (e.g., '11001').`, s = z(), i = H("p"), i.textContent = `This variable-length coding reduces the overall size of the data compared to fixed-length coding 
    (like standard ASCII where every character is 8 bits).`;
  }, m(a, o) {
    R(a, e, o), R(a, n, o), R(a, r, o), R(a, s, o), R(a, i, o);
  }, p: dt, d(a) {
    a && (D(e), D(n), D(r), D(s), D(i));
  } };
}
function dbe(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Data Compression (Huffman)", $$slots: { default: [cbe] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Huffman Coding", links: t3[6], $$slots: { default: [hbe] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 1055 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 1024 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function pbe(t3, e, n) {
  let r = "", s = "", i = null, a = "", o = true;
  function f() {
    if (n(4, a = ""), n(2, s = ""), n(3, i = null), !r) {
      n(4, a = "Please enter text to compress.");
      return;
    }
    try {
      const v = new fbe();
      n(2, s = v.compress(r)), n(3, i = v.getStats(r, s));
    } catch (v) {
      n(4, a = "Compression Failed: " + v.message);
    }
  }
  const c = [{ text: "Data compression - Wikipedia", url: "https://en.wikipedia.org/wiki/Data_compression" }];
  function l(v) {
    r = v, n(0, r);
  }
  const h = () => {
    n(0, r = ""), n(2, s = ""), n(3, i = null);
  };
  function m(v) {
    o = v, n(1, o);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 3 && o && r && f();
  }, [r, o, s, i, a, f, c, l, h, m];
}
class gbe extends xt {
  constructor(e) {
    super(), wt(this, e, pbe, dbe, At, {});
  }
}
class mbe {
  createDelta(e, n) {
    const r = [];
    let s = 0, i = 0;
    for (; i < n.length; ) s < e.length && e[s] === n[i] ? (r.push({ op: "COPY", index: s, len: 1, val: e[s] }), s++, i++) : (r.push({ op: "ADD", val: n[i] }), i++);
    for (; s < e.length; ) r.push({ op: "DELETE", index: s, val: e[s] }), s++;
    return r;
  }
  applyDelta(e, n) {
    let r = "";
    for (const s of n) s.op === "COPY" ? r += e.substr(s.index, s.len) : s.op === "ADD" && (r += s.val);
    return r;
  }
}
function vbe(t3) {
  let e;
  return { c() {
    e = we("Generate Delta & Reconstruct");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function ybe(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function lC(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[5]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 32 && Ze(n, r[5]);
  }, d(r) {
    r && D(e);
  } };
}
function uC(t3) {
  let e, n, r, s, i, a, o;
  n = new et({ props: { label: "Generated Delta (Operations):", value: t3[3], readonly: true, expandable: true, rows: 6, font: "monospace" } }), i = new et({ props: { label: "Reconstructed from Source + Delta:", value: t3[4], readonly: true } });
  let f = t3[4] === t3[1] && cC();
  return { c() {
    e = H("div"), fe(n.$$.fragment), r = z(), s = H("div"), fe(i.$$.fragment), a = z(), f && f.c(), V(s, "class", "reconstruction-box svelte-19xazsf"), V(e, "class", "results-area");
  }, m(c, l) {
    R(c, e, l), ae(n, e, null), q(e, r), q(e, s), ae(i, s, null), q(s, a), f && f.m(s, null), o = true;
  }, p(c, l) {
    const h = {};
    l & 8 && (h.value = c[3]), n.$set(h);
    const m = {};
    l & 16 && (m.value = c[4]), i.$set(m), c[4] === c[1] ? f || (f = cC(), f.c(), f.m(s, null)) : f && (f.d(1), f = null);
  }, i(c) {
    o || (W(n.$$.fragment, c), W(i.$$.fragment, c), o = true);
  }, o(c) {
    j(n.$$.fragment, c), j(i.$$.fragment, c), o = false;
  }, d(c) {
    c && D(e), oe(n), oe(i), f && f.d();
  } };
}
function cC(t3) {
  let e;
  return { c() {
    e = H("div"), e.textContent = "Verified Match", V(e, "class", "success-badge svelte-19xazsf");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function bbe(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F;
  function U(d) {
    t3[8](d);
  }
  let Q = { label: "Source Sequence:", placeholder: "Original text...", rows: 3 };
  t3[0] !== void 0 && (Q.value = t3[0]), r = new et({ props: Q }), Qe.push(() => ze(r, "value", U));
  function P(d) {
    t3[9](d);
  }
  let N = { label: "Target Sequence:", placeholder: "Modified text...", rows: 3 };
  t3[1] !== void 0 && (N.value = t3[1]), o = new et({ props: N }), Qe.push(() => ze(o, "value", P)), h = new ut({ props: { $$slots: { default: [vbe] }, $$scope: { ctx: t3 } } }), h.$on("click", t3[6]), v = new ut({ props: { variant: "secondary", $$slots: { default: [ybe] }, $$scope: { ctx: t3 } } }), v.$on("click", t3[10]);
  function L(d) {
    t3[11](d);
  }
  let B = {};
  t3[2] !== void 0 && (B.checked = t3[2]), _ = new xr({ props: B }), Qe.push(() => ze(_, "checked", L));
  let u = t3[5] && lC(t3), p = t3[3] && uC(t3);
  return { c() {
    e = H("div"), n = H("div"), fe(r.$$.fragment), i = z(), a = H("div"), fe(o.$$.fragment), c = z(), l = H("div"), fe(h.$$.fragment), m = z(), fe(v.$$.fragment), b = z(), A = H("div"), fe(_.$$.fragment), I = z(), u && u.c(), S = z(), p && p.c(), $ = Lt(), V(n, "class", "input-item"), V(a, "class", "input-item"), V(e, "class", "inputs-grid svelte-19xazsf"), St(A, "margin-left", "auto"), V(l, "class", "button-row");
  }, m(d, y) {
    R(d, e, y), q(e, n), ae(r, n, null), q(e, i), q(e, a), ae(o, a, null), R(d, c, y), R(d, l, y), ae(h, l, null), q(l, m), ae(v, l, null), q(l, b), q(l, A), ae(_, A, null), R(d, I, y), u && u.m(d, y), R(d, S, y), p && p.m(d, y), R(d, $, y), F = true;
  }, p(d, y) {
    const w = {};
    !s && y & 1 && (s = true, w.value = d[0], qe(() => s = false)), r.$set(w);
    const E = {};
    !f && y & 2 && (f = true, E.value = d[1], qe(() => f = false)), o.$set(E);
    const M = {};
    y & 4096 && (M.$$scope = { dirty: y, ctx: d }), h.$set(M);
    const x = {};
    y & 4096 && (x.$$scope = { dirty: y, ctx: d }), v.$set(x);
    const g = {};
    !C && y & 4 && (C = true, g.checked = d[2], qe(() => C = false)), _.$set(g), d[5] ? u ? u.p(d, y) : (u = lC(d), u.c(), u.m(S.parentNode, S)) : u && (u.d(1), u = null), d[3] ? p ? (p.p(d, y), y & 8 && W(p, 1)) : (p = uC(d), p.c(), W(p, 1), p.m($.parentNode, $)) : p && (Xt(), j(p, 1, 1, () => {
      p = null;
    }), er());
  }, i(d) {
    F || (W(r.$$.fragment, d), W(o.$$.fragment, d), W(h.$$.fragment, d), W(v.$$.fragment, d), W(_.$$.fragment, d), W(p), F = true);
  }, o(d) {
    j(r.$$.fragment, d), j(o.$$.fragment, d), j(h.$$.fragment, d), j(v.$$.fragment, d), j(_.$$.fragment, d), j(p), F = false;
  }, d(d) {
    d && (D(e), D(c), D(l), D(I), D(S), D($)), oe(r), oe(o), oe(h), oe(v), oe(_), u && u.d(d), p && p.d(d);
  } };
}
function Abe(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v;
  return { c() {
    e = H("p"), e.innerHTML = `<strong>Data Differencing</strong> (or Delta Encoding) calculates the difference between two files or strings. 
    Instead of saving both versions fully, you save the <strong>Source</strong> and a small <strong>Delta</strong> file.`, n = z(), r = H("p"), r.textContent = `This tool demonstrates the concept of data differencing,
    which involves computing the differences (delta) between two data sequences
    and using these differences to reconstruct the modified sequence.`, s = z(), i = H("b"), i.textContent = "Key Features:", a = z(), o = H("ul"), o.innerHTML = `<li>Generate a delta between a source and a target sequence.</li> <li>Reconstruct the target sequence from the source using the delta.</li> <li>The underlying logic relies on comparing byte sequences to detect matching, 
    added, or deleted segments, enabling efficient data transformations.</li>`, f = z(), c = H("p"), c.innerHTML = "<strong>Operations:</strong>", l = z(), h = H("ul"), h.innerHTML = "<li><strong>COPY:</strong> Read specific bytes from the Source (saves space).</li> <li><strong>ADD:</strong> Insert new bytes that don&#39;t exist in Source.</li> <li><strong>DELETE:</strong> Skip bytes present in Source.</li>", m = z(), v = H("p"), v.textContent = "This technique is heavily used in software updates (patches), version control systems (Git), and data synchronization to save bandwidth.";
  }, m(b, A) {
    R(b, e, A), R(b, n, A), R(b, r, A), R(b, s, A), R(b, i, A), R(b, a, A), R(b, o, A), R(b, f, A), R(b, c, A), R(b, l, A), R(b, h, A), R(b, m, A), R(b, v, A);
  }, p: dt, d(b) {
    b && (D(e), D(n), D(r), D(s), D(i), D(a), D(o), D(f), D(c), D(l), D(h), D(m), D(v));
  } };
}
function wbe(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Data Differencing", $$slots: { default: [bbe] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Data Differencing", links: t3[7], $$slots: { default: [Abe] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 4159 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 4096 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function xbe(t3, e, n) {
  let r = "", s = "", i = "", a = "", o = "", f = true;
  function c() {
    if (n(5, o = ""), n(3, i = ""), n(4, a = ""), !r) return n(5, o = "Please enter source text.");
    if (!s) return n(5, o = "Please enter target text.");
    try {
      const A = new mbe(), _ = A.createDelta(r, s);
      if (n(3, i = JSON.stringify(_, null, 2)), n(4, a = A.applyDelta(r, _)), a !== s) throw new Error("Integrity Check Failed: Reconstructed string does not match target.");
    } catch (A) {
      n(5, o = A.message);
    }
  }
  const l = [{ text: "Data differencing - Wikipedia", url: "https://en.wikipedia.org/wiki/Data_differencing" }];
  function h(A) {
    r = A, n(0, r);
  }
  function m(A) {
    s = A, n(1, s);
  }
  const v = () => {
    n(0, r = ""), n(1, s = ""), n(3, i = ""), n(4, a = "");
  };
  function b(A) {
    f = A, n(2, f);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 7 && f && r && s && c();
  }, [r, s, f, i, a, o, c, l, h, m, v, b];
}
class _be extends xt {
  constructor(e) {
    super(), wt(this, e, xbe, wbe, At, {});
  }
}
function Ebe(t3) {
  if (!t3) return { entropy: 0, distribution: [], totalBytes: 0 };
  const n = new TextEncoder().encode(t3), r = n.length, s = {};
  for (const o of n) s[o] = (s[o] || 0) + 1;
  let i = 0;
  const a = [];
  for (const o in s) {
    const f = parseInt(o), c = s[o], l = c / r;
    i -= l * Math.log2(l), a.push({ byte: f, hex: "0x" + f.toString(16).toUpperCase().padStart(2, "0"), char: Bbe(f), count: c, probability: l });
  }
  return a.sort((o, f) => o.byte - f.byte), { entropy: i, distribution: a, totalBytes: r };
}
function Bbe(t3) {
  return t3 >= 32 && t3 <= 126 ? String.fromCharCode(t3) : ".";
}
function hC(t3, e, n) {
  const r = t3.slice();
  return r[14] = e[n], r;
}
function dC(t3, e, n) {
  const r = t3.slice();
  return r[17] = e[n], r;
}
function Cbe(t3) {
  let e;
  return { c() {
    e = we("Calculate Entropy");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function kbe(t3) {
  let e;
  return { c() {
    e = we("Load Example");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function Ibe(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function pC(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[3]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 8 && Ze(n, r[3]);
  }, d(r) {
    r && D(e);
  } };
}
function gC(t3) {
  let e, n, r, s, i = t3[1].entropy.toFixed(5) + "", a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U, Q, P, N, L = t3[1].totalBytes + "", B, u, p, d, y, w = t3[1].distribution.length + "", E, M, x, g = Mr(t3[5]), k = [];
  for (let K = 0; K < g.length; K += 1) k[K] = mC(dC(t3, g, K));
  let T = Mr(t3[4]), O = [];
  for (let K = 0; K < T.length; K += 1) O[K] = vC(hC(t3, T, K));
  return { c() {
    e = H("div"), n = H("div"), r = H("span"), s = we("Shannon Entropy: "), a = we(i), o = we(" bits/byte"), f = z(), c = H("div"), l = H("h3"), l.textContent = "Byte Frequency Distribution", h = z(), m = Nr("svg"), v = Nr("g");
    for (let K = 0; K < k.length; K += 1) k[K].c();
    b = Nr("line"), A = Nr("line"), _ = Nr("g");
    for (let K = 0; K < O.length; K += 1) O[K].c();
    C = Nr("text"), I = we("Probability"), S = Nr("text"), $ = we("Byte Value (Sorted)"), F = z(), U = H("div"), Q = H("div"), P = we("Total Bytes: "), N = H("strong"), B = we(L), u = z(), p = H("div"), d = we("Unique Bytes: "), y = H("strong"), E = we(w), M = z(), x = H("div"), x.innerHTML = "Max Possible Entropy: <strong>8.00 bits</strong>", V(r, "class", "value svelte-1yd3y4n"), V(n, "class", "entropy-display svelte-1yd3y4n"), V(l, "class", "chart-title svelte-1yd3y4n"), V(v, "class", "grid"), V(b, "x1", t3[6].left), V(b, "y1", t3[6].top), V(b, "x2", t3[6].left), V(b, "y2", Nf - t3[6].bottom), V(b, "stroke", "#334155"), V(A, "x1", t3[6].left), V(A, "y1", Nf - t3[6].bottom), V(A, "x2", wh - t3[6].right), V(A, "y2", Nf - t3[6].bottom), V(A, "stroke", "#334155"), V(_, "class", "bars svelte-1yd3y4n"), V(C, "x", 15), V(C, "y", Nf / 2), V(C, "transform", "rotate(-90, 15, " + Nf / 2 + ")"), V(C, "text-anchor", "middle"), V(C, "class", "axis-title svelte-1yd3y4n"), V(S, "x", wh / 2), V(S, "y", Nf - 5), V(S, "text-anchor", "middle"), V(S, "class", "axis-title svelte-1yd3y4n"), V(m, "viewBox", "0 0 " + wh + " " + Nf), V(m, "class", "chart-svg svelte-1yd3y4n"), V(c, "class", "chart-container svelte-1yd3y4n"), V(U, "class", "stats-footer svelte-1yd3y4n"), V(e, "class", "results-area");
  }, m(K, Y) {
    R(K, e, Y), q(e, n), q(n, r), q(r, s), q(r, a), q(r, o), q(e, f), q(e, c), q(c, l), q(c, h), q(c, m), q(m, v);
    for (let J = 0; J < k.length; J += 1) k[J] && k[J].m(v, null);
    q(m, b), q(m, A), q(m, _);
    for (let J = 0; J < O.length; J += 1) O[J] && O[J].m(_, null);
    q(m, C), q(C, I), q(m, S), q(S, $), q(e, F), q(e, U), q(U, Q), q(Q, P), q(Q, N), q(N, B), q(U, u), q(U, p), q(p, d), q(p, y), q(y, E), q(U, M), q(U, x);
  }, p(K, Y) {
    if (Y & 2 && i !== (i = K[1].entropy.toFixed(5) + "") && Ze(a, i), Y & 96) {
      g = Mr(K[5]);
      let J;
      for (J = 0; J < g.length; J += 1) {
        const G = dC(K, g, J);
        k[J] ? k[J].p(G, Y) : (k[J] = mC(G), k[J].c(), k[J].m(v, null));
      }
      for (; J < k.length; J += 1) k[J].d(1);
      k.length = g.length;
    }
    if (Y & 16) {
      T = Mr(K[4]);
      let J;
      for (J = 0; J < T.length; J += 1) {
        const G = hC(K, T, J);
        O[J] ? O[J].p(G, Y) : (O[J] = vC(G), O[J].c(), O[J].m(_, null));
      }
      for (; J < O.length; J += 1) O[J].d(1);
      O.length = T.length;
    }
    Y & 2 && L !== (L = K[1].totalBytes + "") && Ze(B, L), Y & 2 && w !== (w = K[1].distribution.length + "") && Ze(E, w);
  }, d(K) {
    K && D(e), jn(k, K), jn(O, K);
  } };
}
function mC(t3) {
  let e, n, r, s, i = t3[17].label + "", a, o;
  return { c() {
    e = Nr("line"), s = Nr("text"), a = we(i), V(e, "x1", t3[6].left), V(e, "y1", n = t3[17].y), V(e, "x2", wh - t3[6].right), V(e, "y2", r = t3[17].y), V(e, "stroke", "#e2e8f0"), V(e, "stroke-dasharray", "4"), V(s, "x", t3[6].left - 10), V(s, "y", o = t3[17].y + 4), V(s, "text-anchor", "end"), V(s, "class", "tick-label svelte-1yd3y4n");
  }, m(f, c) {
    R(f, e, c), R(f, s, c), q(s, a);
  }, p(f, c) {
    c & 32 && n !== (n = f[17].y) && V(e, "y1", n), c & 32 && r !== (r = f[17].y) && V(e, "y2", r), c & 32 && i !== (i = f[17].label + "") && Ze(a, i), c & 32 && o !== (o = f[17].y + 4) && V(s, "y", o);
  }, d(f) {
    f && (D(e), D(s));
  } };
}
function vC(t3) {
  let e, n, r, s = t3[14].byte + "", i, a, o = t3[14].hex + "", f, c, l = t3[14].char + "", h, m, v = t3[14].probability.toFixed(4) + "", b, A, _, C, I;
  return { c() {
    e = Nr("rect"), n = Nr("title"), r = we("Byte: "), i = we(s), a = we(" ("), f = we(o), c = we(") Char: "), h = we(l), m = we(" Prob: "), b = we(v), V(e, "x", A = t3[14].x), V(e, "y", _ = t3[14].y), V(e, "width", C = t3[14].width), V(e, "height", I = t3[14].height), V(e, "fill", "#4169E1"), V(e, "stroke", "#2b50c0"), V(e, "stroke-width", "1"), V(e, "class", "svelte-1yd3y4n");
  }, m(S, $) {
    R(S, e, $), q(e, n), q(n, r), q(n, i), q(n, a), q(n, f), q(n, c), q(n, h), q(n, m), q(n, b);
  }, p(S, $) {
    $ & 16 && s !== (s = S[14].byte + "") && Ze(i, s), $ & 16 && o !== (o = S[14].hex + "") && Ze(f, o), $ & 16 && l !== (l = S[14].char + "") && Ze(h, l), $ & 16 && v !== (v = S[14].probability.toFixed(4) + "") && Ze(b, v), $ & 16 && A !== (A = S[14].x) && V(e, "x", A), $ & 16 && _ !== (_ = S[14].y) && V(e, "y", _), $ & 16 && C !== (C = S[14].width) && V(e, "width", C), $ & 16 && I !== (I = S[14].height) && V(e, "height", I);
  }, d(S) {
    S && D(e);
  } };
}
function Sbe(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C;
  function I(P) {
    t3[10](P);
  }
  let S = { label: "Input Data:", placeholder: "Enter text to analyze...", expandable: true, rows: 4 };
  t3[0] !== void 0 && (S.value = t3[0]), e = new et({ props: S }), Qe.push(() => ze(e, "value", I)), i = new ut({ props: { $$slots: { default: [Cbe] }, $$scope: { ctx: t3 } } }), i.$on("click", t3[7]), o = new ut({ props: { variant: "secondary", $$slots: { default: [kbe] }, $$scope: { ctx: t3 } } }), o.$on("click", t3[8]), c = new ut({ props: { variant: "secondary", $$slots: { default: [Ibe] }, $$scope: { ctx: t3 } } }), c.$on("click", t3[11]);
  function $(P) {
    t3[12](P);
  }
  let F = {};
  t3[2] !== void 0 && (F.checked = t3[2]), m = new xr({ props: F }), Qe.push(() => ze(m, "checked", $));
  let U = t3[3] && pC(t3), Q = t3[1] && gC(t3);
  return { c() {
    fe(e.$$.fragment), r = z(), s = H("div"), fe(i.$$.fragment), a = z(), fe(o.$$.fragment), f = z(), fe(c.$$.fragment), l = z(), h = H("div"), fe(m.$$.fragment), b = z(), U && U.c(), A = z(), Q && Q.c(), _ = Lt(), St(h, "margin-left", "auto"), V(s, "class", "button-row");
  }, m(P, N) {
    ae(e, P, N), R(P, r, N), R(P, s, N), ae(i, s, null), q(s, a), ae(o, s, null), q(s, f), ae(c, s, null), q(s, l), q(s, h), ae(m, h, null), R(P, b, N), U && U.m(P, N), R(P, A, N), Q && Q.m(P, N), R(P, _, N), C = true;
  }, p(P, N) {
    const L = {};
    !n && N & 1 && (n = true, L.value = P[0], qe(() => n = false)), e.$set(L);
    const B = {};
    N & 1048576 && (B.$$scope = { dirty: N, ctx: P }), i.$set(B);
    const u = {};
    N & 1048576 && (u.$$scope = { dirty: N, ctx: P }), o.$set(u);
    const p = {};
    N & 1048576 && (p.$$scope = { dirty: N, ctx: P }), c.$set(p);
    const d = {};
    !v && N & 4 && (v = true, d.checked = P[2], qe(() => v = false)), m.$set(d), P[3] ? U ? U.p(P, N) : (U = pC(P), U.c(), U.m(A.parentNode, A)) : U && (U.d(1), U = null), P[1] ? Q ? Q.p(P, N) : (Q = gC(P), Q.c(), Q.m(_.parentNode, _)) : Q && (Q.d(1), Q = null);
  }, i(P) {
    C || (W(e.$$.fragment, P), W(i.$$.fragment, P), W(o.$$.fragment, P), W(c.$$.fragment, P), W(m.$$.fragment, P), C = true);
  }, o(P) {
    j(e.$$.fragment, P), j(i.$$.fragment, P), j(o.$$.fragment, P), j(c.$$.fragment, P), j(m.$$.fragment, P), C = false;
  }, d(P) {
    P && (D(r), D(s), D(b), D(A), D(_)), oe(e, P), oe(i), oe(o), oe(c), oe(m), U && U.d(P), Q && Q.d(P);
  } };
}
function Mbe(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v;
  return { c() {
    e = H("p"), e.innerHTML = `<strong>Shannon Entropy</strong> is a measure of the randomness or information density in a file. 
    It is measured in <strong>bits per byte</strong>. This tool calculates the Shannon entropy of the provided input data, 
    a measurement used in information theory to assess the randomness or unpredictability of data. 
    It provides a visualization of the frequency distribution of byte values in the data.`, n = z(), r = H("ul"), r.innerHTML = "<li><strong>0.0 bits:</strong> No randomness (e.g., &quot;AAAAA&quot;). Contains zero information.</li> <li><strong>8.0 bits:</strong> Maximum randomness (e.g., random noise or encrypted data). Each byte is unpredictable.</li> <li><strong>English Text:</strong> Typically around 3.5 - 4.5 bits/byte.</li>", s = z(), i = H("h4"), i.textContent = "Features:", a = z(), o = H("ul"), o.innerHTML = "<li>Calculates Shannon entropy, a common metric in data analysis and cryptography.</li> <li>Generates a histogram to show the distribution of byte values in the data.</li> <li>Supports custom text input and provides results with a single button click.</li>", f = z(), c = H("h4"), c.textContent = "Usage Instructions:", l = z(), h = H("ol"), h.innerHTML = "<li>Enter the text data into the input field at the top.</li> <li>Click the <b>Calculate Entropy</b> button to calculate the entropy and generate a histogram.</li> <li>The calculated entropy will display below the input, and the histogram will appear beneath it.</li>", m = z(), v = H("p"), v.innerHTML = `<b>Note:</b> Entropy values are particularly useful in fields like cryptography, data compression, and 
    randomness testing.`;
  }, m(b, A) {
    R(b, e, A), R(b, n, A), R(b, r, A), R(b, s, A), R(b, i, A), R(b, a, A), R(b, o, A), R(b, f, A), R(b, c, A), R(b, l, A), R(b, h, A), R(b, m, A), R(b, v, A);
  }, p: dt, d(b) {
    b && (D(e), D(n), D(r), D(s), D(i), D(a), D(o), D(f), D(c), D(l), D(h), D(m), D(v));
  } };
}
function $be(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Shannon Entropy Calculator", $$slots: { default: [Sbe] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Shannon Entropy", links: t3[9], $$slots: { default: [Mbe] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 1048639 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 1048576 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
let wh = 600, Nf = 300;
function Tbe(t3, e, n) {
  let r = "", s = null, i = "", a = true;
  const o = { top: 20, right: 20, bottom: 40, left: 60 };
  let f = [], c = [];
  function l() {
    if (n(3, i = ""), n(1, s = null), !r) {
      n(3, i = "Please enter text data.");
      return;
    }
    try {
      n(1, s = Ebe(r));
    } catch (C) {
      n(3, i = C.message);
    }
  }
  function h() {
    n(0, r = "AAAAAA BBBBBB CCCCCC 1234567890 !@#$%^&*()"), l();
  }
  function m(C) {
    const I = wh - o.left - o.right, S = Nf - o.top - o.bottom, $ = Math.max(...C.map((L) => L.probability)), F = Math.ceil($ * 10) / 10 || 0.1, U = (L) => S - L / F * S, Q = I / C.length, P = Math.max(2, Q - 2);
    n(4, f = C.map((L, B) => ({ x: o.left + B * Q, y: o.top + U(L.probability), height: S - U(L.probability), width: P, ...L }))), n(5, c = []);
    const N = 5;
    for (let L = 0; L <= N; L++) {
      const B = F / N * L;
      c.push({ val: B, y: o.top + U(B), label: B.toFixed(2) });
    }
  }
  const v = [{ text: "Entropy (Information theory) - Wikipedia", url: "https://en.wikipedia.org/wiki/Entropy_(information_theory)" }];
  function b(C) {
    r = C, n(0, r);
  }
  const A = () => {
    n(0, r = ""), n(1, s = null);
  };
  function _(C) {
    a = C, n(2, a);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 2 && s && s.distribution.length > 0 && m(s.distribution), t3.$$.dirty & 5 && a && r && l();
  }, [r, s, a, i, f, c, o, l, h, v, b, A, _];
}
class Dbe extends xt {
  constructor(e) {
    super(), wt(this, e, Tbe, $be, At, {});
  }
}
function Rbe(t3, e) {
  for (; e > 0n; ) {
    let n = e;
    e = t3 % e, t3 = n;
  }
  return t3;
}
function Fbe(t3, e, n) {
  let r = 1n;
  for (t3 = t3 % n; e > 0n; ) e % 2n === 1n && (r = r * t3 % n), t3 = t3 * t3 % n, e /= 2n;
  return r;
}
function Pbe(t3) {
  if (t3 <= 1n) return false;
  if (t3 <= 3n) return true;
  if (t3 % 2n === 0n || t3 % 3n === 0n) return false;
  let e = t3 - 1n, n = 0n;
  for (; e % 2n === 0n; ) e /= 2n, n += 1n;
  const r = [2n, 3n, 5n, 7n, 11n, 13n, 17n, 19n, 23n];
  for (const s of r) {
    if (t3 <= s) break;
    let i = Fbe(s, e, t3);
    if (i === 1n || i === t3 - 1n) continue;
    let a = false;
    for (let o = 0n; o < n - 1n; o++) if (i = i * i % t3, i === t3 - 1n) {
      a = true;
      break;
    }
    if (!a) return false;
  }
  return true;
}
function pP(t3) {
  if (t3 % 2n === 0n) return 2n;
  let e = BigInt(Math.floor(Math.random() * 100)) + 2n, n = e, r = BigInt(Math.floor(Math.random() * 100)) + 1n, s = 1n;
  const i = (a) => (a * a + r) % t3;
  for (; s === 1n; ) {
    e = i(e), n = i(i(n));
    let a = e > n ? e - n : n - e;
    if (s = Rbe(a, t3), s === t3) return pP(t3);
  }
  return s;
}
function Nbe(t3) {
  if (!/^\d+$/.test(t3)) throw new Error("Invalid integer input.");
  let e = BigInt(t3);
  const n = {};
  if (e <= 0n) throw new Error("Number must be > 0");
  if (e === 1n) return { 1: 1 };
  const r = (o) => {
    const f = o.toString();
    n[f] = (n[f] || 0) + 1;
  };
  for (; e % 2n === 0n; ) r(2n), e /= 2n;
  for (; e % 3n === 0n; ) r(3n), e /= 3n;
  const s = [];
  e > 1n && s.push(e);
  let i = 0;
  const a = 1e4;
  for (; s.length > 0; ) {
    if (i++ > a) throw new Error("Calculation timed out (Number too complex).");
    let o = s.pop();
    if (Pbe(o)) {
      r(o);
      continue;
    }
    let f = pP(o);
    s.push(f), s.push(o / f);
  }
  return n;
}
function Ube(t3) {
  return Object.entries(t3).sort((e, n) => {
    const r = BigInt(e[0]) - BigInt(n[0]);
    return r > 0n ? 1 : r < 0n ? -1 : 0;
  }).map(([e, n]) => n > 1 ? `${e}^${n}` : `${e}`).join(" * ");
}
function Lbe(t3) {
  let e;
  return { c() {
    e = we("Factorize");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function Obe(t3) {
  let e;
  return { c() {
    e = we("Calculating...");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function Qbe(t3) {
  let e;
  function n(i, a) {
    return i[5] ? Obe : Lbe;
  }
  let r = n(t3), s = r(t3);
  return { c() {
    s.c(), e = Lt();
  }, m(i, a) {
    s.m(i, a), R(i, e, a);
  }, p(i, a) {
    r !== (r = n(i)) && (s.d(1), s = r(i), s && (s.c(), s.m(e.parentNode, e)));
  }, d(i) {
    i && D(e), s.d(i);
  } };
}
function Kbe(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function yC(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[4]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 16 && Ze(n, r[4]);
  }, d(r) {
    r && D(e);
  } };
}
function bC(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b = JSON.stringify(t3[2], null, 4) + "", A;
  return { c() {
    e = H("div"), n = H("div"), r = H("h4"), r.textContent = "Mathematical Representation:", s = z(), i = H("div"), a = we(t3[0]), o = we(" = "), f = we(t3[3]), c = z(), l = H("div"), h = H("h4"), h.textContent = "Factor Dictionary:", m = z(), v = H("div"), A = we(b), V(r, "class", "svelte-al9lb4"), V(i, "class", "math-str svelte-al9lb4"), V(n, "class", "result-box svelte-al9lb4"), V(h, "class", "svelte-al9lb4"), V(v, "class", "dict-view svelte-al9lb4"), V(l, "class", "result-box svelte-al9lb4"), V(e, "class", "results-area svelte-al9lb4");
  }, m(_, C) {
    R(_, e, C), q(e, n), q(n, r), q(n, s), q(n, i), q(i, a), q(i, o), q(i, f), q(e, c), q(e, l), q(l, h), q(l, m), q(l, v), q(v, A);
  }, p(_, C) {
    C & 1 && Ze(a, _[0]), C & 8 && Ze(f, _[3]), C & 4 && b !== (b = JSON.stringify(_[2], null, 4) + "") && Ze(A, b);
  }, d(_) {
    _ && D(e);
  } };
}
function Hbe(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A;
  function _(U) {
    t3[8](U);
  }
  let C = { label: "Number to Factorize:", placeholder: "e.g. 123456", type: "number", min: "1" };
  t3[0] !== void 0 && (C.value = t3[0]), e = new et({ props: C }), Qe.push(() => ze(e, "value", _)), i = new ut({ props: { disabled: t3[5], $$slots: { default: [Qbe] }, $$scope: { ctx: t3 } } }), i.$on("click", t3[6]), o = new ut({ props: { variant: "secondary", $$slots: { default: [Kbe] }, $$scope: { ctx: t3 } } }), o.$on("click", t3[9]);
  function I(U) {
    t3[10](U);
  }
  let S = {};
  t3[1] !== void 0 && (S.checked = t3[1]), l = new xr({ props: S }), Qe.push(() => ze(l, "checked", I));
  let $ = t3[4] && yC(t3), F = t3[2] && bC(t3);
  return { c() {
    fe(e.$$.fragment), r = z(), s = H("div"), fe(i.$$.fragment), a = z(), fe(o.$$.fragment), f = z(), c = H("div"), fe(l.$$.fragment), m = z(), $ && $.c(), v = z(), F && F.c(), b = Lt(), St(c, "margin-left", "auto"), V(s, "class", "button-row svelte-al9lb4");
  }, m(U, Q) {
    ae(e, U, Q), R(U, r, Q), R(U, s, Q), ae(i, s, null), q(s, a), ae(o, s, null), q(s, f), q(s, c), ae(l, c, null), R(U, m, Q), $ && $.m(U, Q), R(U, v, Q), F && F.m(U, Q), R(U, b, Q), A = true;
  }, p(U, Q) {
    const P = {};
    !n && Q & 1 && (n = true, P.value = U[0], qe(() => n = false)), e.$set(P);
    const N = {};
    Q & 32 && (N.disabled = U[5]), Q & 2080 && (N.$$scope = { dirty: Q, ctx: U }), i.$set(N);
    const L = {};
    Q & 2048 && (L.$$scope = { dirty: Q, ctx: U }), o.$set(L);
    const B = {};
    !h && Q & 2 && (h = true, B.checked = U[1], qe(() => h = false)), l.$set(B), U[4] ? $ ? $.p(U, Q) : ($ = yC(U), $.c(), $.m(v.parentNode, v)) : $ && ($.d(1), $ = null), U[2] ? F ? F.p(U, Q) : (F = bC(U), F.c(), F.m(b.parentNode, b)) : F && (F.d(1), F = null);
  }, i(U) {
    A || (W(e.$$.fragment, U), W(i.$$.fragment, U), W(o.$$.fragment, U), W(l.$$.fragment, U), A = true);
  }, o(U) {
    j(e.$$.fragment, U), j(i.$$.fragment, U), j(o.$$.fragment, U), j(l.$$.fragment, U), A = false;
  }, d(U) {
    U && (D(r), D(s), D(m), D(v), D(b)), oe(e, U), oe(i), oe(o), oe(l), $ && $.d(U), F && F.d(U);
  } };
}
function qbe(t3) {
  let e, n, r, s, i, a, o, f, c;
  return { c() {
    e = H("p"), e.innerHTML = `<b>Integer factorization</b> is the process of decomposing a composite integer into a product 
    of smaller integers, known as factors, which, when multiplied together, give the original number.
    If all the factors are prime numbers, the factorization is called a prime factorization.
    For example, the integer 28 can be factored into 2 \xD7 2 \xD7 7, where 2 and 7 are prime numbers.`, n = z(), r = H("p"), r.innerHTML = "<strong>Key Concepts:</strong>", s = z(), i = H("ul"), i.innerHTML = `<li><strong>Prime Factors:</strong> These are the factors of a number that are prime. For instance, the prime factors of 60 are 2, 3, and 5, 
    since 60 = 2 \xD7 2 \xD7 3 \xD7 5.</li> <li><strong>Composite Numbers:</strong> These are numbers that have more than two distinct factors. For example, 15 is a composite number because 
    it can be factored into 3 and 5.</li> <li><strong>Unique Factorization Theorem:</strong> Also known as the Fundamental Theorem of Arithmetic, this states that every integer greater than 1 
    can be uniquely represented as a product of prime factors, up to the order of the factors. For example, 84 = 2 \xD7 2 \xD7 3 \xD7 7, and no other combination of primes 
    yields 84.</li> <li><strong>Cryptography:</strong> Integer factorization is the backbone of many cryptographic systems, such as RSA encryption. The security of RSA relies on the 
    difficulty of factoring large composite numbers, which makes breaking the encryption computationally infeasible.</li>`, a = z(), o = H("p"), o.innerHTML = "<strong>Example:</strong>", f = z(), c = H("ul"), c.innerHTML = "<li>Input: <strong>60</strong></li> <li>Prime Factors: <strong>2, 2, 3, 5</strong></li> <li>Result: <b>60 = 2^2 * 3 * 5</b></li>";
  }, m(l, h) {
    R(l, e, h), R(l, n, h), R(l, r, h), R(l, s, h), R(l, i, h), R(l, a, h), R(l, o, h), R(l, f, h), R(l, c, h);
  }, p: dt, d(l) {
    l && (D(e), D(n), D(r), D(s), D(i), D(a), D(o), D(f), D(c));
  } };
}
function zbe(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Integer Factorization", $$slots: { default: [Hbe] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Integer Factorization", links: t3[7], $$slots: { default: [qbe] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 2111 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 2048 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function Gbe(t3, e, n) {
  let r = "", s = null, i = "", a = "", o = true, f = false;
  async function c() {
    if (n(4, a = ""), n(2, s = null), n(3, i = ""), !r) {
      n(4, a = "Please enter a number.");
      return;
    }
    n(5, f = true);
    try {
      await new Promise((A) => setTimeout(A, 50));
      const b = Nbe(r);
      n(2, s = b), n(3, i = Ube(b));
    } catch (b) {
      n(4, a = b.message);
    } finally {
      n(5, f = false);
    }
  }
  const l = [{ text: "Integer Factorization - Wikipedia", url: "https://en.wikipedia.org/wiki/Integer_factorization" }];
  function h(b) {
    r = b, n(0, r);
  }
  const m = () => {
    n(0, r = ""), n(2, s = null);
  };
  function v(b) {
    o = b, n(1, o);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 3 && o && r && c();
  }, [r, o, s, i, a, f, c, l, h, m, v];
}
class Vbe extends xt {
  constructor(e) {
    super(), wt(this, e, Gbe, zbe, At, {});
  }
}
function Ybe(t3, e) {
  if (!t3 || !e) throw new Error("Please provide both binary variables.");
  if (/[^01]/.test(t3) || /[^01]/.test(e)) throw new Error("Inputs must be binary strings (containing only 0 and 1).");
  const n = Math.max(t3.length, e.length), r = t3.padStart(n, "0"), s = e.padStart(n, "0");
  let i = "";
  for (let a = 0; a < n; a++) i += r[a] !== s[a] ? "1" : "0";
  return i;
}
function Wbe(t3) {
  let e;
  return { c() {
    e = we("Compute XOR");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function Jbe(t3) {
  let e;
  return { c() {
    e = we("Clear");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function AC(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[4]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 16 && Ze(n, r[4]);
  }, d(r) {
    r && D(e);
  } };
}
function wC(t3) {
  let e, n, r, s, i;
  return n = new et({ props: { label: "Result:", value: t3[3], readonly: true, withCopy: true } }), { c() {
    e = H("div"), fe(n.$$.fragment), r = z(), s = H("div"), s.innerHTML = "Logic: <strong>1</strong> if bits differ, <strong>0</strong> if bits match.", V(s, "class", "logic-explanation svelte-13qvmsg"), V(e, "class", "result-area svelte-13qvmsg");
  }, m(a, o) {
    R(a, e, o), ae(n, e, null), q(e, r), q(e, s), i = true;
  }, p(a, o) {
    const f = {};
    o & 8 && (f.value = a[3]), n.$set(f);
  }, i(a) {
    i || (W(n.$$.fragment, a), i = true);
  }, o(a) {
    j(n.$$.fragment, a), i = false;
  }, d(a) {
    a && D(e), oe(n);
  } };
}
function Zbe(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $, F, U, Q;
  function P(w) {
    t3[8](w);
  }
  let N = { label: "Variable 1 (Binary):", placeholder: "e.g. 1010" };
  t3[0] !== void 0 && (N.value = t3[0]), r = new et({ props: N }), Qe.push(() => ze(r, "value", P));
  function L(w) {
    t3[9](w);
  }
  let B = { label: "Variable 2 (Binary):", placeholder: "e.g. 0110" };
  t3[1] !== void 0 && (B.value = t3[1]), c = new et({ props: B }), Qe.push(() => ze(c, "value", L)), v = new ut({ props: { $$slots: { default: [Wbe] }, $$scope: { ctx: t3 } } }), v.$on("click", t3[5]), A = new ut({ props: { variant: "secondary", $$slots: { default: [Jbe] }, $$scope: { ctx: t3 } } }), A.$on("click", t3[6]);
  function u(w) {
    t3[10](w);
  }
  let p = {};
  t3[2] !== void 0 && (p.checked = t3[2]), I = new xr({ props: p }), Qe.push(() => ze(I, "checked", u));
  let d = t3[4] && AC(t3), y = t3[3] && wC(t3);
  return { c() {
    e = H("div"), n = H("div"), fe(r.$$.fragment), i = z(), a = H("div"), a.textContent = "\u2295", o = z(), f = H("div"), fe(c.$$.fragment), h = z(), m = H("div"), fe(v.$$.fragment), b = z(), fe(A.$$.fragment), _ = z(), C = H("div"), fe(I.$$.fragment), $ = z(), d && d.c(), F = z(), y && y.c(), U = Lt(), V(n, "class", "input-col svelte-13qvmsg"), V(a, "class", "operator-icon svelte-13qvmsg"), V(a, "title", "Exclusive OR"), V(f, "class", "input-col svelte-13qvmsg"), V(e, "class", "operation-layout svelte-13qvmsg"), St(C, "margin-left", "auto"), V(m, "class", "button-row svelte-13qvmsg");
  }, m(w, E) {
    R(w, e, E), q(e, n), ae(r, n, null), q(e, i), q(e, a), q(e, o), q(e, f), ae(c, f, null), R(w, h, E), R(w, m, E), ae(v, m, null), q(m, b), ae(A, m, null), q(m, _), q(m, C), ae(I, C, null), R(w, $, E), d && d.m(w, E), R(w, F, E), y && y.m(w, E), R(w, U, E), Q = true;
  }, p(w, E) {
    const M = {};
    !s && E & 1 && (s = true, M.value = w[0], qe(() => s = false)), r.$set(M);
    const x = {};
    !l && E & 2 && (l = true, x.value = w[1], qe(() => l = false)), c.$set(x);
    const g = {};
    E & 2048 && (g.$$scope = { dirty: E, ctx: w }), v.$set(g);
    const k = {};
    E & 2048 && (k.$$scope = { dirty: E, ctx: w }), A.$set(k);
    const T = {};
    !S && E & 4 && (S = true, T.checked = w[2], qe(() => S = false)), I.$set(T), w[4] ? d ? d.p(w, E) : (d = AC(w), d.c(), d.m(F.parentNode, F)) : d && (d.d(1), d = null), w[3] ? y ? (y.p(w, E), E & 8 && W(y, 1)) : (y = wC(w), y.c(), W(y, 1), y.m(U.parentNode, U)) : y && (Xt(), j(y, 1, 1, () => {
      y = null;
    }), er());
  }, i(w) {
    Q || (W(r.$$.fragment, w), W(c.$$.fragment, w), W(v.$$.fragment, w), W(A.$$.fragment, w), W(I.$$.fragment, w), W(y), Q = true);
  }, o(w) {
    j(r.$$.fragment, w), j(c.$$.fragment, w), j(v.$$.fragment, w), j(A.$$.fragment, w), j(I.$$.fragment, w), j(y), Q = false;
  }, d(w) {
    w && (D(e), D(h), D(m), D($), D(F), D(U)), oe(r), oe(c), oe(v), oe(A), oe(I), d && d.d(w), y && y.d(w);
  } };
}
function jbe(t3) {
  let e, n, r, s, i, a, o, f, c, l, h;
  return { c() {
    e = H("p"), e.innerHTML = `<b>The XOR (Exclusive OR)</b> operation is a fundamental binary operation used in digital logic and computing.
    It takes two binary inputs and outputs a binary result. In XOR, the result is <strong>1</strong> if the two 
    inputs are different (one input is 1 and the other is 0), and the result is <strong>0</strong> if the inputs 
    are the same (both 0 or both 1).`, n = z(), r = H("p"), r.textContent = `The XOR operation is symbolized by \u2295 or ^, and it is widely used in fields such as cryptography, error detection,
    computer graphics, and data encoding.`, s = z(), i = H("p"), i.innerHTML = "<strong>Applications of XOR Operation:</strong>", a = z(), o = H("ul"), o.innerHTML = `<li><strong>Cryptography:</strong> XOR is a foundational operation in encryption algorithms. 
    The simplicity and reversibility of XOR make it useful in symmetric encryption, 
    such as the XOR cipher. Modern cryptographic algorithms use XOR in combination 
    with other operations for secure data encoding.</li> <li><strong>Error Detection:</strong> XOR is commonly used in parity checks and checksums, 
    which help detect data corruption in storage or transmission.</li> <li><strong>Data Manipulation:</strong> XOR can swap values without needing a temporary variable. 
    For example, to swap two integers A and B, one can use XOR: 
    <code>A = A \u2295 B; B = A \u2295 B; A = A \u2295 B;</code>. This approach is efficient for 
    low-level programming and embedded systems.</li> <li><strong>Pseudorandom Number Generation:</strong> XOR is often used in pseudorandom 
    number generators to achieve bitwise randomness and efficiency.</li>`, f = z(), c = H("h3"), c.textContent = "Truth Table", l = z(), h = H("table"), h.innerHTML = '<thead><tr><th class="svelte-13qvmsg">A</th> <th class="svelte-13qvmsg">B</th> <th class="svelte-13qvmsg">A \u2295 B</th></tr></thead> <tbody><tr><td class="svelte-13qvmsg">0</td><td class="svelte-13qvmsg">0</td><td class="svelte-13qvmsg">0</td></tr> <tr><td class="svelte-13qvmsg">0</td><td class="svelte-13qvmsg">1</td><td class="svelte-13qvmsg">1</td></tr> <tr><td class="svelte-13qvmsg">1</td><td class="svelte-13qvmsg">0</td><td class="svelte-13qvmsg">1</td></tr> <tr><td class="svelte-13qvmsg">1</td><td class="svelte-13qvmsg">1</td><td class="svelte-13qvmsg">0</td></tr></tbody>', V(h, "class", "truth-table svelte-13qvmsg");
  }, m(m, v) {
    R(m, e, v), R(m, n, v), R(m, r, v), R(m, s, v), R(m, i, v), R(m, a, v), R(m, o, v), R(m, f, v), R(m, c, v), R(m, l, v), R(m, h, v);
  }, p: dt, d(m) {
    m && (D(e), D(n), D(r), D(s), D(i), D(a), D(o), D(f), D(c), D(l), D(h));
  } };
}
function Xbe(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "XOR Operation", $$slots: { default: [Zbe] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About XOR (Exclusive OR)", links: t3[7], $$slots: { default: [jbe] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 2079 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 2048 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function eAe(t3, e, n) {
  let r = "", s = "", i = "", a = "", o = true;
  function f() {
    n(4, a = ""), n(3, i = "");
    try {
      n(3, i = Ybe(r, s));
    } catch (b) {
      n(4, a = b.message);
    }
  }
  function c() {
    n(0, r = ""), n(1, s = ""), n(3, i = ""), n(4, a = "");
  }
  const l = [{ text: "Wikipedia", url: "https://en.wikipedia.org/wiki/Exclusive_or" }];
  function h(b) {
    r = b, n(0, r);
  }
  function m(b) {
    s = b, n(1, s);
  }
  function v(b) {
    o = b, n(2, o);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 7 && o && r && s && f();
  }, [r, s, o, i, a, f, c, l, h, m, v];
}
class tAe extends xt {
  constructor(e) {
    super(), wt(this, e, eAe, Xbe, At, {});
  }
}
var Td = {}, rAe = function() {
  return typeof Promise == "function" && Promise.prototype && Promise.prototype.then;
}, gP = {}, Vs = {};
let J4;
const nAe = [0, 26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655, 733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706];
Vs.getSymbolSize = function(e) {
  if (!e) throw new Error('"version" cannot be null or undefined');
  if (e < 1 || e > 40) throw new Error('"version" should be in range from 1 to 40');
  return e * 4 + 17;
};
Vs.getSymbolTotalCodewords = function(e) {
  return nAe[e];
};
Vs.getBCHDigit = function(t3) {
  let e = 0;
  for (; t3 !== 0; ) e++, t3 >>>= 1;
  return e;
};
Vs.setToSJISFunction = function(e) {
  if (typeof e != "function") throw new Error('"toSJISFunc" is not a valid function.');
  J4 = e;
};
Vs.isKanjiModeEnabled = function() {
  return typeof J4 < "u";
};
Vs.toSJIS = function(e) {
  return J4(e);
};
var km = {};
(function(t3) {
  t3.L = { bit: 1 }, t3.M = { bit: 0 }, t3.Q = { bit: 3 }, t3.H = { bit: 2 };
  function e(n) {
    if (typeof n != "string") throw new Error("Param is not a string");
    switch (n.toLowerCase()) {
      case "l":
      case "low":
        return t3.L;
      case "m":
      case "medium":
        return t3.M;
      case "q":
      case "quartile":
        return t3.Q;
      case "h":
      case "high":
        return t3.H;
      default:
        throw new Error("Unknown EC Level: " + n);
    }
  }
  t3.isValid = function(r) {
    return r && typeof r.bit < "u" && r.bit >= 0 && r.bit < 4;
  }, t3.from = function(r, s) {
    if (t3.isValid(r)) return r;
    try {
      return e(r);
    } catch {
      return s;
    }
  };
})(km);
function mP() {
  this.buffer = [], this.length = 0;
}
mP.prototype = { get: function(t3) {
  const e = Math.floor(t3 / 8);
  return (this.buffer[e] >>> 7 - t3 % 8 & 1) === 1;
}, put: function(t3, e) {
  for (let n = 0; n < e; n++) this.putBit((t3 >>> e - n - 1 & 1) === 1);
}, getLengthInBits: function() {
  return this.length;
}, putBit: function(t3) {
  const e = Math.floor(this.length / 8);
  this.buffer.length <= e && this.buffer.push(0), t3 && (this.buffer[e] |= 128 >>> this.length % 8), this.length++;
} };
var iAe = mP;
function Dd(t3) {
  if (!t3 || t3 < 1) throw new Error("BitMatrix size must be defined and greater than 0");
  this.size = t3, this.data = new Uint8Array(t3 * t3), this.reservedBit = new Uint8Array(t3 * t3);
}
Dd.prototype.set = function(t3, e, n, r) {
  const s = t3 * this.size + e;
  this.data[s] = n, r && (this.reservedBit[s] = true);
};
Dd.prototype.get = function(t3, e) {
  return this.data[t3 * this.size + e];
};
Dd.prototype.xor = function(t3, e, n) {
  this.data[t3 * this.size + e] ^= n;
};
Dd.prototype.isReserved = function(t3, e) {
  return this.reservedBit[t3 * this.size + e];
};
var sAe = Dd, vP = {};
(function(t3) {
  const e = Vs.getSymbolSize;
  t3.getRowColCoords = function(r) {
    if (r === 1) return [];
    const s = Math.floor(r / 7) + 2, i = e(r), a = i === 145 ? 26 : Math.ceil((i - 13) / (2 * s - 2)) * 2, o = [i - 7];
    for (let f = 1; f < s - 1; f++) o[f] = o[f - 1] - a;
    return o.push(6), o.reverse();
  }, t3.getPositions = function(r) {
    const s = [], i = t3.getRowColCoords(r), a = i.length;
    for (let o = 0; o < a; o++) for (let f = 0; f < a; f++) o === 0 && f === 0 || o === 0 && f === a - 1 || o === a - 1 && f === 0 || s.push([i[o], i[f]]);
    return s;
  };
})(vP);
var yP = {};
const aAe = Vs.getSymbolSize, xC = 7;
yP.getPositions = function(e) {
  const n = aAe(e);
  return [[0, 0], [n - xC, 0], [0, n - xC]];
};
var bP = {};
(function(t3) {
  t3.Patterns = { PATTERN000: 0, PATTERN001: 1, PATTERN010: 2, PATTERN011: 3, PATTERN100: 4, PATTERN101: 5, PATTERN110: 6, PATTERN111: 7 };
  const e = { N1: 3, N2: 3, N3: 40, N4: 10 };
  t3.isValid = function(s) {
    return s != null && s !== "" && !isNaN(s) && s >= 0 && s <= 7;
  }, t3.from = function(s) {
    return t3.isValid(s) ? parseInt(s, 10) : void 0;
  }, t3.getPenaltyN1 = function(s) {
    const i = s.size;
    let a = 0, o = 0, f = 0, c = null, l = null;
    for (let h = 0; h < i; h++) {
      o = f = 0, c = l = null;
      for (let m = 0; m < i; m++) {
        let v = s.get(h, m);
        v === c ? o++ : (o >= 5 && (a += e.N1 + (o - 5)), c = v, o = 1), v = s.get(m, h), v === l ? f++ : (f >= 5 && (a += e.N1 + (f - 5)), l = v, f = 1);
      }
      o >= 5 && (a += e.N1 + (o - 5)), f >= 5 && (a += e.N1 + (f - 5));
    }
    return a;
  }, t3.getPenaltyN2 = function(s) {
    const i = s.size;
    let a = 0;
    for (let o = 0; o < i - 1; o++) for (let f = 0; f < i - 1; f++) {
      const c = s.get(o, f) + s.get(o, f + 1) + s.get(o + 1, f) + s.get(o + 1, f + 1);
      (c === 4 || c === 0) && a++;
    }
    return a * e.N2;
  }, t3.getPenaltyN3 = function(s) {
    const i = s.size;
    let a = 0, o = 0, f = 0;
    for (let c = 0; c < i; c++) {
      o = f = 0;
      for (let l = 0; l < i; l++) o = o << 1 & 2047 | s.get(c, l), l >= 10 && (o === 1488 || o === 93) && a++, f = f << 1 & 2047 | s.get(l, c), l >= 10 && (f === 1488 || f === 93) && a++;
    }
    return a * e.N3;
  }, t3.getPenaltyN4 = function(s) {
    let i = 0;
    const a = s.data.length;
    for (let f = 0; f < a; f++) i += s.data[f];
    return Math.abs(Math.ceil(i * 100 / a / 5) - 10) * e.N4;
  };
  function n(r, s, i) {
    switch (r) {
      case t3.Patterns.PATTERN000:
        return (s + i) % 2 === 0;
      case t3.Patterns.PATTERN001:
        return s % 2 === 0;
      case t3.Patterns.PATTERN010:
        return i % 3 === 0;
      case t3.Patterns.PATTERN011:
        return (s + i) % 3 === 0;
      case t3.Patterns.PATTERN100:
        return (Math.floor(s / 2) + Math.floor(i / 3)) % 2 === 0;
      case t3.Patterns.PATTERN101:
        return s * i % 2 + s * i % 3 === 0;
      case t3.Patterns.PATTERN110:
        return (s * i % 2 + s * i % 3) % 2 === 0;
      case t3.Patterns.PATTERN111:
        return (s * i % 3 + (s + i) % 2) % 2 === 0;
      default:
        throw new Error("bad maskPattern:" + r);
    }
  }
  t3.applyMask = function(s, i) {
    const a = i.size;
    for (let o = 0; o < a; o++) for (let f = 0; f < a; f++) i.isReserved(f, o) || i.xor(f, o, n(s, f, o));
  }, t3.getBestMask = function(s, i) {
    const a = Object.keys(t3.Patterns).length;
    let o = 0, f = 1 / 0;
    for (let c = 0; c < a; c++) {
      i(c), t3.applyMask(c, s);
      const l = t3.getPenaltyN1(s) + t3.getPenaltyN2(s) + t3.getPenaltyN3(s) + t3.getPenaltyN4(s);
      t3.applyMask(c, s), l < f && (f = l, o = c);
    }
    return o;
  };
})(bP);
var Im = {};
const jf = km, yp = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 4, 1, 2, 4, 4, 2, 4, 4, 4, 2, 4, 6, 5, 2, 4, 6, 6, 2, 5, 8, 8, 4, 5, 8, 8, 4, 5, 8, 11, 4, 8, 10, 11, 4, 9, 12, 16, 4, 9, 16, 16, 6, 10, 12, 18, 6, 10, 17, 16, 6, 11, 16, 19, 6, 13, 18, 21, 7, 14, 21, 25, 8, 16, 20, 25, 8, 17, 23, 25, 9, 17, 23, 34, 9, 18, 25, 30, 10, 20, 27, 32, 12, 21, 29, 35, 12, 23, 34, 37, 12, 25, 34, 40, 13, 26, 35, 42, 14, 28, 38, 45, 15, 29, 40, 48, 16, 31, 43, 51, 17, 33, 45, 54, 18, 35, 48, 57, 19, 37, 51, 60, 19, 38, 53, 63, 20, 40, 56, 66, 21, 43, 59, 70, 22, 45, 62, 74, 24, 47, 65, 77, 25, 49, 68, 81], bp = [7, 10, 13, 17, 10, 16, 22, 28, 15, 26, 36, 44, 20, 36, 52, 64, 26, 48, 72, 88, 36, 64, 96, 112, 40, 72, 108, 130, 48, 88, 132, 156, 60, 110, 160, 192, 72, 130, 192, 224, 80, 150, 224, 264, 96, 176, 260, 308, 104, 198, 288, 352, 120, 216, 320, 384, 132, 240, 360, 432, 144, 280, 408, 480, 168, 308, 448, 532, 180, 338, 504, 588, 196, 364, 546, 650, 224, 416, 600, 700, 224, 442, 644, 750, 252, 476, 690, 816, 270, 504, 750, 900, 300, 560, 810, 960, 312, 588, 870, 1050, 336, 644, 952, 1110, 360, 700, 1020, 1200, 390, 728, 1050, 1260, 420, 784, 1140, 1350, 450, 812, 1200, 1440, 480, 868, 1290, 1530, 510, 924, 1350, 1620, 540, 980, 1440, 1710, 570, 1036, 1530, 1800, 570, 1064, 1590, 1890, 600, 1120, 1680, 1980, 630, 1204, 1770, 2100, 660, 1260, 1860, 2220, 720, 1316, 1950, 2310, 750, 1372, 2040, 2430];
Im.getBlocksCount = function(e, n) {
  switch (n) {
    case jf.L:
      return yp[(e - 1) * 4 + 0];
    case jf.M:
      return yp[(e - 1) * 4 + 1];
    case jf.Q:
      return yp[(e - 1) * 4 + 2];
    case jf.H:
      return yp[(e - 1) * 4 + 3];
    default:
      return;
  }
};
Im.getTotalCodewordsCount = function(e, n) {
  switch (n) {
    case jf.L:
      return bp[(e - 1) * 4 + 0];
    case jf.M:
      return bp[(e - 1) * 4 + 1];
    case jf.Q:
      return bp[(e - 1) * 4 + 2];
    case jf.H:
      return bp[(e - 1) * 4 + 3];
    default:
      return;
  }
};
var AP = {}, Sm = {};
const xh = new Uint8Array(512), eg = new Uint8Array(256);
(function() {
  let e = 1;
  for (let n = 0; n < 255; n++) xh[n] = e, eg[e] = n, e <<= 1, e & 256 && (e ^= 285);
  for (let n = 255; n < 512; n++) xh[n] = xh[n - 255];
})();
Sm.log = function(e) {
  if (e < 1) throw new Error("log(" + e + ")");
  return eg[e];
};
Sm.exp = function(e) {
  return xh[e];
};
Sm.mul = function(e, n) {
  return e === 0 || n === 0 ? 0 : xh[eg[e] + eg[n]];
};
(function(t3) {
  const e = Sm;
  t3.mul = function(r, s) {
    const i = new Uint8Array(r.length + s.length - 1);
    for (let a = 0; a < r.length; a++) for (let o = 0; o < s.length; o++) i[a + o] ^= e.mul(r[a], s[o]);
    return i;
  }, t3.mod = function(r, s) {
    let i = new Uint8Array(r);
    for (; i.length - s.length >= 0; ) {
      const a = i[0];
      for (let f = 0; f < s.length; f++) i[f] ^= e.mul(s[f], a);
      let o = 0;
      for (; o < i.length && i[o] === 0; ) o++;
      i = i.slice(o);
    }
    return i;
  }, t3.generateECPolynomial = function(r) {
    let s = new Uint8Array([1]);
    for (let i = 0; i < r; i++) s = t3.mul(s, new Uint8Array([1, e.exp(i)]));
    return s;
  };
})(AP);
const wP = AP;
function Z4(t3) {
  this.genPoly = void 0, this.degree = t3, this.degree && this.initialize(this.degree);
}
Z4.prototype.initialize = function(e) {
  this.degree = e, this.genPoly = wP.generateECPolynomial(this.degree);
};
Z4.prototype.encode = function(e) {
  if (!this.genPoly) throw new Error("Encoder not initialized");
  const n = new Uint8Array(e.length + this.degree);
  n.set(e);
  const r = wP.mod(n, this.genPoly), s = this.degree - r.length;
  if (s > 0) {
    const i = new Uint8Array(this.degree);
    return i.set(r, s), i;
  }
  return r;
};
var oAe = Z4, xP = {}, xl = {}, j4 = {};
j4.isValid = function(e) {
  return !isNaN(e) && e >= 1 && e <= 40;
};
var Do = {};
const _P = "[0-9]+", fAe = "[A-Z $%*+\\-./:]+";
let Gh = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
Gh = Gh.replace(/u/g, "\\u");
const lAe = "(?:(?![A-Z0-9 $%*+\\-./:]|" + Gh + `)(?:.|[\r
]))+`;
Do.KANJI = new RegExp(Gh, "g");
Do.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
Do.BYTE = new RegExp(lAe, "g");
Do.NUMERIC = new RegExp(_P, "g");
Do.ALPHANUMERIC = new RegExp(fAe, "g");
const uAe = new RegExp("^" + Gh + "$"), cAe = new RegExp("^" + _P + "$"), hAe = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
Do.testKanji = function(e) {
  return uAe.test(e);
};
Do.testNumeric = function(e) {
  return cAe.test(e);
};
Do.testAlphanumeric = function(e) {
  return hAe.test(e);
};
(function(t3) {
  const e = j4, n = Do;
  t3.NUMERIC = { id: "Numeric", bit: 1, ccBits: [10, 12, 14] }, t3.ALPHANUMERIC = { id: "Alphanumeric", bit: 2, ccBits: [9, 11, 13] }, t3.BYTE = { id: "Byte", bit: 4, ccBits: [8, 16, 16] }, t3.KANJI = { id: "Kanji", bit: 8, ccBits: [8, 10, 12] }, t3.MIXED = { bit: -1 }, t3.getCharCountIndicator = function(i, a) {
    if (!i.ccBits) throw new Error("Invalid mode: " + i);
    if (!e.isValid(a)) throw new Error("Invalid version: " + a);
    return a >= 1 && a < 10 ? i.ccBits[0] : a < 27 ? i.ccBits[1] : i.ccBits[2];
  }, t3.getBestModeForData = function(i) {
    return n.testNumeric(i) ? t3.NUMERIC : n.testAlphanumeric(i) ? t3.ALPHANUMERIC : n.testKanji(i) ? t3.KANJI : t3.BYTE;
  }, t3.toString = function(i) {
    if (i && i.id) return i.id;
    throw new Error("Invalid mode");
  }, t3.isValid = function(i) {
    return i && i.bit && i.ccBits;
  };
  function r(s) {
    if (typeof s != "string") throw new Error("Param is not a string");
    switch (s.toLowerCase()) {
      case "numeric":
        return t3.NUMERIC;
      case "alphanumeric":
        return t3.ALPHANUMERIC;
      case "kanji":
        return t3.KANJI;
      case "byte":
        return t3.BYTE;
      default:
        throw new Error("Unknown mode: " + s);
    }
  }
  t3.from = function(i, a) {
    if (t3.isValid(i)) return i;
    try {
      return r(i);
    } catch {
      return a;
    }
  };
})(xl);
(function(t3) {
  const e = Vs, n = Im, r = km, s = xl, i = j4, a = 7973, o = e.getBCHDigit(a);
  function f(m, v, b) {
    for (let A = 1; A <= 40; A++) if (v <= t3.getCapacity(A, b, m)) return A;
  }
  function c(m, v) {
    return s.getCharCountIndicator(m, v) + 4;
  }
  function l(m, v) {
    let b = 0;
    return m.forEach(function(A) {
      const _ = c(A.mode, v);
      b += _ + A.getBitsLength();
    }), b;
  }
  function h(m, v) {
    for (let b = 1; b <= 40; b++) if (l(m, b) <= t3.getCapacity(b, v, s.MIXED)) return b;
  }
  t3.from = function(v, b) {
    return i.isValid(v) ? parseInt(v, 10) : b;
  }, t3.getCapacity = function(v, b, A) {
    if (!i.isValid(v)) throw new Error("Invalid QR Code version");
    typeof A > "u" && (A = s.BYTE);
    const _ = e.getSymbolTotalCodewords(v), C = n.getTotalCodewordsCount(v, b), I = (_ - C) * 8;
    if (A === s.MIXED) return I;
    const S = I - c(A, v);
    switch (A) {
      case s.NUMERIC:
        return Math.floor(S / 10 * 3);
      case s.ALPHANUMERIC:
        return Math.floor(S / 11 * 2);
      case s.KANJI:
        return Math.floor(S / 13);
      case s.BYTE:
      default:
        return Math.floor(S / 8);
    }
  }, t3.getBestVersionForData = function(v, b) {
    let A;
    const _ = r.from(b, r.M);
    if (Array.isArray(v)) {
      if (v.length > 1) return h(v, _);
      if (v.length === 0) return 1;
      A = v[0];
    } else A = v;
    return f(A.mode, A.getLength(), _);
  }, t3.getEncodedBits = function(v) {
    if (!i.isValid(v) || v < 7) throw new Error("Invalid QR Code version");
    let b = v << 12;
    for (; e.getBCHDigit(b) - o >= 0; ) b ^= a << e.getBCHDigit(b) - o;
    return v << 12 | b;
  };
})(xP);
var EP = {};
const Pb = Vs, BP = 1335, dAe = 21522, _C = Pb.getBCHDigit(BP);
EP.getEncodedBits = function(e, n) {
  const r = e.bit << 3 | n;
  let s = r << 10;
  for (; Pb.getBCHDigit(s) - _C >= 0; ) s ^= BP << Pb.getBCHDigit(s) - _C;
  return (r << 10 | s) ^ dAe;
};
var CP = {};
const pAe = xl;
function Qu(t3) {
  this.mode = pAe.NUMERIC, this.data = t3.toString();
}
Qu.getBitsLength = function(e) {
  return 10 * Math.floor(e / 3) + (e % 3 ? e % 3 * 3 + 1 : 0);
};
Qu.prototype.getLength = function() {
  return this.data.length;
};
Qu.prototype.getBitsLength = function() {
  return Qu.getBitsLength(this.data.length);
};
Qu.prototype.write = function(e) {
  let n, r, s;
  for (n = 0; n + 3 <= this.data.length; n += 3) r = this.data.substr(n, 3), s = parseInt(r, 10), e.put(s, 10);
  const i = this.data.length - n;
  i > 0 && (r = this.data.substr(n), s = parseInt(r, 10), e.put(s, i * 3 + 1));
};
var gAe = Qu;
const mAe = xl, Cy = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", " ", "$", "%", "*", "+", "-", ".", "/", ":"];
function Ku(t3) {
  this.mode = mAe.ALPHANUMERIC, this.data = t3;
}
Ku.getBitsLength = function(e) {
  return 11 * Math.floor(e / 2) + 6 * (e % 2);
};
Ku.prototype.getLength = function() {
  return this.data.length;
};
Ku.prototype.getBitsLength = function() {
  return Ku.getBitsLength(this.data.length);
};
Ku.prototype.write = function(e) {
  let n;
  for (n = 0; n + 2 <= this.data.length; n += 2) {
    let r = Cy.indexOf(this.data[n]) * 45;
    r += Cy.indexOf(this.data[n + 1]), e.put(r, 11);
  }
  this.data.length % 2 && e.put(Cy.indexOf(this.data[n]), 6);
};
var vAe = Ku;
const yAe = xl;
function Hu(t3) {
  this.mode = yAe.BYTE, typeof t3 == "string" ? this.data = new TextEncoder().encode(t3) : this.data = new Uint8Array(t3);
}
Hu.getBitsLength = function(e) {
  return e * 8;
};
Hu.prototype.getLength = function() {
  return this.data.length;
};
Hu.prototype.getBitsLength = function() {
  return Hu.getBitsLength(this.data.length);
};
Hu.prototype.write = function(t3) {
  for (let e = 0, n = this.data.length; e < n; e++) t3.put(this.data[e], 8);
};
var bAe = Hu;
const AAe = xl, wAe = Vs;
function qu(t3) {
  this.mode = AAe.KANJI, this.data = t3;
}
qu.getBitsLength = function(e) {
  return e * 13;
};
qu.prototype.getLength = function() {
  return this.data.length;
};
qu.prototype.getBitsLength = function() {
  return qu.getBitsLength(this.data.length);
};
qu.prototype.write = function(t3) {
  let e;
  for (e = 0; e < this.data.length; e++) {
    let n = wAe.toSJIS(this.data[e]);
    if (n >= 33088 && n <= 40956) n -= 33088;
    else if (n >= 57408 && n <= 60351) n -= 49472;
    else throw new Error("Invalid SJIS character: " + this.data[e] + `
Make sure your charset is UTF-8`);
    n = (n >>> 8 & 255) * 192 + (n & 255), t3.put(n, 13);
  }
};
var xAe = qu, kP = { exports: {} };
(function(t3) {
  var e = { single_source_shortest_paths: function(n, r, s) {
    var i = {}, a = {};
    a[r] = 0;
    var o = e.PriorityQueue.make();
    o.push(r, 0);
    for (var f, c, l, h, m, v, b, A, _; !o.empty(); ) {
      f = o.pop(), c = f.value, h = f.cost, m = n[c] || {};
      for (l in m) m.hasOwnProperty(l) && (v = m[l], b = h + v, A = a[l], _ = typeof a[l] > "u", (_ || A > b) && (a[l] = b, o.push(l, b), i[l] = c));
    }
    if (typeof s < "u" && typeof a[s] > "u") {
      var C = ["Could not find a path from ", r, " to ", s, "."].join("");
      throw new Error(C);
    }
    return i;
  }, extract_shortest_path_from_predecessor_list: function(n, r) {
    for (var s = [], i = r; i; ) s.push(i), n[i], i = n[i];
    return s.reverse(), s;
  }, find_path: function(n, r, s) {
    var i = e.single_source_shortest_paths(n, r, s);
    return e.extract_shortest_path_from_predecessor_list(i, s);
  }, PriorityQueue: { make: function(n) {
    var r = e.PriorityQueue, s = {}, i;
    n = n || {};
    for (i in r) r.hasOwnProperty(i) && (s[i] = r[i]);
    return s.queue = [], s.sorter = n.sorter || r.default_sorter, s;
  }, default_sorter: function(n, r) {
    return n.cost - r.cost;
  }, push: function(n, r) {
    var s = { value: n, cost: r };
    this.queue.push(s), this.queue.sort(this.sorter);
  }, pop: function() {
    return this.queue.shift();
  }, empty: function() {
    return this.queue.length === 0;
  } } };
  t3.exports = e;
})(kP);
var _Ae = kP.exports;
(function(t3) {
  const e = xl, n = gAe, r = vAe, s = bAe, i = xAe, a = Do, o = Vs, f = _Ae;
  function c(C) {
    return unescape(encodeURIComponent(C)).length;
  }
  function l(C, I, S) {
    const $ = [];
    let F;
    for (; (F = C.exec(S)) !== null; ) $.push({ data: F[0], index: F.index, mode: I, length: F[0].length });
    return $;
  }
  function h(C) {
    const I = l(a.NUMERIC, e.NUMERIC, C), S = l(a.ALPHANUMERIC, e.ALPHANUMERIC, C);
    let $, F;
    return o.isKanjiModeEnabled() ? ($ = l(a.BYTE, e.BYTE, C), F = l(a.KANJI, e.KANJI, C)) : ($ = l(a.BYTE_KANJI, e.BYTE, C), F = []), I.concat(S, $, F).sort(function(Q, P) {
      return Q.index - P.index;
    }).map(function(Q) {
      return { data: Q.data, mode: Q.mode, length: Q.length };
    });
  }
  function m(C, I) {
    switch (I) {
      case e.NUMERIC:
        return n.getBitsLength(C);
      case e.ALPHANUMERIC:
        return r.getBitsLength(C);
      case e.KANJI:
        return i.getBitsLength(C);
      case e.BYTE:
        return s.getBitsLength(C);
    }
  }
  function v(C) {
    return C.reduce(function(I, S) {
      const $ = I.length - 1 >= 0 ? I[I.length - 1] : null;
      return $ && $.mode === S.mode ? (I[I.length - 1].data += S.data, I) : (I.push(S), I);
    }, []);
  }
  function b(C) {
    const I = [];
    for (let S = 0; S < C.length; S++) {
      const $ = C[S];
      switch ($.mode) {
        case e.NUMERIC:
          I.push([$, { data: $.data, mode: e.ALPHANUMERIC, length: $.length }, { data: $.data, mode: e.BYTE, length: $.length }]);
          break;
        case e.ALPHANUMERIC:
          I.push([$, { data: $.data, mode: e.BYTE, length: $.length }]);
          break;
        case e.KANJI:
          I.push([$, { data: $.data, mode: e.BYTE, length: c($.data) }]);
          break;
        case e.BYTE:
          I.push([{ data: $.data, mode: e.BYTE, length: c($.data) }]);
      }
    }
    return I;
  }
  function A(C, I) {
    const S = {}, $ = { start: {} };
    let F = ["start"];
    for (let U = 0; U < C.length; U++) {
      const Q = C[U], P = [];
      for (let N = 0; N < Q.length; N++) {
        const L = Q[N], B = "" + U + N;
        P.push(B), S[B] = { node: L, lastCount: 0 }, $[B] = {};
        for (let u = 0; u < F.length; u++) {
          const p = F[u];
          S[p] && S[p].node.mode === L.mode ? ($[p][B] = m(S[p].lastCount + L.length, L.mode) - m(S[p].lastCount, L.mode), S[p].lastCount += L.length) : (S[p] && (S[p].lastCount = L.length), $[p][B] = m(L.length, L.mode) + 4 + e.getCharCountIndicator(L.mode, I));
        }
      }
      F = P;
    }
    for (let U = 0; U < F.length; U++) $[F[U]].end = 0;
    return { map: $, table: S };
  }
  function _(C, I) {
    let S;
    const $ = e.getBestModeForData(C);
    if (S = e.from(I, $), S !== e.BYTE && S.bit < $.bit) throw new Error('"' + C + '" cannot be encoded with mode ' + e.toString(S) + `.
 Suggested mode is: ` + e.toString($));
    switch (S === e.KANJI && !o.isKanjiModeEnabled() && (S = e.BYTE), S) {
      case e.NUMERIC:
        return new n(C);
      case e.ALPHANUMERIC:
        return new r(C);
      case e.KANJI:
        return new i(C);
      case e.BYTE:
        return new s(C);
    }
  }
  t3.fromArray = function(I) {
    return I.reduce(function(S, $) {
      return typeof $ == "string" ? S.push(_($, null)) : $.data && S.push(_($.data, $.mode)), S;
    }, []);
  }, t3.fromString = function(I, S) {
    const $ = h(I, o.isKanjiModeEnabled()), F = b($), U = A(F, S), Q = f.find_path(U.map, "start", "end"), P = [];
    for (let N = 1; N < Q.length - 1; N++) P.push(U.table[Q[N]].node);
    return t3.fromArray(v(P));
  }, t3.rawSplit = function(I) {
    return t3.fromArray(h(I, o.isKanjiModeEnabled()));
  };
})(CP);
const Mm = Vs, ky = km, EAe = iAe, BAe = sAe, CAe = vP, kAe = yP, Nb = bP, Ub = Im, IAe = oAe, tg = xP, SAe = EP, MAe = xl, Iy = CP;
function $Ae(t3, e) {
  const n = t3.size, r = kAe.getPositions(e);
  for (let s = 0; s < r.length; s++) {
    const i = r[s][0], a = r[s][1];
    for (let o = -1; o <= 7; o++) if (!(i + o <= -1 || n <= i + o)) for (let f = -1; f <= 7; f++) a + f <= -1 || n <= a + f || (o >= 0 && o <= 6 && (f === 0 || f === 6) || f >= 0 && f <= 6 && (o === 0 || o === 6) || o >= 2 && o <= 4 && f >= 2 && f <= 4 ? t3.set(i + o, a + f, true, true) : t3.set(i + o, a + f, false, true));
  }
}
function TAe(t3) {
  const e = t3.size;
  for (let n = 8; n < e - 8; n++) {
    const r = n % 2 === 0;
    t3.set(n, 6, r, true), t3.set(6, n, r, true);
  }
}
function DAe(t3, e) {
  const n = CAe.getPositions(e);
  for (let r = 0; r < n.length; r++) {
    const s = n[r][0], i = n[r][1];
    for (let a = -2; a <= 2; a++) for (let o = -2; o <= 2; o++) a === -2 || a === 2 || o === -2 || o === 2 || a === 0 && o === 0 ? t3.set(s + a, i + o, true, true) : t3.set(s + a, i + o, false, true);
  }
}
function RAe(t3, e) {
  const n = t3.size, r = tg.getEncodedBits(e);
  let s, i, a;
  for (let o = 0; o < 18; o++) s = Math.floor(o / 3), i = o % 3 + n - 8 - 3, a = (r >> o & 1) === 1, t3.set(s, i, a, true), t3.set(i, s, a, true);
}
function Sy(t3, e, n) {
  const r = t3.size, s = SAe.getEncodedBits(e, n);
  let i, a;
  for (i = 0; i < 15; i++) a = (s >> i & 1) === 1, i < 6 ? t3.set(i, 8, a, true) : i < 8 ? t3.set(i + 1, 8, a, true) : t3.set(r - 15 + i, 8, a, true), i < 8 ? t3.set(8, r - i - 1, a, true) : i < 9 ? t3.set(8, 15 - i - 1 + 1, a, true) : t3.set(8, 15 - i - 1, a, true);
  t3.set(r - 8, 8, 1, true);
}
function FAe(t3, e) {
  const n = t3.size;
  let r = -1, s = n - 1, i = 7, a = 0;
  for (let o = n - 1; o > 0; o -= 2) for (o === 6 && o--; ; ) {
    for (let f = 0; f < 2; f++) if (!t3.isReserved(s, o - f)) {
      let c = false;
      a < e.length && (c = (e[a] >>> i & 1) === 1), t3.set(s, o - f, c), i--, i === -1 && (a++, i = 7);
    }
    if (s += r, s < 0 || n <= s) {
      s -= r, r = -r;
      break;
    }
  }
}
function PAe(t3, e, n) {
  const r = new EAe();
  n.forEach(function(f) {
    r.put(f.mode.bit, 4), r.put(f.getLength(), MAe.getCharCountIndicator(f.mode, t3)), f.write(r);
  });
  const s = Mm.getSymbolTotalCodewords(t3), i = Ub.getTotalCodewordsCount(t3, e), a = (s - i) * 8;
  for (r.getLengthInBits() + 4 <= a && r.put(0, 4); r.getLengthInBits() % 8 !== 0; ) r.putBit(0);
  const o = (a - r.getLengthInBits()) / 8;
  for (let f = 0; f < o; f++) r.put(f % 2 ? 17 : 236, 8);
  return NAe(r, t3, e);
}
function NAe(t3, e, n) {
  const r = Mm.getSymbolTotalCodewords(e), s = Ub.getTotalCodewordsCount(e, n), i = r - s, a = Ub.getBlocksCount(e, n), o = r % a, f = a - o, c = Math.floor(r / a), l = Math.floor(i / a), h = l + 1, m = c - l, v = new IAe(m);
  let b = 0;
  const A = new Array(a), _ = new Array(a);
  let C = 0;
  const I = new Uint8Array(t3.buffer);
  for (let Q = 0; Q < a; Q++) {
    const P = Q < f ? l : h;
    A[Q] = I.slice(b, b + P), _[Q] = v.encode(A[Q]), b += P, C = Math.max(C, P);
  }
  const S = new Uint8Array(r);
  let $ = 0, F, U;
  for (F = 0; F < C; F++) for (U = 0; U < a; U++) F < A[U].length && (S[$++] = A[U][F]);
  for (F = 0; F < m; F++) for (U = 0; U < a; U++) S[$++] = _[U][F];
  return S;
}
function UAe(t3, e, n, r) {
  let s;
  if (Array.isArray(t3)) s = Iy.fromArray(t3);
  else if (typeof t3 == "string") {
    let c = e;
    if (!c) {
      const l = Iy.rawSplit(t3);
      c = tg.getBestVersionForData(l, n);
    }
    s = Iy.fromString(t3, c || 40);
  } else throw new Error("Invalid data");
  const i = tg.getBestVersionForData(s, n);
  if (!i) throw new Error("The amount of data is too big to be stored in a QR Code");
  if (!e) e = i;
  else if (e < i) throw new Error(`
The chosen QR Code version cannot contain this amount of data.
Minimum version required to store current data is: ` + i + `.
`);
  const a = PAe(e, n, s), o = Mm.getSymbolSize(e), f = new BAe(o);
  return $Ae(f, e), TAe(f), DAe(f, e), Sy(f, n, 0), e >= 7 && RAe(f, e), FAe(f, a), isNaN(r) && (r = Nb.getBestMask(f, Sy.bind(null, f, n))), Nb.applyMask(r, f), Sy(f, n, r), { modules: f, version: e, errorCorrectionLevel: n, maskPattern: r, segments: s };
}
gP.create = function(e, n) {
  if (typeof e > "u" || e === "") throw new Error("No input text");
  let r = ky.M, s, i;
  return typeof n < "u" && (r = ky.from(n.errorCorrectionLevel, ky.M), s = tg.from(n.version), i = Nb.from(n.maskPattern), n.toSJISFunc && Mm.setToSJISFunction(n.toSJISFunc)), UAe(e, s, r, i);
};
var IP = {}, X4 = {};
(function(t3) {
  function e(n) {
    if (typeof n == "number" && (n = n.toString()), typeof n != "string") throw new Error("Color should be defined as hex string");
    let r = n.slice().replace("#", "").split("");
    if (r.length < 3 || r.length === 5 || r.length > 8) throw new Error("Invalid hex color: " + n);
    (r.length === 3 || r.length === 4) && (r = Array.prototype.concat.apply([], r.map(function(i) {
      return [i, i];
    }))), r.length === 6 && r.push("F", "F");
    const s = parseInt(r.join(""), 16);
    return { r: s >> 24 & 255, g: s >> 16 & 255, b: s >> 8 & 255, a: s & 255, hex: "#" + r.slice(0, 6).join("") };
  }
  t3.getOptions = function(r) {
    r || (r = {}), r.color || (r.color = {});
    const s = typeof r.margin > "u" || r.margin === null || r.margin < 0 ? 4 : r.margin, i = r.width && r.width >= 21 ? r.width : void 0, a = r.scale || 4;
    return { width: i, scale: i ? 4 : a, margin: s, color: { dark: e(r.color.dark || "#000000ff"), light: e(r.color.light || "#ffffffff") }, type: r.type, rendererOpts: r.rendererOpts || {} };
  }, t3.getScale = function(r, s) {
    return s.width && s.width >= r + s.margin * 2 ? s.width / (r + s.margin * 2) : s.scale;
  }, t3.getImageWidth = function(r, s) {
    const i = t3.getScale(r, s);
    return Math.floor((r + s.margin * 2) * i);
  }, t3.qrToImageData = function(r, s, i) {
    const a = s.modules.size, o = s.modules.data, f = t3.getScale(a, i), c = Math.floor((a + i.margin * 2) * f), l = i.margin * f, h = [i.color.light, i.color.dark];
    for (let m = 0; m < c; m++) for (let v = 0; v < c; v++) {
      let b = (m * c + v) * 4, A = i.color.light;
      if (m >= l && v >= l && m < c - l && v < c - l) {
        const _ = Math.floor((m - l) / f), C = Math.floor((v - l) / f);
        A = h[o[_ * a + C] ? 1 : 0];
      }
      r[b++] = A.r, r[b++] = A.g, r[b++] = A.b, r[b] = A.a;
    }
  };
})(X4);
(function(t3) {
  const e = X4;
  function n(s, i, a) {
    s.clearRect(0, 0, i.width, i.height), i.style || (i.style = {}), i.height = a, i.width = a, i.style.height = a + "px", i.style.width = a + "px";
  }
  function r() {
    try {
      return document.createElement("canvas");
    } catch {
      throw new Error("You need to specify a canvas element");
    }
  }
  t3.render = function(i, a, o) {
    let f = o, c = a;
    typeof f > "u" && (!a || !a.getContext) && (f = a, a = void 0), a || (c = r()), f = e.getOptions(f);
    const l = e.getImageWidth(i.modules.size, f), h = c.getContext("2d"), m = h.createImageData(l, l);
    return e.qrToImageData(m.data, i, f), n(h, c, l), h.putImageData(m, 0, 0), c;
  }, t3.renderToDataURL = function(i, a, o) {
    let f = o;
    typeof f > "u" && (!a || !a.getContext) && (f = a, a = void 0), f || (f = {});
    const c = t3.render(i, a, f), l = f.type || "image/png", h = f.rendererOpts || {};
    return c.toDataURL(l, h.quality);
  };
})(IP);
var SP = {};
const LAe = X4;
function EC(t3, e) {
  const n = t3.a / 255, r = e + '="' + t3.hex + '"';
  return n < 1 ? r + " " + e + '-opacity="' + n.toFixed(2).slice(1) + '"' : r;
}
function My(t3, e, n) {
  let r = t3 + e;
  return typeof n < "u" && (r += " " + n), r;
}
function OAe(t3, e, n) {
  let r = "", s = 0, i = false, a = 0;
  for (let o = 0; o < t3.length; o++) {
    const f = Math.floor(o % e), c = Math.floor(o / e);
    !f && !i && (i = true), t3[o] ? (a++, o > 0 && f > 0 && t3[o - 1] || (r += i ? My("M", f + n, 0.5 + c + n) : My("m", s, 0), s = 0, i = false), f + 1 < e && t3[o + 1] || (r += My("h", a), a = 0)) : s++;
  }
  return r;
}
SP.render = function(e, n, r) {
  const s = LAe.getOptions(n), i = e.modules.size, a = e.modules.data, o = i + s.margin * 2, f = s.color.light.a ? "<path " + EC(s.color.light, "fill") + ' d="M0 0h' + o + "v" + o + 'H0z"/>' : "", c = "<path " + EC(s.color.dark, "stroke") + ' d="' + OAe(a, i, s.margin) + '"/>', l = 'viewBox="0 0 ' + o + " " + o + '"', m = '<svg xmlns="http://www.w3.org/2000/svg" ' + (s.width ? 'width="' + s.width + '" height="' + s.width + '" ' : "") + l + ' shape-rendering="crispEdges">' + f + c + `</svg>
`;
  return typeof r == "function" && r(null, m), m;
};
const QAe = rAe, Lb = gP, MP = IP, KAe = SP;
function e6(t3, e, n, r, s) {
  const i = [].slice.call(arguments, 1), a = i.length, o = typeof i[a - 1] == "function";
  if (!o && !QAe()) throw new Error("Callback required as last argument");
  if (o) {
    if (a < 2) throw new Error("Too few arguments provided");
    a === 2 ? (s = n, n = e, e = r = void 0) : a === 3 && (e.getContext && typeof s > "u" ? (s = r, r = void 0) : (s = r, r = n, n = e, e = void 0));
  } else {
    if (a < 1) throw new Error("Too few arguments provided");
    return a === 1 ? (n = e, e = r = void 0) : a === 2 && !e.getContext && (r = n, n = e, e = void 0), new Promise(function(f, c) {
      try {
        const l = Lb.create(n, r);
        f(t3(l, e, r));
      } catch (l) {
        c(l);
      }
    });
  }
  try {
    const f = Lb.create(n, r);
    s(null, t3(f, e, r));
  } catch (f) {
    s(f);
  }
}
Td.create = Lb.create;
Td.toCanvas = e6.bind(null, MP.render);
Td.toDataURL = e6.bind(null, MP.renderToDataURL);
Td.toString = e6.bind(null, function(t3, e, n) {
  return KAe.render(t3, n);
});
async function HAe(t3, e = {}) {
  const n = { errorCorrectionLevel: e.errorCorrectionLevel || "M", type: "image/png", quality: 0.92, margin: e.margin !== void 0 ? e.margin : 4, scale: e.scale || 4, color: { dark: "#000000", light: "#ffffff" } };
  try {
    return t3 ? await Td.toDataURL(t3, n) : null;
  } catch (r) {
    throw new Error(`QR Generation failed: ${r.message}`);
  }
}
function BC(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[5]), V(e, "class", "msg error");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 32 && Ze(n, r[5]);
  }, d(r) {
    r && D(e);
  } };
}
function CC(t3) {
  let e, n, r, s, i, a, o, f;
  return o = new ut({ props: { $$slots: { default: [qAe] }, $$scope: { ctx: t3 } } }), o.$on("click", t3[9]), { c() {
    e = H("div"), n = H("div"), r = H("img"), i = z(), a = H("div"), fe(o.$$.fragment), r6(r.src, s = t3[4]) || V(r, "src", s), V(r, "alt", "Generated QR Code"), V(r, "class", "svelte-uwldy9"), V(n, "class", "qr-preview svelte-uwldy9"), V(a, "class", "action-row"), V(e, "class", "output-area svelte-uwldy9");
  }, m(c, l) {
    R(c, e, l), q(e, n), q(n, r), q(e, i), q(e, a), ae(o, a, null), f = true;
  }, p(c, l) {
    (!f || l & 16 && !r6(r.src, s = c[4])) && V(r, "src", s);
    const h = {};
    l & 131072 && (h.$$scope = { dirty: l, ctx: c }), o.$set(h);
  }, i(c) {
    f || (W(o.$$.fragment, c), f = true);
  }, o(c) {
    j(o.$$.fragment, c), f = false;
  }, d(c) {
    c && D(e), oe(o);
  } };
}
function qAe(t3) {
  let e;
  return { c() {
    e = we("Download PNG image");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function zAe(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I, S, $;
  function F(p) {
    t3[11](p);
  }
  let U = { id: "ec-level", label: "Error Correction:", options: t3[6] };
  t3[1] !== void 0 && (U.value = t3[1]), n = new Ht({ props: U }), Qe.push(() => ze(n, "value", F));
  function Q(p) {
    t3[12](p);
  }
  let P = { id: "mod-size", label: "Module Size:", options: t3[7] };
  t3[2] !== void 0 && (P.value = t3[2]), i = new Ht({ props: P }), Qe.push(() => ze(i, "value", Q));
  function N(p) {
    t3[13](p);
  }
  let L = { id: "margin-size", label: "Margin (Border):", options: t3[8] };
  t3[3] !== void 0 && (L.value = t3[3]), f = new Ht({ props: L }), Qe.push(() => ze(f, "value", N));
  let B = t3[5] && BC(t3), u = t3[4] && CC(t3);
  return { c() {
    e = H("div"), fe(n.$$.fragment), s = z(), fe(i.$$.fragment), o = z(), fe(f.$$.fragment), l = z(), h = H("div"), m = H("label"), m.textContent = "Input Text / URL:", v = z(), b = H("textarea"), A = z(), B && B.c(), _ = z(), u && u.c(), C = Lt(), V(e, "class", "controls-grid svelte-uwldy9"), V(m, "for", "qr-input"), V(m, "class", "svelte-uwldy9"), V(b, "id", "qr-input"), V(b, "placeholder", "Type text or URL here to generate QR..."), V(b, "rows", "4"), V(b, "class", "svelte-uwldy9"), V(h, "class", "input-area svelte-uwldy9");
  }, m(p, d) {
    R(p, e, d), ae(n, e, null), q(e, s), ae(i, e, null), q(e, o), ae(f, e, null), R(p, l, d), R(p, h, d), q(h, m), q(h, v), q(h, b), yr(b, t3[0]), R(p, A, d), B && B.m(p, d), R(p, _, d), u && u.m(p, d), R(p, C, d), I = true, S || ($ = Kt(b, "input", t3[14]), S = true);
  }, p(p, d) {
    const y = {};
    !r && d & 2 && (r = true, y.value = p[1], qe(() => r = false)), n.$set(y);
    const w = {};
    !a && d & 4 && (a = true, w.value = p[2], qe(() => a = false)), i.$set(w);
    const E = {};
    !c && d & 8 && (c = true, E.value = p[3], qe(() => c = false)), f.$set(E), d & 1 && yr(b, p[0]), p[5] ? B ? B.p(p, d) : (B = BC(p), B.c(), B.m(_.parentNode, _)) : B && (B.d(1), B = null), p[4] ? u ? (u.p(p, d), d & 16 && W(u, 1)) : (u = CC(p), u.c(), W(u, 1), u.m(C.parentNode, C)) : u && (Xt(), j(u, 1, 1, () => {
      u = null;
    }), er());
  }, i(p) {
    I || (W(n.$$.fragment, p), W(i.$$.fragment, p), W(f.$$.fragment, p), W(u), I = true);
  }, o(p) {
    j(n.$$.fragment, p), j(i.$$.fragment, p), j(f.$$.fragment, p), j(u), I = false;
  }, d(p) {
    p && (D(e), D(l), D(h), D(A), D(_), D(C)), oe(n), oe(i), oe(f), B && B.d(p), u && u.d(p), S = false, $();
  } };
}
function GAe(t3) {
  let e, n, r, s, i, a, o;
  return { c() {
    e = H("p"), e.textContent = "This tool allows you to create QR codes from any text input. You can customize various parameters, including:", n = z(), r = H("ul"), r.innerHTML = "<li><strong>Error Correction:</strong> Allows the QR code to be scanned even if part of it is damaged or covered. &#39;High&#39; allows up to 30% damage but makes the code denser.</li> <li><strong>Module Size:</strong> The pixel size of each black/white square (dot).</li>", s = z(), i = H("p"), i.textContent = `The generated QR code will be displayed within the application. You have the option to download the 
        .png file image that will be generated.`, a = z(), o = H("p"), o.textContent = "Simply enter your text, adjust the settings as needed, and the tool will generate your (static) QR code!";
  }, m(f, c) {
    R(f, e, c), R(f, n, c), R(f, r, c), R(f, s, c), R(f, i, c), R(f, a, c), R(f, o, c);
  }, p: dt, d(f) {
    f && (D(e), D(n), D(r), D(s), D(i), D(a), D(o));
  } };
}
function VAe(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "QR Code Generator", $$slots: { default: [zAe] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About QR Codes", links: t3[10], $$slots: { default: [GAe] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 131135 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 131072 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function YAe(t3, e, n) {
  let r = "", s = "", i = "", a = "M", o = 5, f = 4;
  const c = [{ value: "L", label: "Low (7%)" }, { value: "M", label: "Medium (15%)" }, { value: "Q", label: "Quartile (25%)" }, { value: "H", label: "High (30%)" }], l = [{ value: 2, label: "2px (Tiny)" }, { value: 5, label: "5px (Medium)" }, { value: 10, label: "10px (Large)" }, { value: 20, label: "20px (Huge)" }], h = [{ value: 0, label: "None (0 blocks)" }, { value: 1, label: "Thin (1 block)" }, { value: 4, label: "Standard (4 blocks)" }];
  async function m() {
    if (!r) {
      n(4, s = "");
      return;
    }
    n(5, i = "");
    try {
      n(4, s = await HAe(r, { errorCorrectionLevel: a, scale: o, margin: f }));
    } catch (S) {
      n(5, i = S.message);
    } finally {
    }
  }
  function v() {
    if (!s) return;
    const S = document.createElement("a");
    S.href = s, S.download = "qrcode.png", document.body.appendChild(S), S.click(), document.body.removeChild(S);
  }
  const b = [{ text: "QR Code - Wikipedia", url: "https://en.wikipedia.org/wiki/QR_code" }];
  function A(S) {
    a = S, n(1, a);
  }
  function _(S) {
    o = S, n(2, o);
  }
  function C(S) {
    f = S, n(3, f);
  }
  function I() {
    r = this.value, n(0, r);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 15 && (r || a || o || f) && m();
  }, [r, a, o, f, s, i, c, l, h, v, b, A, _, C, I];
}
class WAe extends xt {
  constructor(e) {
    super(), wt(this, e, YAe, VAe, At, {});
  }
}
const JAe = "lorem ipsum dolor sit amet consectetur adipiscing elit sed do eiusmod tempor incididunt ut labore et dolore magna aliqua ut enim ad minim veniam quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur Excepteur sint occaecat cupidatat non proident sunt in culpa qui officia deserunt mollit anim id est laborum", kC = JAe.split(" ");
function ZAe(t3) {
  if (!t3 || t3 <= 0) return "";
  let e = [], n = 0, r = 0;
  for (; r < t3; ) {
    r++;
    const s = kC[Math.floor(Math.random() * kC.length)];
    if (n + s.length + e.length <= t3) e.push(s), n += s.length;
    else break;
  }
  return e.join(" ");
}
function jAe(t3) {
  let e;
  return { c() {
    e = we("Generate");
  }, m(n, r) {
    R(n, e, r);
  }, d(n) {
    n && D(e);
  } };
}
function IC(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[2]), V(e, "class", "msg error svelte-1f8lqgd");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 4 && Ze(n, r[2]);
  }, d(r) {
    r && D(e);
  } };
}
function SC(t3) {
  let e, n, r, s;
  return r = new et({ props: { value: t3[1], readonly: true, expandable: true, withCopy: true } }), { c() {
    e = H("div"), n = H("div"), fe(r.$$.fragment), V(n, "class", "result-box"), V(e, "class", "result-section");
  }, m(i, a) {
    R(i, e, a), q(e, n), ae(r, n, null), s = true;
  }, p(i, a) {
    const o = {};
    a & 2 && (o.value = i[1]), r.$set(o);
  }, i(i) {
    s || (W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(e), oe(r);
  } };
}
function XAe(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v;
  o = new ut({ props: { $$slots: { default: [jAe] }, $$scope: { ctx: t3 } } }), o.$on("click", t3[3]);
  let b = t3[2] && IC(t3), A = t3[1] && SC(t3);
  return { c() {
    e = H("div"), n = H("div"), r = H("label"), r.textContent = "How many characters:", s = z(), i = H("input"), a = z(), fe(o.$$.fragment), f = z(), b && b.c(), c = z(), A && A.c(), l = Lt(), V(r, "for", "char-limit"), V(r, "class", "svelte-1f8lqgd"), V(i, "id", "char-limit"), V(i, "type", "number"), V(i, "min", "1"), V(i, "class", "number-input svelte-1f8lqgd"), V(n, "class", "input-wrapper svelte-1f8lqgd"), V(e, "class", "controls svelte-1f8lqgd");
  }, m(_, C) {
    R(_, e, C), q(e, n), q(n, r), q(n, s), q(n, i), yr(i, t3[0]), q(e, a), ae(o, e, null), R(_, f, C), b && b.m(_, C), R(_, c, C), A && A.m(_, C), R(_, l, C), h = true, m || (v = Kt(i, "input", t3[5]), m = true);
  }, p(_, C) {
    C & 1 && Nn(i.value) !== _[0] && yr(i, _[0]);
    const I = {};
    C & 64 && (I.$$scope = { dirty: C, ctx: _ }), o.$set(I), _[2] ? b ? b.p(_, C) : (b = IC(_), b.c(), b.m(c.parentNode, c)) : b && (b.d(1), b = null), _[1] ? A ? (A.p(_, C), C & 2 && W(A, 1)) : (A = SC(_), A.c(), W(A, 1), A.m(l.parentNode, l)) : A && (Xt(), j(A, 1, 1, () => {
      A = null;
    }), er());
  }, i(_) {
    h || (W(o.$$.fragment, _), W(A), h = true);
  }, o(_) {
    j(o.$$.fragment, _), j(A), h = false;
  }, d(_) {
    _ && (D(e), D(f), D(c), D(l)), oe(o), b && b.d(_), A && A.d(_), m = false, v();
  } };
}
function e4e(t3) {
  let e, n, r;
  return { c() {
    e = H("p"), e.innerHTML = `<b>Lorem Ipsum</b> is dummy text used in laying out print, graphic or web designs. 
        The passage is attributed to an unknown typesetter in the 15th century who is thought 
        to have scrambled parts of Cicero&#39;s <i>De Finibus Bonorum et Malorum</i> for use in a type specimen book.`, n = z(), r = H("p"), r.textContent = "This tool generates random sentences using the standard Latin vocabulary, ensuring the text fits within your specified character limit.";
  }, m(s, i) {
    R(s, e, i), R(s, n, i), R(s, r, i);
  }, p: dt, d(s) {
    s && (D(e), D(n), D(r));
  } };
}
function t4e(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Lorem Ipsum Generator", $$slots: { default: [XAe] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Lorem Ipsum", links: t3[4], $$slots: { default: [e4e] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 71 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 64 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function r4e(t3, e, n) {
  let r = 500, s = "", i = "";
  function a() {
    if (r <= 0) {
      n(2, i = "Please enter a valid number of characters."), n(1, s = "");
      return;
    }
    n(2, i = "");
    try {
      n(1, s = ZAe(r)), s || n(2, i = "Length too short to fit any words.");
    } catch (c) {
      n(2, i = c.message);
    }
  }
  const o = [{ text: "Lorem Ipsum - Wikipedia", url: "https://en.wikipedia.org/wiki/Lorem_ipsum" }];
  function f() {
    r = Nn(this.value), n(0, r);
  }
  return [r, s, i, a, o, f];
}
class n4e extends xt {
  constructor(e) {
    super(), wt(this, e, r4e, t4e, At, {});
  }
}
function i4e(t3, e) {
  if (e === 0) throw new Error("Modulus cannot be zero");
  const n = BigInt(t3), r = BigInt(e);
  return (n % r + r) % r;
}
function MC(t3) {
  let e, n;
  return { c() {
    e = H("div"), n = we(t3[3]), V(e, "class", "msg error svelte-1jniyci");
  }, m(r, s) {
    R(r, e, s), q(e, n);
  }, p(r, s) {
    s & 8 && Ze(n, r[3]);
  }, d(r) {
    r && D(e);
  } };
}
function $C(t3) {
  let e, n, r, s, i;
  return { c() {
    e = H("div"), n = H("span"), n.textContent = "Result:", r = z(), s = H("span"), i = we(t3[2]), V(n, "class", "label svelte-1jniyci"), V(s, "class", "value svelte-1jniyci"), V(e, "class", "result-box svelte-1jniyci");
  }, m(a, o) {
    R(a, e, o), q(e, n), q(e, r), q(e, s), q(s, i);
  }, p(a, o) {
    o & 4 && Ze(i, a[2]);
  }, d(a) {
    a && D(e);
  } };
}
function s4e(t3) {
  let e, n, r, s, i, a, o, f, c, l, h, m, v, b, A, _, C, I = t3[3] && MC(t3), S = t3[2] !== "" && $C(t3);
  return { c() {
    e = H("div"), n = H("div"), r = H("div"), s = H("label"), s.textContent = "Number (A)", i = z(), a = H("input"), o = z(), f = H("div"), f.textContent = "%", c = z(), l = H("div"), h = H("label"), h.textContent = "Modulus (B)", m = z(), v = H("input"), b = z(), I && I.c(), A = z(), S && S.c(), V(s, "for", "varA"), V(s, "class", "svelte-1jniyci"), V(a, "id", "varA"), V(a, "type", "number"), V(a, "class", "calc-input svelte-1jniyci"), V(r, "class", "input-group svelte-1jniyci"), V(f, "class", "operator svelte-1jniyci"), V(h, "for", "varB"), V(h, "class", "svelte-1jniyci"), V(v, "id", "varB"), V(v, "type", "number"), V(v, "class", "calc-input svelte-1jniyci"), V(l, "class", "input-group svelte-1jniyci"), V(n, "class", "inputs-row svelte-1jniyci"), V(e, "class", "calc-container svelte-1jniyci");
  }, m($, F) {
    R($, e, F), q(e, n), q(n, r), q(r, s), q(r, i), q(r, a), yr(a, t3[0]), q(n, o), q(n, f), q(n, c), q(n, l), q(l, h), q(l, m), q(l, v), yr(v, t3[1]), q(e, b), I && I.m(e, null), q(e, A), S && S.m(e, null), _ || (C = [Kt(a, "input", t3[5]), Kt(v, "input", t3[6])], _ = true);
  }, p($, F) {
    F & 1 && Nn(a.value) !== $[0] && yr(a, $[0]), F & 2 && Nn(v.value) !== $[1] && yr(v, $[1]), $[3] ? I ? I.p($, F) : (I = MC($), I.c(), I.m(e, A)) : I && (I.d(1), I = null), $[2] !== "" ? S ? S.p($, F) : (S = $C($), S.c(), S.m(e, null)) : S && (S.d(1), S = null);
  }, d($) {
    $ && D(e), I && I.d(), S && S.d(), _ = false, Mn(C);
  } };
}
function a4e(t3) {
  let e, n, r, s, i, a, o;
  return { c() {
    e = H("p"), e.innerHTML = "<b>Modular Arithmetic</b> is a system of arithmetic for integers, where numbers &quot;wrap around&quot; when reaching a certain value, called the <b>modulus</b>.", n = z(), r = H("p"), r.innerHTML = "The operation <code>A % B</code> finds the remainder when A is divided by B.", s = z(), i = H("ul"), i.innerHTML = "<li>Example: <code>10 % 3 = 1</code> (because 10 divided by 3 is 3 with a remainder of 1).</li> <li>Example: <code>15 % 5 = 0</code> (15 divides perfectly by 5).</li>", a = z(), o = H("p"), o.innerHTML = "In cryptography, we treat negative numbers carefully. This tool calculates <code>-5 % 4 = 3</code> whereas standard calculators might return -1.";
  }, m(f, c) {
    R(f, e, c), R(f, n, c), R(f, r, c), R(f, s, c), R(f, i, c), R(f, a, c), R(f, o, c);
  }, p: dt, d(f) {
    f && (D(e), D(n), D(r), D(s), D(i), D(a), D(o));
  } };
}
function o4e(t3) {
  let e, n, r, s;
  return e = new ar({ props: { title: "Mod Calculator", $$slots: { default: [s4e] }, $$scope: { ctx: t3 } } }), r = new Rt({ props: { title: "About Modulo", links: t3[4], $$slots: { default: [a4e] }, $$scope: { ctx: t3 } } }), { c() {
    fe(e.$$.fragment), n = z(), fe(r.$$.fragment);
  }, m(i, a) {
    ae(e, i, a), R(i, n, a), ae(r, i, a), s = true;
  }, p(i, [a]) {
    const o = {};
    a & 271 && (o.$$scope = { dirty: a, ctx: i }), e.$set(o);
    const f = {};
    a & 256 && (f.$$scope = { dirty: a, ctx: i }), r.$set(f);
  }, i(i) {
    s || (W(e.$$.fragment, i), W(r.$$.fragment, i), s = true);
  }, o(i) {
    j(e.$$.fragment, i), j(r.$$.fragment, i), s = false;
  }, d(i) {
    i && D(n), oe(e, i), oe(r, i);
  } };
}
function f4e(t3, e, n) {
  let r = "", s = "", i = "", a = "";
  function o(h, m) {
    if (n(3, a = ""), n(2, i = ""), !(h === "" || m === "")) {
      if (!/^-?\d+$/.test(h) || !/^-?\d+$/.test(m)) {
        n(3, a = "Please enter valid integers.");
        return;
      }
      try {
        const v = BigInt(h), b = BigInt(m);
        if (b === 0n) {
          n(3, a = "Modulus cannot be zero.");
          return;
        }
        const A = i4e(v, b);
        n(2, i = A.toString());
      } catch (v) {
        n(3, a = v.message);
      }
    }
  }
  const f = [{ text: "Modular Arithmetic - Wikipedia", url: "https://en.wikipedia.org/wiki/Modular_arithmetic" }, { text: "Khan Academy - Modular Arithmetic", url: "https://www.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/what-is-modular-arithmetic" }];
  function c() {
    r = Nn(this.value), n(0, r);
  }
  function l() {
    s = Nn(this.value), n(1, s);
  }
  return t3.$$.update = () => {
    t3.$$.dirty & 3 && o(r, s);
  }, [r, s, i, a, f, c, l];
}
class l4e extends xt {
  constructor(e) {
    super(), wt(this, e, f4e, o4e, At, {});
  }
}
function u4e(t3) {
  let e, n, r, s;
  const i = [p4e, d4e, h4e], a = [];
  function o(f, c) {
    return f[1] === "home" ? 0 : f[1] && f[1].component ? 1 : 2;
  }
  return n = o(t3), r = a[n] = i[n](t3), { c() {
    e = H("main"), r.c(), V(e, "class", "content svelte-irww4c");
  }, m(f, c) {
    R(f, e, c), a[n].m(e, null), s = true;
  }, p(f, c) {
    let l = n;
    n = o(f), n === l ? a[n].p(f, c) : (Xt(), j(a[l], 1, 1, () => {
      a[l] = null;
    }), er(), r = a[n], r ? r.p(f, c) : (r = a[n] = i[n](f), r.c()), W(r, 1), r.m(e, null));
  }, i(f) {
    s || (W(r), s = true);
  }, o(f) {
    j(r), s = false;
  }, d(f) {
    f && D(e), a[n].d();
  } };
}
function c4e(t3) {
  let e, n;
  return e = new gQ({}), e.$on("close", t3[4]), e.$on("requestNavigation", t3[8]), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p: dt, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function h4e(t3) {
  let e, n, r, s, i, a, o = t3[1].name + "", f, c, l, h;
  return { c() {
    e = H("div"), n = H("h3"), n.textContent = "Work in Progress", r = z(), s = H("p"), i = we("The tool "), a = H("strong"), f = we(o), c = we(" has not been created yet."), l = z(), h = H("p"), h.textContent = "Check back later for updates!", V(n, "class", "svelte-irww4c"), V(h, "class", "sub-text svelte-irww4c"), V(e, "class", "placeholder svelte-irww4c");
  }, m(m, v) {
    R(m, e, v), q(e, n), q(e, r), q(e, s), q(s, i), q(s, a), q(a, f), q(s, c), q(e, l), q(e, h);
  }, p(m, v) {
    v & 2 && o !== (o = m[1].name + "") && Ze(f, o);
  }, i: dt, o: dt, d(m) {
    m && D(e);
  } };
}
function d4e(t3) {
  let e, n, r;
  var s = t3[1].component;
  function i(a, o) {
    return {};
  }
  return s && (e = s6(s, i())), { c() {
    e && fe(e.$$.fragment), n = Lt();
  }, m(a, o) {
    e && ae(e, a, o), R(a, n, o), r = true;
  }, p(a, o) {
    if (o & 2 && s !== (s = a[1].component)) {
      if (e) {
        Xt();
        const f = e;
        j(f.$$.fragment, 1, 0, () => {
          oe(f, 1);
        }), er();
      }
      s ? (e = s6(s, i()), fe(e.$$.fragment), W(e.$$.fragment, 1), ae(e, n.parentNode, n)) : e = null;
    }
  }, i(a) {
    r || (e && W(e.$$.fragment, a), r = true);
  }, o(a) {
    e && j(e.$$.fragment, a), r = false;
  }, d(a) {
    a && D(n), e && oe(e, a);
  } };
}
function p4e(t3) {
  let e, n;
  return e = new rQ({}), { c() {
    fe(e.$$.fragment);
  }, m(r, s) {
    ae(e, r, s), n = true;
  }, p: dt, i(r) {
    n || (W(e.$$.fragment, r), n = true);
  }, o(r) {
    j(e.$$.fragment, r), n = false;
  }, d(r) {
    oe(e, r);
  } };
}
function g4e(t3) {
  let e, n, r, s, i, a;
  n = new eQ({ props: { menuStructure: t3[0], activeTool: t3[1] } }), n.$on("select", t3[5]), n.$on("toggle", t3[6]), n.$on("home", t3[7]), n.$on("openTerminal", t3[3]);
  const o = [c4e, u4e], f = [];
  function c(l, h) {
    return l[2] ? 0 : 1;
  }
  return s = c(t3), i = f[s] = o[s](t3), { c() {
    e = H("div"), fe(n.$$.fragment), r = z(), i.c(), V(e, "class", "app-container svelte-irww4c");
  }, m(l, h) {
    R(l, e, h), ae(n, e, null), q(e, r), f[s].m(e, null), a = true;
  }, p(l, [h]) {
    const m = {};
    h & 1 && (m.menuStructure = l[0]), h & 2 && (m.activeTool = l[1]), n.$set(m);
    let v = s;
    s = c(l), s === v ? f[s].p(l, h) : (Xt(), j(f[v], 1, 1, () => {
      f[v] = null;
    }), er(), i = f[s], i ? i.p(l, h) : (i = f[s] = o[s](l), i.c()), W(i, 1), i.m(e, null));
  }, i(l) {
    a || (W(n.$$.fragment, l), W(i), a = true);
  }, o(l) {
    j(n.$$.fragment, l), j(i), a = false;
  }, d(l) {
    l && D(e), oe(n), f[s].d();
  } };
}
function m4e(t3, e, n) {
  let r = [{ category: "Asymmetric Encryption", icon: "", expanded: false, items: [{ name: "Certificate Signing Request (CSR)", component: Fre }, { name: "Diffie Hellman Key Exchange", component: Gre }, { name: "Elliptic Curve DSA (ECDSA)", component: une }, { name: "Generate ECDSA Key Pair", component: wne }, { name: "RSA", component: Rne }, { name: "Generate RSA Key Pair", component: zne }, { name: "X.509 Self-Signed Certificate", component: tie }] }, { category: "Symmetric Encryption", icon: "", expanded: false, items: [{ name: "AES", component: Pie }, { name: "DES", component: Gie }, { name: "Triple DES", component: rse }, { name: "Fernet", component: wse }] }, { category: "Ciphers", icon: "", expanded: false, items: [{ name: "Affine Cipher", component: Ose }, { name: "Caesar Cipher", component: Sse }, { name: "Bacon Cipher", component: Jse }, { name: "Bifid Cipher", component: aae }, { name: "ChaCha20", component: yae }] }, { category: "Converters", icon: "", expanded: false, items: [{ name: "Binary", component: W0e }, { name: "ASCII", component: aue }, { name: "Decimal/Binary Converter", component: mue }, { name: "Octal Converter", component: Cue }, { name: "Hex Converter", component: Nue }, { name: "Codepoint Converter", component: Vue }, { name: "Decimal/Radix (Base) Converter", component: sce }, { name: "Decimal/BCD (Binary coded decimal)", component: gce }, { name: "Char to HTML Entity", component: Bce }, { name: "PEM to DER (Hex)", component: Fce }, { name: "Unix Time Converter", component: Yce }, { name: "Nato Phonetic Alphabet", component: ihe }, { name: "Hexdump Converter", component: hhe }, { name: "CSV / JSON Converter", component: _he }] }, { category: "Encoders", icon: "", expanded: false, items: [{ name: "A1Z26", component: Dhe }, { name: "Braille", component: qhe }, { name: "Base Encoder/Decoder", component: ode }, { name: "Morse Code", component: vde }, { name: "Punycode", component: Mde }, { name: "Quoted Printable", component: Qde }, { name: "URL Encoder", component: Zde }, { name: "UTF Encoding", component: upe }] }, { category: "File Handling Tools", icon: "", expanded: false, items: [{ name: "Zip Encryptor", component: hle }, { name: "File Hash Generator", component: Cle }, { name: "Compare File Hashes", component: M0e }, { name: "File Type Detector", component: f0e }, { name: "Log File Analyzer", component: b0e }, { name: "Pretty Good Privacy (PGP)", component: VO }] }, { category: "Hashing Algorithms", icon: "", expanded: false, items: [{ name: "SHA2-family", component: Lpe }, { name: "SHA3-family", component: d1e }, { name: "Hash Identifier", component: E1e }, { name: "Bcrypt Hash Generator", component: F1e }, { name: "BLAKE", component: J1e }, { name: "CRC", component: uge }, { name: "Message Digest", component: Vge }, { name: "RIPEMD-160", component: ume }, { name: "Keccak", component: Ame }, { name: "Whirlpool", component: Mme }, { name: "SHAKE", component: Ome }, { name: "cSHAKE", component: t2e }] }, { category: "Cryptanalysis", icon: "", expanded: false, items: [{ name: "RSA Wiener Attack", component: g2e }, { name: "Differential Analysis", component: b2e }, { name: "Linear Cryptanalysis", component: _2e }, { name: "Boomerang Attack", component: k2e }, { name: "Brute Force Attack", component: Bve }, { name: "Adaptive Chosen-Plaintext Attack", component: Sve }, { name: "Birthday Attack", component: Dve }, { name: "Black Bag Cryptanalysis", component: Nve }, { name: "Ciphertext-Only Analysis", component: Qve }, { name: "Chosen-Plaintext Analysis", component: zve }, { name: "Davies' Attack", component: Wve }, { name: "Harvest now, Decrypt later", component: Xve }, { name: "Integral Cryptanalysis", component: nye }, { name: "Known Plaintext Attack", component: oye }, { name: "Man-in-the-middle Attack", component: cye }, { name: "Mod N Cryptanalysis", component: gye }, { name: "Power Analysis", component: bye }, { name: "Rainbow Table Attack", component: _ye }, { name: "Replay Attack", component: kye }, { name: "Related-Key Attack", component: $ye }, { name: "Rubber-Hose Cryptanalysis", component: Fye }, { name: "Side-Channel Attack", component: Lye }, { name: "Slide Attack", component: Hye }, { name: "Timing Analysis Attack", component: Vye }, { name: "eXtended Sparse Linearization Attack", component: Zye }] }, { category: "Other Tools", icon: "", expanded: false, items: [{ name: "HMAC", component: a3e }, { name: "Frequency Analysis", component: g3e }, { name: "Prime Number Generator", component: k3e }, { name: "Pseudo-Random Number Generator", component: P3e }, { name: "Randomness Tester", component: Z3e }, { name: "Circular Bit Shift", component: abe }, { name: "Data compression", component: gbe }, { name: "Data differencing", component: _be }, { name: "Entropy", component: Dbe }, { name: "Integer Factorization", component: Vbe }, { name: "XOR operation", component: tAe }, { name: "QR Code Generator", component: WAe }, { name: "Lorem Ipsum Generator", component: n4e }, { name: "Mod Calculator", component: l4e }] }], s = "home", i = false;
  function a() {
    n(2, i = true), n(1, s = null);
  }
  function o() {
    n(2, i = false);
  }
  function f(m) {
    n(2, i = false), n(1, s = m.detail);
  }
  function c(m) {
    const v = m.detail;
    n(0, r[v].expanded = !r[v].expanded, r);
  }
  function l() {
    n(2, i = false), n(1, s = "home");
  }
  function h(m) {
    const v = m.detail;
    let b = null;
    for (const A of r) {
      const _ = A.items.find((C) => C.name.toLowerCase().includes(v));
      if (_) {
        b = _;
        break;
      }
    }
    b ? (n(1, s = b), n(2, i = false)) : console.log("Tool not found via terminal");
  }
  return [r, s, i, a, o, f, c, l, h];
}
class v4e extends xt {
  constructor(e) {
    super(), wt(this, e, m4e, g4e, At, {});
  }
}
new v4e({ target: document.getElementById("app") });
